<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/devops/gitlab%E5%AE%89%E8%A3%85/"/>
      <url>/devops/gitlab%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>操作系统：<code>Linux version 3.10.0-862.el7.x86_64 </code></p><p>Gitlab：<code>gitlab-ce14.10.0-ce.0.el7 </code></p><h1 id="安装必要依赖">安装必要依赖</h1><p>安装所需的依赖：<code>ssh</code>、<code>postfix(用于邮件通知)</code> 、<code>wget</code>，已安装的可略过。</p><h2 id="ssh">ssh</h2><p>安装ssh，<code>root</code> 用户可不加 <code>sudo</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y curl policycoreutils-pythonopenssh-server</span><br></pre></td></tr></table></figure><p>设置开机自启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> sshd  </span><br></pre></td></tr></table></figure><p>启动ssh服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start sshd</span><br></pre></td></tr></table></figure><h2 id="postfix">postfix</h2><p>安装 <code>Postfix</code> 用于发送通知邮件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install postfix</span><br></pre></td></tr></table></figure><p>设置开机自启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> postfix</span><br></pre></td></tr></table></figure><p>启动postfix</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start postfix </span><br></pre></td></tr></table></figure><h2 id="wget">wget</h2><p><code>wget</code> 用于从外网下载插件，检查系统中是否已经安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-01 ~]<span class="comment"># wget -V</span></span><br><span class="line">GNU Wget 1.14 在 linux-gnu 上编译。</span><br><span class="line"></span><br><span class="line">+digest +https +ipv6 +iri +large-file +nls +ntlm +opie +ssl/openssl</span><br><span class="line"></span><br><span class="line">Wgetrc:</span><br><span class="line">    /etc/wgetrc (系统)</span><br><span class="line">字符集: /usr/share/locale</span><br><span class="line">编译: gcc -DHAVE_CONFIG_H -DSYSTEM_WGETRC=<span class="string">&quot;/etc/wgetrc&quot;</span></span><br><span class="line">    -DLOCALEDIR=<span class="string">&quot;/usr/share/locale&quot;</span> -I. -I../lib -I../lib -O2 -g -pipe</span><br><span class="line">    -Wall -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector-strong</span><br><span class="line">    --param=ssp-buffer-size=4 -grecord-gcc-switches -m64 -mtune=generic</span><br><span class="line">链接程序: gcc -O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 -fexceptions</span><br><span class="line">    -fstack-protector-strong --param=ssp-buffer-size=4</span><br><span class="line">    -grecord-gcc-switches -m64 -mtune=generic -lssl -lcrypto</span><br><span class="line">    /usr/lib64/libssl.so /usr/lib64/libcrypto.so /usr/lib64/libz.so</span><br><span class="line">    -ldl -lz -lz -lidn -luuid -lpcre ftp-opie.o openssl.o http-ntlm.o</span><br><span class="line">    ../lib/libgnu.a</span><br><span class="line"></span><br><span class="line">Copyright (C) 2011 Free Software Foundation, Inc.</span><br><span class="line">授权 GPLv3+: GNU GPL 第三版或更高版本</span><br><span class="line">&lt;http://www.gnu.org/licenses/gpl.html&gt;。</span><br><span class="line">这是自由软件：您可以自由地更改并重新分发它。</span><br><span class="line">在法律所允许的范围内，没有任何担保。</span><br><span class="line"></span><br><span class="line">最初由 Hrvoje Nikšić &lt;hniksic@xemacs.org&gt; 编写。</span><br><span class="line">请将错误报告或建议寄给 &lt;bug-wget@gnu.org&gt;。</span><br></pre></td></tr></table></figure><p>如果未安装则进行安装，安装命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install wget -y</span><br></pre></td></tr></table></figure><h2 id="vim">vim</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install vim -y</span><br></pre></td></tr></table></figure><h1 id="GitLab-安装">GitLab 安装</h1><h2 id="yum-方式安装">yum 方式安装</h2><blockquote><p>注意： gitlab-ce 镜像仅支持 x86-64 架构</p></blockquote><p>Centos可以通过配置yum源然后使用yum一键安装，国内可以使用清华大学镜像源安装GitLab速度会快不少。<a href="https://mirror.tuna.tsinghua.edu.cn/help/gitlab-ce/">【相关配置安装参考这里】</a>。</p><p>将以下内容写入 <code>yum</code> 源配置文件：<code>/etc/yum.repos.d/gitlab-ce.repo</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/yum.repos.d/gitlab-ce.repo</span></span><br><span class="line">[gitlab-ce]</span><br><span class="line">name=Gitlab CE Repository</span><br><span class="line">baseurl=https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el<span class="variable">$releasever</span>/</span><br><span class="line">gpgcheck=0</span><br><span class="line">enabled=1</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum makecache <span class="comment">#将服务器包信息下载到本地缓存</span></span><br><span class="line">yum install gitlab-ce <span class="comment">#自动安装最新版</span></span><br></pre></td></tr></table></figure><p>安装指定版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yum install gitlab-ce-x.x.x    #安装指定版本</span></span><br></pre></td></tr></table></figure><h2 id="rpm-方式安装">rpm 方式安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el8/gitlab-ce-14.0.0-ce.0.el8.x86_64.rpm</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -i gitlab-ce-14.0.0-ce.0.el8.x86_64.rpm</span><br></pre></td></tr></table></figure><p>详细操作请自行查找相关资料。</p><p>无论使用哪种方式，看到类似如下输出表示安装成功：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">Running transaction check</span><br><span class="line">Running transaction test</span><br><span class="line">Transaction test succeeded</span><br><span class="line">Running transaction</span><br><span class="line">  正在安装    : setools-libs-3.3.8-4.el7.x86_64                                                                                         1/8</span><br><span class="line">  正在安装    : libcgroup-0.41-21.el7.x86_64                                                                                            2/8</span><br><span class="line">  正在安装    : audit-libs-python-2.8.5-4.el7.x86_64                                                                                    3/8</span><br><span class="line">  正在安装    : python-IPy-0.75-6.el7.noarch                                                                                            4/8</span><br><span class="line">  正在安装    : libsemanage-python-2.5-14.el7.x86_64                                                                                    5/8</span><br><span class="line">  正在安装    : checkpolicy-2.5-8.el7.x86_64                                                                                            6/8</span><br><span class="line">  正在安装    : policycoreutils-python-2.5-34.el7.x86_64                                                                                7/8</span><br><span class="line">  正在安装    : gitlab-ce-14.10.0-ce.0.el7.x86_64                                                                                       8/8</span><br><span class="line">It looks like GitLab has not been configured yet; skipping the upgrade script.</span><br><span class="line"></span><br><span class="line">       *.                  *.</span><br><span class="line">      ***                 ***</span><br><span class="line">     *****               *****</span><br><span class="line">    .******             *******</span><br><span class="line">    ********            ********</span><br><span class="line">   ,,,,,,,,,***********,,,,,,,,,</span><br><span class="line">  ,,,,,,,,,,,*********,,,,,,,,,,,</span><br><span class="line">  .,,,,,,,,,,,*******,,,,,,,,,,,,</span><br><span class="line">      ,,,,,,,,,*****,,,,,,,,,.</span><br><span class="line">         ,,,,,,,****,,,,,,</span><br><span class="line">            .,,,***,,,,</span><br><span class="line">                ,*,.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     _______ __  __          __</span><br><span class="line">    / ____(_) /_/ /   ____ _/ /_</span><br><span class="line">   / / __/ / __/ /   / __ `/ __ \</span><br><span class="line">  / /_/ / / /_/ /___/ /_/ / /_/ /</span><br><span class="line">  \____/_/\__/_____/\__,_/_.___/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thank you for installing GitLab!</span><br><span class="line">GitLab was unable to detect a valid hostname for your instance.</span><br><span class="line">Please configure a URL for your GitLab instance by setting `external_url`</span><br><span class="line">configuration in /etc/gitlab/gitlab.rb file.</span><br><span class="line">Then, you can start your GitLab instance by running the following command:</span><br><span class="line">  sudo gitlab-ctl reconfigure</span><br><span class="line"></span><br><span class="line">For a comprehensive list of configuration options please see the Omnibus GitLab readme</span><br><span class="line">https://gitlab.com/gitlab-org/omnibus-gitlab/blob/master/README.md</span><br><span class="line"></span><br><span class="line">Help us improve the installation experience, let us know how we did with a 1 minute survey:</span><br><span class="line">https://gitlab.fra1.qualtrics.com/jfe/form/SV_6kVqZANThUQ1bZb?installation=omnibus&amp;release=14-10</span><br><span class="line"></span><br><span class="line">  验证中      : checkpolicy-2.5-8.el7.x86_64                                                                                            1/8</span><br><span class="line">  验证中      : libsemanage-python-2.5-14.el7.x86_64                                                                                    2/8</span><br><span class="line">  验证中      : python-IPy-0.75-6.el7.noarch                                                                                            3/8</span><br><span class="line">  验证中      : policycoreutils-python-2.5-34.el7.x86_64                                                                                4/8</span><br><span class="line">  验证中      : audit-libs-python-2.8.5-4.el7.x86_64                                                                                    5/8</span><br><span class="line">  验证中      : libcgroup-0.41-21.el7.x86_64                                                                                            6/8</span><br><span class="line">  验证中      : gitlab-ce-14.10.0-ce.0.el7.x86_64                                                                                       7/8</span><br><span class="line">  验证中      : setools-libs-3.3.8-4.el7.x86_64                                                                                         8/8</span><br><span class="line"></span><br><span class="line">已安装:</span><br><span class="line">  gitlab-ce.x86_64 0:14.10.0-ce.0.el7</span><br><span class="line"></span><br><span class="line">作为依赖被安装:</span><br><span class="line">  audit-libs-python.x86_64 0:2.8.5-4.el7         checkpolicy.x86_64 0:2.5-8.el7                     libcgroup.x86_64 0:0.41-21.el7</span><br><span class="line">  libsemanage-python.x86_64 0:2.5-14.el7         policycoreutils-python.x86_64 0:2.5-34.el7         python-IPy.noarch 0:0.75-6.el7</span><br><span class="line">  setools-libs.x86_64 0:3.3.8-4.el7</span><br><span class="line"></span><br><span class="line">完毕！</span><br></pre></td></tr></table></figure><h1 id="默认路径">默认路径</h1><p>安装完成后可以利用 <code>rpm -ql gitlab-ce</code> 查看其文件安装路径及相关文件路径</p><ul><li>默认安装路径：<code>/opt/gitlab/</code></li><li>程序数据及配置文件保存路径： <code>/var/opt/gitlab</code></li><li>代码仓库保存位置：<code>/var/opt/gitlab/git-data/repositories/</code></li><li>代码仓库备份位置：<code>/var/opt/gitlab/backups/</code></li><li>postgresql数据及配置目录：<code>/var/opt/gitlab/postgresql/data/</code></li><li>redis默认配置目录：<code>/var/opt/gitlab/redis</code></li><li>gitlab主要配置文件：<code>/etc/gitlab/gitlab.rb</code></li></ul><h1 id="GitLab-配置修改">GitLab 配置修改</h1><p>修改配置文件指定服务器ip和自定义端口：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim  /etc/gitlab/gitlab.rb</span><br><span class="line"></span><br><span class="line">external_url <span class="string">&#x27;http://localhost:8888&#x27;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意这里设置的端口不能被占用，默认是8080端口，如果8080已经使用，请自定义其它端口，并在防火墙设置开放相对应端口，我这里直接使用 <code>8888</code></p></blockquote><p>重置并启动GitLab</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gitlab-ctl reconfigure</span><br><span class="line">gitlab-ctl restart</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># gitlab-ctl restart</span></span><br><span class="line">ok: run: alertmanager: (pid 88474) 1s</span><br><span class="line">ok: run: gitaly: (pid 88487) 0s</span><br><span class="line">ok: run: gitlab-exporter: (pid 88502) 0s</span><br><span class="line">ok: run: gitlab-kas: (pid 88504) 1s</span><br><span class="line">ok: run: gitlab-workhorse: (pid 88516) 0s</span><br><span class="line">ok: run: grafana: (pid 88529) 1s</span><br><span class="line">ok: run: logrotate: (pid 88541) 0s</span><br><span class="line">ok: run: nginx: (pid 88547) 1s</span><br><span class="line">ok: run: node-exporter: (pid 88556) 0s</span><br><span class="line">ok: run: postgres-exporter: (pid 88563) 0s</span><br><span class="line">ok: run: postgresql: (pid 88572) 0s</span><br><span class="line">ok: run: prometheus: (pid 88584) 0s</span><br><span class="line">ok: run: puma: (pid 88601) 0s</span><br><span class="line">ok: run: redis: (pid 88606) 0s</span><br><span class="line">ok: run: redis-exporter: (pid 88612) 1s</span><br><span class="line">ok: run: sidekiq: (pid 88696) 0s</span><br></pre></td></tr></table></figure><p>提示  &quot;ok: run:&quot;表示启动成功</p><h1 id="GitLab-访问">GitLab 访问</h1><p>如果没有域名，直接输入服务器ip和指定端口进行访问。</p><blockquote><p>注意：gitlab-ce-14初装后，将密码放在 <code>/etc/gitlab/initial_root_password</code>临时文件中 ，这个文件将在首次执行 <code>reconfigure</code> 后24小时自动删除，所以拿到密码后尽快登陆Web界面进行密码修改</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat /etc/gitlab/initial_root_password</span></span><br><span class="line"><span class="comment"># WARNING: This value is valid only in the following conditions</span></span><br><span class="line"><span class="comment">#          1. If provided manually (either via `GITLAB_ROOT_PASSWORD` environment variable or via `gitlab_rails[&#x27;initial_root_password&#x27;]` setting in `gitlab.rb`, it was provided before database was seeded for the first time (usually, the first reconfigure run).</span></span><br><span class="line"><span class="comment">#          2. Password hasn&#x27;t been changed manually, either via UI or via command line.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#          If the password shown here doesn&#x27;t work, you must reset the admin password following https://docs.gitlab.com/ee/security/reset_user_password.html#reset-your-root-password.</span></span><br><span class="line"></span><br><span class="line">Password: HjGOs7XePmSXYSbncxu7UDujhh+SWxyjVkxTvVPpbf8=</span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">NOTE:</span> This file will be automatically deleted in the first reconfigure run after 24 hours.</span></span><br></pre></td></tr></table></figure><p><img src="/images/2022-04-26-14-59-55.png" alt=""></p><p><img src="/images/2022-04-26-15-15-30.png" alt=""></p><h1 id="GitLab-常用命令">GitLab 常用命令</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gitlab-ctl start    <span class="comment"># 启动所有 gitlab 组件</span></span><br><span class="line">gitlab-ctl stop     <span class="comment"># 停止所有 gitlab 组件</span></span><br><span class="line">gitlab-ctl restart  <span class="comment"># 重启所有 gitlab 组件</span></span><br><span class="line">gitlab-ctl status   <span class="comment"># 查看服务状态</span></span><br><span class="line">gitlab-ctl reconfigure           <span class="comment"># 启动服务</span></span><br><span class="line">vim /etc/gitlab/gitlab.rb        <span class="comment"># 修改默认的配置文件</span></span><br><span class="line">gitlab-rake gitlab:check SANITIZE=<span class="literal">true</span> --trace    <span class="comment"># 检查gitlab</span></span><br><span class="line">sudo gitlab-ctl tail        <span class="comment"># 查看日志</span></span><br><span class="line">gitlab-ctl --<span class="built_in">help</span>           <span class="comment"># 查看更多命令</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/redis/%E4%BD%BF%E7%94%A8Docker%E6%90%AD%E5%BB%BARedis%E9%9B%86%E7%BE%A4/"/>
      <url>/redis/%E4%BD%BF%E7%94%A8Docker%E6%90%AD%E5%BB%BARedis%E9%9B%86%E7%BE%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="环境准备-v3">环境准备</h1><table><thead><tr><th style="text-align:center">IP</th><th style="text-align:center">操作系统</th></tr></thead><tbody><tr><td style="text-align:center">192.168.252.191</td><td style="text-align:center">CentOS Linux release 7.9.2009 (Core)</td></tr><tr><td style="text-align:center">192.168.252.192</td><td style="text-align:center">CentOS Linux release 7.9.2009 (Core)</td></tr><tr><td style="text-align:center">192.168.252.193</td><td style="text-align:center">CentOS Linux release 7.9.2009 (Core)</td></tr><tr><td style="text-align:center">192.168.252.194</td><td style="text-align:center">CentOS Linux release 7.9.2009 (Core)</td></tr><tr><td style="text-align:center">192.168.252.195</td><td style="text-align:center">CentOS Linux release 7.9.2009 (Core)</td></tr><tr><td style="text-align:center">192.168.252.196</td><td style="text-align:center">CentOS Linux release 7.9.2009 (Core)</td></tr></tbody></table><span id="more"></span><h1 id="整体搭建步骤">整体搭建步骤</h1><p>整体搭建步骤主要分为以下几步：</p><ol><li>下载 Redis 镜像（可以省略，创建容器时如果本地镜像不存在就会去远程拉取）</li><li>更改 Redis 配置文件</li><li>创建并运行 Redis 容器</li><li>使用集群命令创建 Redis Cluster 集群</li></ol><h1 id="Step1：下载镜像">Step1：下载镜像</h1><blockquote><p>省略</p></blockquote><h1 id="Step2：更改配置文件">Step2：更改配置文件</h1><p>获取 <code>redis.conf</code>  修改默认配置</p><ul><li><code>bind 127.0.0.1</code> ：  修改为 <code>0.0.0.0</code> 或指定<code>IP</code>（<code>127.0.0.1</code> 限制了 Redis 只能本地访问）</li><li><code>protected-mode no</code>： 改为<code>yes</code> ：开启保护模式限制为本地访问</li><li><code>daemonize no</code>  ：改为 <code>yes</code>：是否以守护进程方式启动可后台运行</li><li><code>dir  ./</code> ：Redis 数据存放文件夹（可选）</li><li><code>appendonly yes</code> ：Redis 持久化（可选）</li><li><code>cluster-enabled </code>：设置为集群节点</li></ul><h1 id="Step3：创建并启动容器">Step3：创建并启动容器</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --net host --name redis  -v /usr/confs/redis.conf:/etc/redis/redis.conf -v /usr/redisdata:/data redis redis-server /etc/redis/redis.conf --appendonly yes</span><br></pre></td></tr></table></figure><p>命令解释：</p><ul><li><code>--name redis</code> ：指定容器名称</li><li><code>-v</code> ：挂载目录，前表示主机部分/后表示容器部分</li><li><code>-d</code> ：表示后台启动</li><li><code>redis-server /etc/redis/redis.conf</code> ：以配置文件启动 <code>Redis</code> ，加载容器内的 <code>conf</code> 文件，最终找到的是 <code>/usr/confs/redis.conf</code></li><li><code>appendonly yes</code>：开启 <code>Redis</code>  持久化</li><li><code>--requirepass</code>：“如果有密码”</li></ul><p>在每台虚机上重复执行 <code>Step2</code> 和 <code>Step3</code> 启动6个redis节点。</p><blockquote><p>注意：如果在执行创建集群命令时卡在&quot; Waiting for the cluster to join …&quot;，启动容器时添加 <code>--net host</code></p></blockquote><h1 id="Step4：创建Redis集群">Step4：创建Redis集群</h1><p>格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it redis redis-cli --cluster create 192.168.252.191:6379 192.168.252.192:6379 192.168.252.193:6379 192.168.252.194:6379 192.168.252.195:6379 192.168.252.196:6379 --cluster-replicas 1</span><br></pre></td></tr></table></figure><p>查看结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-01 ~]# docker exec -it redis /bin/bash</span><br><span class="line">root@centos-01:/data# redis-cli </span><br><span class="line">127.0.0.1:6379&gt; CLUSTER NODES</span><br><span class="line">ea3bd63f54103bf7873bfa1b8bea4b7c1190d489 192.168.252.191:6379@16379 myself,master - 0 1631258399000 1 connected 0-5460</span><br><span class="line">9d512a4a1bb7b2a92f09005298065c974d3cd545 192.168.252.194:6379@16379 master - 0 1631258399500 9 connected 10923-16383</span><br><span class="line">752d6f9633db932d8347f69d3a4eb52f640d2bdb 192.168.252.192:6379@16379 slave 05debcade3fbaae47c561fefd6c982641a74185c 0 1631258398000 10 connected</span><br><span class="line">7020b7697b4c0c3f5237f8d56a8ee24b41e1faa2 192.168.252.193:6379@16379 slave 9d512a4a1bb7b2a92f09005298065c974d3cd545 0 1631258400520 9 connected</span><br><span class="line">05debcade3fbaae47c561fefd6c982641a74185c 192.168.252.196:6379@16379 master - 0 1631258398478 10 connected 5461-10922</span><br><span class="line">60f3a530a42c1f984d82f93fbb9a4017f40fb498 192.168.252.195:6379@16379 slave ea3bd63f54103bf7873bfa1b8bea4b7c1190d489 0 1631258397457 1 connected</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; CLUSTER INFO</span><br><span class="line">cluster_state:ok</span><br><span class="line">cluster_slots_assigned:16384</span><br><span class="line">cluster_slots_ok:16384</span><br><span class="line">cluster_slots_pfail:0</span><br><span class="line">cluster_slots_fail:0</span><br><span class="line">cluster_known_nodes:6</span><br><span class="line">cluster_size:3</span><br><span class="line">cluster_current_epoch:10</span><br><span class="line">cluster_my_epoch:1</span><br><span class="line">cluster_stats_messages_ping_sent:6497</span><br><span class="line">cluster_stats_messages_pong_sent:6333</span><br><span class="line">cluster_stats_messages_fail_sent:32</span><br><span class="line">cluster_stats_messages_auth-ack_sent:4</span><br><span class="line">cluster_stats_messages_sent:12866</span><br><span class="line">cluster_stats_messages_ping_received:6328</span><br><span class="line">cluster_stats_messages_pong_received:6488</span><br><span class="line">cluster_stats_messages_meet_received:5</span><br><span class="line">cluster_stats_messages_fail_received:6</span><br><span class="line">cluster_stats_messages_auth-req_received:4</span><br><span class="line">cluster_stats_mes</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/test/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
      <url>/test/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="常见测试类型">常见测试类型</h1><ul><li>单元测试</li><li>集成测试</li><li>Web测试</li><li>负载测试</li><li>其他</li></ul><span id="more"></span><h1 id="依赖倒置原则-DIP）">依赖倒置原则(DIP）</h1><p>很多情况下,一个类或者是方法它会依赖一些外部组件，如其他开发写的代码、第三方类库、数据库、网络等，当被测试的代码与这些组件紧耦合时，这段代码将可能是不可测的。如一个方法中依赖一个数据库组件去访问数据库，那么在执行这个方法时，必然要与数据库交互，如果没有数据库，那么该方法就无法运行。所以单元测试不仅是对代码逻辑进行检查，同时还对整个代码结构有所限制，面向对象编程时应当遵循“依赖倒置”原则，模块应该依赖抽象，抽象不应该依赖实现。并且所依赖的抽象，应该显示的通过构造或者方法参数进行暴露，让组件的使用者对组件的依赖一目了然,在单元测试时为了屏蔽这些抽象依赖，不同测试框架中提供了<code>stub</code>、<code>mock</code>、<code>fake</code> 等方式对抽象进行模拟，以便于代码能够正常执行。</p><h1 id="单元测试">单元测试</h1><p>软件应用程序有多种类型的测试。 其中包括集成测试、Web 测试、负载测试和其他测试。 “单元测试”用于对软件中的最小可测试单元进行检查和验证。 单元测试仅测试开发人员控件内的代码。 它们不测试基础结构问题。 基础结构问题包括数据库、文件系统和网络资源。</p><p>编写单元测试时，尽量不要引入基础结构依赖项。这些依赖项会降低测试速度，使测试更加脆弱，应将其保留供集成测试使用。 可以通过遵循<code>Explicit Dependencies Principle</code>（显式依赖项原则）和使用<code>Dependency Injection</code>（依赖项注入）避免应用程序中的这些依赖项。还可以将单元测试保留在单独的项目中，与集成测试相分隔。 这可确保单元测试项目没有引用或依赖于基础结构包。</p><h1 id="单元测试的好处">单元测试的好处</h1><ul><li>比执行功能测试节省时间</li><li>防止回归：新功能上线时可通过单元测试来确保之前存在的功能正常运行不会破坏现有功能</li><li>减少耦合：当代码紧密耦合时，可能很难进行单元测试，如果不为代码编写单元测试，耦合可能就不太明显了</li></ul><h1 id="优质单元测试的特征">优质单元测试的特征</h1><ul><li>快速： 对成熟项目进行数千次单元测试，这很常见。 应花非常少的时间来运行单元测试</li><li>独立： 单元测试是独立的，可以单独运行，并且不依赖文件系统或数据库等任何外部因素</li><li>可重复：运行单元测试的结果应该保持一致，也就是说，如果在运行期间不更改任何内容，总是返回相同结果</li><li>自检查： 测试应该能够在没有任何人工交互的情况下，自动检测测试是否通过</li></ul><h1 id="代码覆盖率">代码覆盖率</h1><p>高代码覆盖率百分比通常与较高的代码质量相关联，但该度量值本身无法确定代码的质量。 设置过高的代码覆盖率百分比目标可能会适得其反，高代码覆盖率百分比不代表代码质量就高， 它仅仅表示单元测试所涵盖的代码量。</p><p>代码覆盖率工具有两种类型</p><ul><li>数据收集器： 数据收集器监视测试执行并收集有关测试运行的信息。 它们以各种输出格式（例如 <code>XML</code>和 <code>JSON</code>）报告收集的信息</li><li>报表生成器： 使用从测试运行收集的数据生成报表，通常为带样式的 <code>HTML</code></li></ul><p>若要通过 Coverlet 获得代码覆盖率，现有单元测试项目必须具有相应的包依赖项，或者依赖于全局工具和对应的 <code>coverlet.console NuGet</code> 包，代码覆盖率是单元测试运行的代码量（行、分支或方法）的度量值，企业版的VS自带了代码覆盖率分析工具，参考：</p><ul><li><a href="https://docs.microsoft.com/en-us/visualstudio/test/using-code-coverage-to-determine-how-much-code-is-being-tested">https://docs.microsoft.com/en-us/visualstudio/test/using-code-coverage-to-determine-how-much-code-is-being-tested</a></li><li><a href="https://github.com/Microsoft/vstest-docs/blob/master/docs/analyze.md#coverage">https://github.com/Microsoft/vstest-docs/blob/master/docs/analyze.md#coverage</a></li></ul><p><code>.dotnet Core</code>（暂不支持<code>.NetFramework</code>）获取代码覆盖率的大致步骤：<code>coverlet(数据收集器)</code>=&gt;<code>ReportGenerator(报表生成器)</code>=&gt;代码覆盖率报告。</p><h1 id="单元测试框架">单元测试框架</h1><p><code>dotnet core </code>中常用的单元测试的框架有<code>MSTest</code>、<code>NUnit</code>和<code>xUnit.net</code>，使用方法都非常相似，都是通过特性标记的方式声明测试方法，然后在方法中使用断言<code>Assertions</code>来判别方法执行结果是否达到预期。</p><p><a href="https://docs.microsoft.com/zh-cn/dotnet/core/testing/?pivots=mstest">dotnet 平台下单元测试各框架介绍</a></p><p><a href="http://https://xunit.github.io/docs/comparisons">框架特性及断言比较参考</a></p><h1 id="MSBuild">MSBuild</h1><p>使用 <code>MSBuild</code> 方式运行测试并生成指定名称的测试结果文件，输出到指定目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet test TestApplication.UnitTests.csproj  /p:CollectCoverage=true /p:CoverletOutputFormat=opencover /p:CoverletOutput=./TestResults/</span><br></pre></td></tr></table></figure><p><img src="/images/2021-09-26-14-18-49.png" alt=""><br>这里有个问题：对使用依赖注入的项目这里获取的覆盖率为0，详情：</p><ul><li><a href="https://github.com/coverlet-coverage/coverlet/blob/master/Documentation/KnownIssues.md">https://github.com/coverlet-coverage/coverlet/blob/master/Documentation/KnownIssues.md</a></li><li><a href="https://github.com/coverlet-coverage/coverlet/issues/922">https://github.com/coverlet-coverage/coverlet/issues/922</a></li></ul><h1 id="VSTest">VSTest</h1><p>使用 <code>coverlet</code> 命令生成覆盖率<code>xml</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet test TestApplication.UnitTests.csproj --collect:&quot;XPlat Code Coverage&quot;</span><br></pre></td></tr></table></figure><h1 id="Reportgenerator">Reportgenerator</h1><p>使用 <code>reportgenerator</code> 命令将<code>xml</code>文件渲染成<code>Html</code>，因为<code>Msbuild</code> 和 <code>VsTest </code>方式生成的目录结果有所不同所以渲染命令也有所不同。</p><h2 id="MSBuild-v2">MSBuild</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reportgenerator &quot;-reports:./TestResults/*.xml;&quot;&quot;--targetdir:D:\RunTime\TestReport&quot;  -reporttypes:Html</span><br></pre></td></tr></table></figure><h2 id="VSTest-v2">VSTest</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reportgenerator &quot;-reports:./TestResults/*/*.xml&quot; &quot;--targetdir:D:\RunTime\TestReport&quot;  -reporttypes:Html</span><br></pre></td></tr></table></figure><h2 id="合并渲染">合并渲染</h2><p>找到<code>xml</code>文件路径，<code>-reports</code> 命令中以<code>;</code>分割即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reportgenerator &quot;-reports:TestApplication.UnitTests/TestResults/*.xml;TestApplication.IntegrationTests/TestResults/*.xml;&quot; &quot;--targetdir:D:\RunTime\TestReport&quot;  -reporttypes:Html</span><br></pre></td></tr></table></figure><p><strong>注意当前的工作目录</strong></p><p>参考：</p><ul><li><a href="https://www.cnblogs.com/cgzl/p/9326127.html">https://www.cnblogs.com/cgzl/p/9326127.html</a></li><li><a href="https://github.com/coverlet-coverage/coverlet">https://github.com/coverlet-coverage/coverlet</a></li><li><a href="https://github.com/danielpalme/ReportGenerator">https://github.com/danielpalme/ReportGenerator</a></li></ul><h1 id="测试可重复性">测试可重复性</h1><ul><li>使用<code>COM+自动事务</code>(TestFixture)</li><li>使用数据清理来保证测试用例的独立和可重复性<code>TestInitialize/TestCleanup</code></li></ul><h1 id="Mock">Mock</h1><p>面向对象编程应该显式依赖抽象，单元测试时应屏蔽依赖的影响(无论是依赖还未实现，或者实现的依赖会阻碍代码执行)，为了满足这一需求出现了<code>Mock</code>、<code>Fake</code>等方式，其原理就是创建一个&quot;假&quot;的&quot;空&quot;的依赖，并用其替代真实依赖，以确保代码能够运行。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OrgPublisherServiceTests</span> : <span class="title">TestBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> Mock&lt;ILogRecorder&lt;OrgPublisherService&gt;&gt; _logger;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrgPublisherServiceTests</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _logger = <span class="keyword">new</span> Mock&lt;ILogRecorder&lt;OrgPublisherService&gt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://https://docs.microsoft.com/zh-cn/dotnet/core/testing/unit-testing-best-practices">单元测试最佳实践</a></p><p><a href="https://github.com/dotnet/aspnetcore/wiki/Engineering-guidelines#unit-tests-and-functional-tests">单元测试规范</a></p><h1 id="注意-v2">注意</h1><p>单元测试仅能保证软件的最小可执行单元是正确的，真正的软件是由这些最小可执行单元组成的一个整体，单元的正确性无法保证整体的正确性。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/test/%E8%87%AA%E5%8A%A8%E5%8C%96UI%E6%B5%8B%E8%AF%95/"/>
      <url>/test/%E8%87%AA%E5%8A%A8%E5%8C%96UI%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p><code>Selenium</code>可以用来做<code>自动化UI测试</code>，支持多语言，这里使用<code>C#</code>编写测试脚本。</p><span id="more"></span><h1 id="NetFramework">.NetFramework</h1><p><code>Selenium.Support</code>，<code>Selenium.WebDriver</code>,<code>Selenium.RC</code></p><h1 id="Dotnet-core">Dotnet core</h1><p>核心库：<code>Selenium.Support</code>，<code>Selenium.WebDriver</code>,<code>Selenium.Chrome.WebDriver</code></p><p>注意：Selenium.RC包在dotnetcore会存在不兼容的问题，无法正常找到<code>chromedriver.exe</code> 文件。</p><p><strong>Exception</strong></p><blockquote><p>The chromedriver.exe file does not exist in the current directory or in a directory on the PATH environment variable. The driver can be downloaded at <a href="http://chromedriver.storage.googleapis.com/index.html.%E2%80%9D">http://chromedriver.storage.googleapis.com/index.html.”</a></p></blockquote><p><strong>解决方法</strong></p><blockquote><p>nuget Selenium.Chrome.WebDriver。将ChromeDriver.exe放入构建目录中</p></blockquote><p><strong>注意</strong>：.netcore2.1中引入了<code>Selenium.Chrome.WebDriver</code>包依旧会出现上面的异常</p><h1 id="浏览器驱动下载">浏览器驱动下载</h1><p>需下载本机对应版本，不区分32/64</p><p><a href="https://npm.taobao.org/mirrors/chromedriver/">https://npm.taobao.org/mirrors/chromedriver/</a></p><h1 id="PageObject">PageObject</h1><p>解决的问题：版本迭代太快，UI层元素的属性经常变换，导致维护人员需要花大把的时间去维护代码，为了节省维护成本及时间，就可以利用PageObject 这种设计模式，它就大大的减少了维护时间。</p><p>创建对应浏览器配置，创建WebDriver对象：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">TestBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> IWebDriver driver;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">WebDriverInit</span>(<span class="params"><span class="built_in">string</span> url</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ChromeOptions options = <span class="keyword">new</span> ChromeOptions();</span><br><span class="line">        <span class="comment">// 窗口最大化</span></span><br><span class="line">        options.AddArgument(<span class="string">&quot;start-maximized&quot;</span>);</span><br><span class="line">        driver = <span class="keyword">new</span> ChromeDriver(options);</span><br><span class="line">        driver.Navigate().GoToUrl(url);</span><br><span class="line">        Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ClockInPage，页面模型，封装页面标签属性以及对应操作：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ClockInPage</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">PagePath</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">string</span> input_loginName_id = <span class="string">&quot;tb_LoginID_Account_589f1fc067ff4031&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">string</span> input_passWord_id = <span class="string">&quot;tb_Password&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">string</span> submit_login_Name = <span class="string">&quot;ctl10&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LoginClick</span>(<span class="params">IWebDriver driver, <span class="built_in">string</span> logiName, <span class="built_in">string</span> passWord</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        driver.FindElement(By</span><br><span class="line">            .Id(PagePath.input_loginName_id)).SendKeys(logiName);</span><br><span class="line">        driver.FindElement(By</span><br><span class="line">            .Id(PagePath.input_passWord_id)).SendKeys(passWord);</span><br><span class="line">        driver.FindElement(By</span><br><span class="line">            .Name(PagePath.submit_login_Name)).Click();</span><br><span class="line">        Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ClockInTests，测试方法,采用DDT数据驱动方式提供测试数据：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">TestCategory(<span class="meta-string">&quot;ui\\CodedUITest&quot;</span>)</span>]</span><br><span class="line">[<span class="meta">TestClass()</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ClockInTests</span> : <span class="title">TestBase</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">TestCleanup</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Clean</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        driver.Dispose();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">DataTestMethod</span>]</span><br><span class="line">    [<span class="meta">DataRow(<span class="meta-string">&quot;http://11.11.141.10/OMSP//Login/JSS.aspx&quot;</span>, <span class="meta-string">&quot;wangpengliang&quot;</span>, <span class="meta-string">&quot;Wpl-19950815&quot;</span>, true)</span>]</span><br><span class="line">    [<span class="meta">DataRow(<span class="meta-string">&quot;http://11.11.141.10/OMSP//Login/JSS.aspx&quot;</span>, <span class="meta-string">&quot;111111&quot;</span>, <span class="meta-string">&quot;222222&quot;</span>, false)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ClockIn_Login_01_Normal</span>(<span class="params"><span class="built_in">string</span> url, <span class="built_in">string</span> loginName, <span class="built_in">string</span> passWord, <span class="built_in">bool</span> expect</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        WebDriverInit(url);</span><br><span class="line">        ClockInPage page = <span class="keyword">new</span> ClockInPage();</span><br><span class="line">        page.LoginClick(driver, loginName, passWord);</span><br><span class="line">        Assert.AreEqual(expect, driver.Url != url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/test/%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95/"/>
      <url>/test/%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>学习一下C#中集成测试</p><span id="more"></span><h1 id="集成测试">集成测试</h1><p>集成测试可在包含应用支持基础结构（如数据库、文件系统和网络）的级别上确保应用组件功能正常。</p><p>单元测试关注是的软件最小可执行单元是否能够正常执行，但软件是由一个个最小执行单元组成的集合体，单元与单元之间存在着种种依赖或联系，所以在开发时仅仅确保最小单元的正确往往不够，为了保证软件能够正确运行，单元与单元之间的集成测试是非常必要。</p><p>与单元测试相比，集成测试可在更广泛的级别上评估应用的组件。 单元测试用于测试独立软件组件，如单独的类方法。 集成测试确认两个或更多应用组件一起工作以生成预期结果，可能包括完整处理请求所需的每个组件。</p><h1 id="TestServer">TestServer</h1><p>使用 <code>TestServer</code> 测试API接口</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">       <span class="function"><span class="keyword">protected</span> TestServer <span class="title">CreateSingleTestServer</span>(<span class="params"></span>)</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span> (testServer == <span class="literal">null</span>)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">lock</span> (singleton_Lock)</span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="keyword">if</span> (testServer == <span class="literal">null</span>)</span><br><span class="line">                   &#123;</span><br><span class="line">                       <span class="built_in">string</span> path = Assembly.GetAssembly(<span class="keyword">typeof</span>(TestBase)).Location;</span><br><span class="line"></span><br><span class="line">                       IWebHostBuilder hostBuilder =</span><br><span class="line">                           <span class="keyword">new</span> WebHostBuilder()</span><br><span class="line">                               .UseContentRoot(Path.GetDirectoryName(path))</span><br><span class="line">                               .ConfigureAppConfiguration(cb =&gt;</span><br><span class="line">                               &#123;</span><br><span class="line">                                   cb.AddJsonFile(<span class="string">&quot;appsettings.test.json&quot;</span>, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">                               &#125;)</span><br><span class="line">                               .UseEnvironment(<span class="string">&quot;Development&quot;</span>)</span><br><span class="line">                               .UseStartup&lt;TestStartup&gt;();</span><br><span class="line"></span><br><span class="line">                       testServer = <span class="keyword">new</span> TestServer(hostBuilder);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> testServer;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestStartup</span> : <span class="title">Startup</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="title">TestStartup</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">               IConfiguration configuration,</span></span></span><br><span class="line"><span class="params"><span class="function">               IHostingEnvironment env</span>) : <span class="title">base</span>(<span class="params">configuration, env</span>)</span></span><br><span class="line">           &#123;</span><br><span class="line"><span class="keyword">if</span> debug</span><br><span class="line">               <span class="built_in">string</span> connectionString =</span><br><span class="line">                   Configuration.GetSection(<span class="string">&quot;Database:ConnectString&quot;</span>).Value;</span><br><span class="line"></span><br><span class="line">               testDbContext =</span><br><span class="line">                   <span class="keyword">new</span> ApplicationDbContext(<span class="keyword">new</span> DbContextOptionsBuilder&lt;ApplicationDbContext&gt;()</span><br><span class="line">                       .UseSqlServer(connectionString)</span><br><span class="line">                       .Options);</span><br><span class="line">endif</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">TestClass</span>]</span><br><span class="line">[<span class="meta">TestCategory(<span class="meta-string">&quot;integration&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ApiTest</span> : <span class="title">TestBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> HttpClient client;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">TestInitialize</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Init</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        client = testServer.CreateClient();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">TestCleanup</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Cleanup</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        client.Dispose();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">TestMethod</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">GetAsync</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> response =</span><br><span class="line">           <span class="keyword">await</span> client.GetAsync(<span class="string">$&quot;/api/values&quot;</span>);</span><br><span class="line">        Assert.AreEqual(HttpStatusCode.OK, response.StatusCode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="https://www.cnblogs.com/selimsong/p/9263957.html">https://www.cnblogs.com/selimsong/p/9263957.html</a></li><li><a href="https://docs.microsoft.com/zh-cn/dotnet/core/testing/?pivots=mstest">https://docs.microsoft.com/zh-cn/dotnet/core/testing/?pivots=mstest</a></li><li><a href="https://docs.microsoft.com/zh-cn/aspnet/core/test/integration-tests?view=aspnetcore-3.1#test-app-prerequisites">https://docs.microsoft.com/zh-cn/aspnet/core/test/integration-tests?view=aspnetcore-3.1#test-app-prerequisites</a></li><li><a href="https://www.cnblogs.com/selimsong/p/9306221.html">https://www.cnblogs.com/selimsong/p/9306221.html</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/test/%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95k6/"/>
      <url>/test/%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95k6/</url>
      
        <content type="html"><![CDATA[<p><code>k6</code> 是GitHub上提供的开源负载测试工具，使用Go编写。测试脚本使用JavaScript编写。</p><span id="more"></span><h1 id="先决条件">先决条件</h1><ul><li>安装K6 <a href="https://k6.io/docs/getting-started/installation">https://k6.io/docs/getting-started/installation</a></li><li>环境变量配置；<code>cd</code> 到压测脚本目录</li></ul><h1 id="概念-v3">概念</h1><ul><li>vu：虚拟用户</li><li>duration:持续时长</li></ul><h1 id="入门">入门</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> http <span class="keyword">from</span> <span class="string">&#x27;k6/http&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; sleep &#125; <span class="keyword">from</span> <span class="string">&#x27;k6&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  http.get(<span class="string">&#x27;http://localhost:5000/api/values&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">k6 run ValuesApiK6.js</span><br></pre></td></tr></table></figure><h1 id="多Vu和指定时长">多Vu和指定时长</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">k6 run --vus 10 --duration 10s ValuesApiK6.js</span><br></pre></td></tr></table></figure><h1 id="使用配置选项">使用配置选项</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> http <span class="keyword">from</span> <span class="string">&quot;k6/http&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; sleep,check &#125; <span class="keyword">from</span> <span class="string">&quot;k6&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> options = &#123;</span><br><span class="line">  <span class="attr">vus</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">duration</span>: <span class="string">&#x27;10s&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 脚本至少必须包含一个default函数,这定义了VU的入口点，类似于许多其他语言中的main()函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = http.get(<span class="string">&quot;http://localhost:5000/api/values&quot;</span>);</span><br><span class="line">  check(res, &#123; <span class="string">&#x27;status was 200&#x27;</span>: <span class="function"><span class="params">r</span> =&gt;</span> r.status == <span class="number">200</span> &#125;);</span><br><span class="line">  sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="阶段负载">阶段负载</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> http <span class="keyword">from</span> <span class="string">&quot;k6/http&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; sleep, check &#125; <span class="keyword">from</span> <span class="string">&quot;k6&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> options = &#123;</span><br><span class="line">  <span class="comment">// 阶段负载</span></span><br><span class="line">  <span class="attr">stages</span>: [</span><br><span class="line">    &#123; <span class="attr">duration</span>: <span class="string">&quot;3s&quot;</span>, <span class="attr">target</span>: <span class="number">2</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">duration</span>: <span class="string">&quot;5s&quot;</span>, <span class="attr">target</span>: <span class="number">3</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">duration</span>: <span class="string">&quot;6s&quot;</span>, <span class="attr">target</span>: <span class="number">10</span> &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 脚本至少必须包含一个default函数,这定义了VU的入口点，类似于许多其他语言中的main()函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = http.get(<span class="string">&quot;http://localhost:5000/api/values&quot;</span>);</span><br><span class="line">  check(res, &#123; <span class="string">&quot;status was 200&quot;</span>: <span class="function">(<span class="params">r</span>) =&gt;</span> r.status == <span class="number">200</span> &#125;);</span><br><span class="line">  sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能出现的异常：<code>using multiple execution config shortcuts (</code>duration<code>and</code>stages<code>) simultaneously is not allowed</code>  不允许同时使用多个执行配置快捷方式(“duration”和“stages”)。</p><h1 id="断言">断言</h1><p>需要<code>import &#123; sleep, check &#125; from &quot;k6&quot;;</code> 引入check模块。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">check(res, &#123; <span class="string">&quot;status was 200&quot;</span>: (r) =&gt; r.status == 200 &#125;);</span><br></pre></td></tr></table></figure><h1 id="测试结果">测试结果</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> execution: local-</span><br><span class="line">     script: ValuesApiK6.js</span><br><span class="line">     <span class="attr">output</span>: -</span><br><span class="line"></span><br><span class="line">  scenarios: (<span class="number">100.00</span>%) <span class="number">1</span> executors, <span class="number">10</span> max VUs, 44s max duration (incl. graceful stop):</span><br><span class="line">           * <span class="keyword">default</span>: Up to <span class="number">10</span> looping VUs <span class="keyword">for</span> 14s over <span class="number">3</span> stages (gracefulRampDown: 30s, <span class="attr">gracefulStop</span>: 30s)</span><br><span class="line"></span><br><span class="line">I</span><br><span class="line">running (<span class="number">16.</span>0s), <span class="number">00</span>/<span class="number">10</span> VUs, <span class="number">38</span> complete and <span class="number">0</span> interrupted iterations</span><br><span class="line"><span class="keyword">default</span> ✓ [======================================] <span class="number">00</span>/<span class="number">10</span> VUs  14s9</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ✓ status was <span class="number">200</span> </span><br><span class="line"> </span><br><span class="line">    checks.....................: <span class="number">100.00</span>% ✓ <span class="number">38</span>   ✗ <span class="number">0</span></span><br><span class="line">    data_received..............: <span class="number">176</span> MB  <span class="number">11</span> MB/s</span><br><span class="line">    data_sent..................: <span class="number">3.3</span> kB  <span class="number">208</span> B/s</span><br><span class="line">    http_req_blocked...........: avg=<span class="number">79.1</span>µs   min=0s       med=0s       max=2ms     p(<span class="number">90</span>)=0s      p(<span class="number">95</span>)=<span class="number">149.71</span>µs</span><br><span class="line">    http_req_connecting........: avg=<span class="number">52.85</span>µs  min=0s       med=0s       max=<span class="number">1.</span>01ms  p(<span class="number">90</span>)=0s      p(<span class="number">95</span>)=<span class="number">149.71</span>µs</span><br><span class="line">    http_req_duration..........: avg=<span class="number">682.</span>14ms min=<span class="number">332.</span>4ms  med=<span class="number">516.</span>59ms max=<span class="number">1.</span>66s   p(<span class="number">90</span>)=<span class="number">1.</span>22s   p(<span class="number">95</span>)=<span class="number">1.</span>44s</span><br><span class="line">    http_req_receiving.........: avg=<span class="number">10.</span>39ms  min=<span class="number">3.</span>98ms   med=<span class="number">8.</span>97ms   max=<span class="number">37.</span>89ms p(<span class="number">90</span>)=<span class="number">16.</span>85ms p(<span class="number">95</span>)=<span class="number">23.</span>37ms</span><br><span class="line">    http_req_sending...........: avg=0s       min=0s       med=0s       max=0s      p(<span class="number">90</span>)=0s      p(<span class="number">95</span>)=0s</span><br><span class="line">    http_req_tls_handshaking...: avg=0s       min=0s       med=0s       max=0s      p(<span class="number">90</span>)=0s      p(<span class="number">95</span>)=0s</span><br><span class="line">    http_req_waiting...........: avg=<span class="number">671.</span>75ms min=<span class="number">323.</span>42ms med=<span class="number">508.</span>61ms max=<span class="number">1.</span>65s   p(<span class="number">90</span>)=<span class="number">1.</span>21s   p(<span class="number">95</span>)=<span class="number">1.</span>43s</span><br><span class="line">    http_reqs..................: <span class="number">38</span>      <span class="number">2.374567</span>/s</span><br><span class="line">    iteration_duration.........: avg=<span class="number">1.</span>68s    min=<span class="number">1.</span>33s    med=<span class="number">1.</span>51s    max=<span class="number">2.</span>66s   p(<span class="number">90</span>)=<span class="number">2.</span>22s   p(<span class="number">95</span>)=<span class="number">2.</span>44s</span><br><span class="line">    iterations.................: <span class="number">38</span>      <span class="number">2.374567</span>/s</span><br><span class="line">    vus........................: <span class="number">0</span>       min=<span class="number">0</span>  max=<span class="number">9</span></span><br><span class="line">    vus_max....................: <span class="number">10</span>      min=<span class="number">10</span> max=<span class="number">10</span></span><br></pre></td></tr></table></figure><p>测试细节</p><ul><li><code>execution </code>k6执行模式（本地或云）</li><li><code>output</code> 测试结果的输出。默认值为stdout</li><li><code>script: script.js</code> 显示正在执行的脚本的名称</li><li><code>duration</code> 测试运行时间</li><li><code>iterations</code>  VU 迭代的总数</li><li><code>vus</code>  测试将开始运行的VU的初始数量</li><li><code>max</code>  测试将扩展的VU的最大数量</li></ul><p>测试指标分析参考：<a href="https://k6.io/docs/using-k6/metrics">https://k6.io/docs/using-k6/metrics</a></p><h1 id="测试结果输出第三方平台">测试结果输出第三方平台</h1><p>参考：<a href="https://k6.io/docs/getting-started/results-output#output-plugins">https://k6.io/docs/getting-started/results-output#output-plugins</a></p><h1 id="输出Json格式">输出Json格式</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">k6 run --summary-export=export.json test.js</span><br></pre></td></tr></table></figure><h1 id="输出JSON格式详细信息">输出JSON格式详细信息</h1><p>使用 <code>--out/-o</code> 选项使k6输出JSON格式的详细统计信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">k6 run --out json=my_test_result.json test.js</span><br></pre></td></tr></table></figure><h1 id="tags打标签分组">tags打标签分组</h1><p>参考：<a href="https://k6.io/docs/using-k6/http-requests#url-grouping">https://k6.io/docs/using-k6/http-requests#url-grouping</a></p><h1 id="K6内置指标">K6内置指标</h1><p>参考：<a href="https://k6.io/docs/using-k6/metrics#custom-metrics">https://k6.io/docs/using-k6/metrics#custom-metrics</a></p><h1 id="HTTP内置指标">HTTP内置指标</h1><p>参考：<a href="https://k6.io/docs/using-k6/metrics#metric-types">https://k6.io/docs/using-k6/metrics#metric-types</a></p><h1 id="阈值">阈值</h1><p>阈值是通过/失败标准，用于指定被测系统的性能期望</p><p>预期示例（阈值）：</p><ul><li>系统产生的错误不超过1％</li><li>95％的请求的响应时间应小于200ms</li><li>99％的请求的响应时间应低于400毫秒</li><li>特定端点必须始终在300毫秒内响应</li><li>阈值分析性能指标并确定最终测试结果（通过/失败）。阈值对于负载测试自动化至关重要</li></ul><p>参考：<a href="https://k6.io/docs/using-k6/thresholds">https://k6.io/docs/using-k6/thresholds</a></p><h1 id="分析结果可视化">分析结果可视化</h1><h1 id="influxdb">influxdb</h1><ol><li>安装目录下运行启动 <code>influxdb</code></li><li>启动客户端输入命令开始操作 <code>influx</code></li><li><code>k6 run --out influxdb=http://localhost:8080/test ValuesApiK6.js</code></li></ol><h1 id="Grafana">Grafana</h1><p><img src="/images/2021-09-26-14-43-35.png" alt=""></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/redis/1.9Redis%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88/"/>
      <url>/redis/1.9Redis%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis集群">Redis集群</h1><p>Redis支持三种集群方案</p><ul><li>主从复制</li><li>Sentinel（哨兵）</li><li>Cluster</li></ul><span id="more"></span><h2 id="主从复制">主从复制</h2><p>通过持久化功能，Redis保证了即使在服务器重启的情况下也不会丢失（或少量丢失）数据，因为持久化会把内存中数据保存到硬盘上，重启会从硬盘上加载数据。 但是由于数据是存储在一台服务器上的，如果这台服务器出现硬盘故障等问题，也会导致数据丢失。为了避免单点故障，通常的做法是将数据库复制多个副本以部署在不同的服务器上，这样即使有一台服务器出现故障，其他服务器依然可以继续提供服务。</p><p>为此： <code>Redis 提供了复制（replication）功能，可以实现当一台数据库中的数据更新后，自动将更新的数据同步到其他数据库上</code>。</p><p>在复制的概念中，数据库分为两类，一类是主数据库（master），另一类是从数据库(slave）。主数据库可以进行读写操作，当写操作导致数据变化时会自动将数据同步给从数据库。而从数据库一般是只读的，只接受主数据库同步过来的数据。<code>一个主数据库可以拥有多个从数据库，而一个从数据库只能拥有一个主数据库</code>。</p><h3 id="实现原理">实现原理</h3><ol><li>从库启动成功后连接主库，发送 <code>SYNC</code> 命令</li><li>主库接收到 <code>SYNC</code> 命令后，开始执行 <code>BGSAVE</code> 命令生成 <code>rdb</code> 文件并使用缓冲区记录此后执行的所有写命令</li><li>主库 <code>BGSAVE</code> 执行完毕后，向所有从库发送快照文件，并在发送期间继续记录被执行的写命令</li><li>从库收到快照文件后丢弃所有旧数据，载入收到的快照</li><li>主库快照发送完毕后开始向从库发送缓冲区中的写命令</li><li>从库完成对快照的载入，开始接收命令请求，并执行来自主库缓冲区的写命令（至此：从库初始化完成）</li><li>主库每执行一个写命令就会向从库发送相同的写命令，从库接收并执行收到的写命令（备注：从库初始化完成后的操作）</li><li>出现断开重连后，2.8之后的版本会将断线期间的命令传给从库。增量复制</li><li>主从刚连接时：进行全量同步。全同步结束后：进行增量同步。当然如果有需要 slave 可以在任何时候都可以发起全量同步。Redis 的策略是：无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步</li></ol><h3 id="主从复制优缺点"><strong>主从复制优缺点</strong></h3><p><strong>优点</strong></p><ul><li>主机会自动将数据同步到从机，可以进行读写分离</li><li>为了分载 <code>master</code> 的读操作压力，<code>slave</code> 服务器可以为客户端提供只读操作的服务，但写服务仍必须由 <code>master</code> 完成</li><li><code>slave</code> 同样可以接受其它 <code>slaves</code> 的连接和同步请求，这样可以有效的分载 <code>master</code> 的同步压力</li><li><code>master-server</code> 是以非阻塞的方式为 <code>slaves</code>提供服务。所以在 <code>master-slave</code> 同步期间，客户端仍然可以提交查询或修改请求</li><li><code>slave-server</code> 同样是以非阻塞的方式完成数据同步。在同步期间，如果有客户端提交查询请求，则返回同步之前的数据</li></ul><p><strong>缺点</strong></p><ul><li>不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换 <code>IP</code> 才能恢复（人工介入方式）</li><li>主机宕机，宕机前如有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性</li><li>如果多个 <code>slave</code> 掉线需要重启时，尽量不要在同一时间段进行重启。因为只要 <code>slave</code> 启动，就会发送<code>sync</code> 请求和主机全量同步，当多个 <code>slave</code> 重启时，可能会导致 <code>master</code> <code>IO</code> 剧增从而宕机</li><li>较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂</li></ul><h3 id="主从复制搭建">主从复制搭建</h3><ul><li>集群至少需要3个节点，因为投票容错机制要求超过半数节点认为某个节点挂了该节点才是挂了，所以低于3个节点无法构成集群</li><li>要保证集群的高可用，需要每个节点都有从节点，也就是备份节点。所以Redis集群至少需要6台服务器。这里模拟搭建的是伪分布式集群（<strong>单机多实例</strong>）</li><li>默认情况下不指定主机的话，每台 Redis 都是主节点</li></ul><p>1)：虚机运行3个 Redis 实例（一主二从），修改端口号为（79-81）。复制2份 <code>redis.conf</code> 模拟2个从机实例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang bin]<span class="comment"># ls</span></span><br><span class="line">conf  dump.rdb  redis-benchmark  redis-check-aof  redis-check-rdb  redis-cli  redis-sentinel  redis-server</span><br><span class="line">[root@wangpengliang bin]<span class="comment"># cd conf</span></span><br><span class="line">[root@wangpengliang conf]<span class="comment"># ls</span></span><br><span class="line">redis.conf</span><br><span class="line">[root@wangpengliang conf]<span class="comment"># cp redis.conf redis80.conf</span></span><br><span class="line">[root@wangpengliang conf]<span class="comment"># cp redis.conf redis81.conf</span></span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">端口</th><th style="text-align:center">配置文件</th></tr></thead><tbody><tr><td style="text-align:center">master</td><td style="text-align:center">6379</td><td style="text-align:center">redis.conf</td></tr><tr><td style="text-align:center">slave1</td><td style="text-align:center">6380</td><td style="text-align:center">redis80.conf</td></tr><tr><td style="text-align:center">slave2</td><td style="text-align:center">6381</td><td style="text-align:center">redis81.conf</td></tr></tbody></table><p>2)：修改配置</p><ol><li><code>logfile</code></li><li><code>dbfilename</code></li><li><code>port</code></li><li><code>pidfile</code></li></ol><p>redis.conf</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">logfile <span class="string">&quot;6379.log&quot;</span></span><br><span class="line">dbfilename dump6379.rdb</span><br></pre></td></tr></table></figure><p>redis80.conf</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">logfile <span class="string">&quot;6380.log&quot;</span></span><br><span class="line">dbfilename dump6380.rdb</span><br><span class="line">port 6380</span><br><span class="line">pidfile /var/run/redis_6380.pid</span><br></pre></td></tr></table></figure><p>redis81.conf</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">logfile <span class="string">&quot;6381.log&quot;</span></span><br><span class="line">dbfilename dump6381.rdb</span><br><span class="line">port 6381</span><br><span class="line">pidfile /var/run/redis_6381.pid</span><br></pre></td></tr></table></figure><p>3)：查看Redis进程信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang conf]<span class="comment"># ps -ef|grep redis</span></span><br><span class="line">root       2679      1  0 02:53 ?        00:00:00 ./redis-server 0.0.0.0:6379</span><br><span class="line">root       2685      1  0 02:54 ?        00:00:00 ./redis-server 0.0.0.0:6380</span><br><span class="line">root       2691      1  0 02:54 ?        00:00:00 ./redis-server 0.0.0.0:6381</span><br><span class="line">root       2697   2643  0 02:54 pts/3    00:00:00 grep --color=auto redis</span><br></pre></td></tr></table></figure><p>4)：设置主从：<code>SLAVEOF &#123;host&#125; &#123;port&#125;</code></p><p>80</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang bin]<span class="comment"># ./redis-cli -p 6380</span></span><br><span class="line">127.0.0.1:6380&gt; SLAVEOF 0.0.0.0 6379</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6380&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:slave</span><br><span class="line">master_host:0.0.0.0</span><br><span class="line">master_port:6379</span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:0</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_repl_offset:28</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:fb828085ccb5c0b804cfa2e8112656aef5f561c8</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:28</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:28</span><br></pre></td></tr></table></figure><p>81</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang bin]<span class="comment"># ./redis-cli -p 6381</span></span><br><span class="line">127.0.0.1:6381&gt; clear</span><br><span class="line">127.0.0.1:6381&gt; SLAVEOF 0.0.0.0 6379</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6381&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:slave</span><br><span class="line">master_host:0.0.0.0</span><br><span class="line">master_port:6379</span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:1</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_repl_offset:210</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:fb828085ccb5c0b804cfa2e8112656aef5f561c8</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:210</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:183</span><br><span class="line">repl_backlog_histlen:28</span><br></pre></td></tr></table></figure><p>79（master）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:2</span><br><span class="line">slave0:ip=127.0.0.1,port=6380,state=online,offset=210,lag=0</span><br><span class="line">slave1:ip=127.0.0.1,port=6381,state=online,offset=210,lag=0</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:fb828085ccb5c0b804cfa2e8112656aef5f561c8</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:210</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:210</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：使用命令的方式集群是暂时的；如果需要永久生效需要修改配置文件</p><p>5)：修改配置文件设置主从</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replicaof &lt;masterip&gt; &lt;masterport&gt;</span><br></pre></td></tr></table></figure><p>redis80.conf</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replicaof 0.0.0.0 6379</span><br></pre></td></tr></table></figure><p>redis81.conf</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replicaof 0.0.0.0 6379</span><br></pre></td></tr></table></figure><p>如果主机有密码通过 <code>masterauth &lt;master-password&gt;</code> 设置。</p><p><strong>注意</strong></p><ul><li>主机可写，从机只能读不能写</li><li>主机中数据会自动备份到从机</li></ul><p>6)：主机宕机测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SHUTDOWN</span><br><span class="line">not connected&gt; <span class="built_in">exit</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang bin]<span class="comment"># ps -ef|grep redis</span></span><br><span class="line">root       2723      1  0 03:12 ?        00:00:00 ./redis-server 0.0.0.0:6380</span><br><span class="line">root       2728   2605  0 03:12 pts/1    00:00:00 ./redis-cli -p 6380</span><br><span class="line">root       2730      1  0 03:12 ?        00:00:00 ./redis-server 0.0.0.0:6381</span><br><span class="line">root       2735   2624  0 03:12 pts/2    00:00:00 ./redis-cli -p 6381</span><br><span class="line">root       2738   2643  0 03:16 pts/3    00:00:00 grep --color=auto redis</span><br></pre></td></tr></table></figure><p>80</p><p>此时并没有配置哨兵，所以在 <code>Master</code> 79宕机后，80依旧是从机。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6380&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:slave</span><br><span class="line">master_host:0.0.0.0</span><br><span class="line">master_port:6379</span><br><span class="line">master_link_status:down</span><br><span class="line">master_last_io_seconds_ago:-1</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_repl_offset:1130</span><br><span class="line">master_link_down_since_seconds:17</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:fb828085ccb5c0b804cfa2e8112656aef5f561c8</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:1130</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:771</span><br><span class="line">repl_backlog_histlen:360</span><br></pre></td></tr></table></figure><ul><li>主机断线重连后，从机依旧可以读取到主机的值</li><li>从机断线重连后，从机依旧可以读取到主机的值</li></ul><p>7)：手动切换主节点</p><p>此时使用 <code>Slaveof no one</code> 命令可以使80变成主机。</p><h2 id="Sentinel（哨兵）模式">Sentinel（哨兵）模式</h2><p>主从切换的方法是：当主服务器宕机后，需要手动把从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。这不是一种推荐的方式。哨兵模式是一种特殊的模式，首先 Redis 提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是：哨兵通过发送命令等待Redis服务器响应，从而监控运行的多个Redis实例。</p><h3 id="哨兵作用">哨兵作用</h3><ul><li>通过发送命令，让 Redis 服务器返回监控其运行状态，包括主服务器和从服务器</li><li>当哨兵监测到 master 宕机，会自动将 slave切换成  master ，然后通过 发布订阅模式通知其他的从机修改配置文件，让它们切换主机</li><li>master 切换后，<code>master_redis.conf</code> 、<code>slave_redis.conf</code> 和 <code>sentinel.conf</code> 的内容都会发生改变，<code>master_redis.conf</code>  中会多一行 <code>slaveof </code>的配置，<code>sentinel.conf</code> 的监控目标会随之调换</li><li>一个哨兵进程对 <code>Redis</code> 服务器进行监控，可能会出现问题，为此可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这就形成了多哨兵模式</li></ul><h3 id="故障切换（failover）过程">故障切换（failover）过程</h3><ul><li>假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行 <code>failover</code>，仅仅是哨兵1主观的认为主服务器不可用，这个现象称为 <strong>主观下线</strong></li><li>当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行 <code>failover</code> 。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为 <strong>客观下线</strong></li></ul><h3 id="哨兵工作方式">哨兵工作方式</h3><ul><li>每个<code>sentinel</code>以每秒钟一次的频率向它所知的<code>master</code>、<code>slave</code>、 <code>sentinel</code> 实例发送一个 <code>PING</code> 命令</li><li>如果一个实例（<code>instance</code>）距离最后一次有效回复 <code>PING</code> 命令的时间超过 <code>down-after-milliseconds</code>选项所指定的值， 则这个实例会被 <code>sentinel</code> 标记为主观下线</li><li>如果一个<code>master</code>被标记为主观下线，则正在监视这个<code>master</code>的所有 <code>sentinels</code> 要以每秒一次的频率确认<code>master</code> 的确进入了主观下线状态</li><li>当有足够数量的 <code>sentinel</code>（大于等于配置文件指定的值）在指定的时间范围内确认 <code>master</code> 的确进入了主观下线状态，则 <code>master</code> 会被标记为客观下线</li><li>一般情况下， 每个 <code>sentinel</code> 会以每 10 秒一次的频率向它已知的所有 <code>master</code>、<code>slave</code>发送  <code>INFO </code>命令</li><li>当<code>master</code>被 <code>sentinel</code> 标记为客观下线时，<code>sentinel</code> 向 <code>master</code> 的所有 <code>slave</code> 发送 <code>INFO</code> 命令的频率会从 10 秒一次改为每秒一次</li><li>若没有足够数量的 <code>sentinel</code> 同意 <code>master</code> 已经下线， <code>master</code> 的客观下线状态就会被移除。若<code>master</code> 重新向 <code>sentinel</code> 的 <code>PING</code> 命令返回有效回复，<code>master</code> 的主观下线状态就会被移除</li></ul><h3 id="哨兵模式优缺点">哨兵模式优缺点</h3><p><strong>优点</strong></p><ul><li>哨兵模式是基于主从模式的，所有主从的优点哨兵模式都具有</li><li>主从可以自动切换。系统更健壮、可用性更高（可以看作自动版的主从复制）</li></ul><p><strong>缺点</strong></p><ul><li>Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂</li></ul><h3 id="哨兵模式搭建">哨兵模式搭建</h3><p>1)：Redis安装目录下有一个 <code>sentinel.conf</code> 文件，<code>copy  </code>一份进行修改</p><p>2)：配置哨兵</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置监听的主服务器，这里sentinel monitor代表监控，mymaster代表服务器的名称，可以自定义</span></span><br><span class="line"><span class="comment"># 192.168.11.128代表监控的主服务器，6379代表端口，2代表只有两个或两个以上的哨兵认为主服务器不可用的时候，才会进行failover操作。权值为2，这里的权值，是用来计算我们需要将哪一台服务器升级升主服务器</span></span><br><span class="line">sentinel monitor mymaster 0.0.0.0 6379 2</span><br></pre></td></tr></table></figure><p>3)：启动哨兵</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang bin]<span class="comment"># ./redis-sentinel conf/sentinel.conf</span></span><br><span class="line">2821:X 19 Apr 2021 04:13:16.075 <span class="comment"># oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span></span><br><span class="line">2821:X 19 Apr 2021 04:13:16.075 <span class="comment"># Redis version=6.2.1, bits=64, commit=00000000, modified=0, pid=2821, just sta</span></span><br><span class="line">rted2821:X 19 Apr 2021 04:13:16.075 <span class="comment"># Configuration loaded</span></span><br><span class="line">2821:X 19 Apr 2021 04:13:16.076 * Increased maximum number of open files to 10032 (it was originally <span class="built_in">set</span> to 102</span><br><span class="line">4).2821:X 19 Apr 2021 04:13:16.076 * monotonic clock: POSIX clock_gettime</span><br><span class="line">                _._                                                  </span><br><span class="line">           _.-``__ <span class="string">&#x27;&#x27;</span>-._                                             </span><br><span class="line">      _.-``    `.  `_.  <span class="string">&#x27;&#x27;</span>-._           Redis 6.2.1 (00000000/0) 64 bit</span><br><span class="line">  .-`` .-```.  ```\/    _.,_ <span class="string">&#x27;&#x27;</span>-._                                   </span><br><span class="line"> (    <span class="string">&#x27;      ,       .-`  | `,    )     Running in sentinel mode</span></span><br><span class="line"><span class="string"> |`-._`-...-` __...-.``-._|&#x27;</span>` _.-<span class="string">&#x27;|     Port: 26379</span></span><br><span class="line"><span class="string"> |    `-._   `._    /     _.-&#x27;</span>    |     PID: 2821</span><br><span class="line">  `-._    `-._  `-./  _.-<span class="string">&#x27;    _.-&#x27;</span>                                   </span><br><span class="line"> |`-._`-._    `-.__.-<span class="string">&#x27;    _.-&#x27;</span>_.-<span class="string">&#x27;|                                  </span></span><br><span class="line"><span class="string"> |    `-._`-._        _.-&#x27;</span>_.-<span class="string">&#x27;    |           http://redis.io        </span></span><br><span class="line"><span class="string">  `-._    `-._`-.__.-&#x27;</span>_.-<span class="string">&#x27;    _.-&#x27;</span>                                   </span><br><span class="line"> |`-._`-._    `-.__.-<span class="string">&#x27;    _.-&#x27;</span>_.-<span class="string">&#x27;|                                  </span></span><br><span class="line"><span class="string"> |    `-._`-._        _.-&#x27;</span>_.-<span class="string">&#x27;    |                                  </span></span><br><span class="line"><span class="string">  `-._    `-._`-.__.-&#x27;</span>_.-<span class="string">&#x27;    _.-&#x27;</span>                                   </span><br><span class="line">      `-._    `-.__.-<span class="string">&#x27;    _.-&#x27;</span>                                       </span><br><span class="line">          `-._        _.-<span class="string">&#x27;                                           </span></span><br><span class="line"><span class="string">              `-.__.-&#x27;</span>                                               </span><br><span class="line"></span><br><span class="line">2821:X 19 Apr 2021 04:13:16.076 <span class="comment"># WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/</span></span><br><span class="line">net/core/somaxconn is <span class="built_in">set</span> to the lower value of 128.2821:X 19 Apr 2021 04:13:16.077 <span class="comment"># Sentinel ID is fdcb482b76a22f67429b1473ddc33d0d3769f7f3</span></span><br><span class="line">2821:X 19 Apr 2021 04:13:16.077 <span class="comment"># +monitor master mymaster 0.0.0.0 6379 quorum 1</span></span><br><span class="line">2821:X 19 Apr 2021 04:13:16.078 * +slave slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 0.0.0.0 6379</span><br><span class="line">2821:X 19 Apr 2021 04:13:16.080 * +slave slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 0.0.0.0 6379</span><br></pre></td></tr></table></figure><p>Sentinel 启动之后，就会监视到现在有一个主服务器，两个从服务器；当把其中一个从服务器器关闭之后，可以看到日志</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">2821:X 19 Apr 2021 04:14:03.125 <span class="comment"># +sdown master mymaster 0.0.0.0 6379</span></span><br><span class="line">2821:X 19 Apr 2021 04:14:03.125 <span class="comment"># +odown master mymaster 0.0.0.0 6379 #quorum 1/1</span></span><br><span class="line">2821:X 19 Apr 2021 04:14:03.125 <span class="comment"># +new-epoch 1</span></span><br><span class="line">2821:X 19 Apr 2021 04:14:03.125 <span class="comment"># +try-failover master mymaster 0.0.0.0 6379</span></span><br><span class="line">2821:X 19 Apr 2021 04:14:03.132 <span class="comment"># +vote-for-leader fdcb482b76a22f67429b1473ddc33d0d3769f7f3 1</span></span><br><span class="line">2821:X 19 Apr 2021 04:14:03.132 <span class="comment"># +elected-leader master mymaster 0.0.0.0 6379</span></span><br><span class="line">2821:X 19 Apr 2021 04:14:03.132 <span class="comment"># +failover-state-select-slave master mymaster 0.0.0.0 6379</span></span><br><span class="line">2821:X 19 Apr 2021 04:14:03.199 <span class="comment"># +selected-slave slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 0.0.0.0 6379</span></span><br><span class="line">2821:X 19 Apr 2021 04:14:03.199 * +failover-state-send-slaveof-noone slave 127.0.0.1:6380 127.0.0.1 6380 @ myma</span><br><span class="line">ster 0.0.0.0 63792821:X 19 Apr 2021 04:14:03.282 * +failover-state-wait-promotion slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster</span><br><span class="line"> 0.0.0.0 63792821:X 19 Apr 2021 04:14:03.288 <span class="comment"># +promoted-slave slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 0.0.0.0 6379</span></span><br><span class="line">2821:X 19 Apr 2021 04:14:03.288 <span class="comment"># +failover-state-reconf-slaves master mymaster 0.0.0.0 6379</span></span><br><span class="line">2821:X 19 Apr 2021 04:14:03.340 * +slave-reconf-sent slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 0.0.0.0 637</span><br><span class="line">92821:X 19 Apr 2021 04:14:04.312 * +slave-reconf-inprog slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 0.0.0.0 6</span><br><span class="line">3792821:X 19 Apr 2021 04:14:04.312 * +slave-reconf-done slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 0.0.0.0 637</span><br><span class="line">92821:X 19 Apr 2021 04:14:04.378 <span class="comment"># +failover-end master mymaster 0.0.0.0 6379</span></span><br><span class="line">2821:X 19 Apr 2021 04:14:04.378 <span class="comment"># +switch-master mymaster 0.0.0.0 6379 127.0.0.1 6380</span></span><br><span class="line">2821:X 19 Apr 2021 04:14:04.379 * +slave slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6380</span><br><span class="line">2821:X 19 Apr 2021 04:14:04.379 * +slave slave 0.0.0.0:6379 0.0.0.0 6379 @ mymaster 127.0.0.1 6380</span><br><span class="line">2821:X 19 Apr 2021 04:14:34.411 <span class="comment"># +sdown slave 0.0.0.0:6379 0.0.0.0 6379 @ mymaster 127.0.0.1 6380</span></span><br></pre></td></tr></table></figure><p>此时Master从79转移到了80</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6380&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:1</span><br><span class="line">slave0:ip=127.0.0.1,port=6381,state=online,offset=4615,lag=1</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:872d3e4c9538abb9f117dcc47de99ac57791433a</span><br><span class="line">master_replid2:612af05d7a22d2b35e595f43be74ddd771765798</span><br><span class="line">master_repl_offset:4615</span><br><span class="line">second_repl_offset:1212</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:4615</span><br></pre></td></tr></table></figure><p>79重新连接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang bin]<span class="comment"># ./redis-server conf/redis.conf</span></span><br><span class="line">[root@wangpengliang bin]<span class="comment"># ./redis-cli -p 6379</span></span><br><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:slave</span><br><span class="line">master_host:127.0.0.1</span><br><span class="line">master_port:6380</span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:1</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_repl_offset:35074</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:872d3e4c9538abb9f117dcc47de99ac57791433a</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:35074</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:32735</span><br><span class="line">repl_backlog_histlen:2340</span><br></pre></td></tr></table></figure><p>79重新连接后只能是从机了，master已经被80抢占。</p><h2 id="Cluster-集群模式">Cluster 集群模式</h2><p>Redis Cluster是一种服务器 Sharding 技术，3.0版本开始正式提供。Redis 的哨兵模式基本已经可以实现高可用，读写分离 ，但是在这种模式下每台 Redis 服务器都存储相同的数据，很浪费内存，所以在 Redis3.0上加入了 Cluster 集群模式，实现了 Redis 的分布式存储。也就是说每台 Redis 节点上存储不同的内容。</p><h3 id="Cluster特点">Cluster特点</h3><ul><li>多主多从去中心化：从节点作为备用，复制主节点，不做读写操作不提供服务（可通过 <code>readOnly</code> 实现只读）</li><li>不支持处理多个key：因为数据分散在多个节点，在数据量大高并发的情况下会影响性能</li><li>支持动态扩容节点：Rerdis Cluster 最大的优点之一</li><li>节点之间相互通信，相互选举，不再依赖Sentinel：准确来说是主节点之间相互“监督”，保证及时故障转移</li></ul><h3 id="Cluster集群模式对比">Cluster集群模式对比</h3><ul><li>相比哨兵模式：多个master节点保证主要业务（比如master节点主要负责写）稳定性，不需要搭建多个sentinel实例监控一个master节点</li><li>相比一主多从模式：不需要手动切换，具有自我故障检测，故障转移的特点</li><li>相比其哨兵和主从：对数据进行分片（sharding），不同节点存储数据不一样支持动态扩容。从某种程度上来说，Sentinel模式主要针对高可用（HA），而Cluster模式是不仅针对大数据量，高并发，同时也支持HA</li></ul><h3 id="数据存储设计"><strong>数据存储设计</strong></h3><ul><li>通过算法设计，计算出key应该保存的位置</li><li>将所有的存储空间计划切割成<code>16384</code>份，每台主机保存一部分每份代表的是一个存储空间，不是一个<code>key</code>的保存空间</li><li>将<code>key</code>按照计算出的结果放到对应的存储空间</li></ul><p>1)：<code>key</code>通过<code>hash</code>算法计算出一个值，然后拿这个值<code>%16384</code></p><p>2)：得到一个数（假如是37）为key的保存位置，然后再存入相应的存储空间位置</p><p><img src="/images/2021-09-03-17-12-12.png" alt=""></p><p>3)：假如又增加了一个节点，之前每个节点都会拿出部分槽给新的节点</p><p>4)：如果是去除节点，则把被去除节点的槽加入到存在的节点当中</p><h3 id="哈希槽Slot">哈希槽Slot</h3><p>Redis集群使用一种称作一致性哈希的复合分区形式（组合了哈希分区和列表分袂的特征来计算键的归属实例），键的<code>CRC16</code>哈希值被称为哈希槽。比如对于三个Redis节点，哈希槽的分配方式如下：</p><ul><li>第一节点拥有<code>0-5500</code>哈希槽</li><li>第二节点拥有<code>5501-11000</code>哈希槽</li><li>第三节点拥有剩余的<code>11001-16384</code>哈希槽</li></ul><p>通过计算键的 <code>CRC16</code> 哈希值，然后对16384进行取模得到：<code>HASH_SLOT=CRC16(key) modulo 16383</code>，Redis提供了<strong>CLUSTER KEYSLOT</strong>命令来执行哈希槽的计算。</p><p><strong>注意</strong>：集群节点保存键值对以及键值对过期时间的处理方式与Redis单机模式是一样的，唯一不同就是节点只能使用0号数据库，而单机Redis服务器则没有限制。</p><h3 id="集群内部通讯机制">集群内部通讯机制</h3><p>各个数据库互相通信，保存各个库中槽的编号数据。</p><p>1)：客户端发出一个key访问A，通过算法计算出key的存储位置</p><p>2)：如果一次命中，直接返回</p><p>3)：一次未命中，告知具体位置</p><p>4)：一次命中或者两次命中提高数据访问效率</p><p><img src="/images/2021-09-03-17-12-36.png" alt=""></p><h3 id="Cluster集群搭建">Cluster集群搭建</h3><p>1)：单虚机运行6个redis实例（三主三从），端口号为（79-84）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang <span class="built_in">local</span>]<span class="comment"># cd /usr/local/redis/bin</span></span><br><span class="line">[root@wangpengliang bin]<span class="comment"># ls</span></span><br><span class="line">conf  redis-benchmark  redis-check-aof  redis-check-rdb  redis-cli  redis-sentinel  redis-server</span><br><span class="line">[root@wangpengliang bin]<span class="comment"># cd conf</span></span><br><span class="line">[root@wangpengliang conf]<span class="comment"># ls</span></span><br><span class="line">redis80.conf  redis81.conf  redis.conf  sentinel.conf</span><br><span class="line">[root@wangpengliang conf]<span class="comment"># cp redis.conf redis82.conf</span></span><br><span class="line">[root@wangpengliang conf]<span class="comment"># cp redis.conf redis83.conf</span></span><br><span class="line">[root@wangpengliang conf]<span class="comment"># cp redis.conf redis84.conf</span></span><br><span class="line">[root@wangpengliang conf]<span class="comment">#</span></span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">端口</th><th style="text-align:center">配置文件</th></tr></thead><tbody><tr><td style="text-align:center">6379</td><td style="text-align:center">redis.conf</td></tr><tr><td style="text-align:center">6380</td><td style="text-align:center">redis80.conf</td></tr><tr><td style="text-align:center">6381</td><td style="text-align:center">redis81.conf</td></tr><tr><td style="text-align:center">6382</td><td style="text-align:center">redis82.conf</td></tr><tr><td style="text-align:center">6383</td><td style="text-align:center">redis83.conf</td></tr><tr><td style="text-align:center">6384</td><td style="text-align:center">redis84.conf</td></tr></tbody></table><p>2)：修改配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes <span class="comment"># 后台启动</span></span><br><span class="line">protected-mode no ; <span class="comment"># 允许外部访问</span></span><br><span class="line">port 6379 <span class="comment"># 修改端口号，从79~84</span></span><br><span class="line">cluster-enabled yes <span class="comment"># 开启cluster，去掉注释</span></span><br><span class="line">cluster-config-file nodes-6379.conf <span class="comment"># 自动生成</span></span><br><span class="line">cluster-node-timeout 15000 <span class="comment"># 节点通信时间</span></span><br><span class="line">logfile   /usr/<span class="built_in">local</span>/redis/bin/6379.log</span><br><span class="line">dbfilename 6379dump.rdb  <span class="comment"># 做伪集群的时候，一定要修改rdb文件的名字，如果aof也开的话也需要修改，否则扩容的时候会出现提示说新增扩容节点存在数据，需要先删除数据的提示。</span></span><br></pre></td></tr></table></figure><p>3)：启动Redis</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang bin]<span class="comment"># ./redis-server conf/redis.conf </span></span><br><span class="line">[root@wangpengliang bin]<span class="comment"># ./redis-server conf/redis80.conf </span></span><br><span class="line">[root@wangpengliang bin]<span class="comment"># ./redis-server conf/redis81.conf </span></span><br><span class="line">[root@wangpengliang bin]<span class="comment"># ./redis-server conf/redis82.conf </span></span><br><span class="line">[root@wangpengliang bin]<span class="comment"># ./redis-server conf/redis83.conf </span></span><br><span class="line">[root@wangpengliang bin]<span class="comment"># ./redis-server conf/redis84.conf</span></span><br></pre></td></tr></table></figure><p>查看Redis进程信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang bin]<span class="comment"># ps -ef|grep redis</span></span><br><span class="line">root       3538      1  0 13:37 ?        00:00:01 ./redis-server 0.0.0.0:6382 [cluster]</span><br><span class="line">root       3545      1  0 13:38 ?        00:00:01 ./redis-server 0.0.0.0:6383 [cluster]</span><br><span class="line">root       3551      1  0 13:38 ?        00:00:01 ./redis-server 0.0.0.0:6384 [cluster]</span><br><span class="line">root       3797      1  0 13:48 ?        00:00:00 ./redis-server 0.0.0.0:6380 [cluster]</span><br><span class="line">root       3803      1  0 13:48 ?        00:00:00 ./redis-server 0.0.0.0:6381 [cluster]</span><br><span class="line">root       3816      1  0 13:49 ?        00:00:00 ./redis-server 0.0.0.0:6379 [cluster]</span><br><span class="line">root       3826   3494  0 13:49 pts/0    00:00:00 grep --color=auto redis</span><br></pre></td></tr></table></figure><p><strong>4)</strong>：创建集群</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--cluster create  192.168.80.251:6379 192.168.80.251:6380 192.168.80.251:6381 192.168.80.251:6382 192.168.80.251:6383 192.168.80.251:6384  --cluster-replicas 1</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang bin]<span class="comment"># ./redis-cli --cluster create  192.168.15.251:6379 192.168.15.251:6380 192.168.15.251:6381 192.168.15.251:6382 192.168.15.251:6383 192.168.15.251:6384  --cluster-replicas 1</span></span><br><span class="line">&gt;&gt;&gt; Performing <span class="built_in">hash</span> slots allocation on 6 nodes...</span><br><span class="line">Master[0] -&gt; Slots 0 - 5460</span><br><span class="line">Master[1] -&gt; Slots 5461 - 10922</span><br><span class="line">Master[2] -&gt; Slots 10923 - 16383</span><br><span class="line">Adding replica 192.168.15.251:6383 to 192.168.15.251:6379</span><br><span class="line">Adding replica 192.168.15.251:6384 to 192.168.15.251:6380</span><br><span class="line">Adding replica 192.168.15.251:6382 to 192.168.15.251:6381</span><br><span class="line">&gt;&gt;&gt; Trying to optimize slaves allocation <span class="keyword">for</span> anti-affinity</span><br><span class="line">[WARNING] Some slaves are <span class="keyword">in</span> the same host as their master</span><br><span class="line">M: 48f3cbacb014f1d0f89fe99bb494e1cabb1f80f4 192.168.15.251:6379</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">M: ee511eed5a7d08d39ceef29823b98e299435523e 192.168.15.251:6380</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">M: e4c70b085d10d51a3201c6bf4bfa47adfa000f2e 192.168.15.251:6381</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">S: 5261a1ccb42ac160a93572beae7344e6b0c7c520 192.168.15.251:6382</span><br><span class="line">   replicates 48f3cbacb014f1d0f89fe99bb494e1cabb1f80f4</span><br><span class="line">S: d420ca1e3ef8edd538286e1c7698783447312148 192.168.15.251:6383</span><br><span class="line">   replicates ee511eed5a7d08d39ceef29823b98e299435523e</span><br><span class="line">S: 235fb6093a7f1c92e7144109aee10d1e341d2fb9 192.168.15.251:6384</span><br><span class="line">   replicates e4c70b085d10d51a3201c6bf4bfa47adfa000f2e</span><br><span class="line">Can I <span class="built_in">set</span> the above configuration? (<span class="built_in">type</span> <span class="string">&#x27;yes&#x27;</span> to accept): yes</span><br><span class="line">&gt;&gt;&gt; Nodes configuration updated</span><br><span class="line">&gt;&gt;&gt; Assign a different config epoch to each node</span><br><span class="line">&gt;&gt;&gt; Sending CLUSTER MEET messages to join the cluster</span><br><span class="line">Waiting <span class="keyword">for</span> the cluster to join</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 192.168.15.251:6379)</span><br><span class="line">M: 48f3cbacb014f1d0f89fe99bb494e1cabb1f80f4 192.168.15.251:6379</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: e4c70b085d10d51a3201c6bf4bfa47adfa000f2e 192.168.15.251:6381</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: ee511eed5a7d08d39ceef29823b98e299435523e 192.168.15.251:6380</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 5261a1ccb42ac160a93572beae7344e6b0c7c520 192.168.15.251:6382</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 48f3cbacb014f1d0f89fe99bb494e1cabb1f80f4</span><br><span class="line">S: 235fb6093a7f1c92e7144109aee10d1e341d2fb9 192.168.15.251:6384</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates e4c70b085d10d51a3201c6bf4bfa47adfa000f2e</span><br><span class="line">S: d420ca1e3ef8edd538286e1c7698783447312148 192.168.15.251:6383</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates ee511eed5a7d08d39ceef29823b98e299435523e</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check <span class="keyword">for</span> open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure><h1 id="Redis-Cluster集群命令">Redis-Cluster集群命令</h1><ul><li><code>cluster info</code> ：打印集群的信息</li><li><code>cluster nodes</code>：列出集群当前已知的所有节点（ node），以及这些节点的相关信息</li><li><code>cluster meet</code>   ：将 ip 和 port 所指定的节点添加到集群当中</li><li><code>cluster forget &lt;node_id&gt;</code> ：从集群中移除 node_id 指定的节点</li><li><code>cluster replicate &lt;master_node_id&gt;</code> ：将当前从节点设置为 node_id 指定的master节点的slave节点。只能针对slave节点操作</li><li><code>cluster saveconfig</code>：将节点的配置文件保存到硬盘里面</li><li><code>cluster addslots  [slot ...]</code> ：将一个或多个槽（ slot）指派（ assign）给当前节点</li><li><code>cluster delslots  [slot ...] </code>：移除一个或多个槽对当前节点的指派</li><li><code>cluster flushslots</code> ：移除指派给当前节点的所有槽，让当前节点变成一个没有指派任何槽的节点</li><li><code>cluster setslot  node &lt;node_id&gt;</code> ：将槽 slot 指派给 node_id 指定的节点</li><li><code>cluster setslot  migrating &lt;node_id&gt;</code> ：将本节点的槽 slot 迁移到 node_id 指定的节点中</li><li><code>cluster setslot  importing &lt;node_id&gt;</code> ：从 node_id 指定的节点中导入槽 slot 到本节点</li><li><code>cluster setslot  stable</code> ：取消对槽 slot 的导入（ import）或者迁移（ migrate）</li><li><code>cluster keyslot</code>  ：计算键 key 应该被放置在哪个槽上</li><li><code>cluster countkeysinslot</code> ：返回槽 slot 目前包含的键值对数量</li><li><code>cluster getkeysinslot</code>   ：返回 count 个 slot 槽中的键</li></ul><h1 id="查看Redis数据库信息">查看Redis数据库信息</h1><p><code>info replication</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line"><span class="comment"># 角色</span></span><br><span class="line">role:master</span><br><span class="line"><span class="comment"># 连接的从机数量</span></span><br><span class="line">connected_slaves:0</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:28d568fba5f2ed0f9034a4f63acc4960287099af</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:0</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/redis/%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9E%E6%8E%A5Redis/"/>
      <url>/redis/%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9E%E6%8E%A5Redis/</url>
      
        <content type="html"><![CDATA[<p>测试代码：<a href="https://github.com/wangpengliang815/CodeSnippet/tree/master/CommonLib/CommonLib">https://github.com/wangpengliang815/CodeSnippet/tree/master/CommonLib/CommonLib</a></p><p>参考文档：<a href="https://www.bookstack.cn/books/StackExchange.Redis-docs-cn">https://www.bookstack.cn/books/StackExchange.Redis-docs-cn</a></p><span id="more"></span><h1 id="客户端-v3">客户端</h1><ul><li>ServiceStack.Redis 是商业版，免费版有限制</li><li>StackExchange.Redis 是免费版，但是内核在 .NETCore 运行有问题经常 Timeout，暂无法解决</li><li>csRedis于2016年开始支持.NETCore一直迭代至今，实现了低门槛、高性能，和分区高级玩法的.NETCore redis-cli SDK</li></ul><h1 id="ServiceStack-Redis">ServiceStack.Redis</h1><p>商业版，免费版有限制。放弃。</p><h1 id="StackExchange-Redis">StackExchange.Redis</h1><h2 id="安装-v4">安装</h2><p><code>StackExchange.Redis</code> 是 C# 操作 <code>Redis</code> 数据库的客户端。在 <code>NuGet</code> 中搜索 <code>StackExchange.Redis</code> ，直接点击按钮安装即可。</p><h2 id="封装">封装</h2><p><code>RedisHelper</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">CommonLib</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> Newtonsoft.Json;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> StackExchange.Redis;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> System;</span><br><span class="line">    <span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line">    <span class="keyword">using</span> System.Linq;</span><br><span class="line">    <span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 基于StackExchange.Redis封装的Helper</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RedisHelper</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 自定义缓存Key前缀</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;value&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> The custom key prefix.</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/value&gt;</span></span></span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">string</span> CustomKeyPrefix &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> ConnectionMultiplexer对象</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> ConnectionMultiplexer conn;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> Redis数据库对象</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">readonly</span> IDatabase db;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> Initializes a new instance of the <span class="doctag">&lt;see cref=&quot;RedisHelper&quot;/&gt;</span> class.</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;dbSerialNumber&quot;&gt;</span>The database serial number.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;redisConnectionString&quot;&gt;</span>The redis connection string.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;customKeyPrefix&quot;&gt;</span>The custom key prefix.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">RedisHelper</span>(<span class="params"><span class="built_in">int</span> dbSerialNumber</span></span></span><br><span class="line"><span class="params"><span class="function">            , <span class="built_in">string</span> redisConnectionString</span></span></span><br><span class="line"><span class="params"><span class="function">            , <span class="built_in">string</span> customKeyPrefix = <span class="literal">null</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            CustomKeyPrefix = customKeyPrefix;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> customSingleton </span></span><br><span class="line">            RedisConnectionMultiplexerHelper.RedisConnectionString = redisConnectionString;</span><br><span class="line">            conn = RedisConnectionMultiplexerHelper.Instance;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            conn = ConnectionMultiplexer.Connect(redisConnectionString);</span><br><span class="line">            db = conn.GetDatabase(dbSerialNumber);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 保存单个k/v</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;key&quot;&gt;</span>The key.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;value&quot;&gt;</span>The value.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;expiry&quot;&gt;</span>The expiry.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">StringSet</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">string</span> <span class="keyword">value</span>, TimeSpan? expiry = <span class="literal">default</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            key = GenerateCustomKey(key);</span><br><span class="line">            <span class="keyword">return</span> db.StringSet(key, <span class="keyword">value</span>, expiry);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 保存多个k/v</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;keyValues&quot;&gt;</span>The key values.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">StringSet</span>(<span class="params">List&lt;KeyValuePair&lt;RedisKey, RedisValue&gt;&gt; keyValues</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            List&lt;KeyValuePair&lt;RedisKey, RedisValue&gt;&gt; newkeyValues = keyValues</span><br><span class="line">                .Select(p =&gt; <span class="keyword">new</span> KeyValuePair&lt;RedisKey, RedisValue&gt;(GenerateCustomKey(p.Key), p.Value))</span><br><span class="line">                .ToList();</span><br><span class="line">            <span class="keyword">return</span> db.StringSet(newkeyValues.ToArray());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 以Json格式保存对象</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;typeparam name=&quot;T&quot;&gt;</span><span class="doctag">&lt;/typeparam&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;key&quot;&gt;</span>The key.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;object&quot;&gt;</span>The object.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;expiry&quot;&gt;</span>The expiry.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">StringSet</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="built_in">string</span> key, T @<span class="built_in">object</span>, TimeSpan? expiry = <span class="literal">default</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            key = GenerateCustomKey(key);</span><br><span class="line">            <span class="built_in">string</span> json = ConvertToJson(@object);</span><br><span class="line">            <span class="keyword">return</span> db.StringSet(key, json, expiry);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 获取单个Key</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;key&quot;&gt;</span>The key.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">StringGet</span>(<span class="params"><span class="built_in">string</span> key</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            key = GenerateCustomKey(key);</span><br><span class="line">            <span class="keyword">return</span> db.StringGet(key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 获取多个Key</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;listKeys&quot;&gt;</span>The list keys.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> RedisValue[] <span class="title">StringGet</span>(<span class="params">List&lt;<span class="built_in">string</span>&gt; listKeys</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            List&lt;<span class="built_in">string</span>&gt; redisKeys = listKeys.Select(GenerateCustomKey).ToList();</span><br><span class="line">            <span class="keyword">return</span> db.StringGet(ConvertToRedisKeys(redisKeys));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 获取value转换为Object</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;typeparam name=&quot;T&quot;&gt;</span><span class="doctag">&lt;/typeparam&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;key&quot;&gt;</span>The key.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">StringGet</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="built_in">string</span> key</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            key = GenerateCustomKey(key);</span><br><span class="line">            <span class="keyword">return</span> ConvertToObject&lt;T&gt;(db.StringGet(key));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> Increment,如果key存在,则:value+=value</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;key&quot;&gt;</span>The key.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;incrementVal&quot;&gt;</span>The increment value.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">StringIncrement</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">double</span> incrementVal = <span class="number">1</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            key = GenerateCustomKey(key);</span><br><span class="line">            <span class="keyword">return</span> db.StringIncrement(key, incrementVal);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> Decrement,如果key存在,则:value-=value</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;key&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;decrementVal&quot;&gt;</span>The decrement value.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>减少后的值<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">StringDecrement</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">double</span> decrementVal = <span class="number">1</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            key = GenerateCustomKey(key);</span><br><span class="line">            <span class="keyword">return</span> db.StringDecrement(key, decrementVal);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 判断hash中某个key是否已经被缓存</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;key&quot;&gt;</span>The key.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;hashFieldName&quot;&gt;</span>Name of the hash field.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">HashExists</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">string</span> hashFieldName</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            key = GenerateCustomKey(key);</span><br><span class="line">            <span class="keyword">return</span> db.HashExists(key, hashFieldName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 存储数据到hash表</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;typeparam name=&quot;T&quot;&gt;</span><span class="doctag">&lt;/typeparam&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;key&quot;&gt;</span>The key.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;hashFieldName&quot;&gt;</span>Name of the hash field.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;hashValue&quot;&gt;</span>The hash value.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">HashSet</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="built_in">string</span> key, <span class="built_in">string</span> hashFieldName, T hashValue</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            key = GenerateCustomKey(key);</span><br><span class="line">            <span class="built_in">string</span> json = ConvertToJson(hashValue);</span><br><span class="line">            <span class="keyword">return</span> db.HashSet(key, hashFieldName, json);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 移除hash中的某值</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;key&quot;&gt;</span>The key.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;hashFieldName&quot;&gt;</span>Name of the hash field.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">HashDelete</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">string</span> hashFieldName</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            key = GenerateCustomKey(key);</span><br><span class="line">            <span class="keyword">return</span> db.HashDelete(key, hashFieldName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 移除hash中的多个值</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;key&quot;&gt;</span>The key.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;hashFieldNames&quot;&gt;</span>The hash field names.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">long</span> <span class="title">HashDelete</span>(<span class="params"><span class="built_in">string</span> key, List&lt;RedisValue&gt; hashFieldNames</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            key = GenerateCustomKey(key);</span><br><span class="line">            <span class="keyword">return</span> db.HashDelete(key, hashFieldNames.ToArray());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 从hash表获取数据</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;typeparam name=&quot;T&quot;&gt;</span><span class="doctag">&lt;/typeparam&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;key&quot;&gt;</span>The key.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;hashFieldName&quot;&gt;</span>Name of the hash field.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">HashGet</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="built_in">string</span> key, <span class="built_in">string</span> hashFieldName</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            key = GenerateCustomKey(key);</span><br><span class="line">            <span class="built_in">string</span> <span class="keyword">value</span> = db.HashGet(key, hashFieldName);</span><br><span class="line">            <span class="keyword">return</span> ConvertToObject&lt;T&gt;(<span class="keyword">value</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> hash为数字增长value</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;key&quot;&gt;</span>The key.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;hashFieldName&quot;&gt;</span>Name of the hash field.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;incrementVal&quot;&gt;</span>The increment value.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">HashIncrement</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">string</span> hashFieldName, <span class="built_in">double</span> incrementVal = <span class="number">1</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            key = GenerateCustomKey(key);</span><br><span class="line">            <span class="keyword">return</span> db.HashIncrement(key, hashFieldName, incrementVal);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> hash为数字减少value</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;key&quot;&gt;</span>The key.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;hashFieldName&quot;&gt;</span>Name of the hash field.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;decrementVal&quot;&gt;</span>The decrement value.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">HashDecrement</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">string</span> hashFieldName, <span class="built_in">double</span> decrementVal = <span class="number">1</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            key = GenerateCustomKey(key);</span><br><span class="line">            <span class="keyword">return</span> db.HashDecrement(key, hashFieldName, decrementVal);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 获取hashkey所有rediskey</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;typeparam name=&quot;T&quot;&gt;</span><span class="doctag">&lt;/typeparam&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;key&quot;&gt;</span>The key.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">List</span>&lt;<span class="title">T</span>&gt; <span class="title">HashKeys</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="built_in">string</span> key</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            key = GenerateCustomKey(key);</span><br><span class="line">            RedisValue[] values = db.HashKeys(key);</span><br><span class="line">            <span class="keyword">return</span> ConvetToList&lt;T&gt;(values);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 移除指定List内部的值</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;typeparam name=&quot;T&quot;&gt;</span><span class="doctag">&lt;/typeparam&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;key&quot;&gt;</span>The key.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;value&quot;&gt;</span>The value.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ListRemove</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="built_in">string</span> key, T <span class="keyword">value</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            key = GenerateCustomKey(key);</span><br><span class="line">            db.ListRemove(key, ConvertToJson(<span class="keyword">value</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 获取指定key的List</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;typeparam name=&quot;T&quot;&gt;</span><span class="doctag">&lt;/typeparam&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;key&quot;&gt;</span>The key.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">List</span>&lt;<span class="title">T</span>&gt; <span class="title">ListRange</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="built_in">string</span> key</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            key = GenerateCustomKey(key);</span><br><span class="line">            RedisValue[] values = db.ListRange(key);</span><br><span class="line">            <span class="keyword">return</span> ConvetToList&lt;T&gt;(values);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 入队：列表从最右边插入一个元素</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;typeparam name=&quot;T&quot;&gt;</span><span class="doctag">&lt;/typeparam&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;key&quot;&gt;</span>The key.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;value&quot;&gt;</span>The value.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">long</span> <span class="title">ListRightPush</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="built_in">string</span> key, T <span class="keyword">value</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            key = GenerateCustomKey(key);</span><br><span class="line">            <span class="keyword">return</span> db.ListRightPush(key, ConvertToJson(<span class="keyword">value</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 出队：列表从最右边获取一个元素</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;typeparam name=&quot;T&quot;&gt;</span><span class="doctag">&lt;/typeparam&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;key&quot;&gt;</span>The key.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">ListRightPop</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="built_in">string</span> key</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            key = GenerateCustomKey(key);</span><br><span class="line">            RedisValue <span class="keyword">value</span> = db.ListRightPop(key);</span><br><span class="line">            <span class="keyword">return</span> ConvertToObject&lt;T&gt;(<span class="keyword">value</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 入栈：列表从最左边插入一个元素</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;typeparam name=&quot;T&quot;&gt;</span><span class="doctag">&lt;/typeparam&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;key&quot;&gt;</span>The key.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;value&quot;&gt;</span>The value.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">long</span> <span class="title">ListLeftPush</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="built_in">string</span> key, T <span class="keyword">value</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            key = GenerateCustomKey(key);</span><br><span class="line">            <span class="keyword">return</span> db.ListLeftPush(key, ConvertToJson(<span class="keyword">value</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 出栈：列表从最左边获取一个元素</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;typeparam name=&quot;T&quot;&gt;</span><span class="doctag">&lt;/typeparam&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;key&quot;&gt;</span>The key.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">ListLeftPop</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="built_in">string</span> key</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            key = GenerateCustomKey(key);</span><br><span class="line">            <span class="keyword">var</span> <span class="keyword">value</span> = db.ListLeftPop(key);</span><br><span class="line">            <span class="keyword">return</span> ConvertToObject&lt;T&gt;(<span class="keyword">value</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 获取集合中的数量</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;key&quot;&gt;</span>The key.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">long</span> <span class="title">ListLength</span>(<span class="params"><span class="built_in">string</span> key</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            key = GenerateCustomKey(key);</span><br><span class="line">            <span class="keyword">return</span> db.ListLength(key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> Sorteds the set add.</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;typeparam name=&quot;T&quot;&gt;</span><span class="doctag">&lt;/typeparam&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;key&quot;&gt;</span>The key.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;value&quot;&gt;</span>The value.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;score&quot;&gt;</span>The score.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">SortedSetAdd</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="built_in">string</span> key, T <span class="keyword">value</span>, <span class="built_in">double</span> score</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            key = GenerateCustomKey(key);</span><br><span class="line">            <span class="keyword">return</span> db.SortedSetAdd(key, ConvertToJson&lt;T&gt;(<span class="keyword">value</span>), score);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> Sorteds the set remove.</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;typeparam name=&quot;T&quot;&gt;</span><span class="doctag">&lt;/typeparam&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;key&quot;&gt;</span>The key.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;value&quot;&gt;</span>The value.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">SortedSetRemove</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="built_in">string</span> key, T <span class="keyword">value</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            key = GenerateCustomKey(key);</span><br><span class="line">            <span class="keyword">return</span> db.SortedSetRemove(key, ConvertToJson(<span class="keyword">value</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> Sorteds the set range by rank.</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;typeparam name=&quot;T&quot;&gt;</span><span class="doctag">&lt;/typeparam&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;key&quot;&gt;</span>The key.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;start&quot;&gt;</span>The start.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;stop&quot;&gt;</span>The stop.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;order&quot;&gt;</span>The order.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">List</span>&lt;<span class="title">T</span>&gt; <span class="title">SortedSetRangeByRank</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="built_in">string</span> key, <span class="built_in">long</span> start, <span class="built_in">long</span> stop, Order order = Order.Ascending</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            key = GenerateCustomKey(key);</span><br><span class="line">            <span class="keyword">var</span> values = db.SortedSetRangeByRank(key, start, stop, order);</span><br><span class="line">            <span class="keyword">return</span> ConvetToList&lt;T&gt;(values);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> Sorteds the length of the set.</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;key&quot;&gt;</span>The key.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">long</span> <span class="title">SortedSetLength</span>(<span class="params"><span class="built_in">string</span> key</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            key = GenerateCustomKey(key);</span><br><span class="line">            <span class="keyword">return</span> db.SortedSetLength(key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 删除单个key</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;key&quot;&gt;</span>The key.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">KeyDelete</span>(<span class="params"><span class="built_in">string</span> key</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            key = GenerateCustomKey(key);</span><br><span class="line">            <span class="keyword">return</span> db.KeyDelete(key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 删除多个key</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;keys&quot;&gt;</span>The keys.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">long</span> <span class="title">KeyDelete</span>(<span class="params">List&lt;<span class="built_in">string</span>&gt; keys</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            List&lt;<span class="built_in">string</span>&gt; newKeys = keys.Select(GenerateCustomKey).ToList();</span><br><span class="line">            <span class="keyword">return</span> db.KeyDelete(ConvertToRedisKeys(newKeys));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 判断key是否存储</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;key&quot;&gt;</span>The key.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">KeyExists</span>(<span class="params"><span class="built_in">string</span> key</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            key = GenerateCustomKey(key);</span><br><span class="line">            <span class="keyword">return</span> db.KeyExists(key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 重命名key</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;key&quot;&gt;</span>The key.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;newKey&quot;&gt;</span>The new key.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">KeyRename</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">string</span> newKey</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            key = GenerateCustomKey(key);</span><br><span class="line">            <span class="keyword">return</span> db.KeyRename(key, newKey);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 设置Key过期时间</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;key&quot;&gt;</span>The key.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;expiry&quot;&gt;</span>The expiry.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">KeyExpire</span>(<span class="params"><span class="built_in">string</span> key, TimeSpan? expiry = <span class="literal">default</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            key = GenerateCustomKey(key);</span><br><span class="line">            <span class="keyword">return</span> db.KeyExpire(key, expiry);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> Redis订阅</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;subChannel&quot;&gt;</span>The sub channel.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;handler&quot;&gt;</span>The handler.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Subscribe</span>(<span class="params"><span class="built_in">string</span> subChannel, Action&lt;RedisChannel, RedisValue&gt; handler = <span class="literal">null</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            ISubscriber sub = conn.GetSubscriber();</span><br><span class="line">            sub.Subscribe(subChannel, (channel, message) =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (handler == <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(subChannel + <span class="string">&quot; 订阅收到消息：&quot;</span> + message);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    handler(channel, message);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> Redis发布</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;typeparam name=&quot;T&quot;&gt;</span><span class="doctag">&lt;/typeparam&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;channel&quot;&gt;</span>The channel.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;message&quot;&gt;</span>The message.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">long</span> <span class="title">Publish</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="built_in">string</span> channel, T message</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            ISubscriber sub = conn.GetSubscriber();</span><br><span class="line">            <span class="keyword">return</span> sub.Publish(channel, ConvertToJson(message));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> Redis取消订阅</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;channel&quot;&gt;</span>The channel.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Unsubscribe</span>(<span class="params"><span class="built_in">string</span> channel</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            ISubscriber sub = conn.GetSubscriber();</span><br><span class="line">            sub.Unsubscribe(channel);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> Redis取消全部订阅</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UnsubscribeAll</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            ISubscriber sub = conn.GetSubscriber();</span><br><span class="line">            sub.UnsubscribeAll();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 创建一个Redis事务</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;dbSerialNumber&quot;&gt;</span>The database serial number.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ITransaction <span class="title">CreateTransaction</span>(<span class="params"><span class="built_in">int</span> dbSerialNumber</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> conn.GetDatabase(dbSerialNumber).CreateTransaction();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;<span class="built_in">bool</span>&gt; <span class="title">StringSetAsync</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">string</span> <span class="keyword">value</span>, TimeSpan? expiry = <span class="literal">default</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            key = GenerateCustomKey(key);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">await</span> db.StringSetAsync(key, <span class="keyword">value</span>, expiry);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;<span class="built_in">bool</span>&gt; <span class="title">StringSetAsync</span>(<span class="params">List&lt;KeyValuePair&lt;RedisKey, RedisValue&gt;&gt; keyValues</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            List&lt;KeyValuePair&lt;RedisKey, RedisValue&gt;&gt; newkeyValues = keyValues</span><br><span class="line">                .Select(p =&gt; <span class="keyword">new</span> KeyValuePair&lt;RedisKey, RedisValue&gt;(GenerateCustomKey(p.Key), p.Value))</span><br><span class="line">                .ToList();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">await</span> db.StringSetAsync(newkeyValues.ToArray());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> <span class="title">Task</span>&lt;<span class="title">bool</span>&gt; <span class="title">StringSetAsync</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="built_in">string</span> key, T @<span class="built_in">object</span>, TimeSpan? expiry = <span class="literal">default</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            key = GenerateCustomKey(key);</span><br><span class="line">            <span class="built_in">string</span> json = ConvertToJson(@object);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">await</span> db.StringSetAsync(key, json, expiry);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;<span class="built_in">string</span>&gt; <span class="title">StringGetAsync</span>(<span class="params"><span class="built_in">string</span> key</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            key = GenerateCustomKey(key);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">await</span> db.StringGetAsync(key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">async</span> Task&lt;RedisValue[]&gt; StringGetAsync(List&lt;<span class="built_in">string</span>&gt; listKeys)</span><br><span class="line">        &#123;</span><br><span class="line">            List&lt;<span class="built_in">string</span>&gt; redisKeys = listKeys.Select(GenerateCustomKey).ToList();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">await</span> db.StringGetAsync(ConvertToRedisKeys(redisKeys));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> <span class="title">Task</span>&lt;<span class="title">T</span>&gt; <span class="title">StringGetAsync</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="built_in">string</span> key</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            key = GenerateCustomKey(key);</span><br><span class="line">            <span class="keyword">return</span> ConvertToObject&lt;T&gt;(<span class="keyword">await</span> db.StringGetAsync(key));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;<span class="built_in">double</span>&gt; <span class="title">StringIncrementAsync</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">double</span> incrementVal = <span class="number">1</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            key = GenerateCustomKey(key);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">await</span> db.StringIncrementAsync(key, incrementVal);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;<span class="built_in">double</span>&gt; <span class="title">StringDecrementAsync</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">double</span> decrementVal = <span class="number">1</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            key = GenerateCustomKey(key);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">await</span> db.StringDecrementAsync(key, decrementVal);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;<span class="built_in">bool</span>&gt; <span class="title">HashExistsAsync</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">string</span> dataKey</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            key = GenerateCustomKey(key);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">await</span> db.HashExistsAsync(key, dataKey);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> <span class="title">Task</span>&lt;<span class="title">bool</span>&gt; <span class="title">HashSetAsync</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="built_in">string</span> key, <span class="built_in">string</span> hashFieldName, T hashValue</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            key = GenerateCustomKey(key);</span><br><span class="line">            <span class="built_in">string</span> json = ConvertToJson(hashValue);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">await</span> db.HashSetAsync(key, hashFieldName, json);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;<span class="built_in">bool</span>&gt; <span class="title">HashDeleteAsync</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">string</span> hashFieldName</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            key = GenerateCustomKey(key);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">await</span> db.HashDeleteAsync(key, hashFieldName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;<span class="built_in">long</span>&gt; <span class="title">HashDeleteAsync</span>(<span class="params"><span class="built_in">string</span> key, List&lt;RedisValue&gt; hashFieldNames</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            key = GenerateCustomKey(key);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">await</span> db.HashDeleteAsync(key, hashFieldNames.ToArray());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> <span class="title">Task</span>&lt;<span class="title">T</span>&gt; <span class="title">HashGetAsync</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="built_in">string</span> key, <span class="built_in">string</span> hashFieldName</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            key = GenerateCustomKey(key);</span><br><span class="line">            <span class="built_in">string</span> <span class="keyword">value</span> = <span class="keyword">await</span> db.HashGetAsync(key, hashFieldName);</span><br><span class="line">            <span class="keyword">return</span> ConvertToObject&lt;T&gt;(<span class="keyword">value</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;<span class="built_in">double</span>&gt; <span class="title">HashIncrementAsync</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">string</span> hashFieldName, <span class="built_in">double</span> incrementVal = <span class="number">1</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            key = GenerateCustomKey(key);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">await</span> db.HashIncrementAsync(key, hashFieldName, incrementVal);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;<span class="built_in">double</span>&gt; <span class="title">HashDecrementAsync</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">string</span> hashFieldName, <span class="built_in">double</span> decrementVal = <span class="number">1</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            key = GenerateCustomKey(key);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">await</span> db.HashDecrementAsync(key, hashFieldName, decrementVal);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> <span class="title">Task</span>&lt;<span class="title">List</span>&lt;<span class="title">T</span>&gt;&gt; <span class="title">HashKeysAsync</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="built_in">string</span> key</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            key = GenerateCustomKey(key);</span><br><span class="line">            RedisValue[] values = <span class="keyword">await</span> db.HashKeysAsync(key);</span><br><span class="line">            <span class="keyword">return</span> ConvetToList&lt;T&gt;(values);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> <span class="title">Task</span>&lt;<span class="title">long</span>&gt; <span class="title">ListRemoveAsync</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="built_in">string</span> key, T <span class="keyword">value</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            key = GenerateCustomKey(key);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">await</span> db.ListRemoveAsync(key, ConvertToJson(<span class="keyword">value</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> <span class="title">Task</span>&lt;<span class="title">List</span>&lt;<span class="title">T</span>&gt;&gt; <span class="title">ListRangeAsync</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="built_in">string</span> key</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            key = GenerateCustomKey(key);</span><br><span class="line">            RedisValue[] values = <span class="keyword">await</span> db.ListRangeAsync(key);</span><br><span class="line">            <span class="keyword">return</span> ConvetToList&lt;T&gt;(values);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> <span class="title">Task</span>&lt;<span class="title">long</span>&gt; <span class="title">ListRightPushAsync</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="built_in">string</span> key, T <span class="keyword">value</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            key = GenerateCustomKey(key);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">await</span> db.ListRightPushAsync(key, ConvertToJson(<span class="keyword">value</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> <span class="title">Task</span>&lt;<span class="title">T</span>&gt; <span class="title">ListRightPopAsync</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="built_in">string</span> key</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            key = GenerateCustomKey(key);</span><br><span class="line">            RedisValue <span class="keyword">value</span> = <span class="keyword">await</span> db.ListRightPopAsync(key);</span><br><span class="line">            <span class="keyword">return</span> ConvertToObject&lt;T&gt;(<span class="keyword">value</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> <span class="title">Task</span>&lt;<span class="title">long</span>&gt; <span class="title">ListLeftPushAsync</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="built_in">string</span> key, T <span class="keyword">value</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            key = GenerateCustomKey(key);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">await</span> db.ListLeftPushAsync(key, ConvertToJson(<span class="keyword">value</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> <span class="title">Task</span>&lt;<span class="title">T</span>&gt; <span class="title">ListLeftPopAsync</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="built_in">string</span> key</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            key = GenerateCustomKey(key);</span><br><span class="line">            <span class="keyword">var</span> <span class="keyword">value</span> = <span class="keyword">await</span> db.ListLeftPopAsync(key);</span><br><span class="line">            <span class="keyword">return</span> ConvertToObject&lt;T&gt;(<span class="keyword">value</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;<span class="built_in">long</span>&gt; <span class="title">ListLengthAsync</span>(<span class="params"><span class="built_in">string</span> key</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            key = GenerateCustomKey(key);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">await</span> db.ListLengthAsync(key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> <span class="title">Task</span>&lt;<span class="title">bool</span>&gt; <span class="title">SortedSetAddAsync</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="built_in">string</span> key, T <span class="keyword">value</span>, <span class="built_in">double</span> score</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            key = GenerateCustomKey(key);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">await</span> db.SortedSetAddAsync(key, ConvertToJson&lt;T&gt;(<span class="keyword">value</span>), score);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> <span class="title">Task</span>&lt;<span class="title">bool</span>&gt; <span class="title">SortedSetRemoveAsync</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="built_in">string</span> key, T <span class="keyword">value</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            key = GenerateCustomKey(key);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">await</span> db.SortedSetRemoveAsync(key, ConvertToJson(<span class="keyword">value</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> <span class="title">Task</span>&lt;<span class="title">List</span>&lt;<span class="title">T</span>&gt;&gt; <span class="title">SortedSetRangeByRankAsync</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="built_in">string</span> key, <span class="built_in">long</span> start, <span class="built_in">long</span> stop, Order order = Order.Ascending</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            key = GenerateCustomKey(key);</span><br><span class="line">            <span class="keyword">var</span> values = <span class="keyword">await</span> db.SortedSetRangeByRankAsync(key, start, stop, order);</span><br><span class="line">            <span class="keyword">return</span> ConvetToList&lt;T&gt;(values);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;<span class="built_in">long</span>&gt; <span class="title">SortedSetLengthAsync</span>(<span class="params"><span class="built_in">string</span> key</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            key = GenerateCustomKey(key);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">await</span> db.SortedSetLengthAsync(key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;<span class="built_in">bool</span>&gt; <span class="title">KeyDeleteAsync</span>(<span class="params"><span class="built_in">string</span> key</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            key = GenerateCustomKey(key);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">await</span> db.KeyDeleteAsync(key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;<span class="built_in">long</span>&gt; <span class="title">KeyDeleteAsync</span>(<span class="params">List&lt;<span class="built_in">string</span>&gt; keys</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            List&lt;<span class="built_in">string</span>&gt; newKeys = keys.Select(GenerateCustomKey).ToList();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">await</span> db.KeyDeleteAsync(ConvertToRedisKeys(newKeys));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;<span class="built_in">bool</span>&gt; <span class="title">KeyExistsAsync</span>(<span class="params"><span class="built_in">string</span> key</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            key = GenerateCustomKey(key);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">await</span> db.KeyExistsAsync(key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;<span class="built_in">bool</span>&gt; <span class="title">KeyRenameAsync</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">string</span> newKey</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            key = GenerateCustomKey(key);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">await</span> db.KeyRenameAsync(key, newKey);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;<span class="built_in">bool</span>&gt; <span class="title">KeyExpireAsync</span>(<span class="params"><span class="built_in">string</span> key, TimeSpan? expiry = <span class="literal">default</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            key = GenerateCustomKey(key);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">await</span> db.KeyExpireAsync(key, expiry);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">SubscribeAsync</span>(<span class="params"><span class="built_in">string</span> subChannel, Action&lt;RedisChannel, RedisValue&gt; handler = <span class="literal">null</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            ISubscriber sub = conn.GetSubscriber();</span><br><span class="line">            <span class="keyword">await</span> sub.SubscribeAsync(subChannel, (channel, message) =&gt;</span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="keyword">if</span> (handler == <span class="literal">null</span>)</span><br><span class="line">                 &#123;</span><br><span class="line">                     Console.WriteLine(subChannel + <span class="string">&quot; 订阅收到消息：&quot;</span> + message);</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">else</span></span><br><span class="line">                 &#123;</span><br><span class="line">                     handler(channel, message);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> <span class="title">Task</span>&lt;<span class="title">long</span>&gt; <span class="title">PublishAsync</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="built_in">string</span> channel, T message</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            ISubscriber sub = conn.GetSubscriber();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">await</span> sub.PublishAsync(channel, ConvertToJson(message));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">UnsubscribeAsync</span>(<span class="params"><span class="built_in">string</span> channel</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            ISubscriber sub = conn.GetSubscriber();</span><br><span class="line">            <span class="keyword">await</span> sub.UnsubscribeAsync(channel);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">UnsubscribeAllAsync</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            ISubscriber sub = conn.GetSubscriber();</span><br><span class="line">            <span class="keyword">await</span> sub.UnsubscribeAllAsync();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 生成自定义Key,格式(CustomKeyPrefix+&quot;_&quot;+Key)</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;oldKey&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="built_in">string</span> <span class="title">GenerateCustomKey</span>(<span class="params"><span class="built_in">string</span> oldKey</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">string</span>.IsNullOrWhiteSpace(CustomKeyPrefix))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">$&quot;<span class="subst">&#123;CustomKeyPrefix&#125;</span>_<span class="subst">&#123;oldKey&#125;</span>&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> oldKey;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 对象序列化</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;typeparam name=&quot;T&quot;&gt;</span><span class="doctag">&lt;/typeparam&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;value&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">ConvertToJson</span>&lt;<span class="title">T</span>&gt;(<span class="params">T <span class="keyword">value</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">value</span> <span class="keyword">is</span> <span class="built_in">string</span> ? <span class="keyword">value</span>.ToString() : JsonConvert.SerializeObject(<span class="keyword">value</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> RedisValue转Object</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;typeparam name=&quot;T&quot;&gt;</span><span class="doctag">&lt;/typeparam&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;value&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> T <span class="title">ConvertToObject</span>&lt;<span class="title">T</span>&gt;(<span class="params">RedisValue <span class="keyword">value</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span>(T).Name.Equals(<span class="keyword">typeof</span>(<span class="built_in">string</span>).Name))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> JsonConvert.DeserializeObject&lt;T&gt;(<span class="string">$&quot;&#x27;<span class="subst">&#123;<span class="keyword">value</span>&#125;</span>&#x27;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> JsonConvert.DeserializeObject&lt;T&gt;(<span class="keyword">value</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> RedisValue转List</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;typeparam name=&quot;T&quot;&gt;</span><span class="doctag">&lt;/typeparam&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;values&quot;&gt;</span>The values.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="title">List</span>&lt;<span class="title">T</span>&gt; <span class="title">ConvetToList</span>&lt;<span class="title">T</span>&gt;(<span class="params">RedisValue[] values</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            List&lt;T&gt; result = <span class="keyword">new</span>();</span><br><span class="line">            <span class="keyword">foreach</span> (RedisValue item <span class="keyword">in</span> values)</span><br><span class="line">            &#123;</span><br><span class="line">                T @object = ConvertToObject&lt;T&gt;(item);</span><br><span class="line">                result.Add(@object);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 转换为RedisKey</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;redisKeys&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> RedisKey[] <span class="title">ConvertToRedisKeys</span>(<span class="params">List&lt;<span class="built_in">string</span>&gt; redisKeys</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> redisKeys.Select(redisKey =&gt; (RedisKey)redisKey).ToArray();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 单例获取RedisConnectionMultiplexer</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">RedisConnectionMultiplexerHelper</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> Redis连接字符串</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> RedisConnectionString &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">object</span> locker = <span class="keyword">new</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> ConnectionMultiplexer对象</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> ConnectionMultiplexer connectionMultiplexerInstance;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 单例获取</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> ConnectionMultiplexer Instance</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (connectionMultiplexerInstance == <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">lock</span> (locker)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span> (connectionMultiplexerInstance == <span class="literal">null</span> || !connectionMultiplexerInstance.IsConnected)</span><br><span class="line">                        &#123;</span><br><span class="line">                            connectionMultiplexerInstance = GetConnectionMultiplexer();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> connectionMultiplexerInstance;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ConnectionMultiplexer <span class="title">GetConnectionMultiplexer</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">string</span>.IsNullOrWhiteSpace(RedisConnectionString))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;RedisConnectionString IsNullOrWhiteSpace!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">var</span> connect = ConnectionMultiplexer.Connect(RedisConnectionString);</span><br><span class="line"></span><br><span class="line">            connect.ConnectionFailed += MuxerConnectionFailed;</span><br><span class="line">            connect.ConnectionRestored += MuxerConnectionRestored;</span><br><span class="line">            connect.ErrorMessage += MuxerErrorMessage;</span><br><span class="line">            connect.ConfigurationChanged += MuxerConfigurationChanged;</span><br><span class="line">            connect.HashSlotMoved += MuxerHashSlotMoved;</span><br><span class="line">            connect.InternalError += MuxerInternalError;</span><br><span class="line">            <span class="keyword">return</span> connect;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 配置更改时</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;sender&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;e&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MuxerConfigurationChanged</span>(<span class="params"><span class="built_in">object</span> sender, EndPointEventArgs e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;Configuration changed: <span class="subst">&#123;e.EndPoint&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 发生错误时</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;sender&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;e&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MuxerErrorMessage</span>(<span class="params"><span class="built_in">object</span> sender, RedisErrorEventArgs e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;ErrorMessage:<span class="subst">&#123;e.Message&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 重新建立连接之前的错误</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;sender&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;e&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MuxerConnectionRestored</span>(<span class="params"><span class="built_in">object</span> sender, ConnectionFailedEventArgs e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;ConnectionRestored:<span class="subst">&#123;e.EndPoint&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 连接失败,如果重新连接成功将不会收到这个通知</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;sender&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;e&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MuxerConnectionFailed</span>(<span class="params"><span class="built_in">object</span> sender, ConnectionFailedEventArgs e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;重新连接：Endpoint failed:<span class="subst">&#123;e.EndPoint&#125;</span>,<span class="subst">&#123;e.FailureType&#125;</span>,<span class="subst">&#123;e.Exception.Message&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 更改集群</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;sender&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;e&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MuxerHashSlotMoved</span>(<span class="params"><span class="built_in">object</span> sender, HashSlotMovedEventArgs e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;HashSlotMoved:NewEndPoint=<span class="subst">&#123;e.NewEndPoint&#125;</span>,OldEndPoint=<span class="subst">&#123; e.OldEndPoint&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> Redis类库错误</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;sender&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;e&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MuxerInternalError</span>(<span class="params"><span class="built_in">object</span> sender, InternalErrorEventArgs e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;InternalError:Message=<span class="subst">&#123;e.Exception.Message&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="CSRedisCore">CSRedisCore</h1><p><code>csRedis</code> 对所有方法名称进行了调整，使其和 <code>redis-cli</code>保持一致，如果熟悉 <code>redis-cli</code> 的命令可以直接上手，学习成本降低很多。</p><h2 id="安装-v5">安装</h2><p>Github：<a href="https://github.com/2881099/csRedis">https://github.com/2881099/csRedis</a></p><p><code>csRedisCore</code> 是 C# 操作 <code>Redis</code> 数据库的另一个客户端。在 <code>NuGet</code> 中搜索 <code>csRedisCore</code> ，直接点击按钮安装即可。</p><h2 id="初始化-v2">初始化</h2><p>使用连接字符串创建redis实例，可使用以下两种方式</p><ol><li>使用<code>RedisHelper</code> ： <code>RedisHelper.Initialization(new csRedisClient(&quot;127.0.0.1:6379&quot;))</code></li><li>使用<code>csRedisClient</code>：<code>csRedisClient var csRedis = new csRedisClient(&quot;127.0.0.1:6379&quot;);</code></li></ol><p>然后就可以进行操作了。</p><h2 id="字符串-string">字符串(string)</h2><p>关于字符串的<code>value</code>：</p><ul><li><code>value</code> 可以用来存储任意格式的数据，如 <code>json</code>、<code>jpg</code> 甚至视频文件</li><li><code>value</code> 最大容量为 <code>512M</code></li><li><code>value</code> 可以存储3种类型的值：字节串（byte string）/整数（int）/浮点数（double）string / 对象</li></ul><p>其中，整数的取值范围和系统的长整数取值范围相同。</p><ul><li>在32位的操作系统上，整数就是32位的</li><li>在64位操作系统上，整数就是64位有符号整数</li><li>浮点数的取值范围和IEEE 754标准的双精度浮点数相同</li></ul><h2 id="简单操作">简单操作</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*    字符串操作键值对    */</span></span><br><span class="line">csRedis.Set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;wangpengliang&quot;</span>);</span><br><span class="line">csRedis.Set(<span class="string">&quot;name2&quot;</span>, <span class="string">&quot;wangkaining&quot;</span>);</span><br><span class="line">csRedis.Set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;wangpengliang2&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据键获取对应的值</span></span><br><span class="line">csRedis.Get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除元素</span></span><br><span class="line">csRedis.Del(<span class="string">&quot;name2&quot;</span>);</span><br></pre></td></tr></table></figure><p>在对同一个键多次赋值时，该键的值是最后一次赋值时的值，实例中 <code>hello</code> 对应的值最终为<code>wangpengliang2</code>。</p><p>由于 <code>Redis</code> 可以对字符串的类型进行“识别”，所以除了对字符串进行增、删、查、之外，我们还可以对整数类型进行自增、自减操作，对字节串的一部分进行读取或者写入。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*    数值操作    */</span></span><br><span class="line">csRedis.Set(<span class="string">&quot;num-key&quot;</span>, <span class="string">&quot;24&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// value += 5</span></span><br><span class="line">csRedis.IncrBy(<span class="string">&quot;num-key&quot;</span>,<span class="number">5</span>); </span><br><span class="line"><span class="comment">// output -&gt; 29</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// value -= 10</span></span><br><span class="line">csRedis.IncrBy(<span class="string">&quot;num-key&quot;</span>, <span class="number">-10</span>); </span><br><span class="line"><span class="comment">// output -&gt; 19</span></span><br><span class="line"><span class="comment">/*    字节串操作    */</span></span><br><span class="line">csRedis.Set(<span class="string">&quot;string-key&quot;</span>, <span class="string">&quot;hello &quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在指定key的value末尾追加字符串</span></span><br><span class="line">csRedis.Append(<span class="string">&quot;string-key&quot;</span>, <span class="string">&quot;world&quot;</span>); </span><br><span class="line"><span class="comment">// output -&gt; &quot;hello world&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取从指定范围所有字符构成的子串（start:3,end:7）</span></span><br><span class="line">csRedis.GetRange(<span class="string">&quot;string-key&quot;</span>,<span class="number">3</span>,<span class="number">7</span>)  </span><br><span class="line"><span class="comment">// output -&gt;  &quot;lo wo&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 用新字符串从指定位置覆写原value（index:4）</span></span><br><span class="line">csRedis.SetRange(<span class="string">&quot;string-key&quot;</span>, <span class="number">4</span>, <span class="string">&quot;aa&quot;</span>); </span><br><span class="line"><span class="comment">// output -&gt; &quot;hellaaword&quot;</span></span><br></pre></td></tr></table></figure><h2 id="非正常情况">非正常情况</h2><ul><li>对字节串进行自增、自减操作时，redis会报错</li><li>使用<code>Append</code>、<code>SetRange</code>方法对 <code>value</code> 写入时，字节串的长度可能不够用，这时redis会使用空字符(<code>null</code> ) 将 <code>value</code>扩充到指定长度，然后再进行写入操作</li></ul><h2 id="列表-List">列表(List)</h2><blockquote><p>The speed of adding a new element with the <a href="https://redis.io/commands/lpush">LPUSH</a> command to the head of a list with ten elements is the same as adding an element to the head of list with 10 million elements.</p><p>译：使用<code>LPUSH</code>命令，向包含10个元素的列表添加新元素的速度等于向包含一千万个元素的列表添加新元素的速度。</p></blockquote><ul><li>列表可以有序的存储多个字符串操作（字符串可以重复）</li><li>列表是通过链表来实现的，所以它添加新元素的速度非常快</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从右端推入元素</span></span><br><span class="line">csRedis.RPush(<span class="string">&quot;my-list&quot;</span>, <span class="string">&quot;item1&quot;</span>, <span class="string">&quot;item2&quot;</span>, <span class="string">&quot;item3&quot;</span>, <span class="string">&quot;item4&quot;</span>); </span><br><span class="line"><span class="comment">// 从右端弹出元素</span></span><br><span class="line">csRedis.RPop(<span class="string">&quot;my-list&quot;</span>);</span><br><span class="line"><span class="comment">// 从左端推入元素</span></span><br><span class="line">csRedis.LPush(<span class="string">&quot;my-list&quot;</span>,<span class="string">&quot;LeftPushItem&quot;</span>);</span><br><span class="line"><span class="comment">// 从左端弹出元素</span></span><br><span class="line">csRedis.LPop(<span class="string">&quot;my-list&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历链表元素（start:0,end:-1即可返回所有元素）</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> csRedis.LRange(<span class="string">&quot;my-list&quot;</span>, <span class="number">0</span>, <span class="number">-1</span>))</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 按索引值获取元素（当索引值大于链表长度，返回空值，不会报错）</span></span><br><span class="line">Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;csRedis.LIndex(<span class="string">&quot;my-list&quot;</span>, <span class="number">1</span>)&#125;</span>&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 修剪指定范围内的元素（start:4,end:10）</span></span><br><span class="line">csRedis.LTrim(<span class="string">&quot;my-list&quot;</span>, <span class="number">4</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>除了对列表中的元素进行以上简单的处理之外，还可以将一个列表中的元素复制到另一个列表中。在语义上，列表的左端默认为“头部”，列表的右端为“尾部”。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将my-list最后一个元素弹出并压入another-list的头部</span></span><br><span class="line">csRedis.RPopLPush(<span class="string">&quot;my-list&quot;</span>, <span class="string">&quot;another-list&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="集合-Set">集合(Set)</h2><p>集合以无序的方式存储<strong>各不相同</strong>的元素，也就是说在集合中的每个元素的<code>Key</code>都不重复。在 <code>Redis</code>中可以快速地对集合执行添加、移除等操作。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际上只插入了两个元素(&quot;item1&quot;,&quot;item2&quot;)</span></span><br><span class="line">csRedis.SAdd(<span class="string">&quot;my-set&quot;</span>, <span class="string">&quot;item1&quot;</span>, <span class="string">&quot;item1&quot;</span>, <span class="string">&quot;item2&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 集合的遍历</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> member <span class="keyword">in</span> csRedis.SMembers(<span class="string">&quot;my-set&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;集合成员：<span class="subst">&#123;member.ToString()&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断元素是否存在</span></span><br><span class="line"><span class="built_in">string</span> member = <span class="string">&quot;item1&quot;</span>;</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;member&#125;</span>是否存在:<span class="subst">&#123;csRedis.SIsMember(<span class="string">&quot;my-set&quot;</span>, member)&#125;</span>&quot;</span>); </span><br><span class="line"><span class="comment">// output -&gt; True</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除元素</span></span><br><span class="line">csRedis.SRem(<span class="string">&quot;my-set&quot;</span>, member);</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;member&#125;</span>是否存在:<span class="subst">&#123;csRedis.SIsMember(<span class="string">&quot;my-set&quot;</span>, member)&#125;</span>&quot;</span>); </span><br><span class="line"><span class="comment">// output -&gt;  False</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机移除一个元素</span></span><br><span class="line">csRedis.SPop(<span class="string">&quot;my-set&quot;</span>);</span><br></pre></td></tr></table></figure><p>以上是对一个集合中的元素进行操作，除此之外还可以对两个集合进行交、并、差操作。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">csRedis.SAdd(<span class="string">&quot;set-a&quot;</span>, <span class="string">&quot;item1&quot;</span>, <span class="string">&quot;item2&quot;</span>, <span class="string">&quot;item3&quot;</span>,<span class="string">&quot;item4&quot;</span>,<span class="string">&quot;item5&quot;</span>);</span><br><span class="line">csRedis.SAdd(<span class="string">&quot;set-b&quot;</span>, <span class="string">&quot;item2&quot;</span>, <span class="string">&quot;item5&quot;</span>, <span class="string">&quot;item6&quot;</span>, <span class="string">&quot;item7&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 差集</span></span><br><span class="line">csRedis.SDiff(<span class="string">&quot;set-a&quot;</span>, <span class="string">&quot;set-b&quot;</span>); </span><br><span class="line"><span class="comment">// output -&gt; &quot;item1&quot;, &quot;item3&quot;,&quot;item4&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交集</span></span><br><span class="line">csRedis.SInter(<span class="string">&quot;set-a&quot;</span>, <span class="string">&quot;set-b&quot;</span>); </span><br><span class="line"><span class="comment">// output -&gt; &quot;item2&quot;,&quot;item5&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 并集</span></span><br><span class="line">csRedis.SUnion(<span class="string">&quot;set-a&quot;</span>, <span class="string">&quot;set-b&quot;</span>);</span><br><span class="line"><span class="comment">// output -&gt; &quot;item1&quot;,&quot;item2&quot;,&quot;item3&quot;,&quot;item4&quot;,&quot;item5&quot;,&quot;item6&quot;,&quot;item7&quot;</span></span><br></pre></td></tr></table></figure><p>另外还可以用 <code>SDiffStore</code>,<code>SInterStore</code>,<code>SUnionStore</code> 将操作后的结果存储在新的集合中。</p><h2 id="散列-HashMap">散列(HashMap)</h2><p>在 <code>Redis</code> 中可以使用散列将多个键值对存储在一个 <code>key</code> 上，从而达到将一系列相关数据存放在一起的目的。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向散列添加元素</span></span><br><span class="line">csRedis.HSet(<span class="string">&quot;ArticleID:10001&quot;</span>, <span class="string">&quot;Title&quot;</span>, <span class="string">&quot;了解简单的Redis数据结构&quot;</span>);</span><br><span class="line">csRedis.HSet(<span class="string">&quot;ArticleID:10001&quot;</span>, <span class="string">&quot;Author&quot;</span>, <span class="string">&quot;xscape&quot;</span>);</span><br><span class="line">csRedis.HSet(<span class="string">&quot;ArticleID:10001&quot;</span>, <span class="string">&quot;PublishTime&quot;</span>, <span class="string">&quot;2019-01-01&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据Key获取散列中的元素</span></span><br><span class="line">csRedis.HGet(<span class="string">&quot;ArticleID:10001&quot;</span>, <span class="string">&quot;Title&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取散列中的所有元素</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> csRedis.HGetAll(<span class="string">&quot;ArticleID:10001&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(item.Value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>HGet</code>和<code>HSet</code>方法执行一次只能处理一个键值对，而<code>HMGet</code>和<code>HMSet</code>是他们的多参数版本，一次可以处理多个键值对。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> keys = <span class="keyword">new</span> <span class="built_in">string</span>[] &#123; <span class="string">&quot;Title&quot;</span>,<span class="string">&quot;Author&quot;</span>,<span class="string">&quot;publishTime&quot;</span>&#125;;</span><br><span class="line">csRedis.HMGet(<span class="string">&quot;ID:10001&quot;</span>, keys);</span><br></pre></td></tr></table></figure><p>虽然使用<code>HGetAll</code>可以取出所有的value，但是<strong>有时候散列包含的值可能非常大，容易造成服务器的堵塞</strong>，为了避免这种情况，我们可以使用<code>HKeys</code>取到散列的所有键(<em><code>HVals可以取出所有值</code></em>)，然后再使用 <code>HGet</code>方法一个一个地取出键对应的值。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> csRedis.HKeys(<span class="string">&quot;ID:10001&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;item&#125;</span> - <span class="subst">&#123;csRedis.HGet(<span class="string">&quot;ID:10001&quot;</span>, item)&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和处理字符串一样，也可以对散列中的值进行自增、自减操作，原理同字符串是一样的。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">csRedis.HSet(<span class="string">&quot;ArticleID:10001&quot;</span>, <span class="string">&quot;votes&quot;</span>, <span class="string">&quot;257&quot;</span>);</span><br><span class="line">csRedis.HIncrBy(<span class="string">&quot;ID:10001&quot;</span>, <span class="string">&quot;votes&quot;</span>, <span class="number">40</span>);</span><br><span class="line"><span class="comment">// output -&gt; 297</span></span><br></pre></td></tr></table></figure><h2 id="有序集合">有序集合</h2><p>有序集合可以看作是可排序的散列，不过有序集合的 <code>val</code> 成为<code>score</code> 分值，集合内的元素就是基于<code>score</code> 进行排序的，<code>score</code> 以双精度浮点数的格式存储。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向有序集合添加元素</span></span><br><span class="line">csRedis.ZAdd(<span class="string">&quot;Quiz&quot;</span>, (<span class="number">79</span>, <span class="string">&quot;Math&quot;</span>));</span><br><span class="line">csRedis.ZAdd(<span class="string">&quot;Quiz&quot;</span>, (<span class="number">98</span>, <span class="string">&quot;English&quot;</span>));</span><br><span class="line">csRedis.ZAdd(<span class="string">&quot;Quiz&quot;</span>, (<span class="number">87</span>, <span class="string">&quot;Algorithm&quot;</span>));</span><br><span class="line">csRedis.ZAdd(<span class="string">&quot;Quiz&quot;</span>, (<span class="number">84</span>, <span class="string">&quot;Database&quot;</span>));</span><br><span class="line">csRedis.ZAdd(<span class="string">&quot;Quiz&quot;</span>, (<span class="number">59</span>, <span class="string">&quot;Operation System&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回集合中的元素数量</span></span><br><span class="line">csRedis.ZCard(<span class="string">&quot;Quiz&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取集合中指定范围(90~100)的元素集合</span></span><br><span class="line">csRedis.ZRangeByScore(<span class="string">&quot;Quiz&quot;</span>,<span class="number">90</span>,<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取集合所有元素并升序排序</span></span><br><span class="line">csRedis.ZRangeWithScores(<span class="string">&quot;Quiz&quot;</span>, <span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除集合中的元素</span></span><br><span class="line">csRedis.ZRem(<span class="string">&quot;Quiz&quot;</span>, <span class="string">&quot;Math&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="事务">事务</h2><p>事务可以保证一个客户端在执行多条命令时，不被其他客户端打断，这跟关系型数据库的事务是不一样的。事务需要使用 <code>MULTI</code> 和 <code>EXEC</code> 命令，<code>Redis</code> 会将被<code>MULTI</code> 和 <code>EXEC</code>所包围的代码依次执行，当该事务结束之后才会处理其他客户端的命令。</p><p><strong>管道(pipeline)</strong></p><p><code>Redis</code> 的事务是通过 <code>pipeline</code> 实现的，使用时客户端会自动调用 <code>MULTI</code> 和 <code>EXEX</code> 命令，<strong>将多条命令打包并一次性地发送给 <code>Redis</code>，然后 <code>Redis</code>再将命令的执行结果全部打包并一次性返回给客户端</strong>，这样有效的减少了Redis与客户端的通信次数，提升执行多次命令时的性能。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 事务处理</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"> [<span class="meta">TestMethod</span>]</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Transaction</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> strKey = Guid.NewGuid().ToString();</span><br><span class="line">            <span class="built_in">string</span> strval = Faker.Name.FullName();</span><br><span class="line"></span><br><span class="line">            <span class="built_in">string</span> intKey = Guid.NewGuid().ToString();</span><br><span class="line">            <span class="built_in">int</span> intVal = Faker.RandomNumber.Next(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> one</span></span><br><span class="line">            <span class="comment">// 第一种方式:正常情况下redis命令批处理,返回[true,true]</span></span><br><span class="line">            <span class="built_in">object</span>[] result = csRedis.StartPipe()</span><br><span class="line">                .Set(strKey, strval)</span><br><span class="line">                .Set(intKey, intVal)</span><br><span class="line">                .EndPipe();</span><br><span class="line">            Console.WriteLine(JsonConvert.SerializeObject(result));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> two</span></span><br><span class="line">            <span class="comment">// 第二种方式：对string类型进行IncrBy操作,会抛出异常但不影响执行,返回[false, false, null]; Redis中多了两条数据</span></span><br><span class="line">            <span class="built_in">object</span>[] result2 = csRedis.StartPipe()</span><br><span class="line">                .Set(strKey, strval)</span><br><span class="line">                .Set(intKey, intVal)</span><br><span class="line">                .IncrBy(strKey, <span class="number">5</span>)</span><br><span class="line">                .EndPipe();</span><br><span class="line">            Console.WriteLine(JsonConvert.SerializeObject(result2));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> three</span></span><br><span class="line">            <span class="comment">// 第三种方式：对string类型进行IncrBy操作,错误的命令不被执行,Redis中多了两条数据</span></span><br><span class="line">            <span class="keyword">using</span> <span class="keyword">var</span> rc = csRedis.Nodes.First().Value.Get();</span><br><span class="line">            rc.Value.Multi();</span><br><span class="line">            rc.Value.SAdd(strKey, strval);</span><br><span class="line">            rc.Value.SAdd(intKey, intVal);</span><br><span class="line">            rc.Value.SAdd(strKey, <span class="number">5</span>);</span><br><span class="line">            <span class="comment">// 此时报错：EXEC  ---&gt; CSRedis.RedisException: WRONGTYPE Operation against a key holding the wrong kind of value</span></span><br><span class="line">            rc.Value.Exec();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> four</span></span><br><span class="line">            <span class="comment">// 第四种方式：对string类型进行IncrBy操作,错误的命令不被执行,Redis中多了两条数据</span></span><br><span class="line">            <span class="keyword">var</span> tran = csRedis.StartPipe();</span><br><span class="line">            tran.Set(strKey, strval);</span><br><span class="line">            tran.Set(intKey, intVal);</span><br><span class="line">            tran.IncrBy(strKey, <span class="number">5</span>);</span><br><span class="line">            <span class="keyword">var</span> b = tran.EndPipe();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="Key的过期">Key的过期</h2><p>Redis允许为key设置有效期，当key过期之后，key就不存在了。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">TestMethod</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">KeyExpire</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> key = <span class="string">&quot;name&quot;</span>;</span><br><span class="line">    <span class="built_in">string</span> <span class="keyword">value</span> = <span class="string">&quot;wangpengliang&quot;</span>;</span><br><span class="line">    csRedis.Set(key, <span class="keyword">value</span>);</span><br><span class="line"></span><br><span class="line">    csRedis.Expire(key, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">string</span> result = csRedis.Get(key);</span><br><span class="line">    Assert.AreEqual(<span class="keyword">value</span>, result);</span><br><span class="line">    Thread.Sleep(<span class="number">4000</span>);</span><br><span class="line">    result = csRedis.Get(key);</span><br><span class="line">    Assert.AreEqual(<span class="literal">null</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分区">分区</h2><p>多个服务节点共同分担存储，与官方的分区、集群、高可用方案不同。</p><blockquote><p>例如：缓存数据达到500G，如果使用一台redis-server服务器光靠内存存储将非常吃力，使用硬盘又影响性能。<br>可以使用此功能自动管理N台redis-server服务器分担存储，每台服务器只需约 (500/N)G 内存，且每台服务器匀可以配置官方高可用架构。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var rds = new CSRedis.CSRedisClient(null,</span><br><span class="line">  &quot;127.0.0.1:6371,password=123,defaultDatabase=11,poolsize=10,ssl=false,writeBuffer=10240,prefix=key前辍&quot;, </span><br><span class="line">  &quot;127.0.0.1:6372,password=123,defaultDatabase=12,poolsize=11,ssl=false,writeBuffer=10240,prefix=key前辍&quot;,</span><br><span class="line">  &quot;127.0.0.1:6373,password=123,defaultDatabase=13,poolsize=12,ssl=false,writeBuffer=10240,prefix=key前辍&quot;,</span><br><span class="line">  &quot;127.0.0.1:6374,password=123,defaultDatabase=14,poolsize=13,ssl=false,writeBuffer=10240,prefix=key前辍&quot;);</span><br><span class="line">//实现思路：根据key.GetHashCode() % 节点总数量，确定连向的节点</span><br><span class="line">//也可以自定义规则(第一个参数设置)</span><br><span class="line"></span><br><span class="line">rds.MSet(&quot;key1&quot;, 1, &quot;key2&quot;, 2, &quot;key3&quot;, 3, &quot;key4&quot;, 4);</span><br><span class="line">rds.MGet(&quot;key1&quot;, &quot;key2&quot;, &quot;key3&quot;, &quot;key4&quot;);</span><br></pre></td></tr></table></figure><h2 id="发布订阅">发布订阅</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//普通订阅</span><br><span class="line">rds.Subscribe(</span><br><span class="line">  (&quot;chan1&quot;, msg =&gt; Console.WriteLine(msg.Body)),</span><br><span class="line">  (&quot;chan2&quot;, msg =&gt; Console.WriteLine(msg.Body)));</span><br><span class="line"></span><br><span class="line">//模式订阅（通配符）</span><br><span class="line">rds.PSubscribe(new[] &#123; &quot;test*&quot;, &quot;*test001&quot;, &quot;test*002&quot; &#125;, msg =&gt; &#123;</span><br><span class="line">  Console.WriteLine($&quot;PSUB   &#123;msg.MessageId&#125;:&#123;msg.Body&#125;    &#123;msg.Pattern&#125;: chan:&#123;msg.Channel&#125;&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">//模式订阅已经解决的难题：</span><br><span class="line">//1、分区的节点匹配规则，导致通配符最大可能匹配全部节点，所以全部节点都要订阅</span><br><span class="line">//2、本组 &quot;test*&quot;, &quot;*test001&quot;, &quot;test*002&quot; 订阅全部节点时，需要解决同一条消息不可执行多次</span><br><span class="line"></span><br><span class="line">//发布</span><br><span class="line">rds.Publish(&quot;chan1&quot;, &quot;123123123&quot;);</span><br><span class="line">//无论是分区或普通模式，rds.Publish 都可以正常通信</span><br></pre></td></tr></table></figure><h2 id="缓存壳">缓存壳</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// 缓存壳</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        [TestMethod]</span><br><span class="line">        public void CacheShell()</span><br><span class="line">        &#123;</span><br><span class="line">            string value = &quot;wangpengliang&quot;;</span><br><span class="line">#if debug</span><br><span class="line">            // 一般的缓存代码，如不封装比较繁琐</span><br><span class="line">            var cacheValue = csRedis.Get(&quot;name&quot;);</span><br><span class="line">            // 如果已被缓存</span><br><span class="line">            if (!string.IsNullOrEmpty(cacheValue))</span><br><span class="line">            &#123;</span><br><span class="line">                try</span><br><span class="line">                &#123;</span><br><span class="line">                    // </span><br><span class="line">                &#125;</span><br><span class="line">                catch</span><br><span class="line">                &#123;</span><br><span class="line">                    //出错时删除key</span><br><span class="line">                    csRedis.Del(&quot;name&quot;);</span><br><span class="line">                    throw;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                csRedis.Set(&quot;name&quot;, value, 10);</span><br><span class="line">            &#125;</span><br><span class="line">#endif</span><br><span class="line">            // 判断key=name是否已存在,存在返回value,不存在设置</span><br><span class="line">            string t1 = csRedis.CacheShell(&quot;name&quot;, 10, () =&gt; value);</span><br><span class="line">            Assert.AreEqual(value, t1);</span><br><span class="line">            string t2 = csRedis.CacheShell(&quot;name&quot;, 10, () =&gt; &quot;wangpengliang2&quot;);</span><br><span class="line">            Assert.AreEqual(value, t2);</span><br><span class="line">            string t3 = csRedis.CacheShell(&quot;name2&quot;, 10, () =&gt; &quot;wangpengliang2&quot;);</span><br><span class="line">            Assert.AreEqual(&quot;wangpengliang2&quot;, t3);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="管道">管道</h2><p>使用管道模式，打包多条命令一起执行，从而提高性能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var ret1 = rds.StartPipe().Set(&quot;a&quot;, &quot;1&quot;).Get(&quot;a&quot;).EndPipe();</span><br><span class="line">var ret2 = rds.StartPipe(p =&gt; p.Set(&quot;a&quot;, &quot;1&quot;).Get(&quot;a&quot;));</span><br><span class="line"></span><br><span class="line">var ret3 = rds.StartPipe().Get(&quot;b&quot;).Get(&quot;a&quot;).Get(&quot;a&quot;).EndPipe();</span><br><span class="line">//与 rds.MGet(&quot;b&quot;, &quot;a&quot;, &quot;a&quot;) 性能相比，经测试差之毫厘</span><br></pre></td></tr></table></figure><h2 id="多数据库">多数据库</h2><blockquote><p>如果确定一定以及肯定非要有切换数据库的需求，请看以下代码：通过定义多个CSRedisClient实现</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 多数据库,使用多个CSRedisClient实现</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">[TestMethod]</span><br><span class="line">public void MultiDatabase()</span><br><span class="line">&#123;</span><br><span class="line">    // 实际使用必须要单例</span><br><span class="line">    CSRedisClient[] redis = new CSRedisClient[14];</span><br><span class="line">    for (int i = 0; i &lt; redis.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        redis[i] = new CSRedisClient($&quot;&#123;redisConnection&#125;,defaultDatabase=&#123;i&#125;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    redis[0].Set(&quot;db0&quot;, &quot;db0&quot;);</span><br><span class="line">    string t1 = redis[0].Get(&quot;db0&quot;);</span><br><span class="line">    Assert.AreEqual(&quot;db0&quot;, t1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    redis[1].Set(&quot;db1&quot;, &quot;db1&quot;);</span><br><span class="line">    string t2 = redis[1].Get(&quot;db1&quot;);</span><br><span class="line">    Assert.AreEqual(&quot;db1&quot;, t2);</span><br><span class="line"></span><br><span class="line">    redis[2].Set(&quot;db2&quot;, &quot;db2&quot;);</span><br><span class="line">    string t3 = redis[2].Get(&quot;db2&quot;);</span><br><span class="line">    Assert.AreEqual(&quot;db2&quot;, t3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/rabbitMq/1.8RabbitMQ%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
      <url>/rabbitMq/1.8RabbitMQ%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>rabbitMq常见问题记录</p><span id="more"></span><h1 id="为什么要使用消息队列">为什么要使用消息队列</h1><h2 id="解耦">解耦</h2><p><strong>传统模式</strong>：系统间耦合度强 如系统A直接调用系统B系统C的代码，如果再有系统D接入，则系统A还要修改代码。<br><strong>中间件模式</strong>：系统A将消息写入消息队列，系统B、系统C 订阅消息队列，如果再有系统D介入，直接订阅消息队列即可 系统A不必修改代码。</p><h2 id="异步-v2">异步</h2><p><strong>传统模式</strong>：一些非必的业务逻辑以同步得方式运行浪费时间。<br><strong>中间件模式</strong>：将消息写入消息队列 一些非必要的业务逻辑以异步得方式运行提高响应速度。</p><h2 id="削峰-限流">削峰/限流</h2><p><strong>传统模式</strong>：并发量大得时候所有请求全部到数据库，造成数据库连接异常。<br><strong>中间件模式</strong>：系统按照数据库能处理得并发量从消息队列中慢慢拉取消息。在生产环境中这种短暂得高峰期积压是允许的。</p><h1 id="消息队列的使用场景">消息队列的使用场景</h1><p>消息队列常见的使用场景很多，比较核心的有3个：<code>解耦</code>、<code>异步</code>、<code>削峰</code>。</p><h1 id="什么是RabbitMQ">什么是RabbitMQ</h1><p>即一个消息队列，主要是用来实现应用程序的异步和解耦，同时也能起到消息缓冲，消息分发的作用。RabbitMQ使用的是<code>AMQP</code>协议，它是一种二进制协议</p><p><code>AMQP</code>，即<code>Advanced Message Queuing Protocol</code>(高级消息排队协议),一个提供统一消息服务的应用层标准高级消息队列协议,是应用层协议的一个开放标准,为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条件的限制。</p><h1 id="为什么使用RabbitMQ">为什么使用RabbitMQ</h1><p>这里涉及一个消息中间件选型的问题</p><p><img src="/images/2021-09-05-23-07-23.png" alt=""></p><table><thead><tr><th>特性</th><th style="text-align:center">ActiveMQ</th><th style="text-align:left">RabbitMQ</th><th>RocketMQ</th><th style="text-align:center">kafka</th></tr></thead><tbody><tr><td>开发语言</td><td style="text-align:center">java</td><td style="text-align:left">erlang</td><td>java</td><td style="text-align:center">scala</td></tr><tr><td>单机吞吐量</td><td style="text-align:center">万级</td><td style="text-align:left">万级</td><td>10万级</td><td style="text-align:center">10万级</td></tr><tr><td>时效性</td><td style="text-align:center">ms级</td><td style="text-align:left">us级</td><td>ms级</td><td style="text-align:center">ms级以内</td></tr><tr><td>可用性</td><td style="text-align:center">高(主从架构)</td><td style="text-align:left">高(主从架构)</td><td>非常高(分布式架构)</td><td style="text-align:center">非常高(分布式架构)</td></tr><tr><td>功能特性</td><td style="text-align:center">成熟的产品，在很多公司得到应用；有较多的文档；各种协议支持较好</td><td style="text-align:left">基于erlang开发，所以并发能力很强，性能极其好，延时很低;管理界面较丰富</td><td>MQ功能比较完备，扩展性佳</td><td style="text-align:center">只支持主要的MQ功能，像消息查询，消息回溯等功能没有提供，在大数据领域应用广泛</td></tr></tbody></table><ul><li>中小型软件公司，建议选<code>RabbitMQ</code>.一方面，<code>erlang</code>语言天生具备高并发的特性，而且他的管理界面用起来十分方便。正所谓，成也萧何，败也萧何！他的弊端也在这里，虽然<code>RabbitMQ</code>是开源的，然而国内有几个能定制化开发erlang的程序员呢？所幸，RabbitMQ的社区十分活跃，可以解决开发过程中遇到的bug，这点对于中小型公司来说十分重要。不考虑rocketmq和kafka的原因是，一方面中小型软件公司不如互联网公司，数据量没那么大，选消息中间件，应首选功能比较完备的，所以kafka排除。不考虑rocketmq的原因是，rocketmq是阿里出品，如果阿里放弃维护rocketmq，中小型公司一般抽不出人来进行rocketmq的定制化开发，因此不推荐</li><li>大型软件公司，根据具体使用在rocketMq和kafka之间二选一。一方面，大型软件公司，具备足够的资金搭建分布式环境，也具备足够大的数据量。针对rocketMQ,大型软件公司也可以抽出人手对rocketMQ进行定制化开发，毕竟国内有能力改JAVA源码的人，还是相当多的。至于kafka，根据业务场景选择，如果有日志采集功能，肯定首选kafka</li></ul><blockquote><p>具体该选哪个，应该根据实际场景考虑，不能为了用而用</p></blockquote><h1 id="使用消息队列的缺点">使用消息队列的缺点</h1><p><strong>系统可用性降低</strong>：本来其他系统只要运行好好的，那你的系统就是正常的。现在加了消息队列进去，那消息队列挂了，你的系统也就挂了。因此，系统可用性降低<br><strong>系统复杂性增加</strong>：要多考虑很多方面的问题，比如一致性问题、如何保证消息不被重复消费，如何保证保证消息可靠传输。因此，需要考虑的东西更多，系统复杂性增大</p><h1 id="如何实现高可用">如何实现高可用</h1><p>参考：搭建RabbitMQ高可用集群</p><h1 id="重要角色有哪些">重要角色有哪些</h1><p><strong>生产者</strong>：消费的创建者，负责创建和推送数据到消息服务器<br><strong>消费者</strong>：消息的接收方，用于处理数据和确认消息<br><strong>代理</strong>：指RabbitMQ本身，本身不生产消息，只扮演“快递”的角色</p><h1 id="重要组件有哪些">重要组件有哪些</h1><p><code>ConnectionFactory</code>（连接管理器）：应用程序与Rabbit之间建立连接的管理器，程序代码中使用<br><code>Channel</code>（信道）：消息推送使用的通道<br><code>Exchange</code>（交换器）：用于接收，分配消息<br><code>Queue</code>（队列）：用于存储生产者的消息<br><code>RoutingKey</code>（路由键）：用于把生产者的数据分配到交换器上<br><code>BindingKey</code>（绑定键）：用于把交换器的消息绑定到队列上</p><h1 id="vhost作用">vhost作用</h1><p>每个RabbitMQ都能创建多个<code>vhost</code>，称为虚拟主机，每个虚拟主机都是mini版的RabbitMQ，它拥有自己的队列，交换器和绑定，拥有自己的权限机制。</p><h1 id="消息如何发送">消息如何发送</h1><p>首先客户端必须连接到RabbitMQ服务器才能发布和消费消息，客户端和 rabbit server 之间会创建一个tcp连接，一旦tcp打开并通过了认证（认证就是你发送给rabbit服务器的用户名和密码），你的客户端和 就创建一条 amqp 信道（channel），信道是创建在“真实”tcp上的虚拟连接，amqp命令都是通过信道发送出去的，每个信道都会有唯一的id，不论是发布消息，订阅队列都是通过这个信道完成。</p><h1 id="怎么保证消息可靠性">怎么保证消息可靠性</h1><p>从三个角度分析：生产者弄丢数据 消息队列弄丢数据 消费者弄丢数据。</p><h2 id="生产者丢失数据">生产者丢失数据</h2><p>提供 <code>Transacton</code> 和 <code>confirm</code> 机制来确保生产者不丢消息。</p><p><code>Transacton</code>: 发消息前开启事务（channel.txSelect()),然后发送消息，如果发送过程中有什么异常，事务就会回滚（channel,txRollback()),如果发送成功则提交事务（channel.txCommit()).然而缺点是吞吐量下降了。因此生产用<code>confirm</code>模式居多。一但channel 进入confirm 模式，所有该信道上面发送的消息都将会指派一个唯一的ID（从1开始），一但消息被投递到所有匹配的队列之后，rabbitMQ就会发送一个ACK给生产者（包含消息的唯一ID),这就使生产这知道消息已经到达消息队列了。如果RabbitMQ没有处理该消息，则会发送一个Nack消息给你，你可以进行重试操作。</p><h2 id="消息队列丢失数据">消息队列丢失数据</h2><p>处理消息队列丢失数据的情况，一把是开启持久化磁盘的配置。这个持久话配置可以和 <code>confirm</code> 机制配合使用，你可以在持久化磁盘之后，再给生产这发送一个Ack信号。这样如果持久化磁盘之前，rabbitMQ阵亡了，那么生产者收不到Ack信号，生产者会自动重发。</p><p>持久化一般分两步</p><ol><li>将<code>queue</code> 的持久化标识 <code>durable</code>设置为 <code>true</code>,则代表一个持久化队列</li><li>发送消息的时候将 <code>deliveryMode=2</code></li></ol><p>这样设置之后，rabbitMQ就算挂掉了，重启后也能恢复数据。</p><h2 id="消费者丢数据">消费者丢数据</h2><p>消费者丢数据一般是因为采用了自动确认消息模式，这种模式下，消费者会自动确认收到信息。这时rabbitMQ会立即将消息删除，这种情况下如果消费者出现异常而没能处理该消息，就会丢失该消息。</p><p><strong>解决方案</strong>：采用手动确认消息即可，在处理完消息后才发送 <code>ack</code></p><h1 id="怎么避免消息丢失">怎么避免消息丢失</h1><p>将数据写到消息队列上，系统B和C还没来得及取消息队列的数据，就挂掉了。如果没有做任何的措施，数据就丢了，这时候就要考虑数据的持久化，<code>磁盘</code>、<code>数据库</code>、<code>Redis</code>等，是同步存储还是异步存储。</p><h1 id="消息持久化成功的条件">消息持久化成功的条件</h1><ul><li>声明队列必须设置持久化 <code>durable</code>设置为 <code>true</code></li><li>消息推送投递模式必须设置持久化， <code>deliveryMode</code> 设置为2（持久）</li><li>消息已经到达持久化交换器</li><li>消息已经到达持久化队列</li></ul><h1 id="持久化有什么缺点">持久化有什么缺点</h1><p>持久化的缺点就是降低了服务器的吞吐量，因为使用的是磁盘而非内存存储，从而降低了吞吐量。可使用SSD硬盘来缓解吞吐量的问题。</p><h1 id="有几种广播类型">有几种广播类型</h1><ul><li><code>direct</code>（默认）：最基础最简单的模式，发送方把消息发送给订阅方，如果有多个订阅者，默认采用轮询的方式进行消息发送</li><li><code>headers</code>：与 <code>direct</code>类似，只是性能很差，实际开发使用很少</li><li><code>fanout</code>：分发模式，把消费分发给所有订阅者</li><li><code>topic</code>：匹配订阅模式，使用正则匹配到消息队列，能匹配到的都能接收到</li></ul><h1 id="延迟消息队列如何实现">延迟消息队列如何实现</h1><p>消息过期后进入<code>死信交换器</code>，再由交换器转发到延迟消费队列，实现延迟功能，使用 <code>RabbitMQ-delayed-message-exchange</code> 插件实现延迟功能。</p><h1 id="集群有什么用">集群有什么用</h1><p><strong>高可用</strong>：某个服务器出现问题，整个RabbitMQ还可以继续使用<br><strong>高容量</strong>：集群可以承载更多的消息量</p><h1 id="节点的类型有哪些">节点的类型有哪些</h1><p><strong>磁盘节点</strong>：消息会存储到磁盘<br><strong>内存节点</strong>：消息都存储到内存中，重启服务器消息丢失，性能高于磁盘类型</p><h1 id="集群搭建需要注意哪些问题">集群搭建需要注意哪些问题</h1><ul><li>各节点之间使用<code>-link</code> 连接，此属性不能忽略</li><li>各节点使用的 <code>erlang cookie</code>值必须相同，此值相当于“秘钥”的功能，用于各节点的认证</li><li>整个集群必须包含一个磁盘节点</li></ul><h1 id="节点拷贝问题">节点拷贝问题</h1><p>每个节点是其他节点的完整拷贝吗?为什么<br>不是，原因有以下两个：</p><ol><li>存储空间的考虑：如果每个节点都拥有所有队列的完全拷贝，这样新增节点不但没有新增存储空间，反而增加了更多的冗余数据</li><li>性能的考虑：如果每条消息都需要完整拷贝每一个集群节点，那新增节点并没有提升处理消息的能力，最多是保持和单节点相同的性能甚至更糟</li></ol><h1 id="集群中唯一磁盘节点崩溃会发生什么情况">集群中唯一磁盘节点崩溃会发生什么情况</h1><p>如果唯一磁盘的磁盘节点崩溃，不能进行以下操作：</p><ul><li>不能创建队列</li><li>不能创建交换器</li><li>不能创建绑定</li><li>不能添加用户</li><li>不能更改权限</li><li>不能添加和删除集群节点</li></ul><p>唯一磁盘节点崩溃了，集群是可以保持运行的，但不能更改任何东西。</p><h1 id="集群节点停止顺序">集群节点停止顺序</h1><p>对集群的停止的顺序是有要求的，应该先关闭内存节点，最后关闭磁盘节点。如果顺序恰好相反的话，可能造成消息的丢失。</p><h1 id="Kafka与RabbitMQ">Kafka与RabbitMQ</h1><h2 id="应用场景方面">应用场景方面</h2><p>RabbitMQ：用于实时的，对可靠性要求较高的消息传递上<br>kafka：用于处于活跃的流式数据，大数据量的数据处理上</p><h2 id="架构模型方面">架构模型方面</h2><p>producer，broker，consumer<br>RabbitMQ：以broker为中心，有消息的确认机制<br>kafka：以consumer为中心，无消息的确认机制</p><h2 id="吞吐量方面">吞吐量方面</h2><p>RabbitMQ：支持消息的可靠的传递，支持事务，不支持批量操作，基于存储的可靠性的要求存储可以采用内存或硬盘，吞吐量小<br>kafka：内部采用消息的批量处理，数据的存储和获取是本地磁盘顺序批量操作，消息处理的效率高，吞吐量高</p><h2 id="集群负载均衡方面">集群负载均衡方面</h2><p>RabbitMQ：本身不支持负载均衡，需要loadbalancer的支持<br>kafka：采用zookeeper对集群中的broker，consumer进行管理，可以注册topic到zookeeper上，通过zookeeper的协调机制，producer保存对应的topic的broker信息，可以随机或者轮询发送到broker上，producer可以基于语义指定分片，消息发送到broker的某个分片上。<br>kafka通过zk和分区机制实现：zk记录broker信息，生产者可以获取到并通过策略完成负载均衡；通过分区，投递消息到不同分区，消费者通过服务组完成均衡消费</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/rabbitMq/1.9RabbitMQ%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88/"/>
      <url>/rabbitMq/1.9RabbitMQ%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>集群方案</p><span id="more"></span>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/redis/1.1NoSql%E6%A6%82%E8%BF%B0/"/>
      <url>/redis/1.1NoSql%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是NoSQL">什么是NoSQL</h1><p>在现代的计算系统上每天网络上都会产生庞大的数据量。这些数据有很大一部分是由关系数据库管理系统（RDBMS）来处理。 1970年 E.F.Codd’s提出的关系模型的论文 “A relational model of data for large shared data banks”，这使得数据建模和应用程序编程更加简单。</p><blockquote><p>NoSQL(NoSQL = Not Only SQL )，意即&quot;不仅仅是SQL&quot;</p></blockquote><span id="more"></span><h1 id="为什么要使用NoSQL">为什么要使用NoSQL</h1><p>传统关系型数据库面对海量数据的存储，以及实现高访问量、高并发读/写，显得力不从心。尤其是当面对超大规模、高并发、高吞吐量的大型动态网站的时候，就会暴露出很多难以克服的问题，影响用户体验。为了满足对海量数据的高速存储需求，实现高并发、高吞吐量，NoSQL 应运而生。NoSQL 的出现可以解决传统关系型数据库所不能解决的问题。</p><p><strong>1) ：NoSQL 解决了高并发读/写问题</strong></p><p>Web 2.0 动态网站需要根据用户的个性化信息来实时生成动态页面和提供动态信息，而无法使用动态页面的静态化技术，因此数据库的并发负载就会非常高。比如，微博、朋友圈的实时更新，就会出现每秒上万次的读/写需求。关系型数据库在面对每秒上万次的 SQL 查询操作时还能应对自如，但是在面对每秒上万次的 SQL 写操作时就难以胜任了。普通的 BBS 系统网站也存在高并发读/写的需求，比如，实时统计在线人数、记录热门帖子的浏览次数等，当面对这些需求时，传统的关系型数据库就会出现大量问题。</p><p><strong>2) NoSQL 解决了海量数据的高效率存储和访问问题</strong></p><p>面对实时产生的<a href="http://c.biancheng.net/big_data/">大数据</a>量的存储与查询，关系型数据库是难以应付的，会显得效率非常低。而利用 NoSQL 的高效存储与查询能力，就能解决这个问题。</p><p><strong>3) NoSQL 实现了高可用性及高可扩展性</strong></p><p>在基于 Web 的架构中，关系型数据库难以进行横向扩展。当一个网站系统的用户量和访问量与日俱增的时候，数据库没有办法像 Web 服务器或应用服务器那样通过添加更多的硬件来搭建负载均衡的服务器。对于很多提供 24 小时不间断服务的网站来说，对数据库系统的维护升级和扩展是非常折磨人的一件事，往往需要停机维护和数据迁移。</p><h1 id="NoSQL-数据库特点">NoSQL 数据库特点</h1><p>NoSQL 数据库具有如下特点</p><ul><li>容易扩展，方便使用。数据之间没有关系</li><li>数据模型非常灵活，无须提前为要存储的数据建立字段类型，随时可以存储自定义的数据格式</li><li>适合大数据量、高性能的存储</li><li>具有高并发读/写、高可用性</li></ul><h1 id="在什么应用场景下使用-NoSQL">在什么应用场景下使用 NoSQL</h1><p>NoSQL 数据库的应用场景比较广泛</p><ul><li>对于大数据量、高并发的存储系统及相关应用</li><li>对于一些数据模型比较简单的相关应用</li><li>对数据一致性要求不是很高的业务场景</li><li>对于给定 key 来映射一些复杂值的环境</li><li>对一些大型系统的日志信息的存储</li><li>存储用户信息，如大型电商系统的购物车、会话等</li><li>对于多数据源的数据存储</li><li>对易变化、热点高频信息、关键字等信息的存储</li></ul><h1 id="NoSQL四大分类">NoSQL四大分类</h1><h2 id="键值-Key-Value">键值(Key-Value)</h2><p>键值数据库就像在传统语言中使用的哈希表。可以通过key来添加、查询或者删除数据，鉴于使用主键访问，所以会获得不错的性能及扩展性。</p><p><strong>产品</strong>：Riak、Redis、Memcached、Amazon’s Dynamo、Project Voldemort</p><p><strong>适用场景</strong>：</p><p>储存用户信息，比如会话、配置文件、参数、购物车等等。这些信息一般都和ID(键)挂钩，这种情景下键值数据库是个很好的选择。</p><p><strong>不适用场景</strong>：</p><p>取代通过键查询，而是通过值来查询。Key-Value数据库中根本没有通过值查询的途径</p><p>需要储存数据之间的关系。在Key-Value数据库中不能通过两个或以上的键来关联数据</p><p>事务的支持。在Key-Value数据库中故障产生时不可以进行回滚</p><h2 id="列存储"><strong>列存储</strong></h2><p>列存储数据库将数据储存在列族(column family)中，一个列族存储经常被一起查询的相关数据。举个例子，如果我们有一个Person类，我们通常会一起查询他们的姓名和年龄而不是薪资。这种情况下，姓名和年龄就会被放入一个列族中，而薪资则在另一个列族中。</p><p><strong>产品</strong>：Cassandra、HBase</p><p><strong>适用场景</strong></p><p>可以将数据储存在不同的列中，每个应用程序可以将信息写入自己的列族中。</p><p>博客平台。储存每个信息到不同的列族中。举例：标签储存在一个，类别在一个，文章则在另一个。</p><p><strong>不适用场景</strong></p><p>如果需要ACID事务。Vassandra就不支持事务</p><p>原型设计。如果分析Cassandra的数据结构，就会发现结构是基于期望的数据查询方式而定。在模型设计之初，根本不可能去预测它的查询方式，而一旦查询方式改变，就必须重新设计列族。</p><h2 id="文档型"><strong>文档型</strong></h2><p>面向文档数据库会将数据以文档的形式储存。每个文档都是自包含的数据单元，是一系列数据项的集合。每个数据项都有一个名称与对应的值，值既可以是简单的数据类型，如字符串、数字和日期等;也可以是复杂的类型，如有序列表和关联对象。数据存储的最小单位是文档，同一个表中存储的文档属性可以是不同的，数据可以使用XML、JSON或者JSONB等多种形式存储。</p><p><strong>产品</strong>：MongoDB、CouchDB、RavenDB</p><p><strong>适用场景</strong></p><p>日志，企业环境下，每个应用程序都有不同的日志信息。Document-Oriented数据库并没有固定的模式，所以可以使用它储存不同的信息</p><p>分析，鉴于它的弱模式结构，不改变模式下就可以储存不同的度量方法及添加新的度量</p><p><strong>不适用场景</strong></p><p>在不同的文档上添加事务。Document-Oriented数据库并不支持文档间的事务，如果对这方面有需求则不应该选用这个解决方案。</p><h2 id="图形-Graph"><strong>图形(Graph)</strong></h2><p>图数据库允许将数据以图的方式储存。实体会被作为顶点，而实体之间的关系则会被作为边。比如我们有三个实体，Steve Jobs、Apple和Next，则会有两个“Founded by”的边将Apple和Next连接到Steve Jobs。</p><p><strong>产品</strong>：Neo4J、Infinite Graph、OrientDB</p><p><strong>适用场景</strong></p><p>在一些关系性强的数据中</p><p>推荐引擎。如果将数据以图的形式表现，那么将会非常有益于推荐的制定</p><p><strong>不适用场景</strong></p><p>不适合的数据模型。图数据库的适用范围很小，因为很少有操作涉及到整个图</p><h2 id="NoSQL数据库对比"><strong>NoSQL数据库对比</strong></h2><table><thead><tr><th><strong>分类</strong></th><th><strong>Examples举例</strong></th><th><strong>典型应用场景</strong></th><th><strong>数据模型</strong></th><th><strong>优点</strong></th><th style="text-align:left"><strong>缺点</strong></th></tr></thead><tbody><tr><td>键值（key-value）</td><td>Key 指向 Value 的键值对，通常用hash table来实现</td><td></td><td></td><td></td><td style="text-align:left"></td></tr><tr><td>列存储数据库</td><td>Cassandra, HBase, Riak</td><td>分布式的文件系统</td><td>以列簇式存储，将同一列数据存在一起</td><td>查找速度快，可扩展性强，更容易进行分布式扩展</td><td style="text-align:left">功能相对局限</td></tr><tr><td>文档型数据库</td><td>CouchDB, MongoDb</td><td>Web应用（与Key-Value类似，Value是结构化的，不同的是数据库能够了解Value的内容）</td><td>Key-Value对应的键值对，Value为结构化数据</td><td>数据结构要求不严格，表结构可变，不需要像关系型数据库一样需要预先定义表结构</td><td style="text-align:left">查询性能不高，而且缺乏统一的查询语法。</td></tr><tr><td>图形(Graph)数据库</td><td>Neo4J, InfoGrid, Infinite Graph</td><td>社交网络，推荐系统等。专注于构建关系图谱</td><td>图结构</td><td>利用图结构相关算法。比如最短路径寻址，N度关系查找等</td><td style="text-align:left">很多时候需要对整个图做计算才能得出需要的信息，而且这种结构不太好做分布式的集群方案。</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/redis/1.2Redis%E5%AE%89%E8%A3%85/"/>
      <url>/redis/1.2Redis%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="下载安装包">下载安装包</h1><p>Redis（<code>Remote Dictionary Server</code>  )，即远程字典服务，是一个开源的使用 <code>ANSI C</code> 语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p><p><code>Redis </code>是没有 Windows 平台下的官方支持版本的。Redis 官方不建议在 Windows 下使用，所以官网没有 Windows 版本可以下载；可以下载在 github 上的<code>ServiceStack</code>  提供的非官方 Windows 版本的 Redis 但不推荐，因为：</p><ul><li>该版本并不是官方支持的，缺少官方支持在使用上可能会出现很多问题</li><li>Redis的最新版本与 Windows 版本不同步，Redis官网版本早于Redis中文网</li></ul><p>所以不考虑Windows下版本安装，直接选择Linux下版本安装</p><span id="more"></span><p><strong>Linux安装程序分为两种</strong></p><ul><li>手动安装</li><li>yum安装</li></ul><p>如果是手动下载，需要将文件上传到Linux系统中</p><p><img src="/images/2021-09-03-16-16-13.png" alt=""></p><p>解压文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf Redis-6.2.1.tar.gz</span><br></pre></td></tr></table></figure><p>Redis是C语言开发，安装Redis需要先将Redis的源码进行编译，编译依赖gcc环境。因此需要安装gcc，安装过程中有提示时，输入Y即可。（make命令必须在Redis解压后的程序目录下执行）</p><blockquote><p>Centos7安装有默认gcc环境，默认4.8.5版本！编译 Redis-6.x，要求 gcc5.3以上 编译器，否则会遇到大量的错误。主要原因是从 Redis-6.x 开始的多线程代码依赖C标准库中的新增类型 _Atomic 。但注意 gcc 从 4.9 版本才开始正式和完整地支持 stdatomic（gcc-4.8.5 部分支持）。Centos7默认的 gcc 版本为：4.8.5 &lt; 5.3 无法编译</p></blockquote><h1 id="Gcc升级">Gcc升级</h1><p>参考 ：<a href="https://wpl.wiki/linux/Centos7%E5%8D%87%E7%BA%A7gcc%E7%89%88%E6%9C%AC">Centos7升级gcc版本</a></p><h1 id="查看gcc版本">查看gcc版本</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang Redis]<span class="comment"># gcc -v</span></span><br></pre></td></tr></table></figure><h1 id="编译Redis">编译Redis</h1><p>进入 Redis 程序目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/Redis/Redis-6.2.1</span><br></pre></td></tr></table></figure><p>Make：下载环境并编译 Redis 程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost Redis-6.2.1]<span class="comment"># make  install #将Redis安装在Linux默认位置：/usr/local/bin</span></span><br><span class="line">或者（推荐）</span><br><span class="line">[root@localhost Redis-6.2.1]<span class="comment"># make  install  PREFIX=/usr/Redis/Redis-6.2.1/installpackage　#将Redis安装在指定位置</span></span><br></pre></td></tr></table></figure><p>安装完成查看文件列表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang bin]<span class="comment"># cd /usr/Redis/Redis-6.2.1/installpackage/bin</span></span><br><span class="line">[root@wangpengliang bin]<span class="comment"># ls</span></span><br><span class="line">Redis-benchmark  Redis-check-aof  Redis-check-rdb  Redis-cli  Redis-sentinel  Redis-server</span><br><span class="line">[root@wangpengliang bin]<span class="comment"># ll</span></span><br><span class="line">总用量 21940</span><br><span class="line">-rwxr-xr-x. 1 root root  5675824 4月  18 01:32 Redis-benchmark</span><br><span class="line">lrwxrwxrwx. 1 root root       12 4月  18 01:32 Redis-check-aof -&gt; Redis-server</span><br><span class="line">lrwxrwxrwx. 1 root root       12 4月  18 01:32 Redis-check-rdb -&gt; Redis-server</span><br><span class="line">-rwxr-xr-x. 1 root root  5881760 4月  18 01:32 Redis-cli</span><br><span class="line">lrwxrwxrwx. 1 root root       12 4月  18 01:32 Redis-sentinel -&gt; Redis-server</span><br><span class="line">-rwxr-xr-x. 1 root root 10904032 4月  18 01:32 Redis-server</span><br></pre></td></tr></table></figure><h1 id="配置Redis">配置Redis</h1><p>复制 Redis 核心配置文件，文件在安装命令目录中（默认位置在 <code>/usr/local/bin</code> ）。我在安装时选择了安装在指定位置（ <code>/usr/Redis/Redis-6.2.1/installpackage</code> ），Redis配置文件需要放在安装目录下。（<code>Redis.conf </code> 配置文件在 Redis 程序目录中）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入Redis安装目录/bin</span></span><br><span class="line">[root@wangpengliang bin]<span class="comment"># cd /usr/Redis/Redis-6.2.1/installpackage/bin</span></span><br><span class="line"><span class="comment"># 创建目录conf：用于存放配置文件</span></span><br><span class="line">[root@wangpengliang bin]<span class="comment"># mkdir conf</span></span><br><span class="line"><span class="comment"># 查看创建结果</span></span><br><span class="line">[root@wangpengliang bin]<span class="comment"># ll</span></span><br><span class="line">总用量 21940</span><br><span class="line">drwxr-xr-x. 2 root root        6 4月  18 01:43 conf</span><br><span class="line">-rwxr-xr-x. 1 root root  5675824 4月  18 01:32 Redis-benchmark</span><br><span class="line">lrwxrwxrwx. 1 root root       12 4月  18 01:32 Redis-check-aof -&gt; Redis-server</span><br><span class="line">lrwxrwxrwx. 1 root root       12 4月  18 01:32 Redis-check-rdb -&gt; Redis-server</span><br><span class="line">-rwxr-xr-x. 1 root root  5881760 4月  18 01:32 Redis-cli</span><br><span class="line">lrwxrwxrwx. 1 root root       12 4月  18 01:32 Redis-sentinel -&gt; Redis-server</span><br><span class="line">-rwxr-xr-x. 1 root root 10904032 4月  18 01:32 Redis-server</span><br><span class="line"><span class="comment"># 复制Redis程序目录中的配置文件放入到Redis安装目录下conf目录中</span></span><br><span class="line">[root@wangpengliang bin]<span class="comment"># cp /usr/Redis/Redis-6.2.1/Redis.conf /usr/Redis/Redis-6.2.1/install</span></span><br><span class="line">package/bin/conf/[root@wangpengliang bin]<span class="comment"># ll</span></span><br><span class="line">总用量 21940</span><br><span class="line">drwxr-xr-x. 2 root root       24 4月  18 01:44 conf</span><br><span class="line">-rwxr-xr-x. 1 root root  5675824 4月  18 01:32 Redis-benchmark</span><br><span class="line">lrwxrwxrwx. 1 root root       12 4月  18 01:32 Redis-check-aof -&gt; Redis-server</span><br><span class="line">lrwxrwxrwx. 1 root root       12 4月  18 01:32 Redis-check-rdb -&gt; Redis-server</span><br><span class="line">-rwxr-xr-x. 1 root root  5881760 4月  18 01:32 Redis-cli</span><br><span class="line">lrwxrwxrwx. 1 root root       12 4月  18 01:32 Redis-sentinel -&gt; Redis-server</span><br><span class="line">-rwxr-xr-x. 1 root root 10904032 4月  18 01:32 Redis-server</span><br><span class="line"><span class="comment"># 进入Redis安装目录下conf目录</span></span><br><span class="line">[root@wangpengliang bin]<span class="comment"># cd conf</span></span><br><span class="line"><span class="comment"># 查看配置文件</span></span><br><span class="line">[root@wangpengliang conf]<span class="comment"># ll</span></span><br><span class="line">总用量 92</span><br><span class="line">-rw-r--r--. 1 root root 92222 4月  18 01:44 Redis.conf</span><br></pre></td></tr></table></figure><h1 id="启动Redis">启动Redis</h1><ol><li>进入 <code>Redis</code> 安装目录 <code>bin</code></li><li>使用命令启动 <code>Redis</code> 服务（测试 <code>Redis</code> 服务会占用一个窗口）</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在Redis安装目录下的bin目录中启动Redis服务并指定配置文件</span></span><br><span class="line">[root@wangpengliang bin]<span class="comment"># ./Redis-server conf/Redis.conf</span></span><br><span class="line">20335:C 18 Apr 2021 01:51:48.190 <span class="comment"># oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span></span><br><span class="line">20335:C 18 Apr 2021 01:51:48.190 <span class="comment"># Redis version=6.2.1, bits=64, commit=00000000, modified=0,</span></span><br><span class="line"> pid=20335, just started20335:C 18 Apr 2021 01:51:48.190 <span class="comment"># Configuration loaded</span></span><br><span class="line">20335:M 18 Apr 2021 01:51:48.191 * Increased maximum number of open files to 10032 (it was or</span><br><span class="line">iginally <span class="built_in">set</span> to 1024).20335:M 18 Apr 2021 01:51:48.191 * monotonic clock: POSIX clock_gettime</span><br><span class="line">                _._                                                  </span><br><span class="line">           _.-``__ <span class="string">&#x27;&#x27;</span>-._                                             </span><br><span class="line">      _.-``    `.  `_.  <span class="string">&#x27;&#x27;</span>-._           Redis 6.2.1 (00000000/0) 64 bit</span><br><span class="line">  .-`` .-```.  ```\/    _.,_ <span class="string">&#x27;&#x27;</span>-._                                   </span><br><span class="line"> (    <span class="string">&#x27;      ,       .-`  | `,    )     Running in standalone mode</span></span><br><span class="line"><span class="string"> |`-._`-...-` __...-.``-._|&#x27;</span>` _.-<span class="string">&#x27;|     Port: 6379</span></span><br><span class="line"><span class="string"> |    `-._   `._    /     _.-&#x27;</span>    |     PID: 20335</span><br><span class="line">  `-._    `-._  `-./  _.-<span class="string">&#x27;    _.-&#x27;</span>                                   </span><br><span class="line"> |`-._`-._    `-.__.-<span class="string">&#x27;    _.-&#x27;</span>_.-<span class="string">&#x27;|                                  </span></span><br><span class="line"><span class="string"> |    `-._`-._        _.-&#x27;</span>_.-<span class="string">&#x27;    |           http://Redis.io        </span></span><br><span class="line"><span class="string">  `-._    `-._`-.__.-&#x27;</span>_.-<span class="string">&#x27;    _.-&#x27;</span>                                   </span><br><span class="line"> |`-._`-._    `-.__.-<span class="string">&#x27;    _.-&#x27;</span>_.-<span class="string">&#x27;|                                  </span></span><br><span class="line"><span class="string"> |    `-._`-._        _.-&#x27;</span>_.-<span class="string">&#x27;    |                                  </span></span><br><span class="line"><span class="string">  `-._    `-._`-.__.-&#x27;</span>_.-<span class="string">&#x27;    _.-&#x27;</span>                                   </span><br><span class="line">      `-._    `-.__.-<span class="string">&#x27;    _.-&#x27;</span>                                       </span><br><span class="line">          `-._        _.-<span class="string">&#x27;                                           </span></span><br><span class="line"><span class="string">              `-.__.-&#x27;</span>                                               </span><br><span class="line"></span><br><span class="line">20335:M 18 Apr 2021 01:51:48.193 <span class="comment"># WARNING: The TCP backlog setting of 511 cannot be enforced</span></span><br><span class="line"> because /proc/sys/net/core/somaxconn is <span class="built_in">set</span> to the lower value of 128.20335:M 18 Apr 2021 01:51:48.193 <span class="comment"># Server initialized</span></span><br><span class="line">20335:M 18 Apr 2021 01:51:48.193 <span class="comment"># WARNING overcommit_memory is set to 0! Background save may</span></span><br><span class="line"> fail under low memory condition. To fix this issue add <span class="string">&#x27;vm.overcommit_memory = 1&#x27;</span> to /etc/sysctl.conf and <span class="keyword">then</span> reboot or run the <span class="built_in">command</span> <span class="string">&#x27;sysctl vm.overcommit_memory=1&#x27;</span> <span class="keyword">for</span> this to take effect.20335:M 18 Apr 2021 01:51:48.193 * Ready to accept connections</span><br></pre></td></tr></table></figure><h1 id="测试Redis">测试Redis</h1><p>新开连接窗口，启动客户端连接 <code>Redis</code> 服务器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang ~]# cd /usr/Redis/Redis-6.2.1/installpackage/bin</span><br><span class="line"># 启动客户端连接服务器并指定端口</span><br><span class="line">[root@wangpengliang bin]# ./Redis-cli -p  6379</span><br><span class="line"># 测试连接</span><br><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br><span class="line"># 退出Redis</span><br><span class="line">127.0.0.1:6379&gt; exit</span><br></pre></td></tr></table></figure><h1 id="后台启动Redis">后台启动Redis</h1><p>以上的 <code>Redis</code> 安装和启动可以算是临时服务。当开启服务后，Redis服务窗口是无法再使用的，可以将 <code>Redis</code> 服务设置为后台启动服务，避免 <code>Linux</code> 窗口连接的浪费。</p><ol><li>编辑 Redis 配置文件 <code>Redis.conf</code></li><li>开启 Redis 后台服务（默认是关闭的）</li></ol><p>Step1：<code>vi /usr/Redis/Redis6.x/bin/conf/Redis.conf</code>　打开编辑(键入命令 <code>:set nu</code>  显示行号)</p><p>Step2：输入<code>i</code>、<code>I</code>、<code>a</code> 等进入编辑模式</p><p>Step3：将<code>daemonize</code> no 改成<code>daemonize</code> yes（表示开启Redis后台服务：约225行）</p><p>Step4：按 <code>esc</code> 退出插入模式，输入<code>:wq</code> 保存退出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动Redis服务</span></span><br><span class="line">[root@wangpengliang bin]<span class="comment"># ./Redis-server conf/Redis.conf</span></span><br><span class="line"><span class="comment"># 此时Redis服务已经作为后台服务启动，不再占用窗口，直接在本窗口启用客户端测试连接</span></span><br><span class="line">[root@wangpengliang bin]<span class="comment"># ./Redis-cli -p 6379</span></span><br><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exit</span></span><br></pre></td></tr></table></figure><h1 id="查看Redis服务进程">查看Redis服务进程</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看进程服务，过滤只看Redis的</span></span><br><span class="line">[root@wangpengliang bin]<span class="comment"># ps -ef |grep Redis</span></span><br><span class="line">root      20395      1  0 02:07 ?      00:00:00 ./Redis-server 127.0.0.1:6379</span><br><span class="line">root      20410  20345  0 02:10 pts/1     00:00:00 grep --color=auto Redis</span><br></pre></td></tr></table></figure><h1 id="卸载">卸载</h1><p>删除 <code>Redis</code> 安装目录和 <code>Redis</code> 解压文件即可。</p><h1 id="Redis6379端口不通解决方法">Redis6379端口不通解决方法</h1><p><strong>背景</strong></p><ol><li><code>Redis  </code> 在虚拟机中安装</li><li>使用 <code>RedisClient</code>  在  <code>Windows</code>  主机中连接</li></ol><p>虚拟机中查看 Redis 进程和端口，都是存在的；但是IP地址需要设置为 <code>0.0.0.0</code> 而不是 <code>127.0.0.1</code> ，更改 Redis 使用的配置文件即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bind</span> 127.0.0.1</span><br><span class="line">=&gt;</span><br><span class="line"><span class="built_in">bind</span> 0.0.0.0</span><br></pre></td></tr></table></figure><p><code>127.0.0.1</code>只能是本机能使用，如果 Redis 已经启动，需要先停止才能使配置文件生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang bin]<span class="comment"># ./Redis-cli -p 6379</span></span><br><span class="line">127.0.0.1:6379&gt; SHUTDOWN</span><br><span class="line">not connected&gt;</span><br></pre></td></tr></table></figure><p>重启 Redis</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang bin]<span class="comment"># ./Redis-server conf/Redis.conf</span></span><br></pre></td></tr></table></figure><p>主机中使用 <code>RedisClient</code> 连接</p><p><img src="/images/2021-09-03-16-20-40.png" alt=""></p><p>本机安装的Redis版本为<code>6.x</code>，<code>RedisClient</code>暂不支持</p><p><img src="/images/2021-09-03-16-21-04.png" alt=""></p><p>这里可以使用控制台来测试，只是缺少了可视化的优势，需要自己敲命令</p><p><img src="/images/2021-09-03-16-21-25.png" alt=""></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/redis/1.4Redis%E7%89%B9%E6%AE%8A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/redis/1.4Redis%E7%89%B9%E6%AE%8A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>redis特殊数据类型</p><span id="more"></span><h1 id="Geospatial-地理位置">Geospatial 地理位置</h1><h1 id="Hyperloglog-基数统计">Hyperloglog 基数统计</h1><h1 id="Bitmap位图">Bitmap位图</h1><blockquote><p>TODO：知道有这个东西，需要用的时候看下文档即可，不做记录。</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/redis/1.5Redis%E4%BA%8B%E5%8A%A1%E6%93%8D%E4%BD%9C/"/>
      <url>/redis/1.5Redis%E4%BA%8B%E5%8A%A1%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="事务概念">事务概念</h1><p>一次执行多个命令，本质是一组命令的集合。一个事务中的所有命令都会序列化，<strong>按顺序的串行化执行</strong>而不会被其他命令插入，不许加塞。</p><span id="more"></span><h1 id="事务作用">事务作用</h1><p>一个队列中，一次性、顺序性、排他性的执行一系列命令。</p><h1 id="事务常用命令">事务常用命令</h1><h2 id="multi"><code>multi</code></h2><p>标记一个事务块的开始</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; get k1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span></span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">3) <span class="string">&quot;v1&quot;</span></span><br></pre></td></tr></table></figure><h2 id="discard"><code>discard</code></h2><p>取消事务，放弃执行事务块内的所有命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; discard</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><h2 id="exec-v2"><code>exec</code></h2><p>执行所有事务块内的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; get k1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span></span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">3) <span class="string">&quot;v1&quot;</span></span><br></pre></td></tr></table></figure><h1 id="事务原子性">事务原子性</h1><p>Redis单条命令是保证原子性的，但是<strong>Redis事务并不能保证原子性</strong>。所有的命令在事务中并不会立即执行，只会在执行事务的时候才会执行，所以<strong>Redis事务没有事务隔离级别的概念</strong>。</p><p><strong>编译时异常</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k3 v3</span><br><span class="line">QUEUED</span><br><span class="line"><span class="comment"># 随便写的，此时会报错误不存在这个命令；但是并没有说事务停止了</span></span><br><span class="line">127.0.0.1:6379(TX)&gt; helloworld</span><br><span class="line">(error) ERR unknown <span class="built_in">command</span> `helloworld`, with args beginning with: </span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k4 v4\</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span></span><br><span class="line">(error) EXECABORT Transaction discarded because of previous errors.</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><p>结果可知：事务中所有命令都不会被执行</p><p><strong>运行时异常</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k3 v3</span><br><span class="line">QUEUED</span><br><span class="line"><span class="comment"># k1值是字符串类型所以无法自增，但是并没有提示错误</span></span><br><span class="line">127.0.0.1:6379(TX)&gt; incr k1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span></span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">3) OK</span><br><span class="line">4) (error) ERR value is not an <span class="built_in">integer</span> or out of range</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line"><span class="string">&quot;v1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; get k2</span><br><span class="line"><span class="string">&quot;v2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; get k3</span><br><span class="line"><span class="string">&quot;v3&quot;</span></span><br></pre></td></tr></table></figure><p>结果可知：出错的命令不会被执行，正常的命令还是会被执行</p><p>基于编译时异常和运行时异常的区别，可以更好的理解为什么说：<strong>Redis单条命令是保证原子性的，但是Redis事务是不保证原子性的</strong>。</p><h1 id="Watch监控">Watch监控</h1><p><strong>乐观锁</strong>：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量。</p><p><strong>悲观锁</strong>：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会 <code>block</code> 直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</p><h2 id="单线程操作"><strong>单线程操作</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 余额</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> money 100</span><br><span class="line">OK</span><br><span class="line"><span class="comment"># 花出去的钱</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> out 0</span><br><span class="line">OK</span><br><span class="line"><span class="comment"># 监视money</span></span><br><span class="line">127.0.0.1:6379&gt; watch money</span><br><span class="line">OK</span><br><span class="line"><span class="comment"># 启动事务</span></span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line"><span class="comment"># 余额-20</span></span><br><span class="line">127.0.0.1:6379(TX)&gt; DECRby money 20</span><br><span class="line">QUEUED</span><br><span class="line"><span class="comment"># out+20</span></span><br><span class="line">127.0.0.1:6379(TX)&gt; INCRBY out 20</span><br><span class="line">QUEUED</span><br><span class="line"><span class="comment"># 执行事务</span></span><br><span class="line">127.0.0.1:6379(TX)&gt; EXEC</span><br><span class="line">1) (<span class="built_in">integer</span>) 80</span><br><span class="line">2) (<span class="built_in">integer</span>) 20</span><br></pre></td></tr></table></figure><p>结果正常</p><h2 id="多线程操作"><strong>多线程操作</strong></h2><p>客户端1</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 余额</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> money 100</span><br><span class="line">OK</span><br><span class="line"><span class="comment"># 花出去的钱</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> out 0</span><br><span class="line">OK</span><br><span class="line"><span class="comment"># 监视money</span></span><br><span class="line">127.0.0.1:6379&gt; watch money</span><br><span class="line">OK</span><br><span class="line"><span class="comment"># 启动事务</span></span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line"><span class="comment"># 余额-20</span></span><br><span class="line">127.0.0.1:6379(TX)&gt; DECRby money 20</span><br><span class="line">QUEUED</span><br><span class="line"><span class="comment"># out+20</span></span><br><span class="line">127.0.0.1:6379(TX)&gt; INCRBY out 20</span><br><span class="line">QUEUED</span><br></pre></td></tr></table></figure><blockquote><p>注意：这个时候并没有执行事务</p></blockquote><p>客户端2</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; WATCH money</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; incrby money 100</span><br><span class="line">(<span class="built_in">integer</span>) 200</span><br></pre></td></tr></table></figure><p>回到客户端1</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span></span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><p>结果可知：使用<code>watch</code>可以实现乐观锁的功能</p><h1 id="UnWatch">UnWatch</h1><p>接着上面的 watch 讲解，先解锁再获取最新的值进行操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解锁</span></span><br><span class="line">127.0.0.1:6379&gt; unwatch</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; decrby money 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; INCRBY out 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span></span><br><span class="line">1) (<span class="built_in">integer</span>) 180</span><br><span class="line">2) (<span class="built_in">integer</span>) 20</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/redis/1.8Redis%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/"/>
      <url>/redis/1.8Redis%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/</url>
      
        <content type="html"><![CDATA[<blockquote><p>TODO：知道有这个东西，需要用的时候看下文档即可。</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/redis/1.7Redis%E6%8C%81%E4%B9%85%E5%8C%96/"/>
      <url>/redis/1.7Redis%E6%8C%81%E4%B9%85%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="Rdb">Rdb</h1><p>Rdb （Redis DataBase）是Redis用来进行持久化的一种方式，是把当前内存中的数据集快照写入磁盘，也就是 <code>Snapshot</code> 快照（数据库中所有键值对数据）。恢复时将快照文件直接读到内存里。</p><p>Rdb 是 Redis 默认的持久化方案。在指定的时间间隔内，执行指定次数的写操作，则会将内存中的数据写入到磁盘中。即在指定目录下生成一个 <code>dump.rdb</code> (默认名称)文件。<code>Redis</code> 重启会通过加载<code>dump.rdb</code>文件恢复数据。</p><span id="more"></span><h2 id="基本原理">基本原理</h2><p>Rdb 持久化主要是通过 <code>SAVE</code> 和 <code>BGSAVE</code> 两个命令对 <code>Redis</code> 数据库中当前的数据做 <code>snapshot</code> 并生成 <code>rdb</code> 文件来实现的。其中<code>SAVE</code> 是阻塞的，<code>BGSAVE</code> 是非阻塞的，通过 <code>fork</code> 了一个子进程来完成的。在 Redis启动时会检测 <code>rdb</code> 文件，然后载入 <code>rdb</code> 文件中未过期的数据到服务器中。</p><h2 id="触发方式">触发方式</h2><p>Rdb 有两种触发方式：自动触发/手动触发。</p><h3 id="自动触发"><strong>自动触发</strong></h3><p>在 redis.conf 配置文件中的 <code>SNAPSHOTTING</code> 下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># You can set these explicitly by uncommenting the three following lines.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># *快照持久化规则设置</span></span><br><span class="line"><span class="comment"># *如果3600秒内，至少一个Key进行了修改，就会进行持久化</span></span><br><span class="line"><span class="comment"># save 3600 1</span></span><br><span class="line"><span class="comment"># save 300 100</span></span><br><span class="line"><span class="comment"># save 60 10000</span></span><br><span class="line"><span class="comment"># 60s内至少一个Key进行了修改就会进行持久化</span></span><br><span class="line">save 60 1</span><br></pre></td></tr></table></figure><p><strong>相关配置</strong></p><p>指定本地数据库文件名，一般采用默认的 <code>dump.rdb</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dbfilename dump.rdb</span><br></pre></td></tr></table></figure><p>指定本地数据库存放目录，一般用默认配置即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir ./</span><br></pre></td></tr></table></figure><p>默认开启数据压缩</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rdbcompression yes</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang bin]<span class="comment"># ls</span></span><br><span class="line">conf      redis-benchmark  redis-check-rdb  redis-sentinel</span><br><span class="line">dump.rdb  redis-check-aof  redis-cli        redis-server</span><br><span class="line"><span class="comment"># 删除dump.rdb文件</span></span><br><span class="line">[root@wangpengliang bin]<span class="comment"># rm -f dump.rdb</span></span><br><span class="line">[root@wangpengliang bin]<span class="comment"># ls</span></span><br><span class="line">conf             redis-check-aof  redis-cli       redis-server</span><br><span class="line">redis-benchmark  redis-check-rdb  redis-sentinel</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang bin]<span class="comment"># ./redis-server conf/redis.conf</span></span><br><span class="line"><span class="comment"># 触发自动快照策略</span></span><br><span class="line">[root@wangpengliang bin]<span class="comment"># ./redis-cli -p 6379</span></span><br><span class="line">127.0.0.1:6379&gt; SET KEY A</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; SET KEY B</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; SET KEY C</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; SET KEY D</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dump.rdb又存在了</span></span><br><span class="line">[root@wangpengliang bin]<span class="comment"># ls</span></span><br><span class="line">conf      redis-benchmark  redis-check-rdb  redis-sentinel</span><br><span class="line">dump.rdb  redis-check-aof  redis-cli        redis-server</span><br></pre></td></tr></table></figure><h3 id="手动触发"><strong>手动触发</strong></h3><table><thead><tr><th>操作</th><th>描述</th></tr></thead><tbody><tr><td><code>save</code></td><td>该命令会阻塞当前<code>Redis</code> 服务器，执行 <code>save</code> 命令期间，<code>Redis</code> 不能处理其他命令，直到 <code>Rdb</code>  过程完成为止</td></tr><tr><td><code>bgsave</code></td><td>执行该命令时，<code>Redis</code> 会在后台异步进行快照操作，快照同时还可以响应客户端请求。具体操作是 <code>Redis</code> 进程执行 <code>fork</code> 操作创建子进程，Rdb 持久化过程由子进程负责，完成后自动结束。阻塞只发生在 <code>fork</code> 阶段，一般时间很短</td></tr><tr><td><code>flushall</code></td><td></td></tr><tr><td><code>shutdown</code></td><td></td></tr></tbody></table><h2 id="Rdb文件恢复数据">Rdb文件恢复数据</h2><p>将 <code>dump.rdb</code>  文件拷贝到 Redis 的安装目录的<code>bin</code> 目录下，重启 Redis 服务即可。在实际开发中，一般会考虑到物理机硬盘损坏情况，选择备份<code>dump.rdb</code> 。</p><h2 id="Rdb优缺点">Rdb优缺点</h2><table><thead><tr><th style="text-align:left"><strong>优点</strong></th><th style="text-align:left"><strong>缺点</strong></th></tr></thead><tbody><tr><td style="text-align:left">适合大规模的数据恢复</td><td style="text-align:left">数据的完整性和一致性不高，因为可能在最后一次备份时宕机了</td></tr><tr><td style="text-align:left">二进制压缩文件，恢复速度快</td><td style="text-align:left">备份时占用内存，因为Redis 在备份时会独立创建一个子进程，将数据写入到一个临时文件（此时内存中的数据是原来的两倍），最后再将临时文件替换之前的备份文件</td></tr><tr><td style="text-align:left">如果业务对数据完整性和一致性要求不高，Rdb是很好的选择</td><td style="text-align:left"></td></tr></tbody></table><p><strong>注意</strong>：假设 <code>save</code> 策略设置的是60秒，Redis在58秒宕机，会丢失最后一次的数据。</p><h1 id="Aof">Aof</h1><p>Redis 默认不开启。它的出现是为了弥补Rdb的不足（数据的不一致性），所以它采用日志的形式来记录每个<strong>写操作</strong>，并<strong>追加</strong>到文件中。Redis 重启的会根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p><h2 id="基本原理-v2">基本原理</h2><p>AOF（<code>Append Only File</code> ）持久化是通过将存储每次执行的客户端命令，然后由一个伪客户端来执行这些命令将数据写入到服务器中的方式实现的。一共分为命令追加（append）/文件写入/文件同步（sync）三个步骤完成。</p><p>在 redis.conf 配置文件中的<code>APPEND ONLY MODE</code>下</p><p>1 redis 默认关闭，开启需要手动把 <code>no</code> 改为 <code>yes</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes</span><br></pre></td></tr></table></figure><p>2 指定本地数据库文件名，默认值为 <code>appendonly.aof</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendfilename <span class="string">&quot;appendonly.aof&quot;</span></span><br></pre></td></tr></table></figure><p>3 指定更新日志条件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># appendfsync always</span></span><br><span class="line">appendfsync everysec</span><br><span class="line"><span class="comment"># appendfsync no</span></span><br></pre></td></tr></table></figure><p><code>always</code>：同步持久化，每次发生数据变化会立刻写入到磁盘中。性能较差但数据完整性比较好（慢，安全）</p><p><code>everysec</code>：出厂默认推荐，每秒异步记录一次（默认值）</p><p><code>no</code>：不同步</p><p>4 配置重写触发机制</p><p>当 <code>aof</code> 文件大小是上次 <code>rewrite</code> 后大小的一倍且文件大于 <code>64M</code> 时触发；Redis 会 <code>fork出一条新进程，读取内存中的数据，并重新写到一个临时文件中。并没有读取旧文件最后替换旧的aof文件</code>。这里的“一倍”和“64M” 可以通过配置文件修改。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br></pre></td></tr></table></figure><h2 id="触发方式-v2">触发方式</h2><p>根据 <code>redis.conf</code>  配置文件的配置内容触发。</p><h2 id="Aof文件恢复数据">Aof文件恢复数据</h2><p>正常情况下，将 <code>appendonly.aof</code> 文件拷贝到redis的安装目录的<code>bin</code> 目录下，重启redis服务即可。</p><h2 id="Aof文件修复">Aof文件修复</h2><p>在实际开发中，可能因为某些原因导致 <code>appendonly.aof</code> 文件格式异常，从而导致数据还原失败，可以通过命令 <code>redis-check-aof --fix appendonly.aof</code> 进行修复。</p><h2 id="Aof-优缺点">Aof 优缺点</h2><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>数据的完整性和一致性更高</td><td>因为AOF记录的内容多，文件会越来越大</td></tr><tr><td></td><td>因为文件较大数据恢复也会比较慢</td></tr></tbody></table><h1 id="总结-v2">总结</h1><p>Redis 默认开启rdb持久化方式。在指定的时间间隔内，执行指定次数的写操作，则将内存中的数据写入到磁盘中。</p><p>rdb持久化适合大规模的数据恢复但它的数据一致性和完整性较差。</p><p>Redis 需要手动开启 aof 持久化方式，默认是每秒将写操作日志追加到 aof 文件中。</p><p>aof 的数据完整性比 rdb 高，但记录内容多了，会影响数据恢复的效率。</p><p>Redis 针对 aof 文件大的问题，提供重写的瘦身机制。</p><p>若只打算用Redis 做缓存，可以关闭持久化。</p><p>若打算使用Redis 的持久化。建议rdb和aof都开启。其实rdb更适合做数据的备份，留一后手。aof 出问题了，还有 rdb。</p><p>当 rdb 和 aof 文件同时存在时，Redis会优先使用 aof 文件恢复。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/rabbitMq/%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9E%E6%8E%A5RabbitMQ/"/>
      <url>/rabbitMq/%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9E%E6%8E%A5RabbitMQ/</url>
      
        <content type="html"><![CDATA[<p>客户端连接RabbitMQ</p><span id="more"></span><h1 id="RabbitMQ-Client">RabbitMQ.Client</h1><p>基于 <code>RabbitMQ.Client</code> 的封装，在 <code>NuGet</code> 中搜索 <code>RabbitMQ.Client</code> ，直接点击按钮安装即可。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">CommonLib.RabbitMQ</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">global</span>::RabbitMQ.Client;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">global</span>::RabbitMQ.Client.Events;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> System;</span><br><span class="line">    <span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line">    <span class="keyword">using</span> System.Linq;</span><br><span class="line">    <span class="keyword">using</span> System.Text;</span><br><span class="line">    <span class="keyword">using</span> System.Threading;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">QueueOptions</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 是否持久化</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">bool</span> Durable &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 是否自动删除</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">bool</span> AutoDelete &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 参数</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">IDictionary</span>&lt;<span class="title">string</span>, <span class="title">object</span>&gt; Arguments</span> &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">object</span>&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ConsumeQueueOptions</span> : <span class="title">QueueOptions</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 是否自动提交</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">bool</span> AutoAck &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 每次接收消息条数</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">ushort</span>? FetchCount &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ExchangeConsumeQueueOptions</span> : <span class="title">ConsumeQueueOptions</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 路由值</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span>[] RoutingKeys &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 参数</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">IDictionary</span>&lt;<span class="title">string</span>, <span class="title">object</span>&gt; BindArguments</span> &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">object</span>&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ExchangeQueueOptions</span> : <span class="title">QueueOptions</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 交换机类型</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Type &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 队列及路由值</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">List</span>&lt;<span class="title">Tuple</span>&lt;<span class="title">string</span>, <span class="title">string</span>&gt;&gt; QueueAndRoutingKey</span> &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="keyword">new</span> List&lt;Tuple&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 参数</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">IDictionary</span>&lt;<span class="title">string</span>, <span class="title">object</span>&gt; BindArguments</span> &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">object</span>&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">RabbitMQExchangeType</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 普通模式</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">const</span> <span class="built_in">string</span> Common = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 路由模式</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">const</span> <span class="built_in">string</span> Direct = <span class="string">&quot;direct&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 发布/订阅模式</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">const</span> <span class="built_in">string</span> Fanout = <span class="string">&quot;fanout&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 匹配订阅模式</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">const</span> <span class="built_in">string</span> Topic = <span class="string">&quot;topic&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">RabbitBase</span> : <span class="title">IDisposable</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> List&lt;AmqpTcpEndpoint&gt; amqpList;</span><br><span class="line">        <span class="keyword">private</span> IConnection connection;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="title">RabbitBase</span>(<span class="params"><span class="keyword">params</span> <span class="built_in">string</span>[] hosts</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (hosts == <span class="literal">null</span> || hosts.Length == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">&quot;invalid hosts！&quot;</span>, <span class="keyword">nameof</span>(hosts));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            amqpList = <span class="keyword">new</span> List&lt;AmqpTcpEndpoint&gt;();</span><br><span class="line">            amqpList.AddRange(hosts.Select(host =&gt; <span class="keyword">new</span> AmqpTcpEndpoint(host, Port)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="title">RabbitBase</span>(<span class="params"><span class="keyword">params</span> (<span class="built_in">string</span>, <span class="built_in">int</span></span>)[] hostAndPorts)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (hostAndPorts == <span class="literal">null</span> || hostAndPorts.Length == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">&quot;invalid hosts！&quot;</span>, <span class="keyword">nameof</span>(hostAndPorts));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            amqpList = <span class="keyword">new</span> List&lt;AmqpTcpEndpoint&gt;();</span><br><span class="line">            amqpList.AddRange(hostAndPorts.Select(tuple =&gt; <span class="keyword">new</span> AmqpTcpEndpoint(tuple.Item1, tuple.Item2)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 端口</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Port &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="number">5672</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 账号</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> UserName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = ConnectionFactory.DefaultUser;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 密码</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Password &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = ConnectionFactory.DefaultPass;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 虚拟机</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> VirtualHost &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = ConnectionFactory.DefaultVHost;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// connection?.Close();</span></span><br><span class="line">            <span class="comment">// connection?.Dispose();</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 关闭连接</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Close</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            connection?.Close();</span><br><span class="line">            connection?.Dispose();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 获取rabbitmq的连接</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> IModel <span class="title">GetChannel</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (connection == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">lock</span> (<span class="keyword">this</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (connection == <span class="literal">null</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        ConnectionFactory factory = <span class="keyword">new</span>()</span><br><span class="line">                        &#123;</span><br><span class="line">                            Port = Port,</span><br><span class="line">                            UserName = UserName,</span><br><span class="line">                            VirtualHost = VirtualHost,</span><br><span class="line">                            Password = Password</span><br><span class="line">                        &#125;;</span><br><span class="line">                        <span class="comment">// 网络故障自动恢复连接</span></span><br><span class="line">                        factory.AutomaticRecoveryEnabled = <span class="literal">true</span>;</span><br><span class="line">                        <span class="comment">// 心跳处理</span></span><br><span class="line">                        factory.RequestedHeartbeat = <span class="keyword">new</span> TimeSpan(<span class="number">5000</span>);</span><br><span class="line">                        connection = factory.CreateConnection(amqpList);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> connection.CreateModel();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RabbitMQHelper</span> : <span class="title">RabbitBase</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">RabbitMQHelper</span>(<span class="params"><span class="keyword">params</span> <span class="built_in">string</span>[] hosts</span>) : <span class="title">base</span>(<span class="params">hosts</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">RabbitMQHelper</span>(<span class="params"><span class="keyword">params</span> (<span class="built_in">string</span>, <span class="built_in">int</span></span>)[] hostAndPorts) : <span class="title">base</span>(<span class="params">hostAndPorts</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 简单队列消息发布</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;queue&quot;&gt;</span>The queue.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;message&quot;&gt;</span>The message.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;options&quot;&gt;</span>The options.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Publish</span>(<span class="params"><span class="built_in">string</span> queue, <span class="built_in">string</span> message, QueueOptions options = <span class="literal">null</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            options ??= <span class="keyword">new</span> QueueOptions();</span><br><span class="line">            IModel channel = GetChannel();</span><br><span class="line">            channel.QueueDeclare(queue, options.Durable, <span class="literal">false</span>, options.AutoDelete, options.Arguments ?? <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">object</span>&gt;());</span><br><span class="line">            <span class="built_in">byte</span>[] buffer = Encoding.UTF8.GetBytes(message);</span><br><span class="line">            channel.BasicPublish(exchange: <span class="string">&quot;&quot;</span>, routingKey: queue, basicProperties: <span class="literal">null</span>, body: buffer);</span><br><span class="line">            channel.Close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 订阅模式/路由模式/Topic模式</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;exchange&quot;&gt;</span>The exchange.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;routingKey&quot;&gt;</span>The routing key.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;message&quot;&gt;</span>The message.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;options&quot;&gt;</span>The options.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Publish</span>(<span class="params"><span class="built_in">string</span> exchange, <span class="built_in">string</span> routingKey, <span class="built_in">string</span> message, ExchangeQueueOptions options = <span class="literal">null</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            options ??= <span class="keyword">new</span> ExchangeQueueOptions();</span><br><span class="line">            IModel channel = GetChannel();</span><br><span class="line"></span><br><span class="line">            channel.ExchangeDeclare(exchange,</span><br><span class="line">                <span class="built_in">string</span>.IsNullOrEmpty(options.Type) ? RabbitMQExchangeType.Fanout : options.Type,</span><br><span class="line">                options.Durable,</span><br><span class="line">                options.AutoDelete,</span><br><span class="line">                options.Arguments ?? <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">object</span>&gt;());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (options.QueueAndRoutingKey.Count &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> options.QueueAndRoutingKey)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!<span class="built_in">string</span>.IsNullOrEmpty(item.Item1))</span><br><span class="line">                    &#123;</span><br><span class="line">                        channel.QueueDeclare(item.Item1, options.Durable, <span class="literal">false</span>, options.AutoDelete, options.Arguments);</span><br><span class="line"></span><br><span class="line">                        channel.QueueBind(item.Item1,</span><br><span class="line">                            exchange,</span><br><span class="line">                            item.Item2 ?? <span class="string">&quot;&quot;</span>,</span><br><span class="line">                            options.BindArguments ?? <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">object</span>&gt;());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">byte</span>[] buffer = Encoding.UTF8.GetBytes(message);</span><br><span class="line">            channel.BasicPublish(exchange, routingKey, <span class="literal">null</span>, buffer);</span><br><span class="line">            channel.Close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">event</span> Action&lt;RecieveResult&gt; Received;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 构造消费者</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;channel&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;options&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> IBasicConsumer <span class="title">ConsumeInternal</span>(<span class="params">IModel channel, ConsumeQueueOptions options</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            EventingBasicConsumer consumer = <span class="keyword">new</span>(channel);</span><br><span class="line">            consumer.Received += (sender, e) =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    CancellationTokenSource cancellationTokenSource = <span class="keyword">new</span>();</span><br><span class="line">                    <span class="keyword">if</span> (!options.AutoAck)</span><br><span class="line">                    &#123;</span><br><span class="line">                        cancellationTokenSource.Token.Register(() =&gt;</span><br><span class="line">                        &#123;</span><br><span class="line">                            channel.BasicAck(e.DeliveryTag, <span class="literal">false</span>);</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    Received?.Invoke(<span class="keyword">new</span> RecieveResult(e, cancellationTokenSource));</span><br><span class="line">                &#125;</span><br><span class="line">                catch &#123; &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">if</span> (options.FetchCount != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                channel.BasicQos(<span class="number">0</span>, options.FetchCount.Value, <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> consumer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 消息监听</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;queue&quot;&gt;</span>The queue.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;options&quot;&gt;</span>The options.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ListenResult <span class="title">Listen</span>(<span class="params"><span class="built_in">string</span> queue, ConsumeQueueOptions options = <span class="literal">null</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            options ??= <span class="keyword">new</span> ConsumeQueueOptions();</span><br><span class="line">            IModel channel = GetChannel();</span><br><span class="line">            channel.QueueDeclare(queue, options.Durable, <span class="literal">false</span>, options.AutoDelete, options.Arguments ?? <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">object</span>&gt;());</span><br><span class="line">            IBasicConsumer consumer = ConsumeInternal(channel, options);</span><br><span class="line">            channel.BasicConsume(queue, options.AutoAck, consumer);</span><br><span class="line">            ListenResult result = <span class="keyword">new</span>();</span><br><span class="line">            result.Token.Register(() =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    channel.Close();</span><br><span class="line">                    channel.Dispose();</span><br><span class="line">                &#125;</span><br><span class="line">                catch &#123; &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 消费消息</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;exchange&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;queue&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;options&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ListenResult <span class="title">Listen</span>(<span class="params"><span class="built_in">string</span> exchange, <span class="built_in">string</span> queue, ExchangeConsumeQueueOptions options = <span class="literal">null</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            options ??= <span class="keyword">new</span> ExchangeConsumeQueueOptions();</span><br><span class="line">            IModel channel = GetChannel();</span><br><span class="line">            channel.QueueDeclare(queue, options.Durable, <span class="literal">false</span>, options.AutoDelete, options.Arguments ?? <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">object</span>&gt;());</span><br><span class="line">            <span class="keyword">if</span> (options.RoutingKeys != <span class="literal">null</span> &amp;&amp; !<span class="built_in">string</span>.IsNullOrEmpty(exchange))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">foreach</span> (<span class="built_in">string</span> key <span class="keyword">in</span> options.RoutingKeys)</span><br><span class="line">                &#123;</span><br><span class="line">                    channel.QueueBind(queue, exchange, key, options.BindArguments);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            IBasicConsumer consumer = ConsumeInternal(channel, options);</span><br><span class="line">            channel.BasicConsume(queue, options.AutoAck, consumer);</span><br><span class="line">            ListenResult result = <span class="keyword">new</span>();</span><br><span class="line">            result.Token.Register(() =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    channel.Close();</span><br><span class="line">                    channel.Dispose();</span><br><span class="line">                &#125;</span><br><span class="line">                catch &#123; &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RecieveResult</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">private</span> CancellationTokenSource cancellationTokenSource;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">RecieveResult</span>(<span class="params">BasicDeliverEventArgs arg, CancellationTokenSource cancellationTokenSource</span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                Body = Encoding.UTF8.GetString(arg.Body.ToArray());</span><br><span class="line">                ConsumerTag = arg.ConsumerTag;</span><br><span class="line">                DeliveryTag = arg.DeliveryTag;</span><br><span class="line">                Exchange = arg.Exchange;</span><br><span class="line">                Redelivered = arg.Redelivered;</span><br><span class="line">                RoutingKey = arg.RoutingKey;</span><br><span class="line">                <span class="keyword">this</span>.cancellationTokenSource = cancellationTokenSource;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">            <span class="comment"><span class="doctag">///</span> 消息体</span></span><br><span class="line">            <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">            <span class="keyword">public</span> <span class="built_in">string</span> Body &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">            <span class="comment"><span class="doctag">///</span> 消费者标签</span></span><br><span class="line">            <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">            <span class="keyword">public</span> <span class="built_in">string</span> ConsumerTag &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">            <span class="comment"><span class="doctag">///</span> Ack标签</span></span><br><span class="line">            <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">            <span class="keyword">public</span> <span class="built_in">ulong</span> DeliveryTag &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">            <span class="comment"><span class="doctag">///</span> 交换机</span></span><br><span class="line">            <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">            <span class="keyword">public</span> <span class="built_in">string</span> Exchange &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">            <span class="comment"><span class="doctag">///</span> 是否Ack</span></span><br><span class="line">            <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">            <span class="keyword">public</span> <span class="built_in">bool</span> Redelivered &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">            <span class="comment"><span class="doctag">///</span> 路由</span></span><br><span class="line">            <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">            <span class="keyword">public</span> <span class="built_in">string</span> RoutingKey &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Commit</span>(<span class="params"></span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (cancellationTokenSource == <span class="literal">null</span> || cancellationTokenSource.IsCancellationRequested) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">                cancellationTokenSource.Cancel();</span><br><span class="line">                cancellationTokenSource.Dispose();</span><br><span class="line">                cancellationTokenSource = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ListenResult</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">readonly</span> CancellationTokenSource cancellationTokenSource;</span><br><span class="line"></span><br><span class="line">            <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">            <span class="comment"><span class="doctag">///</span> CancellationToken</span></span><br><span class="line">            <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">            <span class="keyword">public</span> CancellationToken Token &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> cancellationTokenSource.Token; &#125; &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">            <span class="comment"><span class="doctag">///</span> 是否已停止</span></span><br><span class="line">            <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">            <span class="keyword">public</span> <span class="built_in">bool</span> Stoped &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> cancellationTokenSource.IsCancellationRequested; &#125; &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">ListenResult</span>(<span class="params"></span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                cancellationTokenSource = <span class="keyword">new</span> CancellationTokenSource();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">            <span class="comment"><span class="doctag">///</span> 停止监听</span></span><br><span class="line">            <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Stop</span>(<span class="params"></span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                cancellationTokenSource.Cancel();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="EasyNetQ">EasyNetQ</h1><h2 id="简介-v2">简介</h2><p>EasyNetQ 是基于官方.NET组件 RabbitMQ.Client 的又一层封装，使用起来更加方便，不用关心具体队列声明，路由声明等细节。EasyNetQ目的是提供一个尽可能简洁适用于RabbitMQ的.NET类库。为了实现这些目标，EasyNetQ强制使用了一些简单的约定。包括如下:</p><ul><li>消息用 .NET 类型 表示</li><li>消息通过 .NET类型 路由</li></ul><p>这意味着消息必须用 .NET class定义。每一个不同的消息类型必须用一个 class 表示。这个类必须是 public 并带有一个默认构造函数和可以读写的属性。这个类不需要实现任何功能。仅仅做一个简单的数据容器，下面是一个简单的消息：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyMessage</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">string</span> Content &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>EasyNetQ通过消息的类型来路由。当发布一个消息，EasyNetQ会检查消息类型， 然后给它一个 基于类型名称、命名空间和程序集的路由键。默认EasyNetQ使用 Newtonsoft.Json 序列化 .NET类型 为 JSON ，这样好处是消息可读性好。</p><blockquote><p><strong>引用</strong>：EasyNetQ是一个在RabbitMQ.Client类库之上提供服务的组件集合。做了这些事情，像序列化、错误处理、线程管理、连接管理等。通过一个Mini-Ioc容器组织在一起。你能很容易用你自己实现去替换这些组件。所以如果你喜欢用XML 序列化而不是用JSON，仅仅需要以一个ISerializer的实现，然后注册到这个容器中。</p><p>这些组件最上层是IAdvancedBus API。这看起来很像AMQP规格。实际也是你能够通过这个API运行很多AMQP方法。这个API对你隐藏了唯一AMQP概念是channels。这是因为channels 是一个复杂的底层概念，不应该被放到AMQP部分规格的第一的位置。 坦白来说，这个API中 ‘Advanced’不是一个非常好的名字。用‘lamqp’可能更好些。</p><p>这个顶层高级API是一系列消息模式：Publish/Subscribe, Request/Response,和 Send/Receive. 这是EasyNetQ坚持的设计思想。这些模式是我们应该实现的。这样有非常小的弹性。要么你接受我的处理方法，或者你就不要去使用。这样做的目的是，不用你和使用者花费精力去重新发明轮子。你不需要每一次去做选择，你只需要简单的去Publish和Subscribe消息。这样设计是未来实现EasyNetQ的核心目标，即尽可能简单的使用RabbitMQ。</p><p>这些模式的后面是这个 IBus API. 再一次看到这个一个简单的名字，它跟消息总线概念有关。IPackagedMessagePatterns可能是一个更好名字。</p><p>80%的用户的工作，在80%的时间都会使用IBus。它不是完备的API，如果这个模式下，你想实现的功能这个IBus没有提供，那么你应该使用IAdvancedBus。这样使用没有问题，EasyNetQ就这这样设计使用的。</p></blockquote><h2 id="优势">优势</h2><p>C#中已经提供了RabbitMQ.Client， RabbitMQ. Client 实现了AMQP协议的客户端（RabbitMQ实现了服务器端）。 AMQP是为HTTP协议设计的。它的设计是跨平台的和与语言无关的。它也旨在灵活支持多种基于交换/绑定/队列模型的消息传递模式。</p><p>RabiitMQ Client 非常地灵活，但是伴随着灵活性而来是复杂性。这意味着需要写大量代码。比如：</p><ul><li>实现消息传递模式，例如 <code>Publish/Subscribe</code>或 <code>Request/Response</code></li><li>实现路由策略。需要设计如何绑定 Exchange/Queue 。并且需要设计怎样在生产者和消费者之间进行消息路由</li><li>实现消息的序列化/反序列化。 如何转换AMQP的二进制消息为编程语言能理解的格式</li><li>为订阅去实现一个消费者线程。将需要有一个专门的消费者循环等待订阅的消息。如何处理多个订阅者，或者瞬间订阅者</li><li>实现消费者重新连接。假如连接崩溃了或者RabbitMQ 服务挂了，怎样能检测到并确保所有的订阅都能被重建</li><li>懂得和实施服务质量设置。需要什么样的设置来确保一个可靠的客户端</li><li>实现一个错误处理策略。假如接受到一个错误的消息，或者发生一个未处理异常被抛出，客户端应该做什么</li><li>实现发布者可靠的消息确认。</li></ul><p>EasyNetQ目标是在AMQP之上封装所有这些关注点在一个简单好用的类库中。</p><h2 id="安装-v3">安装</h2><p>在 <code>NuGet</code> 中搜索 <code>EasyNetQ</code> 直接点击按钮安装即可。EasyNetQ 依赖 RabbitMQ.Client，所以会同时安装两个dll。</p><h2 id="连接">连接</h2><p>使用 EasyNetQ 连接 RabbitMQ，是在应用程序启动时创建一个 <code>IBus</code> 对象，并且在应用程序关闭时释放该对象。<code>RabbitMQ</code> 连接是基于 <code>IBus</code> 接口的，当<code>IBus</code> 中的方法被调用，连接才会开启。创建一个 <code>IBus</code> 对象的方法如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bus = RabbitHutch.CreateBus(“host=myServer;virtualHost=myVirtualHost;username=mike;password=topsecret”);</span><br></pre></td></tr></table></figure><p>连接字符串基于 <code>Key/Value</code> 形式，每个Key中间用分号 <code>;</code> 断开。其中 <code>host</code> 是必须的，其他值采用默认配置。连接中可能用到的 <code>Key</code> 如下：</p><ul><li><code>host</code>：<code>host=localhost</code> 或 <code>host =192.168.1.102</code> 或者 <code>host=my.rabbitmq.com</code> ,集群配置的话可以用逗号将服务地址隔开，例如：<code>host=a.com,b.com,c.com</code></li><li><code>virtualHost</code>：虚拟主机，默认 <code>/</code></li><li><code>username</code>：登录名</li><li><code>password</code>：登录密码</li><li><code>requestedHeartbeat</code>：心跳设置，默认10秒</li><li><code>prefetchcount</code>：默认是50</li><li><code>pubisherConfirms</code>：默认 <code>false</code></li><li><code>persistentMessages</code>：消息持久化，默认 <code>true</code></li><li><code>product</code>：产品名</li><li><code>platform</code>：平台</li><li><code>timeout</code>：默认10秒</li></ul><p>关闭连接，使用 <code>bus.Dispose();</code></p><h2 id="日志">日志</h2><p>EasyNetQ 提供了日志接口 <code> IEasyNetQLogger</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IEasyNetQLogger</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">DebugWrite</span>(<span class="params"><span class="built_in">string</span> format, <span class="keyword">params</span> <span class="built_in">object</span>[] args</span>)</span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">InfoWrite</span>(<span class="params"><span class="built_in">string</span> format, <span class="keyword">params</span> <span class="built_in">object</span>[] args</span>)</span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">ErrorWrite</span>(<span class="params"><span class="built_in">string</span> format, <span class="keyword">params</span> <span class="built_in">object</span>[] args</span>)</span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">ErrorWrite</span>(<span class="params">Exception exception</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部默认用的是 <code>NullLogger</code>，即什么也不做，不记录日志。在测试的时候也可以用 <code>ConsoleLogger</code> 来显示运行中的各种信息。不过一般在正式使用环境中，可以自定义日志并实现 <code>IEasyNetQLogger</code>接口。然后在 <code>RabbitHutch.CreateBus</code> 的重载方法中注册想用的日志类型。（日志中会记录连接RabbitMQ的过程和队列创建细节等信息）代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> logger = <span class="keyword">new</span> MyLogger() <span class="comment">// 继承自 IEasyNetQLogger</span></span><br><span class="line"><span class="keyword">var</span> bus = RabbitHutch.CreateBus(“my connection”, x =&gt; x.Register&lt;IEasyNetQLogger&gt;(_ =&gt; logger));</span><br></pre></td></tr></table></figure><h2 id="发布-订阅">发布/订阅</h2><p>EasyNetQ 支持最简单的消息模式是：发布/订阅。发布消息后任意消费者都可以订阅该消息，并且不需要额外配置。首先：需要先创建一个 <code>IBus</code> 对象，然后创建一个<strong>可序列化的 <code>.NET</code>对象</strong>。调用 <code>Publish</code>方法即可。</p><p><strong>Pub</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">services.AddSingleton(RabbitHutch.CreateBus(redisConnection));</span><br><span class="line">IServiceProvider provider = services.BuildServiceProvider();</span><br><span class="line">mq = provider.GetService&lt;IBus&gt;();</span><br><span class="line">mq.PubSub.Publish(<span class="keyword">new</span> &#123; message = <span class="string">&quot;hello.world&quot;</span> &#125;);</span><br></pre></td></tr></table></figure><blockquote><p>注意：Publish只顾发送消息到队列，但是不管有没有消费端订阅，所以，发布之后，如果没有消费者，该消息将不会被消费甚至丢失。</p></blockquote><p><strong>Sub</strong></p><p>一个EasyNetQ订阅者订阅一种消息类型（<a href="http://xn--siqs75bnrjoro.NET">消息类为.NET</a> 类型）。通过调用Subcribe方法一旦对一个类型设置了订阅，一个持久化队列就会在RabbitMQ broker上被创建，这个类型的任何消息都会被发送到这个队列上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mq.PubSub.Subscribe&lt;MyMessage&gt;(&quot;&quot;, msg =&gt;</span><br><span class="line">&#123;</span><br><span class="line">      Console.WriteLine(msg.Content);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>subscription_id</strong></p><p><strong>相同类型消息、相同订阅id调用Subscribe</strong>：EasyNetQ将会在RabbitMQ Broker上为特定的消息类型的和订阅id的组合创建唯一的队列。每一次调用Subscribe方法会创建一个新的队列消费者。如果用相同的消息和订阅id调用Subscribe两次，将会创建两个消费者去消费同一个队列。然后RabbitMQ将会依次连续轮询消息给每一个消费者（均摊机制）。这种可伸缩性和工作分担是非常棒的。比如：一个处理消息的服务已经超负荷工作了。简单的创建一个新的服务实例（在同一个机器上，或者不同的机器上），不用配置任何东西，自动就得到了伸缩性。</p><p><strong>相同类型消息、不同订阅id调用Subscribe</strong>：假如相同的消息类型，用不同的订阅id调用了两次Subscribe，将创建两个队列，每一个队列有自己的消费者。每一个消息的副本将会路由到每一个队列，因此不同的消费者都将得到所有消息（这个类型的，Fanout）。适用于几个不同的服务都关心相同类型的消息。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/redis/1.10Redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
      <url>/redis/1.10Redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>redis常见问题记录</p><span id="more"></span><h2 id="什么是Redis？">什么是Redis？</h2><p>Redis(Remote Dictionary Server) 是一个使用 C 语言编写的，开源的（BSD许可）高性能非关系型（NoSQL）的键值对数据库。与传统数据库不同的是 Redis 数据存在内存中，所以读写速度非常快。</p><h2 id="Redis优缺点有哪些？">Redis优缺点有哪些？</h2><table><thead><tr><th><strong>优点</strong></th><th><strong>缺点</strong></th></tr></thead><tbody><tr><td>读写性能优异：读 <code>110000次/s</code>，写 <code>81000次/s</code></td><td>缓存和数据库双写一致性问题</td></tr><tr><td>支持数据持久化：支持<code>AOF</code>和<code>RDB</code>两种持久化方式</td><td>缓存雪崩问题</td></tr><tr><td>支持事务：Redis的所有操作都是原子性的，同时还支持对几个操作合并后的原子性执行</td><td>缓存击穿问题</td></tr><tr><td>支持多种数据结构：除了支持<code>String</code>类型外还支持<code>Hash</code>、<code>Set</code>、<code>Zset</code>、<code>List</code>等数据结构</td><td>缓存的并发竞争问题</td></tr><tr><td>支持主从复制：主机会自动将数据同步到从机，可以进行读写分离</td><td></td></tr></tbody></table><h2 id="为什么要用Redis">为什么要用Redis?</h2><p><strong>高性能</strong></p><p>假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在数缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可。</p><p><strong>高并发</strong></p><p>直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。</p><h2 id="Redis为什么快">Redis为什么快?</h2><p><strong>完全基于内存</strong>：绝大部分请求是纯粹的内存操作非常快速。数据存在内存中类似于 HashMap。查找和操作的时间复杂度都是<code>O(1)</code>。</p><p><strong>采用单线程</strong>：避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗。</p><p><strong>使用多路 I/O 复用模型，非阻塞 IO</strong>。</p><p>传统并发模型：每个 <code>I/O</code> 流(快递)都有一个新的线程管理。多路复用：只有单个线程，通过跟踪每个 <code>I/O</code> 流的状态来管理多个 <code>I/O</code> 流</p><h2 id="Redis有哪些数据类型">Redis有哪些数据类型?</h2><p>5种基本数据类型</p><ul><li>String</li><li>List</li><li>Set</li><li>Zset</li><li>Hash</li></ul><p>3种特殊数据类型</p><ul><li>Geospatial 地理位置</li><li>Hyperloglog 基数统计</li><li>Bitmap位图场景</li></ul><h2 id="Redis的应用场景有哪些？">Redis的应用场景有哪些？</h2><p><strong>计数器</strong></p><p>可以对 String 进行自增自减运算，从而实现计数器功能。Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。</p><p><strong>缓存</strong></p><p>将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。</p><p><strong>会话缓存</strong></p><p>可以使用 Redis 来统一存储多台应用服务器的会话信息。当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。</p><p><strong>消息队列</strong>(发布/订阅功能)</p><p><code>List</code> 是一个双向链表，可以通过 <code>lpush</code> 和 <code>rpop</code> 写入和读取消息实现消息队列(不过最好使用 Kafka、RabbitMQ 等消息中间件）。</p><p><strong>分布式锁实现</strong></p><p>在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。可以使用 Redis 自带的 <code>SETNX</code> 命令实现分布式锁，除此之外，还可以使用官方提供的 <code>RedLock</code> 分布式锁实现。</p><p><strong>其它</strong></p><p>Set 可以实现交集、并集等操作，从而实现共同好友等功能。ZSet 可以实现有序性操作，从而实现排行榜等功能。</p><h2 id="什么是Redis持久化？">什么是Redis持久化？</h2><p>持久化就是把内存的数据写到磁盘中去，防止服务宕机内存数据丢失。</p><h2 id="Redis-的持久化机制有哪些？">Redis 的持久化机制有哪些？</h2><p>Redis 提供两种持久化机制 <code>RDB</code>（默认） 和 <code>AOF</code> 机制</p><p><strong>RDB</strong>：是<code>Redis DataBase</code>缩写快照，Redis默认的持久化方式。按照一定的时间将内存的数据以快照的形式保存到硬盘中，对应产生的数据文件为<code>dump.rdb</code>。通过配置文件中的<code>save</code>参数来定义快照周期。</p><table><thead><tr><th><strong>优点</strong></th><th><strong>缺点</strong></th></tr></thead><tbody><tr><td>只有一个文件 <code>dump.rdb</code>，方便持久化</td><td>数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 Redis 发生故障，会发生数据丢失</td></tr><tr><td>容灾性好，一个文件可以保存到安全的磁盘</td><td></td></tr><tr><td>性能最大化，<code>fork</code> 子进程来完成写操作，让主进程继续处理命令，所以是<code>IO</code> 最大化。使用单独子进程来进行持久化，主进程不会进行任何 <code>IO</code> 操作，保证了 Redis 的高性能</td><td></td></tr><tr><td>数据集较大时时，比 <code>AOF</code> 的启动效率更高</td><td></td></tr></tbody></table><p><strong>AOF（Append-only file)</strong>： 是将Redis执行的每次写命令记录到单独的日志文件中，当重启Redis会重新将持久化的日志中文件恢复数据。</p><table><thead><tr><th><strong>优点</strong></th><th><strong>缺点</strong></th></tr></thead><tbody><tr><td>数据安全，AOF 持久化可以配置 <code>appendfsync</code> 属性，有 <code>always</code>，每进行一次 命令操作就记录到 <code>aof</code> 文件中一次</td><td>aof文件比 rdb文件大，且恢复速度慢</td></tr><tr><td>通过 <code>append</code> 模式写文件，即使中途服务器宕机，可以通过 <code>redis-check-aof</code> 工具解决数据一致性问题</td><td>数据集大的时候，比rdb启动效率低</td></tr><tr><td>AOF 机制的 <code>rewrite</code>模式。AOF 文件没被 rewrite 之前（文件过大时会对命令进行合并重写），可以删除其中的某些命令（比如误操作的 flushall）)</td><td></td></tr></tbody></table><p><strong>对比</strong></p><ul><li>aof文件比rdb更新频率高，优先使用aof还原数据</li><li>aof比rdb更安全也更大</li><li>rdb性能比aof好</li><li>如果两个都配了优先加载aof</li></ul><h2 id="如何选择合适的持久化方式">如何选择合适的持久化方式?</h2><p>一般来说， 如果想达到足以媲美PostgreSQL的数据安全性，应该同时使用两种持久化功能。在这种情况下，当 Redis 重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。</p><p>如果非常关心数据， 但仍然可以承受数分钟以内的数据丢失，那么可以只使用RDB持久化。如果只希望数据在服务器运行的时候存在，也可以不使用任何持久化方式。</p><h2 id="过期键的删除策略">过期键的删除策略?</h2><p>Redis是key-value数据库，可以设置Redis中缓存的key的过期时间。Redis的过期策略就是指当Redis中缓存的key过期了，Redis如何处理。</p><p><strong>过期策略通常有以下三种</strong></p><p><strong>定时过期</strong>：每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。</p><p><strong>惰性过期</strong>：只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。</p><p><strong>定期过期</strong>：每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。expires字典会保存所有设置了过期时间的key的过期时间数据，其中，key是指向键空间中的某个键的指针，value是该键的毫秒精度的UNIX时间戳表示的过期时间。键空间是指该Redis集群中保存的所有键。Redis中同时使用了<strong>惰性过期</strong>和<strong>定期过期</strong>两种过期策略。</p><p><strong>注意</strong>：除了缓存服务器自带的缓存失效策略之外（Redis默认的有6中策略可供选择），还可以根据具体的业务需求进行自定义的缓存淘汰策略</p><h2 id="Redis-key的过期时间和永久有效怎么设置？">Redis key的过期时间和永久有效怎么设置？</h2><p><code>EXPIRE</code>和<code>PERSIST</code>命令</p><h2 id="Redis的内存淘汰策略有哪些">Redis的内存淘汰策略有哪些?</h2><p>Redis内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略；Redis的内存淘汰策略是指在Redis的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据。</p><p><strong>全局的键空间选择性移除</strong></p><p><code>noeviction</code>：当内存不足以容纳新写入数据时，新写入操作会报错</p><p><code>allkeys-lru</code>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。（这个是最常用的）</p><p><code>allkeys-random</code>：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key</p><p><strong>设置过期时间的键空间选择性移除</strong></p><p><code>volatile-lru</code>：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key</p><p><code>volatile-random</code>：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key</p><p><code>volatile-ttl</code>：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除</p><p><strong>注意：</strong></p><p>Redis的内存淘汰策略的选取并不会影响过期的key的处理</p><p>内存淘汰策略用于处理内存不足时的需要申请额外空间的数据</p><p>过期策略用于处理过期的缓存数据</p><h2 id="Redis的内存用完了会发生什么？">Redis的内存用完了会发生什么？</h2><p>如果达到设置的上限，Redis的写命令会返回错误信息（但是读命令还可以正常返回）或者可以配置内存淘汰机制，当Redis达到内存上限时会冲刷掉旧的内容。</p><h2 id="Redis如何做内存优化？">Redis如何做内存优化？</h2><p>可以利用Hash,list,sorted set,set等集合类型数据，因为通常情况下很多小的Key-Value可以用更紧凑的方式存放到一起。尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以应该尽可能的将数据模型抽象到一个散列表里面。比如web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key，而应该把这个用户的所有信息存储到一张散列表里面。</p><h2 id="Redis线程模型？">Redis线程模型？</h2><p>Redis基于Reactor模式开发了网络事件处理器，这个处理器被称为文件事件处理器（file event handler）。它的组成结构为4部分：多个套接字、IO多路复用程序、文件事件分派器、事件处理器。因为文件事件分派器队列的消费是单线程的，所以Redis才叫单线程模型。</p><p><strong>参考</strong>：<a href="https://www.cnblogs.com/barrywxx/p/8570821.html">https://www.cnblogs.com/barrywxx/p/8570821.html</a></p><h2 id="什么是事务？">什么是事务？</h2><p>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p><p>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</p><h2 id="Redis事务的概念">Redis事务的概念?</h2><p>Redis 事务的本质是通过<code>MULTI</code>、<code>EXEC</code>、<code>WATCH</code>等一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。总结：Redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。</p><h2 id="Redis事务的三个阶段">Redis事务的三个阶段?</h2><p>1）事务开始  <code>MULTI</code></p><p>2）命令入队</p><p>3）事务执行 <code>EXEC</code></p><p>事务执行过程中，如果服务端收到有EXEC、DISCARD、WATCH、MULTI之外的请求将会把请求放入队列中排队。</p><h2 id="Redis事务相关命令">Redis事务相关命令?</h2><p>Redis事务功能是通过<code>MULTI</code>、<code>EXEC</code>、<code>DISCARD</code>和<code>WATCH</code> 四个原语实现的</p><p>Redis会将一个事务中的所有命令序列化，然后按顺序执行</p><p>Redis不支持回滚，<strong>Redis 在事务失败时不进行回滚，而是继续执行余下的命令</strong>， 所以 Redis 的内部可以保持简单且快速</p><p>如果在一个事务中的命令出现错误，那么所有的命令都不会执行</p><p>如果在一个事务中出现运行错误，那么正确的命令会被执行</p><p>WATCH<code>命令是一个乐观锁，可以为 Redis 事务提供</code>check-and-set<code>（CAS）行为。 可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到</code>EXEC`命令</p><p><code>MULTI</code>命令用于开启一个事务，它总是返回OK。 <code>MULTI</code>执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当<code>EXEC</code>命令被调用时，所有队列中的命令才会被执行</p><p><code>EXEC</code>：执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。 当操作被打断时，返回空值 <code>nil</code></p><p>通过调用<code>DISCARD</code>，客户端可以清空事务队列，并放弃执行事务， 并且客户端会从事务状态中退出</p><p><code>UNWATCH</code>命令可以取消<code>Watch</code>对所有<code>key</code>的监控</p><h2 id="事务管理（ACID）概述">事务管理（ACID）概述</h2><p><strong>原子性（Atomicity）</strong></p><p>原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生</p><p><strong>一致性（Consistency）</strong></p><p>事务前后数据的完整性必须保持一致</p><p><strong>隔离性（Isolation）</strong></p><p>多个事务并发执行时，一个事务的执行不应影响其他事务的执行</p><p><strong>持久性（Durability）</strong></p><p>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响</p><blockquote><p>Redis的事务总是具有ACID中的一致性和隔离性，其他特性是不支持的。当服务器运行在AOF持久化模式下，并且appendfsync选项的值为always时，事务也具有持久性</p></blockquote><h2 id="Redis事务支持隔离性吗？">Redis事务支持隔离性吗？</h2><p>Redis 是单进程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。因此Redis 的事务是总是带有隔离性的。</p><h2 id="Redis事务保证原子性吗，支持回滚吗？">Redis事务保证原子性吗，支持回滚吗？</h2><p>Redis中单条命令是原子性执行的，但事务不保证原子性且没有回滚。事务中任意命令执行失败，其余的命令仍会被执行。</p><h2 id="Redis事务其他实现？">Redis事务其他实现？</h2><ul><li>基于Lua脚本，Redis可以保证脚本内的命令一次性、按顺序地执行。其同时也不提供事务运行错误的回滚，执行过程中如果部分命令运行错误，剩下的命令还是会继续运行完</li><li>基于中间标记变量，通过另外的标记变量来标识事务是否执行完成，读取数据时先读取该标记变量判断是否事务执行完成。但这样会需要额外写代码实现，比较繁琐</li></ul><h2 id="Redis实现分布式锁">Redis实现分布式锁</h2><p>Redis为单进程单线程模式，采用队列模式将并发访问变成串行访问，且多客户端对Redis的连接并不存在竞争关系Redis中可以使用<code>SETNX</code>命令实现分布式锁。</p><p>当且仅当 key 不存在，将 key 的值设为 value。 若给定的 key 已经存在，则 SETNX 不做任何动作</p><p><code>SETNX</code> 是『SET if Not eXists』(如果不存在，则 SET)的简写</p><blockquote><p>返回值：设置成功返回 1 | 设置失败返回 0</p></blockquote><h2 id="如何解决Redis的并发竞争-Key-问题">如何解决Redis的并发竞争 Key 问题</h2><p>所谓 Redis 的并发竞争 Key 的问题也就是多个系统同时对一个 key 进行操作，但是最后执行的顺序和期望的顺序不同，也就导致了结果的不同</p><p><strong>方案一</strong>：分布式锁（zookeeper 和 redis 都可以实现分布式锁）。（如果不存在 Redis 的并发竞争 Key 问题，不要使用分布式锁，这样会影响性能）</p><p><strong>方案二</strong>：并发量过大的情况下,可以通过消息中间件进行处理,把Redis.Set操作放在队列中使其串行化必须依次执行</p><h2 id="什么是-RedLock">什么是 RedLock</h2><p>Redis 官方站提出了一种权威的基于 Redis 实现分布式锁的方式名叫 Redlock，此种方式比原先的单节点的方法更安全。它可以保证以下特性：</p><ul><li>安全特性：互斥访问，即永远只有一个 client 能拿到锁</li><li>避免死锁：最终 client 都可能拿到锁，不会出现死锁的情况，即使原本锁住某资源的 client crash 了或者出现了网络分区</li><li>容错性：只要大部分 Redis 节点存活就可以正常提供服务</li></ul><h2 id="缓存雪崩">缓存雪崩</h2><p>缓存雪崩是指缓存同一时间大面积的失效，所以后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p><p>使缓存集中失效的原因：</p><p>1、Redis服务器宕机</p><p>2、对缓存数据设置了相同的过期时间，导致某时间段内缓存集中失效</p><p><strong>解决方案</strong></p><p>1、针对原因1，可以实现Redis的高可用，Redis Cluster 或者 Redis Sentinel(哨兵) 等</p><p>2、针对原因2，设置缓存过期时间时加上一个随机值，避免缓存在同一时间过期</p><p>3、使用双缓存策略，设置两个缓存，原始缓存和备用缓存，原始缓存失效时，访问备用缓存，备用缓存失效时间设置长点</p><h2 id="缓存穿透">缓存穿透</h2><p>缓存穿透表示查询一个一定不存在的数据，由于没有获取到缓存，所以没写入缓存，导致这个不存在的数据每次都需要去数据库查询，失去了缓存的意义。请求的数据大量的没有获取到缓存，导致走数据库，有可能搞垮数据库，使整个服务瘫痪。</p><p><strong>解决方案</strong></p><p>1、接口层增加校验，如用户鉴权校验，<code>id</code>做基础校验，<code>id&lt;=0</code>的直接拦截</p><p>2、从缓存取不到的数据，在数据库中也没有取到，这时也可以将<code>key-value</code>写为<code>key-null</code>，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击</p><p>3、采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的<code>bitmap</code>中，一个一定不存在的数据会被这个 <code>bitmap</code> 拦截掉，从而避免对底层存储系统的查询压力</p><h2 id="缓存击穿">缓存击穿</h2><p>缓存击穿表示某个key的缓存非常热门，有很高的并发一直在访问，如果该缓存失效，请求会同时打到数据库，压垮数据库。</p><p><strong>缓存击穿与缓存雪崩的区别是</strong>：</p><p>1、缓存击穿针对的是某一热门key缓存</p><p>2、缓存雪崩针对的是大量缓存的集中失效</p><p><strong>解决方案</strong></p><p>1、设置热点数据永远不过期</p><p>2、加互斥锁</p><h2 id="缓存预热">缓存预热</h2><p>缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题，用户直接查询事先被预热的缓存数据。</p><p><strong>解决方案</strong></p><p>1、直接写个缓存刷新页面，上线时手工操作一下</p><p>2、数据量不大，可以在项目启动的时候自动进行加载</p><p>3、定时刷新缓存</p><h2 id="如何保证缓存与数据库双写时的数据一致性？">如何保证缓存与数据库双写时的数据一致性？</h2><p>TODO</p><h2 id="Redis回收进程如何工作的？">Redis回收进程如何工作的？</h2><ol><li>一个客户端运行了新的命令，添加了新的数据</li><li>Redis检查内存使用情况，如果大于maxmemory的限制， 则根据设定好的策略进行回收</li><li>一个新的命令被执行，等等</li><li>所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下</li></ol><h2 id="Redis回收使用的是什么算法？">Redis回收使用的是什么算法？</h2><p>LRU算法</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/redis/1.3Redis%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/redis/1.3Redis%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>Redis基本数据类型</p><span id="more"></span><h1 id="String字符串">String字符串</h1><p>Redis 字符串是字节序列。Redis 字符串是二进制安全的，意味着他们有一个已知的长度没有任何特殊字符终止，所以可以存储任何东西，<code>512M</code> 为上限，主要的还是操作键值对。String的数据结构是简单的 <code>Key-Value</code>模型，Value可以是字符串，也可以是数字。</p><h2 id="set-key-value"><code>set key value</code></h2><p>普通添加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379  <span class="built_in">set</span> name wangpengliang</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379  get name</span><br><span class="line"><span class="string">&quot;wangpengliang&quot;</span></span><br></pre></td></tr></table></figure><h2 id="setex-key-seconds-value"><code>setex key seconds value</code></h2><p>添加时设置过期时间</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379  setex name 30 wangpengliang</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379  get name</span><br><span class="line"><span class="string">&quot;wangpengliang&quot;</span></span><br></pre></td></tr></table></figure><h2 id="ttl"><code>ttl</code></h2><p>检查key还有多少秒过期</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379  setex  name 30 wangpengliang</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379  get name</span><br><span class="line"><span class="string">&quot;wangpengliang&quot;</span></span><br><span class="line"><span class="comment"># 查看距离过期时间还有多少秒</span></span><br><span class="line">127.0.0.1:6379 ttl name</span><br><span class="line">(<span class="built_in">integer</span>) 18</span><br><span class="line">127.0.0.1:6379 &gt;</span><br></pre></td></tr></table></figure><h2 id="setnx-key-value"><code>setnx key value</code></h2><p>如果key不存在，则创建一个key，如果key存在，则创建失败并返回0；<code>setnx</code> 在分布式锁中经常使用到</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置key=name value=wangpengliang</span></span><br><span class="line">127.0.0.1:6379 <span class="built_in">set</span> name wangpengliang</span><br><span class="line">OK</span><br><span class="line"><span class="comment"># 检查是否设置成功</span></span><br><span class="line">127.0.0.1:6379 get name</span><br><span class="line"><span class="string">&quot;wangpengliang&quot;</span></span><br><span class="line"><span class="comment"># 使用setnx设置key=name:因为已存在所以创建失败返回0</span></span><br><span class="line">127.0.0.1:6379 setnx name wangpengliang</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"><span class="comment"># 清空数据库</span></span><br><span class="line">127.0.0.1:6379 FLUSHDB</span><br><span class="line">OK</span><br><span class="line"><span class="comment"># 重新使用setnx设置key=name:返回1说明创建成功</span></span><br><span class="line">127.0.0.1:6379 setnx name wangpengliang</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># 检查是否设置成功</span></span><br><span class="line">127.0.0.1:6379 get name</span><br><span class="line"><span class="string">&quot;wangpengliang&quot;</span></span><br></pre></td></tr></table></figure><h2 id="get-key"><code>get key</code></h2><p>获取指定key的value</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379 <span class="built_in">set</span> name wangpengliang</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379 get name</span><br><span class="line"><span class="string">&quot;wangpengliang&quot;</span></span><br></pre></td></tr></table></figure><h2 id="mset-mget"><code>mset/mget</code></h2><p>用于同时设置/获取一个或多个键值对，批量操作。同时设置多个值，如果其中有一个存在，那么就都创建失败；要么一起成功，要么一起失败，这是一个<strong>原子性操作</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用mset同时设置多个k-v</span></span><br><span class="line">127.0.0.1:6379 mset name1 wangpengliang name2 lizimeng name3 shijiangtao</span><br><span class="line">OK</span><br><span class="line"><span class="comment"># 使用met同时读取多个k-v</span></span><br><span class="line">127.0.0.1:6379 mget name1 name2 name3</span><br><span class="line">1) <span class="string">&quot;wangpengliang&quot;</span></span><br><span class="line">2) <span class="string">&quot;lizimeng&quot;</span></span><br><span class="line">3) <span class="string">&quot;shijiangtao&quot;</span></span><br></pre></td></tr></table></figure><h2 id="incr"><code>incr</code></h2><p>让当前键值以 1 的数量递增，并返回递增后的值。相当于C#中的 <code>i++</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置key=num value=10</span></span><br><span class="line">127.0.0.1:6379 <span class="built_in">set</span> num 10</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379 get num</span><br><span class="line"><span class="string">&quot;10&quot;</span></span><br><span class="line"><span class="comment"># 设置key=num value=value+1</span></span><br><span class="line">127.0.0.1:6379 incr num</span><br><span class="line">(<span class="built_in">integer</span>) 11</span><br></pre></td></tr></table></figure><h2 id="incrby"><code>incrby</code></h2><p>可以指定参数一次增加的数值，并返回递增后的值。<strong>设置步长的方式递增</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置key=num value=10</span></span><br><span class="line">127.0.0.1:6379 <span class="built_in">set</span> num 10</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379 get num</span><br><span class="line"><span class="string">&quot;10&quot;</span></span><br><span class="line"><span class="comment"># 设置key=num value=value+2(2是步长)</span></span><br><span class="line">127.0.0.1:6379 incrby num 2</span><br><span class="line">(<span class="built_in">integer</span>) 12</span><br></pre></td></tr></table></figure><h2 id="decr"><code>decr</code></h2><p>让当前键值以 1 的数量递减，并返回递减后的值。相当于C#中的 <code>i--</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置key=num value=10</span></span><br><span class="line">127.0.0.1:6379 <span class="built_in">set</span> num 10</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379 get num</span><br><span class="line"><span class="string">&quot;10&quot;</span></span><br><span class="line"><span class="comment"># 设置key=num value=value-1</span></span><br><span class="line">127.0.0.1:6379 decr num</span><br><span class="line">(<span class="built_in">integer</span>) 9</span><br></pre></td></tr></table></figure><h2 id="decrby"><code>decrby</code></h2><p>可以指定参数一次减少的数值，并返回递减后的值。<strong>设置步长的方式递减</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置key=num value=10</span></span><br><span class="line"></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379 get num</span><br><span class="line"><span class="string">&quot;10&quot;</span></span><br><span class="line"><span class="comment"># 设置key=num value=value-2(2是步长)</span></span><br><span class="line">127.0.0.1:6379 incrby num 2</span><br><span class="line">(<span class="built_in">integer</span>) 8</span><br></pre></td></tr></table></figure><h2 id="append-v2"><code>append</code></h2><p>向键值的末尾追加 value。如果键不存在则将该键的值设置为 value。返回值是追加后字符串的总长度</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379 append name wang</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379 get name</span><br><span class="line"><span class="string">&quot;wang&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379 <span class="built_in">set</span> name wang</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379 get name</span><br><span class="line"><span class="string">&quot;wang&quot;</span></span><br><span class="line">127.0.0.1:6379 append name pengliang</span><br><span class="line">(<span class="built_in">integer</span>) 13</span><br><span class="line">127.0.0.1:6379 get name</span><br><span class="line"><span class="string">&quot;wangpengliang&quot;</span></span><br></pre></td></tr></table></figure><h2 id="strlen"><code>strlen</code></h2><p>获取字符串长度</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379 <span class="built_in">set</span> name wangpengliang</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379 strlen name</span><br><span class="line">(<span class="built_in">integer</span>) 13</span><br></pre></td></tr></table></figure><h2 id="getrange"><code>getrange</code></h2><p>截取指定索引的字符串，相当于 <code>Substring</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379 <span class="built_in">set</span> name wangpengliang</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379 get name</span><br><span class="line"><span class="string">&quot;wangpengliang&quot;</span></span><br><span class="line">127.0.0.1:6379 getrange name 0 3</span><br><span class="line"><span class="string">&quot;wang&quot;</span></span><br></pre></td></tr></table></figure><h2 id="setrange"><code>setrange</code></h2><p>从指定索引开始替换字符串</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379 <span class="built_in">set</span> name hello</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379 get name</span><br><span class="line"><span class="string">&quot;hello&quot;</span></span><br><span class="line">127.0.0.1:6379 setrange name 0 world</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379 get name</span><br><span class="line"><span class="string">&quot;world&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379 <span class="built_in">set</span> name <span class="string">&quot;hello java&quot;</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379 get name</span><br><span class="line"><span class="string">&quot;hello java&quot;</span></span><br><span class="line">127.0.0.1:6379 setrange name 6 <span class="string">&quot;csharp&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 12</span><br><span class="line">127.0.0.1:6379 get name</span><br><span class="line"><span class="string">&quot;hello csharp&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379 <span class="built_in">set</span> name <span class="string">&quot;hello csharp&quot;</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379 get name</span><br><span class="line"><span class="string">&quot;hello csharp&quot;</span></span><br><span class="line">127.0.0.1:6379 setrange name 6 <span class="string">&quot;java&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 12</span><br><span class="line">127.0.0.1:6379 get name</span><br><span class="line"><span class="string">&quot;hello javarp&quot;</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：命令会确保字符串足够长以便将 <code>value</code> 设置在指定的偏移量上，如果给定 <code>key</code> 原来储存的字符串长度比偏移量小。<strong>比如</strong>：字符串只有 <code>5</code> 个字符长，但你设置的 <code>offset</code> 是 <code>10</code> ，那么原字符和偏移量之间的空白将用零字节(zerobytes, <code>&quot;\x00&quot;</code> )来填充。</p><h2 id="del"><strong>del</strong></h2><p>根据key删除一个或者多个元素</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379 <span class="built_in">set</span> name wangpengliang</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379 get name</span><br><span class="line"><span class="string">&quot;wangpengliang&quot;</span></span><br><span class="line">127.0.0.1:6379 del name</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 get name</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379 mset k1 wangpengliang k2 lizimeng</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379 mget k1 k2</span><br><span class="line">1) <span class="string">&quot;wangpengliang&quot;</span></span><br><span class="line">2) <span class="string">&quot;lizimeng&quot;</span></span><br><span class="line">127.0.0.1:6379 del k1 k2</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379 mget k1 k2</span><br><span class="line">1) (nil)</span><br><span class="line">2) (nil)</span><br></pre></td></tr></table></figure><h2 id="对象方式设置">对象方式设置</h2><p>设置一个user:1对象，值为Json字符串来保存一个对象；<code>set user:1 &#123;name:zhangsan,age:3&#125;</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置key=num value=10</span></span><br><span class="line">127.0.0.1:6379 <span class="built_in">set</span> num 10</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379 get num</span><br><span class="line"><span class="string">&quot;10&quot;</span></span><br><span class="line"><span class="comment"># 设置key=num value=value-1</span></span><br><span class="line">127.0.0.1:6379 decr num</span><br><span class="line">(<span class="built_in">integer</span>) 9</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379 mset user:1:name wangpengliang user:1:age 25</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379 mget user:1:name user:1:age</span><br><span class="line">1) <span class="string">&quot;wangpengliang&quot;</span></span><br><span class="line">2) <span class="string">&quot;25&quot;</span></span><br></pre></td></tr></table></figure><h2 id="getset"><code>getset</code></h2><p>先 <code>get</code> 然后再 <code>set</code><br>如果设置的键不存在值 =&gt; 则设置值，并且返回 <code>nil</code><br>如果设置的键存在值，则返回该值，并设置新的值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379 getset name wangpengliang</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379 get name</span><br><span class="line"><span class="string">&quot;wangpengliang&quot;</span></span><br><span class="line">127.0.0.1:6379 getset name lizimeng</span><br><span class="line"><span class="string">&quot;wangpengliang&quot;</span></span><br><span class="line">127.0.0.1:63</span><br></pre></td></tr></table></figure><h2 id="应用场景">应用场景</h2><ul><li>计数器—点赞,视频播放量,每播放一次就+1</li><li>统计多单位的数量</li><li>粉丝数</li><li>对象缓存存储</li></ul><h1 id="Hash散列表">Hash散列表</h1><p><img src="/images/2021-09-03-16-29-45.png" alt=""></p><p>Redis 的哈希是键值对的集合。Redis 的哈希值是字符串字段和字符串值之间的映射，因此它们被用来表示对象，还有用户信息之类的，经常变动的信息。</p><h2 id="hset"><code>hset</code></h2><p>存储一个哈希键值对的集合。格式：<code>hset key field value</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379 hset user name wangpengliang age 25</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379 hget user name</span><br><span class="line"><span class="string">&quot;wangpengliang&quot;</span></span><br><span class="line">127.0.0.1:6379 hget user age</span><br><span class="line"><span class="string">&quot;25&quot;</span></span><br></pre></td></tr></table></figure><h2 id="hget"><code>hget</code></h2><p>获取一个哈希键的值。格式：<code>hget key field</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379 hset user name wangpengliang age 25</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379 hget user name</span><br><span class="line"><span class="string">&quot;wangpengliang&quot;</span></span><br></pre></td></tr></table></figure><h2 id="hmset"><code>hmset</code></h2><p>存储一个或多个哈希是键值对的集合。格式：<code>hmset key field1 value1 …fieldN keyN</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379 hmset user1 name wangpengliang age 25 address beijing</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379 hmget user1 name age address</span><br><span class="line">1) <span class="string">&quot;wangpengliang&quot;</span></span><br><span class="line">2) <span class="string">&quot;25&quot;</span></span><br><span class="line">3) <span class="string">&quot;beijing&quot;</span></span><br></pre></td></tr></table></figure><h2 id="hmget"><code>hmget</code></h2><p>获取多个指定的键的值。格式：<code>hmget key field1 … fieldN</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379 hset user name wangpengliang age 25</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379 hget user name</span><br><span class="line"><span class="string">&quot;wangpengliang&quot;</span></span><br></pre></td></tr></table></figure><h2 id="hexists"><code>hexists</code></h2><p>判断哈希表中的字段名是否存在 如果存在返回 1 否则返回 0。格式：<code>hexists key field</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379 hmset user1 name wangpengliang age 25 address beijing</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379 hmget user1 name age address</span><br><span class="line">1) <span class="string">&quot;wangpengliang&quot;</span></span><br><span class="line">2) <span class="string">&quot;25&quot;</span></span><br><span class="line">3) <span class="string">&quot;beijing&quot;</span></span><br><span class="line">127.0.0.1:6379 hexists user1 name</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 hexists user1 aa</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><h2 id="hdel"><code>hdel</code></h2><p>删除一个或多个字段。格式：<code>hdel key field</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379 hmset user name wangpengliang age 25</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379 hmget user name age</span><br><span class="line">1) <span class="string">&quot;wangpengliang&quot;</span></span><br><span class="line">2) <span class="string">&quot;25&quot;</span></span><br><span class="line">127.0.0.1:6379 hdel user name</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 hmget user name age</span><br><span class="line">1) (nil)</span><br><span class="line">2) <span class="string">&quot;25&quot;</span></span><br></pre></td></tr></table></figure><h2 id="hgetall"><code>hgetall</code></h2><p>获取一个哈希是键值对的集合。 格式：<code>hgetall key</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379 hmset user name wangpengliang age 25</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379 hgetall user</span><br><span class="line">1) <span class="string">&quot;age&quot;</span></span><br><span class="line">2) <span class="string">&quot;25&quot;</span></span><br><span class="line">3) <span class="string">&quot;name&quot;</span></span><br><span class="line">4) <span class="string">&quot;wangpengliang&quot;</span></span><br></pre></td></tr></table></figure><h2 id="hvals"><code>hvals</code></h2><p>只返回字段值。 格式：<code>hvals key</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379 hmset user name wangpengliang age 25</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379 hvals user</span><br><span class="line">1) <span class="string">&quot;25&quot;</span></span><br><span class="line">2) <span class="string">&quot;wangpengliang&quot;</span></span><br></pre></td></tr></table></figure><h2 id="hkeys"><code>hkeys</code></h2><p>只返回字段名。 格式：<code>hkeys key</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379 hmset user name wangpengliang age 25</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379 hkeys user</span><br><span class="line">1) <span class="string">&quot;age&quot;</span></span><br><span class="line">2) <span class="string">&quot;name&quot;</span></span><br></pre></td></tr></table></figure><h2 id="hlen"><code>hlen</code></h2><p>返回 key 的 hash 的元素个数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379 hmset user name wangpengliang age 25</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379 hlen user</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br></pre></td></tr></table></figure><h2 id="hincrby-key-field-value"><code>hincrby key field value</code></h2><p>指定增量value</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379 hset <span class="built_in">test</span> num 10</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 hget <span class="built_in">test</span> num</span><br><span class="line"><span class="string">&quot;10&quot;</span></span><br><span class="line">127.0.0.1:6379 hincrby <span class="built_in">test</span> num 2</span><br><span class="line">(<span class="built_in">integer</span>) 12</span><br></pre></td></tr></table></figure><h2 id="hsetnx-key-field-value"><code>hsetnx key field value</code></h2><p>如果该键不存在就创建，如果该键存在就创建失败</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379 hsetnx <span class="built_in">test</span> num 10</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 hsetnx <span class="built_in">test</span> num 20</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><h2 id="应用场景-v2">应用场景</h2><ul><li>主要用于存储部分变更数据，比如存储用户信息等等</li></ul><h1 id="List链表">List链表</h1><p>Redis 的链表是简单的字符串列表，可以添加元素到 Redis 列表的头部或尾部。<br><code>Lpush</code>：表示向链表的左添加，也就是向链表的头添加<br><code>Rpush</code>：表示向链表的右添加，也就是向链表的尾添加</p><h2 id="lpush-key-value"><code>lpush key value</code></h2><p>向链表左侧添加(头插法)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379 lpush keys one</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 lpush keys two</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379 lpush keys three</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379 lrange keys 0 -1</span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">3) <span class="string">&quot;one&quot;</span></span><br></pre></td></tr></table></figure><h2 id="rpush-key-value"><code>rpush key value</code></h2><p>向链表右侧添加(尾插法)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379 rpush keys one</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 rpush keys two</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379 rpush keys three</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379 lrange keys 0 -1</span><br><span class="line">1) <span class="string">&quot;one&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">3) <span class="string">&quot;three&quot;</span></span><br></pre></td></tr></table></figure><h2 id="lpop-key"><code>lpop key</code></h2><p>从左边移出一个元素</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379 rpush keys one</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 rpush keys two</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379 rpush keys three</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379 lrange keys 0 -1</span><br><span class="line">1) <span class="string">&quot;one&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">3) <span class="string">&quot;three&quot;</span></span><br><span class="line">127.0.0.1:6379 lpop keys</span><br><span class="line"><span class="string">&quot;one&quot;</span></span><br><span class="line">127.0.0.1:6379 lrange keys 0 -1</span><br><span class="line">1) <span class="string">&quot;two&quot;</span></span><br><span class="line">2) <span class="string">&quot;three&quot;</span></span><br></pre></td></tr></table></figure><h2 id="rpop-key"><code>rpop key</code></h2><p>从右边移出一个元素</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379 rpush keys one</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 rpush keys two</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379 rpush keys three</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379 rpop keys</span><br><span class="line"><span class="string">&quot;three&quot;</span></span><br><span class="line">127.0.0.1:6379 lrange keys 0 -1</span><br><span class="line">1) <span class="string">&quot;one&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br></pre></td></tr></table></figure><h2 id="lrange-key-start-end"><code>lrange key start end</code></h2><p>命令将返回索引从 <code>start</code> 到 <code>stop</code>  之间的所有元素。Redis 的列表起始索引为 0。如果要获取全部的元素：<code>lrange key 0 -1</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379 rpush keys one</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 rpush keys two</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379 lrange keys 0 -1</span><br><span class="line">1) <span class="string">&quot;one&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br></pre></td></tr></table></figure><h2 id="llen-key"><code>llen key</code></h2><p>返回链表中元素的个数 相当于关系型数据库中 <code>select count(*)</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379 rpush keys one</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 rpush keys two</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379 lrange keys 0 -1</span><br><span class="line">1) <span class="string">&quot;one&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">127.0.0.1:6379 llen keys</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br></pre></td></tr></table></figure><h2 id="lindex-key-indexnumber"><code>lindex key indexnumber</code></h2><p>lindex 命令用来返回指定索引的元素，索引从 0 开始，如果是负数表示从右边开始计算的索引，最右边元素的索引是-1。如果要将列表类型当做数组来用，lindex 命令是必不可少的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379 rpush keys one</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 rpush keys two</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379 rpush keys three</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379 lrange keys 0 -1</span><br><span class="line">1) <span class="string">&quot;one&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">3) <span class="string">&quot;three&quot;</span></span><br><span class="line">127.0.0.1:6379 lindex keys 2</span><br><span class="line"><span class="string">&quot;three&quot;</span></span><br></pre></td></tr></table></figure><h2 id="lset-key-indexnumber-value"><code>lset key indexnumber value</code></h2><p>它会将索引为 index的元素赋值为 value，原来的值会被覆盖。如果该列表不存在就会报错。所以使用这个命令之前先使用<code>exists</code>判断一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379 rpush keys one</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 rpush keys two</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379 rpush keys three</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379 lrange keys 0 -1</span><br><span class="line">1) <span class="string">&quot;one&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">3) <span class="string">&quot;three&quot;</span></span><br><span class="line">127.0.0.1:6379 lset keys 2 twotwo</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379 lrange keys 0 -1</span><br><span class="line">1) <span class="string">&quot;one&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">3) <span class="string">&quot;twotwo&quot;</span></span><br><span class="line">127.0.0.1:6379 lset keys 10  twotwo</span><br><span class="line">(error) ERR index out of range</span><br></pre></td></tr></table></figure><h2 id="lrem-key-count-value"><code>lrem key count value</code></h2><p>移除key链表中``count` 个元素的value值，精确匹配，如果链表中有多个重复的值，这里的count指的是可以删除多个相同key的值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379 rpush keys a</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 rpush keys b</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379 rpush keys c</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379 lrange keys 0 -1</span><br><span class="line">1) <span class="string">&quot;a&quot;</span></span><br><span class="line">2) <span class="string">&quot;b&quot;</span></span><br><span class="line">3) <span class="string">&quot;c&quot;</span></span><br><span class="line">127.0.0.1:6379 rpush keys d</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379 rpush keys a</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379 lrange keys 0 -1</span><br><span class="line">1) <span class="string">&quot;a&quot;</span></span><br><span class="line">2) <span class="string">&quot;b&quot;</span></span><br><span class="line">3) <span class="string">&quot;c&quot;</span></span><br><span class="line">4) <span class="string">&quot;d&quot;</span></span><br><span class="line">5) <span class="string">&quot;a&quot;</span></span><br><span class="line">127.0.0.1:6379 lrem keys 2 a</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379 lrange keys 0 -1</span><br><span class="line">1) <span class="string">&quot;b&quot;</span></span><br><span class="line">2) <span class="string">&quot;c&quot;</span></span><br><span class="line">3) <span class="string">&quot;d&quot;</span></span><br></pre></td></tr></table></figure><h2 id="ltrim-list-startIndex-endIndex"><code>ltrim list startIndex endIndex</code></h2><p>通过下标截取指定的长度，这个时候List已经改变了，只剩下截断的元素</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379 clear</span><br><span class="line">127.0.0.1:6379 rpush keys a</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 rpush keys b</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379 rpush keys c</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379 rpush keys d</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379 lrange keys 0 -1</span><br><span class="line">1) <span class="string">&quot;a&quot;</span></span><br><span class="line">2) <span class="string">&quot;b&quot;</span></span><br><span class="line">3) <span class="string">&quot;c&quot;</span></span><br><span class="line">4) <span class="string">&quot;d&quot;</span></span><br><span class="line">127.0.0.1:6379 ltrim keys 2 3</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379 lrange keys 0 -1</span><br><span class="line">1) <span class="string">&quot;c&quot;</span></span><br><span class="line">2) <span class="string">&quot;d&quot;</span></span><br></pre></td></tr></table></figure><h2 id="rpoplpush-source-destination"><code>rpoplpush source destination</code></h2><p>移除当前的source链表中的最后一个元素，并且将该元素移动到<code>destination</code>链表当中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379 rpush keys1 a</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 rpush keys1 b</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379 rpush keys1 c</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379 rpoplpush keys1 keys2</span><br><span class="line"><span class="string">&quot;c&quot;</span></span><br><span class="line">127.0.0.1:6379 lrange keys1 0 -1</span><br><span class="line">1) <span class="string">&quot;a&quot;</span></span><br><span class="line">2) <span class="string">&quot;b&quot;</span></span><br><span class="line">127.0.0.1:6379 lrange keys2 0 -1</span><br><span class="line">1) <span class="string">&quot;c&quot;</span></span><br></pre></td></tr></table></figure><h2 id="linsert-key-BEFORE-AFTER-pivot-value"><code>linsert key BEFORE|AFTER pivot value</code></h2><p>在Key列表的指定元素的前/后面插入元素value</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379 rpush keys1 a</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 rpush keys1 b</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379 rpush keys1 c</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379 linsert keys1 before b a1</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379 lrange keys 0 -1</span><br><span class="line">(empty array)</span><br><span class="line">127.0.0.1:6379 lrange keys1 0 -1</span><br><span class="line">1) <span class="string">&quot;a&quot;</span></span><br><span class="line">2) <span class="string">&quot;a1&quot;</span></span><br><span class="line">3) <span class="string">&quot;b&quot;</span></span><br><span class="line">4) <span class="string">&quot;c&quot;</span></span><br><span class="line">127.0.0.1:6379 linsert keys1 after b b1</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379 lrange keys1 0 -1</span><br><span class="line">1) <span class="string">&quot;a&quot;</span></span><br><span class="line">2) <span class="string">&quot;a1&quot;</span></span><br><span class="line">3) <span class="string">&quot;b&quot;</span></span><br><span class="line">4) <span class="string">&quot;b1&quot;</span></span><br><span class="line">5) <span class="string">&quot;c&quot;</span></span><br></pre></td></tr></table></figure><ul><li>List是一个链表，before node after，left ，right都可以插入值</li><li>如果key不存在，就创建新的链表</li><li>如果key存在就创建新的值</li><li>如果移除了所有的值，空链表，也就代表不存在</li><li>在两边插入或者改动值，效率最高，中间元素相对来说效率会低一点</li></ul><h2 id="应用场景-v3">应用场景</h2><ul><li>消息队列：利用 <code>List</code> 的<code>Push</code> 操作，将任务存在 <code>List</code> 中，然后工作线程再用<code>POP</code> 操作将任务取出进行执行。Redis还提供了操作List中某一段的API，可以直接查询，删除 List 中某一段的元素。</li><li>消息排队：消息队列（Lpush、Rpop）、栈（Lpush、Lpop）使用 <code>List</code> 可以构建队列系统，使用 <code>sorted set</code> 甚至可以构建有优先级的队列系统。</li></ul><h1 id="Set集合">Set集合</h1><p>Redis 的集合是字符串的无序集合。但在Set集合当中，是不允许有重复的。Set是通过hash table实现的，可以进行添加、删除和查找。对集合可以取 <strong>并集</strong>，<strong>交集</strong>，<strong>差集</strong>。</p><h2 id="sadd-key-value"><code>sadd key value</code></h2><p>添加一个 string 元素到key对应的 set 集合中， 成功返回 1,如果元素已经在集合中返回 0</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379 sadd keys a</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 sadd keys b</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 sadd keys a</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379 sadd keys c</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 smembers keys</span><br><span class="line">1) <span class="string">&quot;c&quot;</span></span><br><span class="line">2) <span class="string">&quot;a&quot;</span></span><br><span class="line">3) <span class="string">&quot;b&quot;</span></span><br></pre></td></tr></table></figure><h2 id="scard-key"><code>scard key</code></h2><p>返回 set 的元素个数，如果 set 是空或者key不存在返回 0</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379 sadd keys a</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 sadd keys b</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 sadd keys c</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 smembers keys</span><br><span class="line">1) <span class="string">&quot;c&quot;</span></span><br><span class="line">2) <span class="string">&quot;a&quot;</span></span><br><span class="line">3) <span class="string">&quot;b&quot;</span></span><br><span class="line">127.0.0.1:6379 scard keys</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure><h2 id="smembers-key"><code>smembers key</code></h2><p>返回 key 对应 set 的所有元素，结果是无序的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379 sadd keys a</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 sadd keys b</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 sadd keys c</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 smembers keys</span><br><span class="line">1) <span class="string">&quot;c&quot;</span></span><br><span class="line">2) <span class="string">&quot;a&quot;</span></span><br><span class="line">3) <span class="string">&quot;b&quot;</span></span><br></pre></td></tr></table></figure><h2 id="sismember-key-value"><code>sismember key value</code></h2><p>判断 value 是否在 set 中，存在返回1，0表示不存在或者key不存在</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379 sadd keys a</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 sadd keys b</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 sadd keys c</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 smembers keys</span><br><span class="line">1) <span class="string">&quot;c&quot;</span></span><br><span class="line">2) <span class="string">&quot;a&quot;</span></span><br><span class="line">3) <span class="string">&quot;b&quot;</span></span><br><span class="line">127.0.0.1:6379 sismember keys a</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 sismember keys d</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><h2 id="srem-key-value"><code>srem key value</code></h2><p>从 key 对应 set 中移除给定元素，成功返回1，如果 value 在集合中不存在或者key不存在返回 0</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379 sadd keys a</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 sadd keys b</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 sadd keys c</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 smembers keys</span><br><span class="line">1) <span class="string">&quot;c&quot;</span></span><br><span class="line">2) <span class="string">&quot;a&quot;</span></span><br><span class="line">3) <span class="string">&quot;b&quot;</span></span><br><span class="line">127.0.0.1:6379 srem keys a</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 smembers keys</span><br><span class="line">1) <span class="string">&quot;c&quot;</span></span><br><span class="line">2) <span class="string">&quot;b&quot;</span></span><br><span class="line">127.0.0.1:6379 srem keys g</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><h2 id="srandmember-key-nums"><code>srandmember key nums</code></h2><p>从key集合中随机抽取nums个元素</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379 sadd keys a</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 sadd keys b</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 sadd keys c</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 srandmember keys 2</span><br><span class="line">1) <span class="string">&quot;a&quot;</span></span><br><span class="line">2) <span class="string">&quot;c&quot;</span></span><br></pre></td></tr></table></figure><h2 id="spop-key"><code>spop key</code></h2><p>随机删除一些key集合中的元素</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379 sadd keys a</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 sadd keys b</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 sadd keys c</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 spop keys</span><br><span class="line"><span class="string">&quot;a&quot;</span></span><br><span class="line">127.0.0.1:6379 smembers keys</span><br><span class="line">1) <span class="string">&quot;c&quot;</span></span><br><span class="line">2) <span class="string">&quot;b&quot;</span></span><br></pre></td></tr></table></figure><h2 id="smove-source-destination-member"><code>smove source destination member</code></h2><p>将原集合source中的member元素移动到destination集合中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379 sadd keys a</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 sadd keys b</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 sadd keys c</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 smove keys keys2 a</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 smembers keys</span><br><span class="line">1) <span class="string">&quot;c&quot;</span></span><br><span class="line">2) <span class="string">&quot;b&quot;</span></span><br><span class="line">127.0.0.1:6379 smembers keys2</span><br><span class="line">1) <span class="string">&quot;a&quot;</span></span><br></pre></td></tr></table></figure><h2 id="sdiff-key1-key2"><code>sdiff key1 key2</code></h2><p>取出key1中与key2集合的不同元素，<strong>差集</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379 sadd keys1 a</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 sadd keys1 b</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 sadd keys1 c</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 sadd keys2 c</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 sadd keys2 g</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 sadd keys2 f</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 sdiff keys1 keys2</span><br><span class="line">1) <span class="string">&quot;a&quot;</span></span><br><span class="line">2) <span class="string">&quot;b&quot;</span></span><br></pre></td></tr></table></figure><h2 id="sinter-key1-key2"><code>sinter key1 key2</code></h2><p>取key1与key2两个集合中相同的元素，<strong>交集</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379 sadd keys1 a</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 sadd keys1 b</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 sadd keys1 c</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 sadd keys2 c</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 sadd keys2 g</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 sadd keys2 f</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 sinter keys1 keys2</span><br><span class="line">1) <span class="string">&quot;c&quot;</span></span><br></pre></td></tr></table></figure><h2 id="sunion-key1-key2"><code>sunion key1 key2</code></h2><p>将key1与key2两个集合中的元素合在一起，<strong>并集</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379 sadd keys1 a</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 sadd keys1 b</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 sadd keys1 c</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 sadd keys2 c</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 sadd keys2 g</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 sadd keys2 f</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 sunion keys1 keys2</span><br><span class="line">1) <span class="string">&quot;a&quot;</span></span><br><span class="line">2) <span class="string">&quot;c&quot;</span></span><br><span class="line">3) <span class="string">&quot;g&quot;</span></span><br><span class="line">4) <span class="string">&quot;b&quot;</span></span><br><span class="line">5) <span class="string">&quot;f&quot;</span></span><br></pre></td></tr></table></figure><h2 id="应用场景-v4">应用场景</h2><ul><li>微博、用户将所有关注的人都放入到一个set集合当中，将它的粉丝也放在一个集合中</li><li>共同关注、共同爱好、二度好友、QQ的好友推荐（六度分割理论）</li></ul><h1 id="SortedSet-有序集合-zset">SortedSet( 有序集合) zset</h1><p>Redis 的有序集合类似于 Redis 的集合，字符串不重复的集合；zset是一个有序集合，每一个成员有一个分数与之对应，成员不可以重复，但是分数是可以重复的，zset会自动用分数对成员进行排序。</p><h2 id="zadd-key-score-value"><code>zadd key score value</code></h2><p>将一个或多个 value 及其 socre 加入到 set 中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379 zadd keys 1 a</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 zrange keys 0 -1</span><br><span class="line">1) <span class="string">&quot;a&quot;</span></span><br></pre></td></tr></table></figure><h2 id="zrange-key-start-end"><code>zrange key start end</code></h2><p>0 和-1 表示从索引为 0 的元素到最后一个元素（同 LRANGE 命令相似）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379 zadd keys 1 a</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 zrange keys 0 -1</span><br><span class="line">1) <span class="string">&quot;a&quot;</span></span><br></pre></td></tr></table></figure><h2 id="zrange-key-0-1-withscores"><code>zrange key 0 -1 withscores</code></h2><p>连同 score 一块输出，使用 WITHSCORES 参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379 zadd keys 1 a</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 zadd keys 2 b</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 zadd keys 3 c</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 zrange keys 0 -1 withscores</span><br><span class="line">1) <span class="string">&quot;a&quot;</span></span><br><span class="line">2) <span class="string">&quot;1&quot;</span></span><br><span class="line">3) <span class="string">&quot;b&quot;</span></span><br><span class="line">4) <span class="string">&quot;2&quot;</span></span><br><span class="line">5) <span class="string">&quot;c&quot;</span></span><br><span class="line">6) <span class="string">&quot;3&quot;</span></span><br></pre></td></tr></table></figure><h2 id="zremrangebyscore-key-start-end"><code>zremrangebyscore key start end</code></h2><p>范围删除操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379 zadd keys 1 a</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 zadd keys 2 b</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 zadd keys 3 c</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 zrange keys 0 -1 withscores</span><br><span class="line">1) <span class="string">&quot;a&quot;</span></span><br><span class="line">2) <span class="string">&quot;1&quot;</span></span><br><span class="line">3) <span class="string">&quot;b&quot;</span></span><br><span class="line">4) <span class="string">&quot;2&quot;</span></span><br><span class="line">5) <span class="string">&quot;c&quot;</span></span><br><span class="line">6) <span class="string">&quot;3&quot;</span></span><br><span class="line">127.0.0.1:6379 zremrangebyscore keys 0 2</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379 zrange keys 0 -1 withscores</span><br><span class="line">1) <span class="string">&quot;c&quot;</span></span><br><span class="line">2) <span class="string">&quot;3&quot;</span></span><br></pre></td></tr></table></figure><h2 id="zrangebyscore-key-min-max"><code>zrangebyscore key min max</code></h2><p>升序排序操作，将key按最小值到最大值进行输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379 zadd keys 1 a</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 zadd keys 2 b</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 zadd keys 3 c</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 zrangebyscore keys 1 3</span><br><span class="line">1) <span class="string">&quot;a&quot;</span></span><br><span class="line">2) <span class="string">&quot;b&quot;</span></span><br><span class="line">3) <span class="string">&quot;c&quot;</span></span><br></pre></td></tr></table></figure><h2 id="srandmember-key-nums-v2"><code>srandmember key nums</code></h2><p>倒序排序操作，将key按照从大到小排序输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379 zadd keys 1 a</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 zadd keys 2 b</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 zadd keys 3 c</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 zrevrangebyscore keys 3 1</span><br><span class="line">1) <span class="string">&quot;c&quot;</span></span><br><span class="line">2) <span class="string">&quot;b&quot;</span></span><br><span class="line">3) <span class="string">&quot;a&quot;</span></span><br></pre></td></tr></table></figure><h2 id="zrem-key-value"><code>zrem key value</code></h2><p>删除指定的元素</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379 zadd keys 1 a</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 zadd keys 2 b</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 zadd keys 3 c</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 zrem keys b</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 zrange keys 0 -1</span><br><span class="line">1) <span class="string">&quot;a&quot;</span></span><br><span class="line">2) <span class="string">&quot;c&quot;</span></span><br><span class="line">127.0.0.1:6379 zrem keys d</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379 zrange keys 0 -1</span><br><span class="line">1) <span class="string">&quot;a&quot;</span></span><br><span class="line">2) <span class="string">&quot;c&quot;</span></span><br></pre></td></tr></table></figure><h2 id="zcard-key"><code>zcard key</code></h2><p>获取有序集合中的个数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379 zadd keys 1 a</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 zadd keys 2 b</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 zadd keys 3 c</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 zrem keys b</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 zrange keys 0 -1</span><br><span class="line">1) <span class="string">&quot;a&quot;</span></span><br><span class="line">2) <span class="string">&quot;c&quot;</span></span><br><span class="line">127.0.0.1:6379 zrem keys d</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379 zrange keys 0 -1</span><br><span class="line">1) <span class="string">&quot;a&quot;</span></span><br><span class="line">2) <span class="string">&quot;c&quot;</span></span><br><span class="line">127.0.0.1:6379 zcard keys</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br></pre></td></tr></table></figure><h2 id="count-key-min-max"><code>count key min max</code></h2><p>获取指定区间的成员数量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379 zadd keys 1 a</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 zadd keys 2 b</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 zadd keys 3 c</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 zrem keys b</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379 zrange keys 0 -1</span><br><span class="line">1) <span class="string">&quot;a&quot;</span></span><br><span class="line">2) <span class="string">&quot;c&quot;</span></span><br><span class="line">127.0.0.1:6379 zrem keys d</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379 zrange keys 0 -1</span><br><span class="line">1) <span class="string">&quot;a&quot;</span></span><br><span class="line">2) <span class="string">&quot;c&quot;</span></span><br><span class="line">127.0.0.1:6379 zcard keys</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379 zcount keys 0 2</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><h2 id="应用场景-v5">应用场景</h2><ul><li>存储班级成绩表、工资表排序</li></ul><h1 id="参考-v4">参考</h1><p><a href="https://www.redis.net.cn/order/">Redis中文命令手册</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/redis/1.6Redis%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"/>
      <url>/redis/1.6Redis%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis-Config-配置文件"><code>Redis.Config</code> 配置文件</h1><p>经常使用的配置使用“# =&gt;”方式写了注释</p><span id="more"></span><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br><span class="line">1073</span><br><span class="line">1074</span><br><span class="line">1075</span><br><span class="line">1076</span><br><span class="line">1077</span><br><span class="line">1078</span><br><span class="line">1079</span><br><span class="line">1080</span><br><span class="line">1081</span><br><span class="line">1082</span><br><span class="line">1083</span><br><span class="line">1084</span><br><span class="line">1085</span><br><span class="line">1086</span><br><span class="line">1087</span><br><span class="line">1088</span><br><span class="line">1089</span><br><span class="line">1090</span><br><span class="line">1091</span><br><span class="line">1092</span><br><span class="line">1093</span><br><span class="line">1094</span><br><span class="line">1095</span><br><span class="line">1096</span><br><span class="line">1097</span><br><span class="line">1098</span><br><span class="line">1099</span><br><span class="line">1100</span><br><span class="line">1101</span><br><span class="line">1102</span><br><span class="line">1103</span><br><span class="line">1104</span><br><span class="line">1105</span><br><span class="line">1106</span><br><span class="line">1107</span><br><span class="line">1108</span><br><span class="line">1109</span><br><span class="line">1110</span><br><span class="line">1111</span><br><span class="line">1112</span><br><span class="line">1113</span><br><span class="line">1114</span><br><span class="line">1115</span><br><span class="line">1116</span><br><span class="line">1117</span><br><span class="line">1118</span><br><span class="line">1119</span><br><span class="line">1120</span><br><span class="line">1121</span><br><span class="line">1122</span><br><span class="line">1123</span><br><span class="line">1124</span><br><span class="line">1125</span><br><span class="line">1126</span><br><span class="line">1127</span><br><span class="line">1128</span><br><span class="line">1129</span><br><span class="line">1130</span><br><span class="line">1131</span><br><span class="line">1132</span><br><span class="line">1133</span><br><span class="line">1134</span><br><span class="line">1135</span><br><span class="line">1136</span><br><span class="line">1137</span><br><span class="line">1138</span><br><span class="line">1139</span><br><span class="line">1140</span><br><span class="line">1141</span><br><span class="line">1142</span><br><span class="line">1143</span><br><span class="line">1144</span><br><span class="line">1145</span><br><span class="line">1146</span><br><span class="line">1147</span><br><span class="line">1148</span><br><span class="line">1149</span><br><span class="line">1150</span><br><span class="line">1151</span><br><span class="line">1152</span><br><span class="line">1153</span><br><span class="line">1154</span><br><span class="line">1155</span><br><span class="line">1156</span><br><span class="line">1157</span><br><span class="line">1158</span><br><span class="line">1159</span><br><span class="line">1160</span><br><span class="line">1161</span><br><span class="line">1162</span><br><span class="line">1163</span><br><span class="line">1164</span><br><span class="line">1165</span><br><span class="line">1166</span><br><span class="line">1167</span><br><span class="line">1168</span><br><span class="line">1169</span><br><span class="line">1170</span><br><span class="line">1171</span><br><span class="line">1172</span><br><span class="line">1173</span><br><span class="line">1174</span><br><span class="line">1175</span><br><span class="line">1176</span><br><span class="line">1177</span><br><span class="line">1178</span><br><span class="line">1179</span><br><span class="line">1180</span><br><span class="line">1181</span><br><span class="line">1182</span><br><span class="line">1183</span><br><span class="line">1184</span><br><span class="line">1185</span><br><span class="line">1186</span><br><span class="line">1187</span><br><span class="line">1188</span><br><span class="line">1189</span><br><span class="line">1190</span><br><span class="line">1191</span><br><span class="line">1192</span><br><span class="line">1193</span><br><span class="line">1194</span><br><span class="line">1195</span><br><span class="line">1196</span><br><span class="line">1197</span><br><span class="line">1198</span><br><span class="line">1199</span><br><span class="line">1200</span><br><span class="line">1201</span><br><span class="line">1202</span><br><span class="line">1203</span><br><span class="line">1204</span><br><span class="line">1205</span><br><span class="line">1206</span><br><span class="line">1207</span><br><span class="line">1208</span><br><span class="line">1209</span><br><span class="line">1210</span><br><span class="line">1211</span><br><span class="line">1212</span><br><span class="line">1213</span><br><span class="line">1214</span><br><span class="line">1215</span><br><span class="line">1216</span><br><span class="line">1217</span><br><span class="line">1218</span><br><span class="line">1219</span><br><span class="line">1220</span><br><span class="line">1221</span><br><span class="line">1222</span><br><span class="line">1223</span><br><span class="line">1224</span><br><span class="line">1225</span><br><span class="line">1226</span><br><span class="line">1227</span><br><span class="line">1228</span><br><span class="line">1229</span><br><span class="line">1230</span><br><span class="line">1231</span><br><span class="line">1232</span><br><span class="line">1233</span><br><span class="line">1234</span><br><span class="line">1235</span><br><span class="line">1236</span><br><span class="line">1237</span><br><span class="line">1238</span><br><span class="line">1239</span><br><span class="line">1240</span><br><span class="line">1241</span><br><span class="line">1242</span><br><span class="line">1243</span><br><span class="line">1244</span><br><span class="line">1245</span><br><span class="line">1246</span><br><span class="line">1247</span><br><span class="line">1248</span><br><span class="line">1249</span><br><span class="line">1250</span><br><span class="line">1251</span><br><span class="line">1252</span><br><span class="line">1253</span><br><span class="line">1254</span><br><span class="line">1255</span><br><span class="line">1256</span><br><span class="line">1257</span><br><span class="line">1258</span><br><span class="line">1259</span><br><span class="line">1260</span><br><span class="line">1261</span><br><span class="line">1262</span><br><span class="line">1263</span><br><span class="line">1264</span><br><span class="line">1265</span><br><span class="line">1266</span><br><span class="line">1267</span><br><span class="line">1268</span><br><span class="line">1269</span><br><span class="line">1270</span><br><span class="line">1271</span><br><span class="line">1272</span><br><span class="line">1273</span><br><span class="line">1274</span><br><span class="line">1275</span><br><span class="line">1276</span><br><span class="line">1277</span><br><span class="line">1278</span><br><span class="line">1279</span><br><span class="line">1280</span><br><span class="line">1281</span><br><span class="line">1282</span><br><span class="line">1283</span><br><span class="line">1284</span><br><span class="line">1285</span><br><span class="line">1286</span><br><span class="line">1287</span><br><span class="line">1288</span><br><span class="line">1289</span><br><span class="line">1290</span><br><span class="line">1291</span><br><span class="line">1292</span><br><span class="line">1293</span><br><span class="line">1294</span><br><span class="line">1295</span><br><span class="line">1296</span><br><span class="line">1297</span><br><span class="line">1298</span><br><span class="line">1299</span><br><span class="line">1300</span><br><span class="line">1301</span><br><span class="line">1302</span><br><span class="line">1303</span><br><span class="line">1304</span><br><span class="line">1305</span><br><span class="line">1306</span><br><span class="line">1307</span><br><span class="line">1308</span><br><span class="line">1309</span><br><span class="line">1310</span><br><span class="line">1311</span><br><span class="line">1312</span><br><span class="line">1313</span><br><span class="line">1314</span><br><span class="line">1315</span><br><span class="line">1316</span><br><span class="line">1317</span><br><span class="line">1318</span><br><span class="line">1319</span><br><span class="line">1320</span><br><span class="line">1321</span><br><span class="line">1322</span><br><span class="line">1323</span><br><span class="line">1324</span><br><span class="line">1325</span><br><span class="line">1326</span><br><span class="line">1327</span><br><span class="line">1328</span><br><span class="line">1329</span><br><span class="line">1330</span><br><span class="line">1331</span><br><span class="line">1332</span><br><span class="line">1333</span><br><span class="line">1334</span><br><span class="line">1335</span><br><span class="line">1336</span><br><span class="line">1337</span><br><span class="line">1338</span><br><span class="line">1339</span><br><span class="line">1340</span><br><span class="line">1341</span><br><span class="line">1342</span><br><span class="line">1343</span><br><span class="line">1344</span><br><span class="line">1345</span><br><span class="line">1346</span><br><span class="line">1347</span><br><span class="line">1348</span><br><span class="line">1349</span><br><span class="line">1350</span><br><span class="line">1351</span><br><span class="line">1352</span><br><span class="line">1353</span><br><span class="line">1354</span><br><span class="line">1355</span><br><span class="line">1356</span><br><span class="line">1357</span><br><span class="line">1358</span><br><span class="line">1359</span><br><span class="line">1360</span><br><span class="line">1361</span><br><span class="line">1362</span><br><span class="line">1363</span><br><span class="line">1364</span><br><span class="line">1365</span><br><span class="line">1366</span><br><span class="line">1367</span><br><span class="line">1368</span><br><span class="line">1369</span><br><span class="line">1370</span><br><span class="line">1371</span><br><span class="line">1372</span><br><span class="line">1373</span><br><span class="line">1374</span><br><span class="line">1375</span><br><span class="line">1376</span><br><span class="line">1377</span><br><span class="line">1378</span><br><span class="line">1379</span><br><span class="line">1380</span><br><span class="line">1381</span><br><span class="line">1382</span><br><span class="line">1383</span><br><span class="line">1384</span><br><span class="line">1385</span><br><span class="line">1386</span><br><span class="line">1387</span><br><span class="line">1388</span><br><span class="line">1389</span><br><span class="line">1390</span><br><span class="line">1391</span><br><span class="line">1392</span><br><span class="line">1393</span><br><span class="line">1394</span><br><span class="line">1395</span><br><span class="line">1396</span><br><span class="line">1397</span><br><span class="line">1398</span><br><span class="line">1399</span><br><span class="line">1400</span><br><span class="line">1401</span><br><span class="line">1402</span><br><span class="line">1403</span><br><span class="line">1404</span><br><span class="line">1405</span><br><span class="line">1406</span><br><span class="line">1407</span><br><span class="line">1408</span><br><span class="line">1409</span><br><span class="line">1410</span><br><span class="line">1411</span><br><span class="line">1412</span><br><span class="line">1413</span><br><span class="line">1414</span><br><span class="line">1415</span><br><span class="line">1416</span><br><span class="line">1417</span><br><span class="line">1418</span><br><span class="line">1419</span><br><span class="line">1420</span><br><span class="line">1421</span><br><span class="line">1422</span><br><span class="line">1423</span><br><span class="line">1424</span><br><span class="line">1425</span><br><span class="line">1426</span><br><span class="line">1427</span><br><span class="line">1428</span><br><span class="line">1429</span><br><span class="line">1430</span><br><span class="line">1431</span><br><span class="line">1432</span><br><span class="line">1433</span><br><span class="line">1434</span><br><span class="line">1435</span><br><span class="line">1436</span><br><span class="line">1437</span><br><span class="line">1438</span><br><span class="line">1439</span><br><span class="line">1440</span><br><span class="line">1441</span><br><span class="line">1442</span><br><span class="line">1443</span><br><span class="line">1444</span><br><span class="line">1445</span><br><span class="line">1446</span><br><span class="line">1447</span><br><span class="line">1448</span><br><span class="line">1449</span><br><span class="line">1450</span><br><span class="line">1451</span><br><span class="line">1452</span><br><span class="line">1453</span><br><span class="line">1454</span><br><span class="line">1455</span><br><span class="line">1456</span><br><span class="line">1457</span><br><span class="line">1458</span><br><span class="line">1459</span><br><span class="line">1460</span><br><span class="line">1461</span><br><span class="line">1462</span><br><span class="line">1463</span><br><span class="line">1464</span><br><span class="line">1465</span><br><span class="line">1466</span><br><span class="line">1467</span><br><span class="line">1468</span><br><span class="line">1469</span><br><span class="line">1470</span><br><span class="line">1471</span><br><span class="line">1472</span><br><span class="line">1473</span><br><span class="line">1474</span><br><span class="line">1475</span><br><span class="line">1476</span><br><span class="line">1477</span><br><span class="line">1478</span><br><span class="line">1479</span><br><span class="line">1480</span><br><span class="line">1481</span><br><span class="line">1482</span><br><span class="line">1483</span><br><span class="line">1484</span><br><span class="line">1485</span><br><span class="line">1486</span><br><span class="line">1487</span><br><span class="line">1488</span><br><span class="line">1489</span><br><span class="line">1490</span><br><span class="line">1491</span><br><span class="line">1492</span><br><span class="line">1493</span><br><span class="line">1494</span><br><span class="line">1495</span><br><span class="line">1496</span><br><span class="line">1497</span><br><span class="line">1498</span><br><span class="line">1499</span><br><span class="line">1500</span><br><span class="line">1501</span><br><span class="line">1502</span><br><span class="line">1503</span><br><span class="line">1504</span><br><span class="line">1505</span><br><span class="line">1506</span><br><span class="line">1507</span><br><span class="line">1508</span><br><span class="line">1509</span><br><span class="line">1510</span><br><span class="line">1511</span><br><span class="line">1512</span><br><span class="line">1513</span><br><span class="line">1514</span><br><span class="line">1515</span><br><span class="line">1516</span><br><span class="line">1517</span><br><span class="line">1518</span><br><span class="line">1519</span><br><span class="line">1520</span><br><span class="line">1521</span><br><span class="line">1522</span><br><span class="line">1523</span><br><span class="line">1524</span><br><span class="line">1525</span><br><span class="line">1526</span><br><span class="line">1527</span><br><span class="line">1528</span><br><span class="line">1529</span><br><span class="line">1530</span><br><span class="line">1531</span><br><span class="line">1532</span><br><span class="line">1533</span><br><span class="line">1534</span><br><span class="line">1535</span><br><span class="line">1536</span><br><span class="line">1537</span><br><span class="line">1538</span><br><span class="line">1539</span><br><span class="line">1540</span><br><span class="line">1541</span><br><span class="line">1542</span><br><span class="line">1543</span><br><span class="line">1544</span><br><span class="line">1545</span><br><span class="line">1546</span><br><span class="line">1547</span><br><span class="line">1548</span><br><span class="line">1549</span><br><span class="line">1550</span><br><span class="line">1551</span><br><span class="line">1552</span><br><span class="line">1553</span><br><span class="line">1554</span><br><span class="line">1555</span><br><span class="line">1556</span><br><span class="line">1557</span><br><span class="line">1558</span><br><span class="line">1559</span><br><span class="line">1560</span><br><span class="line">1561</span><br><span class="line">1562</span><br><span class="line">1563</span><br><span class="line">1564</span><br><span class="line">1565</span><br><span class="line">1566</span><br><span class="line">1567</span><br><span class="line">1568</span><br><span class="line">1569</span><br><span class="line">1570</span><br><span class="line">1571</span><br><span class="line">1572</span><br><span class="line">1573</span><br><span class="line">1574</span><br><span class="line">1575</span><br><span class="line">1576</span><br><span class="line">1577</span><br><span class="line">1578</span><br><span class="line">1579</span><br><span class="line">1580</span><br><span class="line">1581</span><br><span class="line">1582</span><br><span class="line">1583</span><br><span class="line">1584</span><br><span class="line">1585</span><br><span class="line">1586</span><br><span class="line">1587</span><br><span class="line">1588</span><br><span class="line">1589</span><br><span class="line">1590</span><br><span class="line">1591</span><br><span class="line">1592</span><br><span class="line">1593</span><br><span class="line">1594</span><br><span class="line">1595</span><br><span class="line">1596</span><br><span class="line">1597</span><br><span class="line">1598</span><br><span class="line">1599</span><br><span class="line">1600</span><br><span class="line">1601</span><br><span class="line">1602</span><br><span class="line">1603</span><br><span class="line">1604</span><br><span class="line">1605</span><br><span class="line">1606</span><br><span class="line">1607</span><br><span class="line">1608</span><br><span class="line">1609</span><br><span class="line">1610</span><br><span class="line">1611</span><br><span class="line">1612</span><br><span class="line">1613</span><br><span class="line">1614</span><br><span class="line">1615</span><br><span class="line">1616</span><br><span class="line">1617</span><br><span class="line">1618</span><br><span class="line">1619</span><br><span class="line">1620</span><br><span class="line">1621</span><br><span class="line">1622</span><br><span class="line">1623</span><br><span class="line">1624</span><br><span class="line">1625</span><br><span class="line">1626</span><br><span class="line">1627</span><br><span class="line">1628</span><br><span class="line">1629</span><br><span class="line">1630</span><br><span class="line">1631</span><br><span class="line">1632</span><br><span class="line">1633</span><br><span class="line">1634</span><br><span class="line">1635</span><br><span class="line">1636</span><br><span class="line">1637</span><br><span class="line">1638</span><br><span class="line">1639</span><br><span class="line">1640</span><br><span class="line">1641</span><br><span class="line">1642</span><br><span class="line">1643</span><br><span class="line">1644</span><br><span class="line">1645</span><br><span class="line">1646</span><br><span class="line">1647</span><br><span class="line">1648</span><br><span class="line">1649</span><br><span class="line">1650</span><br><span class="line">1651</span><br><span class="line">1652</span><br><span class="line">1653</span><br><span class="line">1654</span><br><span class="line">1655</span><br><span class="line">1656</span><br><span class="line">1657</span><br><span class="line">1658</span><br><span class="line">1659</span><br><span class="line">1660</span><br><span class="line">1661</span><br><span class="line">1662</span><br><span class="line">1663</span><br><span class="line">1664</span><br><span class="line">1665</span><br><span class="line">1666</span><br><span class="line">1667</span><br><span class="line">1668</span><br><span class="line">1669</span><br><span class="line">1670</span><br><span class="line">1671</span><br><span class="line">1672</span><br><span class="line">1673</span><br><span class="line">1674</span><br><span class="line">1675</span><br><span class="line">1676</span><br><span class="line">1677</span><br><span class="line">1678</span><br><span class="line">1679</span><br><span class="line">1680</span><br><span class="line">1681</span><br><span class="line">1682</span><br><span class="line">1683</span><br><span class="line">1684</span><br><span class="line">1685</span><br><span class="line">1686</span><br><span class="line">1687</span><br><span class="line">1688</span><br><span class="line">1689</span><br><span class="line">1690</span><br><span class="line">1691</span><br><span class="line">1692</span><br><span class="line">1693</span><br><span class="line">1694</span><br><span class="line">1695</span><br><span class="line">1696</span><br><span class="line">1697</span><br><span class="line">1698</span><br><span class="line">1699</span><br><span class="line">1700</span><br><span class="line">1701</span><br><span class="line">1702</span><br><span class="line">1703</span><br><span class="line">1704</span><br><span class="line">1705</span><br><span class="line">1706</span><br><span class="line">1707</span><br><span class="line">1708</span><br><span class="line">1709</span><br><span class="line">1710</span><br><span class="line">1711</span><br><span class="line">1712</span><br><span class="line">1713</span><br><span class="line">1714</span><br><span class="line">1715</span><br><span class="line">1716</span><br><span class="line">1717</span><br><span class="line">1718</span><br><span class="line">1719</span><br><span class="line">1720</span><br><span class="line">1721</span><br><span class="line">1722</span><br><span class="line">1723</span><br><span class="line">1724</span><br><span class="line">1725</span><br><span class="line">1726</span><br><span class="line">1727</span><br><span class="line">1728</span><br><span class="line">1729</span><br><span class="line">1730</span><br><span class="line">1731</span><br><span class="line">1732</span><br><span class="line">1733</span><br><span class="line">1734</span><br><span class="line">1735</span><br><span class="line">1736</span><br><span class="line">1737</span><br><span class="line">1738</span><br><span class="line">1739</span><br><span class="line">1740</span><br><span class="line">1741</span><br><span class="line">1742</span><br><span class="line">1743</span><br><span class="line">1744</span><br><span class="line">1745</span><br><span class="line">1746</span><br><span class="line">1747</span><br><span class="line">1748</span><br><span class="line">1749</span><br><span class="line">1750</span><br><span class="line">1751</span><br><span class="line">1752</span><br><span class="line">1753</span><br><span class="line">1754</span><br><span class="line">1755</span><br><span class="line">1756</span><br><span class="line">1757</span><br><span class="line">1758</span><br><span class="line">1759</span><br><span class="line">1760</span><br><span class="line">1761</span><br><span class="line">1762</span><br><span class="line">1763</span><br><span class="line">1764</span><br><span class="line">1765</span><br><span class="line">1766</span><br><span class="line">1767</span><br><span class="line">1768</span><br><span class="line">1769</span><br><span class="line">1770</span><br><span class="line">1771</span><br><span class="line">1772</span><br><span class="line">1773</span><br><span class="line">1774</span><br><span class="line">1775</span><br><span class="line">1776</span><br><span class="line">1777</span><br><span class="line">1778</span><br><span class="line">1779</span><br><span class="line">1780</span><br><span class="line">1781</span><br><span class="line">1782</span><br><span class="line">1783</span><br><span class="line">1784</span><br><span class="line">1785</span><br><span class="line">1786</span><br><span class="line">1787</span><br><span class="line">1788</span><br><span class="line">1789</span><br><span class="line">1790</span><br><span class="line">1791</span><br><span class="line">1792</span><br><span class="line">1793</span><br><span class="line">1794</span><br><span class="line">1795</span><br><span class="line">1796</span><br><span class="line">1797</span><br><span class="line">1798</span><br><span class="line">1799</span><br><span class="line">1800</span><br><span class="line">1801</span><br><span class="line">1802</span><br><span class="line">1803</span><br><span class="line">1804</span><br><span class="line">1805</span><br><span class="line">1806</span><br><span class="line">1807</span><br><span class="line">1808</span><br><span class="line">1809</span><br><span class="line">1810</span><br><span class="line">1811</span><br><span class="line">1812</span><br><span class="line">1813</span><br><span class="line">1814</span><br><span class="line">1815</span><br><span class="line">1816</span><br><span class="line">1817</span><br><span class="line">1818</span><br><span class="line">1819</span><br><span class="line">1820</span><br><span class="line">1821</span><br><span class="line">1822</span><br><span class="line">1823</span><br><span class="line">1824</span><br><span class="line">1825</span><br><span class="line">1826</span><br><span class="line">1827</span><br><span class="line">1828</span><br><span class="line">1829</span><br><span class="line">1830</span><br><span class="line">1831</span><br><span class="line">1832</span><br><span class="line">1833</span><br><span class="line">1834</span><br><span class="line">1835</span><br><span class="line">1836</span><br><span class="line">1837</span><br><span class="line">1838</span><br><span class="line">1839</span><br><span class="line">1840</span><br><span class="line">1841</span><br><span class="line">1842</span><br><span class="line">1843</span><br><span class="line">1844</span><br><span class="line">1845</span><br><span class="line">1846</span><br><span class="line">1847</span><br><span class="line">1848</span><br><span class="line">1849</span><br><span class="line">1850</span><br><span class="line">1851</span><br><span class="line">1852</span><br><span class="line">1853</span><br><span class="line">1854</span><br><span class="line">1855</span><br><span class="line">1856</span><br><span class="line">1857</span><br><span class="line">1858</span><br><span class="line">1859</span><br><span class="line">1860</span><br><span class="line">1861</span><br><span class="line">1862</span><br><span class="line">1863</span><br><span class="line">1864</span><br><span class="line">1865</span><br><span class="line">1866</span><br><span class="line">1867</span><br><span class="line">1868</span><br><span class="line">1869</span><br><span class="line">1870</span><br><span class="line">1871</span><br><span class="line">1872</span><br><span class="line">1873</span><br><span class="line">1874</span><br><span class="line">1875</span><br><span class="line">1876</span><br><span class="line">1877</span><br><span class="line">1878</span><br><span class="line">1879</span><br><span class="line">1880</span><br><span class="line">1881</span><br><span class="line">1882</span><br><span class="line">1883</span><br><span class="line">1884</span><br><span class="line">1885</span><br><span class="line">1886</span><br><span class="line">1887</span><br><span class="line">1888</span><br><span class="line">1889</span><br><span class="line">1890</span><br><span class="line">1891</span><br><span class="line">1892</span><br><span class="line">1893</span><br><span class="line">1894</span><br><span class="line">1895</span><br><span class="line">1896</span><br><span class="line">1897</span><br><span class="line">1898</span><br><span class="line">1899</span><br><span class="line">1900</span><br><span class="line">1901</span><br><span class="line">1902</span><br><span class="line">1903</span><br><span class="line">1904</span><br><span class="line">1905</span><br><span class="line">1906</span><br><span class="line">1907</span><br><span class="line">1908</span><br><span class="line">1909</span><br><span class="line">1910</span><br><span class="line">1911</span><br><span class="line">1912</span><br><span class="line">1913</span><br><span class="line">1914</span><br><span class="line">1915</span><br><span class="line">1916</span><br><span class="line">1917</span><br><span class="line">1918</span><br><span class="line">1919</span><br><span class="line">1920</span><br><span class="line">1921</span><br><span class="line">1922</span><br><span class="line">1923</span><br><span class="line">1924</span><br><span class="line">1925</span><br><span class="line">1926</span><br><span class="line">1927</span><br><span class="line">1928</span><br><span class="line">1929</span><br><span class="line">1930</span><br><span class="line">1931</span><br><span class="line">1932</span><br><span class="line">1933</span><br><span class="line">1934</span><br><span class="line">1935</span><br><span class="line">1936</span><br><span class="line">1937</span><br><span class="line">1938</span><br><span class="line">1939</span><br><span class="line">1940</span><br><span class="line">1941</span><br><span class="line">1942</span><br><span class="line">1943</span><br><span class="line">1944</span><br><span class="line">1945</span><br><span class="line">1946</span><br><span class="line">1947</span><br><span class="line">1948</span><br><span class="line">1949</span><br><span class="line">1950</span><br><span class="line">1951</span><br><span class="line">1952</span><br><span class="line">1953</span><br><span class="line">1954</span><br><span class="line">1955</span><br><span class="line">1956</span><br><span class="line">1957</span><br><span class="line">1958</span><br><span class="line">1959</span><br><span class="line">1960</span><br><span class="line">1961</span><br><span class="line">1962</span><br><span class="line">1963</span><br><span class="line">1964</span><br><span class="line">1965</span><br><span class="line">1966</span><br><span class="line">1967</span><br><span class="line">1968</span><br><span class="line">1969</span><br><span class="line">1970</span><br><span class="line">1971</span><br><span class="line">1972</span><br><span class="line">1973</span><br><span class="line">1974</span><br><span class="line">1975</span><br><span class="line">1976</span><br><span class="line">1977</span><br><span class="line">1978</span><br><span class="line">1979</span><br><span class="line">1980</span><br><span class="line">1981</span><br><span class="line">1982</span><br><span class="line">1983</span><br><span class="line">1984</span><br><span class="line">1985</span><br><span class="line">1986</span><br><span class="line">1987</span><br><span class="line">1988</span><br><span class="line">1989</span><br><span class="line">1990</span><br><span class="line">1991</span><br><span class="line">1992</span><br><span class="line">1993</span><br><span class="line">1994</span><br><span class="line">1995</span><br><span class="line">1996</span><br><span class="line">1997</span><br><span class="line">1998</span><br><span class="line">1999</span><br><span class="line">2000</span><br><span class="line">2001</span><br><span class="line">2002</span><br><span class="line">2003</span><br><span class="line">2004</span><br><span class="line">2005</span><br><span class="line">2006</span><br><span class="line">2007</span><br><span class="line">2008</span><br><span class="line">2009</span><br><span class="line">2010</span><br><span class="line">2011</span><br><span class="line">2012</span><br><span class="line">2013</span><br><span class="line">2014</span><br><span class="line">2015</span><br><span class="line">2016</span><br><span class="line">2017</span><br><span class="line">2018</span><br><span class="line">2019</span><br><span class="line">2020</span><br><span class="line">2021</span><br><span class="line">2022</span><br><span class="line">2023</span><br><span class="line">2024</span><br><span class="line">2025</span><br><span class="line">2026</span><br><span class="line">2027</span><br><span class="line">2028</span><br><span class="line">2029</span><br><span class="line">2030</span><br><span class="line">2031</span><br><span class="line">2032</span><br><span class="line">2033</span><br><span class="line">2034</span><br><span class="line">2035</span><br><span class="line">2036</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Redis configuration file example.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Note that in order to read the configuration file, Redis must be</span></span><br><span class="line"><span class="comment"># started with the file path as first argument:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ./redis-server /path/to/redis.conf</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Note on units: when memory size is needed, it is possible to specify</span></span><br><span class="line"><span class="comment"># it in the usual form of 1k 5GB 4M and so forth:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># =&gt; 单位设置</span></span><br><span class="line"><span class="comment"># 1k =&gt; 1000 bytes</span></span><br><span class="line"><span class="comment"># 1kb =&gt; 1024 bytes</span></span><br><span class="line"><span class="comment"># 1m =&gt; 1000000 bytes</span></span><br><span class="line"><span class="comment"># 1mb =&gt; 1024*1024 bytes</span></span><br><span class="line"><span class="comment"># 1g =&gt; 1000000000 bytes</span></span><br><span class="line"><span class="comment"># 1gb =&gt; 1024*1024*1024 bytes</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># =&gt; Redis单位对大小写不敏感</span></span><br><span class="line"><span class="comment"># units are case insensitive so 1GB 1Gb 1gB are all the same.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># =&gt; 包含：可以把多个Redis.conf组合成一个conf</span></span><br><span class="line"><span class="comment">################################## INCLUDES ###################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Include one or more other config files here.  This is useful if you</span></span><br><span class="line"><span class="comment"># have a standard template that goes to all Redis servers but also need</span></span><br><span class="line"><span class="comment"># to customize a few per-server settings.  Include files can include</span></span><br><span class="line"><span class="comment"># other files, so use this wisely.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Note that option &quot;include&quot; won&#x27;t be rewritten by command &quot;CONFIG REWRITE&quot;</span></span><br><span class="line"><span class="comment"># from admin or Redis Sentinel. Since Redis always uses the last processed</span></span><br><span class="line"><span class="comment"># line as value of a configuration directive, you&#x27;d better put includes</span></span><br><span class="line"><span class="comment"># at the beginning of this file to avoid overwriting config change at runtime.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If instead you are interested in using includes to override configuration</span></span><br><span class="line"><span class="comment"># options, it is better to use include as the last line.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># include /path/to/local.conf</span></span><br><span class="line"><span class="comment"># include /path/to/other.conf</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################################## MODULES #####################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Load modules at startup. If the server is not able to load modules</span></span><br><span class="line"><span class="comment"># it will abort. It is possible to use multiple loadmodule directives.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># loadmodule /path/to/my_module.so</span></span><br><span class="line"><span class="comment"># loadmodule /path/to/other_module.so</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># =&gt; 网络配置</span></span><br><span class="line"><span class="comment">################################## NETWORK #####################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># By default, if no &quot;bind&quot; configuration directive is specified, Redis listens</span></span><br><span class="line"><span class="comment"># for connections from all available network interfaces on the host machine.</span></span><br><span class="line"><span class="comment"># It is possible to listen to just one or multiple selected interfaces using</span></span><br><span class="line"><span class="comment"># the &quot;bind&quot; configuration directive, followed by one or more IP addresses.</span></span><br><span class="line"><span class="comment"># Each address can be prefixed by &quot;-&quot;, which means that redis will not fail to</span></span><br><span class="line"><span class="comment"># start if the address is not available. Being not available only refers to</span></span><br><span class="line"><span class="comment"># addresses that does not correspond to any network interfece. Addresses that</span></span><br><span class="line"><span class="comment"># are already in use will always fail, and unsupported protocols will always BE</span></span><br><span class="line"><span class="comment"># silently skipped.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Examples:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># bind 192.168.1.100 10.0.0.1     # listens on two specific IPv4 addresses</span></span><br><span class="line"><span class="comment"># bind 127.0.0.1 ::1              # listens on loopback IPv4 and IPv6</span></span><br><span class="line"><span class="comment"># bind * -::*                     # like the default, all available interfaces</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ~~~ WARNING ~~~ If the computer running Redis is directly exposed to the</span></span><br><span class="line"><span class="comment"># internet, binding to all the interfaces is dangerous and will expose the</span></span><br><span class="line"><span class="comment"># instance to everybody on the internet. So by default we uncomment the</span></span><br><span class="line"><span class="comment"># following bind directive, that will force Redis to listen only on the</span></span><br><span class="line"><span class="comment"># IPv4 and IPv6 (if available) loopback interface addresses (this means Redis</span></span><br><span class="line"><span class="comment"># will only be able to accept client connections from the same host that it is</span></span><br><span class="line"><span class="comment"># running on).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># IF YOU ARE SURE YOU WANT YOUR INSTANCE TO LISTEN TO ALL THE INTERFACES</span></span><br><span class="line"><span class="comment"># JUST COMMENT OUT THE FOLLOWING LINE.</span></span><br><span class="line"><span class="comment"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span></span><br><span class="line"><span class="comment"># =&gt; 绑定的IP:127.0.0.1只能是本地使用，如果需要提供给远程访问，需要设置为*统配或者指定IP</span></span><br><span class="line"><span class="built_in">bind</span> 0.0.0.0 -::1</span><br><span class="line"></span><br><span class="line"><span class="comment"># Protected mode is a layer of security protection, in order to avoid that</span></span><br><span class="line"><span class="comment"># Redis instances left open on the internet are accessed and exploited.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># When protected mode is on and if:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 1) The server is not binding explicitly to a set of addresses using the</span></span><br><span class="line"><span class="comment">#    &quot;bind&quot; directive.</span></span><br><span class="line"><span class="comment"># 2) No password is configured.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The server only accepts connections from clients connecting from the</span></span><br><span class="line"><span class="comment"># IPv4 and IPv6 loopback addresses 127.0.0.1 and ::1, and from Unix domain</span></span><br><span class="line"><span class="comment"># sockets.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># By default protected mode is enabled. You should disable it only if</span></span><br><span class="line"><span class="comment"># you are sure you want clients from other hosts to connect to Redis</span></span><br><span class="line"><span class="comment"># even if no authentication is configured, nor a specific set of interfaces</span></span><br><span class="line"><span class="comment"># are explicitly listed using the &quot;bind&quot; directive.</span></span><br><span class="line"><span class="comment"># =&gt; 是否受保护模式</span></span><br><span class="line">protected-mode yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># Accept connections on the specified port, default is 6379 (IANA #815344).</span></span><br><span class="line"><span class="comment"># If port 0 is specified Redis will not listen on a TCP socket.</span></span><br><span class="line"><span class="comment"># =&gt; 端口设置</span></span><br><span class="line">port 6379</span><br><span class="line"></span><br><span class="line"><span class="comment"># TCP listen() backlog.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># In high requests-per-second environments you need a high backlog in order</span></span><br><span class="line"><span class="comment"># to avoid slow clients connection issues. Note that the Linux kernel</span></span><br><span class="line"><span class="comment"># will silently truncate it to the value of /proc/sys/net/core/somaxconn so</span></span><br><span class="line"><span class="comment"># make sure to raise both the value of somaxconn and tcp_max_syn_backlog</span></span><br><span class="line"><span class="comment"># in order to get the desired effect.</span></span><br><span class="line">tcp-backlog 511</span><br><span class="line"></span><br><span class="line"><span class="comment"># Unix socket.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Specify the path for the Unix socket that will be used to listen for</span></span><br><span class="line"><span class="comment"># incoming connections. There is no default, so Redis will not listen</span></span><br><span class="line"><span class="comment"># on a unix socket when not specified.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># unixsocket /run/redis.sock</span></span><br><span class="line"><span class="comment"># unixsocketperm 700</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Close the connection after a client is idle for N seconds (0 to disable)</span></span><br><span class="line">timeout 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># TCP keepalive.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If non-zero, use SO_KEEPALIVE to send TCP ACKs to clients in absence</span></span><br><span class="line"><span class="comment"># of communication. This is useful for two reasons:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 1) Detect dead peers.</span></span><br><span class="line"><span class="comment"># 2) Force network equipment in the middle to consider the connection to be</span></span><br><span class="line"><span class="comment">#    alive.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># On Linux, the specified value (in seconds) is the period used to send ACKs.</span></span><br><span class="line"><span class="comment"># Note that to close the connection the double of the time is needed.</span></span><br><span class="line"><span class="comment"># On other kernels the period depends on the kernel configuration.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># A reasonable value for this option is 300 seconds, which is the new</span></span><br><span class="line"><span class="comment"># Redis default starting with Redis 3.2.1.</span></span><br><span class="line">tcp-keepalive 300</span><br><span class="line"></span><br><span class="line"><span class="comment">################################# TLS/SSL #####################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># By default, TLS/SSL is disabled. To enable it, the &quot;tls-port&quot; configuration</span></span><br><span class="line"><span class="comment"># directive can be used to define TLS-listening ports. To enable TLS on the</span></span><br><span class="line"><span class="comment"># default port, use:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># port 0</span></span><br><span class="line"><span class="comment"># tls-port 6379</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Configure a X.509 certificate and private key to use for authenticating the</span></span><br><span class="line"><span class="comment"># server to connected clients, masters or cluster peers.  These files should be</span></span><br><span class="line"><span class="comment"># PEM formatted.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># tls-cert-file redis.crt </span></span><br><span class="line"><span class="comment"># tls-key-file redis.key</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Normally Redis uses the same certificate for both server functions (accepting</span></span><br><span class="line"><span class="comment"># connections) and client functions (replicating from a master, establishing</span></span><br><span class="line"><span class="comment"># cluster bus connections, etc.).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Sometimes certificates are issued with attributes that designate them as</span></span><br><span class="line"><span class="comment"># client-only or server-only certificates. In that case it may be desired to use</span></span><br><span class="line"><span class="comment"># different certificates for incoming (server) and outgoing (client)</span></span><br><span class="line"><span class="comment"># connections. To do that, use the following directives:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># tls-client-cert-file client.crt</span></span><br><span class="line"><span class="comment"># tls-client-key-file client.key</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Configure a DH parameters file to enable Diffie-Hellman (DH) key exchange:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># tls-dh-params-file redis.dh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Configure a CA certificate(s) bundle or directory to authenticate TLS/SSL</span></span><br><span class="line"><span class="comment"># clients and peers.  Redis requires an explicit configuration of at least one</span></span><br><span class="line"><span class="comment"># of these, and will not implicitly use the system wide configuration.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># tls-ca-cert-file ca.crt</span></span><br><span class="line"><span class="comment"># tls-ca-cert-dir /etc/ssl/certs</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># By default, clients (including replica servers) on a TLS port are required</span></span><br><span class="line"><span class="comment"># to authenticate using valid client side certificates.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If &quot;no&quot; is specified, client certificates are not required and not accepted.</span></span><br><span class="line"><span class="comment"># If &quot;optional&quot; is specified, client certificates are accepted and must be</span></span><br><span class="line"><span class="comment"># valid if provided, but are not required.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># tls-auth-clients no</span></span><br><span class="line"><span class="comment"># tls-auth-clients optional</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># By default, a Redis replica does not attempt to establish a TLS connection</span></span><br><span class="line"><span class="comment"># with its master.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Use the following directive to enable TLS on replication links.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># tls-replication yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># By default, the Redis Cluster bus uses a plain TCP connection. To enable</span></span><br><span class="line"><span class="comment"># TLS for the bus protocol, use the following directive:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># tls-cluster yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># By default, only TLSv1.2 and TLSv1.3 are enabled and it is highly recommended</span></span><br><span class="line"><span class="comment"># that older formally deprecated versions are kept disabled to reduce the attack surface.</span></span><br><span class="line"><span class="comment"># You can explicitly specify TLS versions to support.</span></span><br><span class="line"><span class="comment"># Allowed values are case insensitive and include &quot;TLSv1&quot;, &quot;TLSv1.1&quot;, &quot;TLSv1.2&quot;,</span></span><br><span class="line"><span class="comment"># &quot;TLSv1.3&quot; (OpenSSL &gt;= 1.1.1) or any combination.</span></span><br><span class="line"><span class="comment"># To enable only TLSv1.2 and TLSv1.3, use:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># tls-protocols &quot;TLSv1.2 TLSv1.3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Configure allowed ciphers.  See the ciphers(1ssl) manpage for more information</span></span><br><span class="line"><span class="comment"># about the syntax of this string.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Note: this configuration applies only to &lt;= TLSv1.2.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># tls-ciphers DEFAULT:!MEDIUM</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Configure allowed TLSv1.3 ciphersuites.  See the ciphers(1ssl) manpage for more</span></span><br><span class="line"><span class="comment"># information about the syntax of this string, and specifically for TLSv1.3</span></span><br><span class="line"><span class="comment"># ciphersuites.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># tls-ciphersuites TLS_CHACHA20_POLY1305_SHA256</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># When choosing a cipher, use the server&#x27;s preference instead of the client</span></span><br><span class="line"><span class="comment"># preference. By default, the server follows the client&#x27;s preference.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># tls-prefer-server-ciphers yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># By default, TLS session caching is enabled to allow faster and less expensive</span></span><br><span class="line"><span class="comment"># reconnections by clients that support it. Use the following directive to disable</span></span><br><span class="line"><span class="comment"># caching.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># tls-session-caching no</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Change the default number of TLS sessions cached. A zero value sets the cache</span></span><br><span class="line"><span class="comment"># to unlimited size. The default size is 20480.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># tls-session-cache-size 5000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Change the default timeout of cached TLS sessions. The default timeout is 300</span></span><br><span class="line"><span class="comment"># seconds.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># tls-session-cache-timeout 60</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################################# GENERAL #####################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># By default Redis does not run as a daemon. Use &#x27;yes&#x27; if you need it.</span></span><br><span class="line"><span class="comment"># Note that Redis will write a pid file in /var/run/redis.pid when daemonized.</span></span><br><span class="line"><span class="comment"># When Redis is supervised by upstart or systemd, this parameter has no impact.</span></span><br><span class="line"><span class="comment"># =&gt; 是否以守护进程的方式运行，默认是no</span></span><br><span class="line">daemonize yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># If you run Redis from upstart or systemd, Redis can interact with your</span></span><br><span class="line"><span class="comment"># supervision tree. Options:</span></span><br><span class="line"><span class="comment">#   supervised no      - no supervision interaction</span></span><br><span class="line"><span class="comment">#   supervised upstart - signal upstart by putting Redis into SIGSTOP mode</span></span><br><span class="line"><span class="comment">#                        requires &quot;expect stop&quot; in your upstart job config</span></span><br><span class="line"><span class="comment">#   supervised systemd - signal systemd by writing READY=1 to $NOTIFY_SOCKET</span></span><br><span class="line"><span class="comment">#                        on startup, and updating Redis status on a regular</span></span><br><span class="line"><span class="comment">#                        basis.</span></span><br><span class="line"><span class="comment">#   supervised auto    - detect upstart or systemd method based on</span></span><br><span class="line"><span class="comment">#                        UPSTART_JOB or NOTIFY_SOCKET environment variables</span></span><br><span class="line"><span class="comment"># Note: these supervision methods only signal &quot;process is ready.&quot;</span></span><br><span class="line"><span class="comment">#       They do not enable continuous pings back to your supervisor.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The default is &quot;no&quot;. To run under upstart/systemd, you can simply uncomment</span></span><br><span class="line"><span class="comment"># the line below:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># supervised auto</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># If a pid file is specified, Redis writes it where specified at startup</span></span><br><span class="line"><span class="comment"># and removes it at exit.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># When the server runs non daemonized, no pid file is created if none is</span></span><br><span class="line"><span class="comment"># specified in the configuration. When the server is daemonized, the pid file</span></span><br><span class="line"><span class="comment"># is used even if not specified, defaulting to &quot;/var/run/redis.pid&quot;.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Creating a pid file is best effort: if Redis is not able to create it</span></span><br><span class="line"><span class="comment"># nothing bad happens, the server will start and run normally.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Note that on modern Linux systems &quot;/run/redis.pid&quot; is more conforming</span></span><br><span class="line"><span class="comment"># and should be used instead.</span></span><br><span class="line"><span class="comment"># =&gt; 如果以守护进程方式运行，需要指定一个守护进程的文件</span></span><br><span class="line">pidfile /var/run/redis_6379.pid</span><br><span class="line"></span><br><span class="line"><span class="comment"># Specify the server verbosity level.</span></span><br><span class="line"><span class="comment"># This can be one of:</span></span><br><span class="line"><span class="comment"># debug (a lot of information, useful for development/testing)</span></span><br><span class="line"><span class="comment"># verbose (many rarely useful info, but not a mess like the debug level)</span></span><br><span class="line"><span class="comment"># notice (moderately verbose, what you want in production probably)</span></span><br><span class="line"><span class="comment"># warning (only very important / critical messages are logged)</span></span><br><span class="line"><span class="comment"># =&gt; 设置日志级别</span></span><br><span class="line">loglevel notice</span><br><span class="line"></span><br><span class="line"><span class="comment"># Specify the log file name. Also the empty string can be used to force</span></span><br><span class="line"><span class="comment"># Redis to log on the standard output. Note that if you use standard</span></span><br><span class="line"><span class="comment"># output for logging but daemonize, logs will be sent to /dev/null</span></span><br><span class="line"><span class="comment"># =&gt; 设置日志的存储位置</span></span><br><span class="line">logfile <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># To enable logging to the system logger, just set &#x27;syslog-enabled&#x27; to yes,</span></span><br><span class="line"><span class="comment"># and optionally update the other syslog parameters to suit your needs.</span></span><br><span class="line"><span class="comment"># syslog-enabled no</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Specify the syslog identity.</span></span><br><span class="line"><span class="comment"># syslog-ident redis</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Specify the syslog facility. Must be USER or between LOCAL0-LOCAL7.</span></span><br><span class="line"><span class="comment"># syslog-facility local0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># To disable the built in crash log, which will possibly produce cleaner core</span></span><br><span class="line"><span class="comment"># dumps when they are needed, uncomment the following:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># crash-log-enabled no</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># To disable the fast memory check that&#x27;s run as part of the crash log, which</span></span><br><span class="line"><span class="comment"># will possibly let redis terminate sooner, uncomment the following:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># crash-memcheck-enabled no</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the number of databases. The default database is DB 0, you can select</span></span><br><span class="line"><span class="comment"># a different one on a per-connection basis using SELECT &lt;dbid&gt; where</span></span><br><span class="line"><span class="comment"># dbid is a number between 0 and &#x27;databases&#x27;-1</span></span><br><span class="line"><span class="comment"># =&gt; 默认数据库数量</span></span><br><span class="line">databases 16</span><br><span class="line"></span><br><span class="line"><span class="comment"># By default Redis shows an ASCII art logo only when started to log to the</span></span><br><span class="line"><span class="comment"># standard output and if the standard output is a TTY and syslog logging is</span></span><br><span class="line"><span class="comment"># disabled. Basically this means that normally a logo is displayed only in</span></span><br><span class="line"><span class="comment"># interactive sessions.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># However it is possible to force the pre-4.0 behavior and always show a</span></span><br><span class="line"><span class="comment"># ASCII art logo in startup logs by setting the following option to yes.</span></span><br><span class="line"><span class="comment"># =&gt; 是否总是显示Logo</span></span><br><span class="line">always-show-logo no</span><br><span class="line"></span><br><span class="line"><span class="comment"># By default, Redis modifies the process title (as seen in &#x27;top&#x27; and &#x27;ps&#x27;) to</span></span><br><span class="line"><span class="comment"># provide some runtime information. It is possible to disable this and leave</span></span><br><span class="line"><span class="comment"># the process name as executed by setting the following to no.</span></span><br><span class="line">set-proc-title yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># When changing the process title, Redis uses the following template to construct</span></span><br><span class="line"><span class="comment"># the modified title.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Template variables are specified in curly brackets. The following variables are</span></span><br><span class="line"><span class="comment"># supported:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># &#123;title&#125;           Name of process as executed if parent, or type of child process.</span></span><br><span class="line"><span class="comment"># &#123;listen-addr&#125;     Bind address or &#x27;*&#x27; followed by TCP or TLS port listening on, or</span></span><br><span class="line"><span class="comment">#                   Unix socket if only that&#x27;s available.</span></span><br><span class="line"><span class="comment"># &#123;server-mode&#125;     Special mode, i.e. &quot;[sentinel]&quot; or &quot;[cluster]&quot;.</span></span><br><span class="line"><span class="comment"># &#123;port&#125;            TCP port listening on, or 0.</span></span><br><span class="line"><span class="comment"># &#123;tls-port&#125;        TLS port listening on, or 0.</span></span><br><span class="line"><span class="comment"># &#123;unixsocket&#125;      Unix domain socket listening on, or &quot;&quot;.</span></span><br><span class="line"><span class="comment"># &#123;config-file&#125;     Name of configuration file used.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">proc-title-template <span class="string">&quot;&#123;title&#125; &#123;listen-addr&#125; &#123;server-mode&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################################ SNAPSHOTTING  ################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Save the DB to disk.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># save &lt;seconds&gt; &lt;changes&gt;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Redis will save the DB if both the given number of seconds and the given</span></span><br><span class="line"><span class="comment"># number of write operations against the DB occurred.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Snapshotting can be completely disabled with a single empty string argument</span></span><br><span class="line"><span class="comment"># as in following example:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># save &quot;&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Unless specified otherwise, by default Redis will save the DB:</span></span><br><span class="line"><span class="comment">#   * After 3600 seconds (an hour) if at least 1 key changed</span></span><br><span class="line"><span class="comment">#   * After 300 seconds (5 minutes) if at least 100 keys changed</span></span><br><span class="line"><span class="comment">#   * After 60 seconds if at least 10000 keys changed</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># You can set these explicitly by uncommenting the three following lines.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># =&gt; 快照持久化规则设置</span></span><br><span class="line"><span class="comment"># =&gt; 如果3600秒内，至少一个Key进行了修改，就会进行持久化</span></span><br><span class="line"><span class="comment"># save 3600 1</span></span><br><span class="line"><span class="comment"># save 300 100</span></span><br><span class="line"><span class="comment"># save 60 10000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># By default Redis will stop accepting writes if RDB snapshots are enabled</span></span><br><span class="line"><span class="comment"># (at least one save point) and the latest background save failed.</span></span><br><span class="line"><span class="comment"># This will make the user aware (in a hard way) that data is not persisting</span></span><br><span class="line"><span class="comment"># on disk properly, otherwise chances are that no one will notice and some</span></span><br><span class="line"><span class="comment"># disaster will happen.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If the background saving process will start working again Redis will</span></span><br><span class="line"><span class="comment"># automatically allow writes again.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># However if you have setup your proper monitoring of the Redis server</span></span><br><span class="line"><span class="comment"># and persistence, you may want to disable this feature so that Redis will</span></span><br><span class="line"><span class="comment"># continue to work as usual even if there are problems with disk,</span></span><br><span class="line"><span class="comment"># permissions, and so forth.</span></span><br><span class="line"><span class="comment"># =&gt; 持久化出错时，是否继续工作</span></span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># Compress string objects using LZF when dump .rdb databases?</span></span><br><span class="line"><span class="comment"># By default compression is enabled as it&#x27;s almost always a win.</span></span><br><span class="line"><span class="comment"># If you want to save some CPU in the saving child set it to &#x27;no&#x27; but</span></span><br><span class="line"><span class="comment"># the dataset will likely be bigger if you have compressible values or keys.</span></span><br><span class="line"><span class="comment"># =&gt; 是否压缩rdb文件；压缩是需要耗费一些CPU资源的</span></span><br><span class="line">rdbcompression yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># Since version 5 of RDB a CRC64 checksum is placed at the end of the file.</span></span><br><span class="line"><span class="comment"># This makes the format more resistant to corruption but there is a performance</span></span><br><span class="line"><span class="comment"># hit to pay (around 10%) when saving and loading RDB files, so you can disable it</span></span><br><span class="line"><span class="comment"># for maximum performances.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># RDB files created with checksum disabled have a checksum of zero that will</span></span><br><span class="line"><span class="comment"># tell the loading code to skip the check.</span></span><br><span class="line"><span class="comment"># =&gt; 保存rdb文件时，是否校验rdb文件</span></span><br><span class="line">rdbchecksum yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># Enables or disables full sanitation checks for ziplist and listpack etc when</span></span><br><span class="line"><span class="comment"># loading an RDB or RESTORE payload. This reduces the chances of a assertion or</span></span><br><span class="line"><span class="comment"># crash later on while processing commands.</span></span><br><span class="line"><span class="comment"># Options:</span></span><br><span class="line"><span class="comment">#   no         - Never perform full sanitation</span></span><br><span class="line"><span class="comment">#   yes        - Always perform full sanitation</span></span><br><span class="line"><span class="comment">#   clients    - Perform full sanitation only for user connections.</span></span><br><span class="line"><span class="comment">#                Excludes: RDB files, RESTORE commands received from the master</span></span><br><span class="line"><span class="comment">#                connection, and client connections which have the</span></span><br><span class="line"><span class="comment">#                skip-sanitize-payload ACL flag.</span></span><br><span class="line"><span class="comment"># The default should be &#x27;clients&#x27; but since it currently affects cluster</span></span><br><span class="line"><span class="comment"># resharding via MIGRATE, it is temporarily set to &#x27;no&#x27; by default.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># sanitize-dump-payload no</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The filename where to dump the DB</span></span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line"><span class="comment"># Remove RDB files used by replication in instances without persistence</span></span><br><span class="line"><span class="comment"># enabled. By default this option is disabled, however there are environments</span></span><br><span class="line"><span class="comment"># where for regulations or other security concerns, RDB files persisted on</span></span><br><span class="line"><span class="comment"># disk by masters in order to feed replicas, or stored on disk by replicas</span></span><br><span class="line"><span class="comment"># in order to load them for the initial synchronization, should be deleted</span></span><br><span class="line"><span class="comment"># ASAP. Note that this option ONLY WORKS in instances that have both AOF</span></span><br><span class="line"><span class="comment"># and RDB persistence disabled, otherwise is completely ignored.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># An alternative (and sometimes better) way to obtain the same effect is</span></span><br><span class="line"><span class="comment"># to use diskless replication on both master and replicas instances. However</span></span><br><span class="line"><span class="comment"># in the case of replicas, diskless is not always an option.</span></span><br><span class="line">rdb-del-sync-files no</span><br><span class="line"></span><br><span class="line"><span class="comment"># The working directory.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The DB will be written inside this directory, with the filename specified</span></span><br><span class="line"><span class="comment"># above using the &#x27;dbfilename&#x27; configuration directive.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The Append Only File will also be created inside this directory.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Note that you must specify a directory here, not a file name.</span></span><br><span class="line"><span class="comment"># =&gt; rdb文件保存目录</span></span><br><span class="line">dir ./</span><br><span class="line"></span><br><span class="line"><span class="comment">################################# REPLICATION #################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Master-Replica replication. Use replicaof to make a Redis instance a copy of</span></span><br><span class="line"><span class="comment"># another Redis server. A few things to understand ASAP about Redis replication.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   +------------------+      +---------------+</span></span><br><span class="line"><span class="comment">#   |      Master      | ---&gt; |    Replica    |</span></span><br><span class="line"><span class="comment">#   | (receive writes) |      |  (exact copy) |</span></span><br><span class="line"><span class="comment">#   +------------------+      +---------------+</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 1) Redis replication is asynchronous, but you can configure a master to</span></span><br><span class="line"><span class="comment">#    stop accepting writes if it appears to be not connected with at least</span></span><br><span class="line"><span class="comment">#    a given number of replicas.</span></span><br><span class="line"><span class="comment"># 2) Redis replicas are able to perform a partial resynchronization with the</span></span><br><span class="line"><span class="comment">#    master if the replication link is lost for a relatively small amount of</span></span><br><span class="line"><span class="comment">#    time. You may want to configure the replication backlog size (see the next</span></span><br><span class="line"><span class="comment">#    sections of this file) with a sensible value depending on your needs.</span></span><br><span class="line"><span class="comment"># 3) Replication is automatic and does not need user intervention. After a</span></span><br><span class="line"><span class="comment">#    network partition replicas automatically try to reconnect to masters</span></span><br><span class="line"><span class="comment">#    and resynchronize with them.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># replicaof &lt;masterip&gt; &lt;masterport&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># If the master is password protected (using the &quot;requirepass&quot; configuration</span></span><br><span class="line"><span class="comment"># directive below) it is possible to tell the replica to authenticate before</span></span><br><span class="line"><span class="comment"># starting the replication synchronization process, otherwise the master will</span></span><br><span class="line"><span class="comment"># refuse the replica request.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># masterauth &lt;master-password&gt;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># However this is not enough if you are using Redis ACLs (for Redis version</span></span><br><span class="line"><span class="comment"># 6 or greater), and the default user is not capable of running the PSYNC</span></span><br><span class="line"><span class="comment"># command and/or other commands needed for replication. In this case it&#x27;s</span></span><br><span class="line"><span class="comment"># better to configure a special user to use with replication, and specify the</span></span><br><span class="line"><span class="comment"># masteruser configuration as such:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># masteruser &lt;username&gt;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># When masteruser is specified, the replica will authenticate against its</span></span><br><span class="line"><span class="comment"># master using the new AUTH form: AUTH &lt;username&gt; &lt;password&gt;.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># When a replica loses its connection with the master, or when the replication</span></span><br><span class="line"><span class="comment"># is still in progress, the replica can act in two different ways:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 1) if replica-serve-stale-data is set to &#x27;yes&#x27; (the default) the replica will</span></span><br><span class="line"><span class="comment">#    still reply to client requests, possibly with out of date data, or the</span></span><br><span class="line"><span class="comment">#    data set may just be empty if this is the first synchronization.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 2) If replica-serve-stale-data is set to &#x27;no&#x27; the replica will reply with</span></span><br><span class="line"><span class="comment">#    an error &quot;SYNC with master in progress&quot; to all commands except:</span></span><br><span class="line"><span class="comment">#    INFO, REPLICAOF, AUTH, PING, SHUTDOWN, REPLCONF, ROLE, CONFIG, SUBSCRIBE,</span></span><br><span class="line"><span class="comment">#    UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, PUBLISH, PUBSUB, COMMAND, POST,</span></span><br><span class="line"><span class="comment">#    HOST and LATENCY.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">replica-serve-stale-data yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># You can configure a replica instance to accept writes or not. Writing against</span></span><br><span class="line"><span class="comment"># a replica instance may be useful to store some ephemeral data (because data</span></span><br><span class="line"><span class="comment"># written on a replica will be easily deleted after resync with the master) but</span></span><br><span class="line"><span class="comment"># may also cause problems if clients are writing to it because of a</span></span><br><span class="line"><span class="comment"># misconfiguration.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Since Redis 2.6 by default replicas are read-only.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Note: read only replicas are not designed to be exposed to untrusted clients</span></span><br><span class="line"><span class="comment"># on the internet. It&#x27;s just a protection layer against misuse of the instance.</span></span><br><span class="line"><span class="comment"># Still a read only replica exports by default all the administrative commands</span></span><br><span class="line"><span class="comment"># such as CONFIG, DEBUG, and so forth. To a limited extent you can improve</span></span><br><span class="line"><span class="comment"># security of read only replicas using &#x27;rename-command&#x27; to shadow all the</span></span><br><span class="line"><span class="comment"># administrative / dangerous commands.</span></span><br><span class="line">replica-read-only yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># Replication SYNC strategy: disk or socket.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># New replicas and reconnecting replicas that are not able to continue the</span></span><br><span class="line"><span class="comment"># replication process just receiving differences, need to do what is called a</span></span><br><span class="line"><span class="comment"># &quot;full synchronization&quot;. An RDB file is transmitted from the master to the</span></span><br><span class="line"><span class="comment"># replicas.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The transmission can happen in two different ways:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 1) Disk-backed: The Redis master creates a new process that writes the RDB</span></span><br><span class="line"><span class="comment">#                 file on disk. Later the file is transferred by the parent</span></span><br><span class="line"><span class="comment">#                 process to the replicas incrementally.</span></span><br><span class="line"><span class="comment"># 2) Diskless: The Redis master creates a new process that directly writes the</span></span><br><span class="line"><span class="comment">#              RDB file to replica sockets, without touching the disk at all.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># With disk-backed replication, while the RDB file is generated, more replicas</span></span><br><span class="line"><span class="comment"># can be queued and served with the RDB file as soon as the current child</span></span><br><span class="line"><span class="comment"># producing the RDB file finishes its work. With diskless replication instead</span></span><br><span class="line"><span class="comment"># once the transfer starts, new replicas arriving will be queued and a new</span></span><br><span class="line"><span class="comment"># transfer will start when the current one terminates.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># When diskless replication is used, the master waits a configurable amount of</span></span><br><span class="line"><span class="comment"># time (in seconds) before starting the transfer in the hope that multiple</span></span><br><span class="line"><span class="comment"># replicas will arrive and the transfer can be parallelized.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># With slow disks and fast (large bandwidth) networks, diskless replication</span></span><br><span class="line"><span class="comment"># works better.</span></span><br><span class="line">repl-diskless-sync no</span><br><span class="line"></span><br><span class="line"><span class="comment"># When diskless replication is enabled, it is possible to configure the delay</span></span><br><span class="line"><span class="comment"># the server waits in order to spawn the child that transfers the RDB via socket</span></span><br><span class="line"><span class="comment"># to the replicas.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This is important since once the transfer starts, it is not possible to serve</span></span><br><span class="line"><span class="comment"># new replicas arriving, that will be queued for the next RDB transfer, so the</span></span><br><span class="line"><span class="comment"># server waits a delay in order to let more replicas arrive.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The delay is specified in seconds, and by default is 5 seconds. To disable</span></span><br><span class="line"><span class="comment"># it entirely just set it to 0 seconds and the transfer will start ASAP.</span></span><br><span class="line">repl-diskless-sync-delay 5</span><br><span class="line"></span><br><span class="line"><span class="comment"># -----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># WARNING: RDB diskless load is experimental. Since in this setup the replica</span></span><br><span class="line"><span class="comment"># does not immediately store an RDB on disk, it may cause data loss during</span></span><br><span class="line"><span class="comment"># failovers. RDB diskless load + Redis modules not handling I/O reads may also</span></span><br><span class="line"><span class="comment"># cause Redis to abort in case of I/O errors during the initial synchronization</span></span><br><span class="line"><span class="comment"># stage with the master. Use only if you know what you are doing.</span></span><br><span class="line"><span class="comment"># -----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Replica can load the RDB it reads from the replication link directly from the</span></span><br><span class="line"><span class="comment"># socket, or store the RDB to a file and read that file after it was completely</span></span><br><span class="line"><span class="comment"># received from the master.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># In many cases the disk is slower than the network, and storing and loading</span></span><br><span class="line"><span class="comment"># the RDB file may increase replication time (and even increase the master&#x27;s</span></span><br><span class="line"><span class="comment"># Copy on Write memory and salve buffers).</span></span><br><span class="line"><span class="comment"># However, parsing the RDB file directly from the socket may mean that we have</span></span><br><span class="line"><span class="comment"># to flush the contents of the current database before the full rdb was</span></span><br><span class="line"><span class="comment"># received. For this reason we have the following options:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># &quot;disabled&quot;    - Don&#x27;t use diskless load (store the rdb file to the disk first)</span></span><br><span class="line"><span class="comment"># &quot;on-empty-db&quot; - Use diskless load only when it is completely safe.</span></span><br><span class="line"><span class="comment"># &quot;swapdb&quot;      - Keep a copy of the current db contents in RAM while parsing</span></span><br><span class="line"><span class="comment">#                 the data directly from the socket. note that this requires</span></span><br><span class="line"><span class="comment">#                 sufficient memory, if you don&#x27;t have it, you risk an OOM kill.</span></span><br><span class="line">repl-diskless-load disabled</span><br><span class="line"></span><br><span class="line"><span class="comment"># Replicas send PINGs to server in a predefined interval. It&#x27;s possible to</span></span><br><span class="line"><span class="comment"># change this interval with the repl_ping_replica_period option. The default</span></span><br><span class="line"><span class="comment"># value is 10 seconds.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># repl-ping-replica-period 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The following option sets the replication timeout for:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 1) Bulk transfer I/O during SYNC, from the point of view of replica.</span></span><br><span class="line"><span class="comment"># 2) Master timeout from the point of view of replicas (data, pings).</span></span><br><span class="line"><span class="comment"># 3) Replica timeout from the point of view of masters (REPLCONF ACK pings).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># It is important to make sure that this value is greater than the value</span></span><br><span class="line"><span class="comment"># specified for repl-ping-replica-period otherwise a timeout will be detected</span></span><br><span class="line"><span class="comment"># every time there is low traffic between the master and the replica. The default</span></span><br><span class="line"><span class="comment"># value is 60 seconds.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># repl-timeout 60</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Disable TCP_NODELAY on the replica socket after SYNC?</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If you select &quot;yes&quot; Redis will use a smaller number of TCP packets and</span></span><br><span class="line"><span class="comment"># less bandwidth to send data to replicas. But this can add a delay for</span></span><br><span class="line"><span class="comment"># the data to appear on the replica side, up to 40 milliseconds with</span></span><br><span class="line"><span class="comment"># Linux kernels using a default configuration.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If you select &quot;no&quot; the delay for data to appear on the replica side will</span></span><br><span class="line"><span class="comment"># be reduced but more bandwidth will be used for replication.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># By default we optimize for low latency, but in very high traffic conditions</span></span><br><span class="line"><span class="comment"># or when the master and replicas are many hops away, turning this to &quot;yes&quot; may</span></span><br><span class="line"><span class="comment"># be a good idea.</span></span><br><span class="line">repl-disable-tcp-nodelay no</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the replication backlog size. The backlog is a buffer that accumulates</span></span><br><span class="line"><span class="comment"># replica data when replicas are disconnected for some time, so that when a</span></span><br><span class="line"><span class="comment"># replica wants to reconnect again, often a full resync is not needed, but a</span></span><br><span class="line"><span class="comment"># partial resync is enough, just passing the portion of data the replica</span></span><br><span class="line"><span class="comment"># missed while disconnected.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The bigger the replication backlog, the longer the replica can endure the</span></span><br><span class="line"><span class="comment"># disconnect and later be able to perform a partial resynchronization.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The backlog is only allocated if there is at least one replica connected.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># repl-backlog-size 1mb</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># After a master has no connected replicas for some time, the backlog will be</span></span><br><span class="line"><span class="comment"># freed. The following option configures the amount of seconds that need to</span></span><br><span class="line"><span class="comment"># elapse, starting from the time the last replica disconnected, for the backlog</span></span><br><span class="line"><span class="comment"># buffer to be freed.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Note that replicas never free the backlog for timeout, since they may be</span></span><br><span class="line"><span class="comment"># promoted to masters later, and should be able to correctly &quot;partially</span></span><br><span class="line"><span class="comment"># resynchronize&quot; with other replicas: hence they should always accumulate backlog.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># A value of 0 means to never release the backlog.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># repl-backlog-ttl 3600</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The replica priority is an integer number published by Redis in the INFO</span></span><br><span class="line"><span class="comment"># output. It is used by Redis Sentinel in order to select a replica to promote</span></span><br><span class="line"><span class="comment"># into a master if the master is no longer working correctly.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># A replica with a low priority number is considered better for promotion, so</span></span><br><span class="line"><span class="comment"># for instance if there are three replicas with priority 10, 100, 25 Sentinel</span></span><br><span class="line"><span class="comment"># will pick the one with priority 10, that is the lowest.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># However a special priority of 0 marks the replica as not able to perform the</span></span><br><span class="line"><span class="comment"># role of master, so a replica with priority of 0 will never be selected by</span></span><br><span class="line"><span class="comment"># Redis Sentinel for promotion.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># By default the priority is 100.</span></span><br><span class="line">replica-priority 100</span><br><span class="line"></span><br><span class="line"><span class="comment"># It is possible for a master to stop accepting writes if there are less than</span></span><br><span class="line"><span class="comment"># N replicas connected, having a lag less or equal than M seconds.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The N replicas need to be in &quot;online&quot; state.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The lag in seconds, that must be &lt;= the specified value, is calculated from</span></span><br><span class="line"><span class="comment"># the last ping received from the replica, that is usually sent every second.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This option does not GUARANTEE that N replicas will accept the write, but</span></span><br><span class="line"><span class="comment"># will limit the window of exposure for lost writes in case not enough replicas</span></span><br><span class="line"><span class="comment"># are available, to the specified number of seconds.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># For example to require at least 3 replicas with a lag &lt;= 10 seconds use:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># min-replicas-to-write 3</span></span><br><span class="line"><span class="comment"># min-replicas-max-lag 10</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Setting one or the other to 0 disables the feature.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># By default min-replicas-to-write is set to 0 (feature disabled) and</span></span><br><span class="line"><span class="comment"># min-replicas-max-lag is set to 10.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># A Redis master is able to list the address and port of the attached</span></span><br><span class="line"><span class="comment"># replicas in different ways. For example the &quot;INFO replication&quot; section</span></span><br><span class="line"><span class="comment"># offers this information, which is used, among other tools, by</span></span><br><span class="line"><span class="comment"># Redis Sentinel in order to discover replica instances.</span></span><br><span class="line"><span class="comment"># Another place where this info is available is in the output of the</span></span><br><span class="line"><span class="comment"># &quot;ROLE&quot; command of a master.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The listed IP address and port normally reported by a replica is</span></span><br><span class="line"><span class="comment"># obtained in the following way:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   IP: The address is auto detected by checking the peer address</span></span><br><span class="line"><span class="comment">#   of the socket used by the replica to connect with the master.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   Port: The port is communicated by the replica during the replication</span></span><br><span class="line"><span class="comment">#   handshake, and is normally the port that the replica is using to</span></span><br><span class="line"><span class="comment">#   listen for connections.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># However when port forwarding or Network Address Translation (NAT) is</span></span><br><span class="line"><span class="comment"># used, the replica may actually be reachable via different IP and port</span></span><br><span class="line"><span class="comment"># pairs. The following two options can be used by a replica in order to</span></span><br><span class="line"><span class="comment"># report to its master a specific set of IP and port, so that both INFO</span></span><br><span class="line"><span class="comment"># and ROLE will report those values.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># There is no need to use both the options if you need to override just</span></span><br><span class="line"><span class="comment"># the port or the IP address.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># replica-announce-ip 5.5.5.5</span></span><br><span class="line"><span class="comment"># replica-announce-port 1234</span></span><br><span class="line"></span><br><span class="line"><span class="comment">############################### KEYS TRACKING #################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Redis implements server assisted support for client side caching of values.</span></span><br><span class="line"><span class="comment"># This is implemented using an invalidation table that remembers, using</span></span><br><span class="line"><span class="comment"># a radix key indexed by key name, what clients have which keys. In turn</span></span><br><span class="line"><span class="comment"># this is used in order to send invalidation messages to clients. Please</span></span><br><span class="line"><span class="comment"># check this page to understand more about the feature:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   https://redis.io/topics/client-side-caching</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># When tracking is enabled for a client, all the read only queries are assumed</span></span><br><span class="line"><span class="comment"># to be cached: this will force Redis to store information in the invalidation</span></span><br><span class="line"><span class="comment"># table. When keys are modified, such information is flushed away, and</span></span><br><span class="line"><span class="comment"># invalidation messages are sent to the clients. However if the workload is</span></span><br><span class="line"><span class="comment"># heavily dominated by reads, Redis could use more and more memory in order</span></span><br><span class="line"><span class="comment"># to track the keys fetched by many clients.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># For this reason it is possible to configure a maximum fill value for the</span></span><br><span class="line"><span class="comment"># invalidation table. By default it is set to 1M of keys, and once this limit</span></span><br><span class="line"><span class="comment"># is reached, Redis will start to evict keys in the invalidation table</span></span><br><span class="line"><span class="comment"># even if they were not modified, just to reclaim memory: this will in turn</span></span><br><span class="line"><span class="comment"># force the clients to invalidate the cached values. Basically the table</span></span><br><span class="line"><span class="comment"># maximum size is a trade off between the memory you want to spend server</span></span><br><span class="line"><span class="comment"># side to track information about who cached what, and the ability of clients</span></span><br><span class="line"><span class="comment"># to retain cached objects in memory.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If you set the value to 0, it means there are no limits, and Redis will</span></span><br><span class="line"><span class="comment"># retain as many keys as needed in the invalidation table.</span></span><br><span class="line"><span class="comment"># In the &quot;stats&quot; INFO section, you can find information about the number of</span></span><br><span class="line"><span class="comment"># keys in the invalidation table at every given moment.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Note: when key tracking is used in broadcasting mode, no memory is used</span></span><br><span class="line"><span class="comment"># in the server side so this setting is useless.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># tracking-table-max-keys 1000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################################## SECURITY ###################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Warning: since Redis is pretty fast, an outside user can try up to</span></span><br><span class="line"><span class="comment"># 1 million passwords per second against a modern box. This means that you</span></span><br><span class="line"><span class="comment"># should use very strong passwords, otherwise they will be very easy to break.</span></span><br><span class="line"><span class="comment"># Note that because the password is really a shared secret between the client</span></span><br><span class="line"><span class="comment"># and the server, and should not be memorized by any human, the password</span></span><br><span class="line"><span class="comment"># can be easily a long string from /dev/urandom or whatever, so by using a</span></span><br><span class="line"><span class="comment"># long and unguessable password no brute force attack will be possible.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Redis ACL users are defined in the following format:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   user &lt;username&gt; ... acl rules ...</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># For example:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   user worker +@list +@connection ~jobs:* on &gt;ffa9203c493aa99</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The special username &quot;default&quot; is used for new connections. If this user</span></span><br><span class="line"><span class="comment"># has the &quot;nopass&quot; rule, then new connections will be immediately authenticated</span></span><br><span class="line"><span class="comment"># as the &quot;default&quot; user without the need of any password provided via the</span></span><br><span class="line"><span class="comment"># AUTH command. Otherwise if the &quot;default&quot; user is not flagged with &quot;nopass&quot;</span></span><br><span class="line"><span class="comment"># the connections will start in not authenticated state, and will require</span></span><br><span class="line"><span class="comment"># AUTH (or the HELLO command AUTH option) in order to be authenticated and</span></span><br><span class="line"><span class="comment"># start to work.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The ACL rules that describe what a user can do are the following:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  on           Enable the user: it is possible to authenticate as this user.</span></span><br><span class="line"><span class="comment">#  off          Disable the user: it&#x27;s no longer possible to authenticate</span></span><br><span class="line"><span class="comment">#               with this user, however the already authenticated connections</span></span><br><span class="line"><span class="comment">#               will still work.</span></span><br><span class="line"><span class="comment">#  skip-sanitize-payload    RESTORE dump-payload sanitation is skipped.</span></span><br><span class="line"><span class="comment">#  sanitize-payload         RESTORE dump-payload is sanitized (default).</span></span><br><span class="line"><span class="comment">#  +&lt;command&gt;   Allow the execution of that command</span></span><br><span class="line"><span class="comment">#  -&lt;command&gt;   Disallow the execution of that command</span></span><br><span class="line"><span class="comment">#  +@&lt;category&gt; Allow the execution of all the commands in such category</span></span><br><span class="line"><span class="comment">#               with valid categories are like @admin, @set, @sortedset, ...</span></span><br><span class="line"><span class="comment">#               and so forth, see the full list in the server.c file where</span></span><br><span class="line"><span class="comment">#               the Redis command table is described and defined.</span></span><br><span class="line"><span class="comment">#               The special category @all means all the commands, but currently</span></span><br><span class="line"><span class="comment">#               present in the server, and that will be loaded in the future</span></span><br><span class="line"><span class="comment">#               via modules.</span></span><br><span class="line"><span class="comment">#  +&lt;command&gt;|subcommand    Allow a specific subcommand of an otherwise</span></span><br><span class="line"><span class="comment">#                           disabled command. Note that this form is not</span></span><br><span class="line"><span class="comment">#                           allowed as negative like -DEBUG|SEGFAULT, but</span></span><br><span class="line"><span class="comment">#                           only additive starting with &quot;+&quot;.</span></span><br><span class="line"><span class="comment">#  allcommands  Alias for +@all. Note that it implies the ability to execute</span></span><br><span class="line"><span class="comment">#               all the future commands loaded via the modules system.</span></span><br><span class="line"><span class="comment">#  nocommands   Alias for -@all.</span></span><br><span class="line"><span class="comment">#  ~&lt;pattern&gt;   Add a pattern of keys that can be mentioned as part of</span></span><br><span class="line"><span class="comment">#               commands. For instance ~* allows all the keys. The pattern</span></span><br><span class="line"><span class="comment">#               is a glob-style pattern like the one of KEYS.</span></span><br><span class="line"><span class="comment">#               It is possible to specify multiple patterns.</span></span><br><span class="line"><span class="comment">#  allkeys      Alias for ~*</span></span><br><span class="line"><span class="comment">#  resetkeys    Flush the list of allowed keys patterns.</span></span><br><span class="line"><span class="comment">#  &amp;&lt;pattern&gt;   Add a glob-style pattern of Pub/Sub channels that can be</span></span><br><span class="line"><span class="comment">#               accessed by the user. It is possible to specify multiple channel</span></span><br><span class="line"><span class="comment">#               patterns.</span></span><br><span class="line"><span class="comment">#  allchannels  Alias for &amp;*</span></span><br><span class="line"><span class="comment">#  resetchannels            Flush the list of allowed channel patterns.</span></span><br><span class="line"><span class="comment">#  &gt;&lt;password&gt;  Add this password to the list of valid password for the user.</span></span><br><span class="line"><span class="comment">#               For example &gt;mypass will add &quot;mypass&quot; to the list.</span></span><br><span class="line"><span class="comment">#               This directive clears the &quot;nopass&quot; flag (see later).</span></span><br><span class="line"><span class="comment">#  &lt;&lt;password&gt;  Remove this password from the list of valid passwords.</span></span><br><span class="line"><span class="comment">#  nopass       All the set passwords of the user are removed, and the user</span></span><br><span class="line"><span class="comment">#               is flagged as requiring no password: it means that every</span></span><br><span class="line"><span class="comment">#               password will work against this user. If this directive is</span></span><br><span class="line"><span class="comment">#               used for the default user, every new connection will be</span></span><br><span class="line"><span class="comment">#               immediately authenticated with the default user without</span></span><br><span class="line"><span class="comment">#               any explicit AUTH command required. Note that the &quot;resetpass&quot;</span></span><br><span class="line"><span class="comment">#               directive will clear this condition.</span></span><br><span class="line"><span class="comment">#  resetpass    Flush the list of allowed passwords. Moreover removes the</span></span><br><span class="line"><span class="comment">#               &quot;nopass&quot; status. After &quot;resetpass&quot; the user has no associated</span></span><br><span class="line"><span class="comment">#               passwords and there is no way to authenticate without adding</span></span><br><span class="line"><span class="comment">#               some password (or setting it as &quot;nopass&quot; later).</span></span><br><span class="line"><span class="comment">#  reset        Performs the following actions: resetpass, resetkeys, off,</span></span><br><span class="line"><span class="comment">#               -@all. The user returns to the same state it has immediately</span></span><br><span class="line"><span class="comment">#               after its creation.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ACL rules can be specified in any order: for instance you can start with</span></span><br><span class="line"><span class="comment"># passwords, then flags, or key patterns. However note that the additive</span></span><br><span class="line"><span class="comment"># and subtractive rules will CHANGE MEANING depending on the ordering.</span></span><br><span class="line"><span class="comment"># For instance see the following example:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   user alice on +@all -DEBUG ~* &gt;somepassword</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This will allow &quot;alice&quot; to use all the commands with the exception of the</span></span><br><span class="line"><span class="comment"># DEBUG command, since +@all added all the commands to the set of the commands</span></span><br><span class="line"><span class="comment"># alice can use, and later DEBUG was removed. However if we invert the order</span></span><br><span class="line"><span class="comment"># of two ACL rules the result will be different:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   user alice on -DEBUG +@all ~* &gt;somepassword</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Now DEBUG was removed when alice had yet no commands in the set of allowed</span></span><br><span class="line"><span class="comment"># commands, later all the commands are added, so the user will be able to</span></span><br><span class="line"><span class="comment"># execute everything.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Basically ACL rules are processed left-to-right.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># For more information about ACL configuration please refer to</span></span><br><span class="line"><span class="comment"># the Redis web site at https://redis.io/topics/acl</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ACL LOG</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The ACL Log tracks failed commands and authentication events associated</span></span><br><span class="line"><span class="comment"># with ACLs. The ACL Log is useful to troubleshoot failed commands blocked </span></span><br><span class="line"><span class="comment"># by ACLs. The ACL Log is stored in memory. You can reclaim memory with </span></span><br><span class="line"><span class="comment"># ACL LOG RESET. Define the maximum entry length of the ACL Log below.</span></span><br><span class="line">acllog-max-len 128</span><br><span class="line"></span><br><span class="line"><span class="comment"># Using an external ACL file</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Instead of configuring users here in this file, it is possible to use</span></span><br><span class="line"><span class="comment"># a stand-alone file just listing users. The two methods cannot be mixed:</span></span><br><span class="line"><span class="comment"># if you configure users here and at the same time you activate the external</span></span><br><span class="line"><span class="comment"># ACL file, the server will refuse to start.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The format of the external ACL user file is exactly the same as the</span></span><br><span class="line"><span class="comment"># format that is used inside redis.conf to describe users.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># aclfile /etc/redis/users.acl</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># IMPORTANT <span class="doctag">NOTE:</span> starting with Redis 6 &quot;requirepass&quot; is just a compatibility</span></span><br><span class="line"><span class="comment"># layer on top of the new ACL system. The option effect will be just setting</span></span><br><span class="line"><span class="comment"># the password for the default user. Clients will still authenticate using</span></span><br><span class="line"><span class="comment"># AUTH &lt;password&gt; as usually, or more explicitly with AUTH default &lt;password&gt;</span></span><br><span class="line"><span class="comment"># if they follow the new protocol: both will work.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The requirepass is not compatable with aclfile option and the ACL LOAD</span></span><br><span class="line"><span class="comment"># command, these will cause requirepass to be ignored.</span></span><br><span class="line"><span class="comment"># =&gt; Redis默认没有密码；可以在这里设置密码</span></span><br><span class="line"><span class="comment"># requirepass wpl19950815</span></span><br><span class="line"><span class="comment"># requirepass foobared</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># New users are initialized with restrictive permissions by default, via the</span></span><br><span class="line"><span class="comment"># equivalent of this ACL rule &#x27;off resetkeys -@all&#x27;. Starting with Redis 6.2, it</span></span><br><span class="line"><span class="comment"># is possible to manage access to Pub/Sub channels with ACL rules as well. The</span></span><br><span class="line"><span class="comment"># default Pub/Sub channels permission if new users is controlled by the </span></span><br><span class="line"><span class="comment"># acl-pubsub-default configuration directive, which accepts one of these values:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># allchannels: grants access to all Pub/Sub channels</span></span><br><span class="line"><span class="comment"># resetchannels: revokes access to all Pub/Sub channels</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># To ensure backward compatibility while upgrading Redis 6.0, acl-pubsub-default</span></span><br><span class="line"><span class="comment"># defaults to the &#x27;allchannels&#x27; permission.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Future compatibility note: it is very likely that in a future version of Redis</span></span><br><span class="line"><span class="comment"># the directive&#x27;s default of &#x27;allchannels&#x27; will be changed to &#x27;resetchannels&#x27; in</span></span><br><span class="line"><span class="comment"># order to provide better out-of-the-box Pub/Sub security. Therefore, it is</span></span><br><span class="line"><span class="comment"># recommended that you explicitly define Pub/Sub permissions for all users</span></span><br><span class="line"><span class="comment"># rather then rely on implicit default values. Once you&#x27;ve set explicit</span></span><br><span class="line"><span class="comment"># Pub/Sub for all exisitn users, you should uncomment the following line.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># acl-pubsub-default resetchannels</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Command renaming (DEPRECATED).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># WARNING: avoid using this option if possible. Instead use ACLs to remove</span></span><br><span class="line"><span class="comment"># commands from the default user, and put them only in some admin user you</span></span><br><span class="line"><span class="comment"># create for administrative purposes.</span></span><br><span class="line"><span class="comment"># ------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># It is possible to change the name of dangerous commands in a shared</span></span><br><span class="line"><span class="comment"># environment. For instance the CONFIG command may be renamed into something</span></span><br><span class="line"><span class="comment"># hard to guess so that it will still be available for internal-use tools</span></span><br><span class="line"><span class="comment"># but not available for general clients.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Example:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># It is also possible to completely kill a command by renaming it into</span></span><br><span class="line"><span class="comment"># an empty string:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># rename-command CONFIG &quot;&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Please note that changing the name of commands that are logged into the</span></span><br><span class="line"><span class="comment"># AOF file or transmitted to replicas may cause problems.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################################### CLIENTS ####################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the max number of connected clients at the same time. By default</span></span><br><span class="line"><span class="comment"># this limit is set to 10000 clients, however if the Redis server is not</span></span><br><span class="line"><span class="comment"># able to configure the process file limit to allow for the specified limit</span></span><br><span class="line"><span class="comment"># the max number of allowed clients is set to the current file limit</span></span><br><span class="line"><span class="comment"># minus 32 (as Redis reserves a few file descriptors for internal uses).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Once the limit is reached Redis will close all the new connections sending</span></span><br><span class="line"><span class="comment"># an error &#x27;max number of clients reached&#x27;.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># IMPORTANT: When Redis Cluster is used, the max number of connections is also</span></span><br><span class="line"><span class="comment"># shared with the cluster bus: every node in the cluster will use two</span></span><br><span class="line"><span class="comment"># connections, one incoming and another outgoing. It is important to size the</span></span><br><span class="line"><span class="comment"># limit accordingly in case of very large clusters.</span></span><br><span class="line"><span class="comment"># =&gt; 限制client最大连接数</span></span><br><span class="line"><span class="comment"># maxclients 10000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">############################## MEMORY MANAGEMENT ################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set a memory usage limit to the specified amount of bytes.</span></span><br><span class="line"><span class="comment"># When the memory limit is reached Redis will try to remove keys</span></span><br><span class="line"><span class="comment"># according to the eviction policy selected (see maxmemory-policy).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If Redis can&#x27;t remove keys according to the policy, or if the policy is</span></span><br><span class="line"><span class="comment"># set to &#x27;noeviction&#x27;, Redis will start to reply with errors to commands</span></span><br><span class="line"><span class="comment"># that would use more memory, like SET, LPUSH, and so on, and will continue</span></span><br><span class="line"><span class="comment"># to reply to read-only commands like GET.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This option is usually useful when using Redis as an LRU or LFU cache, or to</span></span><br><span class="line"><span class="comment"># set a hard memory limit for an instance (using the &#x27;noeviction&#x27; policy).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># WARNING: If you have replicas attached to an instance with maxmemory on,</span></span><br><span class="line"><span class="comment"># the size of the output buffers needed to feed the replicas are subtracted</span></span><br><span class="line"><span class="comment"># from the used memory count, so that network problems / resyncs will</span></span><br><span class="line"><span class="comment"># not trigger a loop where keys are evicted, and in turn the output</span></span><br><span class="line"><span class="comment"># buffer of replicas is full with DELs of keys evicted triggering the deletion</span></span><br><span class="line"><span class="comment"># of more keys, and so forth until the database is completely emptied.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># In short... if you have replicas attached it is suggested that you set a lower</span></span><br><span class="line"><span class="comment"># limit for maxmemory so that there is some free RAM on the system for replica</span></span><br><span class="line"><span class="comment"># output buffers (but this is not needed if the policy is &#x27;noeviction&#x27;).</span></span><br><span class="line"><span class="comment"># =&gt; 配置Redis最大内存容量;单位字节</span></span><br><span class="line"><span class="comment"># maxmemory &lt;bytes&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># MAXMEMORY POLICY: how Redis will select what to remove when maxmemory</span></span><br><span class="line"><span class="comment"># is reached. You can select one from the following behaviors:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># volatile-lru -&gt; Evict using approximated LRU, only keys with an expire set.</span></span><br><span class="line"><span class="comment"># allkeys-lru -&gt; Evict any key using approximated LRU.</span></span><br><span class="line"><span class="comment"># volatile-lfu -&gt; Evict using approximated LFU, only keys with an expire set.</span></span><br><span class="line"><span class="comment"># allkeys-lfu -&gt; Evict any key using approximated LFU.</span></span><br><span class="line"><span class="comment"># volatile-random -&gt; Remove a random key having an expire set.</span></span><br><span class="line"><span class="comment"># allkeys-random -&gt; Remove a random key, any key.</span></span><br><span class="line"><span class="comment"># volatile-ttl -&gt; Remove the key with the nearest expire time (minor TTL)</span></span><br><span class="line"><span class="comment"># noeviction -&gt; Don&#x27;t evict anything, just return an error on write operations.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># LRU means Least Recently Used</span></span><br><span class="line"><span class="comment"># LFU means Least Frequently Used</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Both LRU, LFU and volatile-ttl are implemented using approximated</span></span><br><span class="line"><span class="comment"># randomized algorithms.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Note: with any of the above policies, when there are no suitable keys for</span></span><br><span class="line"><span class="comment"># eviction, Redis will return an error on write operations that require</span></span><br><span class="line"><span class="comment"># more memory. These are usually commands that create new keys, add data or</span></span><br><span class="line"><span class="comment"># modify existing keys. A few examples are: SET, INCR, HSET, LPUSH, SUNIONSTORE,</span></span><br><span class="line"><span class="comment"># SORT (due to the STORE argument), and EXEC (if the transaction includes any</span></span><br><span class="line"><span class="comment"># command that requires memory).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The default is:</span></span><br><span class="line"><span class="comment"># =&gt; 内存到达上限的处理策略</span></span><br><span class="line"><span class="comment"># maxmemory-policy noeviction</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># LRU, LFU and minimal TTL algorithms are not precise algorithms but approximated</span></span><br><span class="line"><span class="comment"># algorithms (in order to save memory), so you can tune it for speed or</span></span><br><span class="line"><span class="comment"># accuracy. By default Redis will check five keys and pick the one that was</span></span><br><span class="line"><span class="comment"># used least recently, you can change the sample size using the following</span></span><br><span class="line"><span class="comment"># configuration directive.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The default of 5 produces good enough results. 10 Approximates very closely</span></span><br><span class="line"><span class="comment"># true LRU but costs more CPU. 3 is faster but not very accurate.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># maxmemory-samples 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Eviction processing is designed to function well with the default setting.</span></span><br><span class="line"><span class="comment"># If there is an unusually large amount of write traffic, this value may need to</span></span><br><span class="line"><span class="comment"># be increased.  Decreasing this value may reduce latency at the risk of </span></span><br><span class="line"><span class="comment"># eviction processing effectiveness</span></span><br><span class="line"><span class="comment">#   0 = minimum latency, 10 = default, 100 = process without regard to latency</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># maxmemory-eviction-tenacity 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Starting from Redis 5, by default a replica will ignore its maxmemory setting</span></span><br><span class="line"><span class="comment"># (unless it is promoted to master after a failover or manually). It means</span></span><br><span class="line"><span class="comment"># that the eviction of keys will be just handled by the master, sending the</span></span><br><span class="line"><span class="comment"># DEL commands to the replica as keys evict in the master side.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This behavior ensures that masters and replicas stay consistent, and is usually</span></span><br><span class="line"><span class="comment"># what you want, however if your replica is writable, or you want the replica</span></span><br><span class="line"><span class="comment"># to have a different memory setting, and you are sure all the writes performed</span></span><br><span class="line"><span class="comment"># to the replica are idempotent, then you may change this default (but be sure</span></span><br><span class="line"><span class="comment"># to understand what you are doing).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Note that since the replica by default does not evict, it may end using more</span></span><br><span class="line"><span class="comment"># memory than the one set via maxmemory (there are certain buffers that may</span></span><br><span class="line"><span class="comment"># be larger on the replica, or data structures may sometimes take more memory</span></span><br><span class="line"><span class="comment"># and so forth). So make sure you monitor your replicas and make sure they</span></span><br><span class="line"><span class="comment"># have enough memory to never hit a real out-of-memory condition before the</span></span><br><span class="line"><span class="comment"># master hits the configured maxmemory setting.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># replica-ignore-maxmemory yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Redis reclaims expired keys in two ways: upon access when those keys are</span></span><br><span class="line"><span class="comment"># found to be expired, and also in background, in what is called the</span></span><br><span class="line"><span class="comment"># &quot;active expire key&quot;. The key space is slowly and interactively scanned</span></span><br><span class="line"><span class="comment"># looking for expired keys to reclaim, so that it is possible to free memory</span></span><br><span class="line"><span class="comment"># of keys that are expired and will never be accessed again in a short time.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The default effort of the expire cycle will try to avoid having more than</span></span><br><span class="line"><span class="comment"># ten percent of expired keys still in memory, and will try to avoid consuming</span></span><br><span class="line"><span class="comment"># more than 25% of total memory and to add latency to the system. However</span></span><br><span class="line"><span class="comment"># it is possible to increase the expire &quot;effort&quot; that is normally set to</span></span><br><span class="line"><span class="comment"># &quot;1&quot;, to a greater value, up to the value &quot;10&quot;. At its maximum value the</span></span><br><span class="line"><span class="comment"># system will use more CPU, longer cycles (and technically may introduce</span></span><br><span class="line"><span class="comment"># more latency), and will tolerate less already expired keys still present</span></span><br><span class="line"><span class="comment"># in the system. It&#x27;s a tradeoff between memory, CPU and latency.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># active-expire-effort 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">############################# LAZY FREEING ####################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Redis has two primitives to delete keys. One is called DEL and is a blocking</span></span><br><span class="line"><span class="comment"># deletion of the object. It means that the server stops processing new commands</span></span><br><span class="line"><span class="comment"># in order to reclaim all the memory associated with an object in a synchronous</span></span><br><span class="line"><span class="comment"># way. If the key deleted is associated with a small object, the time needed</span></span><br><span class="line"><span class="comment"># in order to execute the DEL command is very small and comparable to most other</span></span><br><span class="line"><span class="comment"># O(1) or O(log_N) commands in Redis. However if the key is associated with an</span></span><br><span class="line"><span class="comment"># aggregated value containing millions of elements, the server can block for</span></span><br><span class="line"><span class="comment"># a long time (even seconds) in order to complete the operation.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># For the above reasons Redis also offers non blocking deletion primitives</span></span><br><span class="line"><span class="comment"># such as UNLINK (non blocking DEL) and the ASYNC option of FLUSHALL and</span></span><br><span class="line"><span class="comment"># FLUSHDB commands, in order to reclaim memory in background. Those commands</span></span><br><span class="line"><span class="comment"># are executed in constant time. Another thread will incrementally free the</span></span><br><span class="line"><span class="comment"># object in the background as fast as possible.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># DEL, UNLINK and ASYNC option of FLUSHALL and FLUSHDB are user-controlled.</span></span><br><span class="line"><span class="comment"># It&#x27;s up to the design of the application to understand when it is a good</span></span><br><span class="line"><span class="comment"># idea to use one or the other. However the Redis server sometimes has to</span></span><br><span class="line"><span class="comment"># delete keys or flush the whole database as a side effect of other operations.</span></span><br><span class="line"><span class="comment"># Specifically Redis deletes objects independently of a user call in the</span></span><br><span class="line"><span class="comment"># following scenarios:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 1) On eviction, because of the maxmemory and maxmemory policy configurations,</span></span><br><span class="line"><span class="comment">#    in order to make room for new data, without going over the specified</span></span><br><span class="line"><span class="comment">#    memory limit.</span></span><br><span class="line"><span class="comment"># 2) Because of expire: when a key with an associated time to live (see the</span></span><br><span class="line"><span class="comment">#    EXPIRE command) must be deleted from memory.</span></span><br><span class="line"><span class="comment"># 3) Because of a side effect of a command that stores data on a key that may</span></span><br><span class="line"><span class="comment">#    already exist. For example the RENAME command may delete the old key</span></span><br><span class="line"><span class="comment">#    content when it is replaced with another one. Similarly SUNIONSTORE</span></span><br><span class="line"><span class="comment">#    or SORT with STORE option may delete existing keys. The SET command</span></span><br><span class="line"><span class="comment">#    itself removes any old content of the specified key in order to replace</span></span><br><span class="line"><span class="comment">#    it with the specified string.</span></span><br><span class="line"><span class="comment"># 4) During replication, when a replica performs a full resynchronization with</span></span><br><span class="line"><span class="comment">#    its master, the content of the whole database is removed in order to</span></span><br><span class="line"><span class="comment">#    load the RDB file just transferred.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># In all the above cases the default is to delete objects in a blocking way,</span></span><br><span class="line"><span class="comment"># like if DEL was called. However you can configure each case specifically</span></span><br><span class="line"><span class="comment"># in order to instead release memory in a non-blocking way like if UNLINK</span></span><br><span class="line"><span class="comment"># was called, using the following configuration directives.</span></span><br><span class="line"></span><br><span class="line">lazyfree-lazy-eviction no</span><br><span class="line">lazyfree-lazy-expire no</span><br><span class="line">lazyfree-lazy-server-del no</span><br><span class="line">replica-lazy-flush no</span><br><span class="line"></span><br><span class="line"><span class="comment"># It is also possible, for the case when to replace the user code DEL calls</span></span><br><span class="line"><span class="comment"># with UNLINK calls is not easy, to modify the default behavior of the DEL</span></span><br><span class="line"><span class="comment"># command to act exactly like UNLINK, using the following configuration</span></span><br><span class="line"><span class="comment"># directive:</span></span><br><span class="line"></span><br><span class="line">lazyfree-lazy-user-del no</span><br><span class="line"></span><br><span class="line"><span class="comment"># FLUSHDB, FLUSHALL, and SCRIPT FLUSH support both asynchronous and synchronous</span></span><br><span class="line"><span class="comment"># deletion, which can be controlled by passing the [SYNC|ASYNC] flags into the</span></span><br><span class="line"><span class="comment"># commands. When neither flag is passed, this directive will be used to determine</span></span><br><span class="line"><span class="comment"># if the data should be deleted asynchronously.</span></span><br><span class="line"></span><br><span class="line">lazyfree-lazy-user-flush no</span><br><span class="line"></span><br><span class="line"><span class="comment">################################ THREADED I/O #################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Redis is mostly single threaded, however there are certain threaded</span></span><br><span class="line"><span class="comment"># operations such as UNLINK, slow I/O accesses and other things that are</span></span><br><span class="line"><span class="comment"># performed on side threads.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Now it is also possible to handle Redis clients socket reads and writes</span></span><br><span class="line"><span class="comment"># in different I/O threads. Since especially writing is so slow, normally</span></span><br><span class="line"><span class="comment"># Redis users use pipelining in order to speed up the Redis performances per</span></span><br><span class="line"><span class="comment"># core, and spawn multiple instances in order to scale more. Using I/O</span></span><br><span class="line"><span class="comment"># threads it is possible to easily speedup two times Redis without resorting</span></span><br><span class="line"><span class="comment"># to pipelining nor sharding of the instance.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># By default threading is disabled, we suggest enabling it only in machines</span></span><br><span class="line"><span class="comment"># that have at least 4 or more cores, leaving at least one spare core.</span></span><br><span class="line"><span class="comment"># Using more than 8 threads is unlikely to help much. We also recommend using</span></span><br><span class="line"><span class="comment"># threaded I/O only if you actually have performance problems, with Redis</span></span><br><span class="line"><span class="comment"># instances being able to use a quite big percentage of CPU time, otherwise</span></span><br><span class="line"><span class="comment"># there is no point in using this feature.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># So for instance if you have a four cores boxes, try to use 2 or 3 I/O</span></span><br><span class="line"><span class="comment"># threads, if you have a 8 cores, try to use 6 threads. In order to</span></span><br><span class="line"><span class="comment"># enable I/O threads use the following configuration directive:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># io-threads 4</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Setting io-threads to 1 will just use the main thread as usual.</span></span><br><span class="line"><span class="comment"># When I/O threads are enabled, we only use threads for writes, that is</span></span><br><span class="line"><span class="comment"># to thread the write(2) syscall and transfer the client buffers to the</span></span><br><span class="line"><span class="comment"># socket. However it is also possible to enable threading of reads and</span></span><br><span class="line"><span class="comment"># protocol parsing using the following configuration directive, by setting</span></span><br><span class="line"><span class="comment"># it to yes:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># io-threads-do-reads no</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Usually threading reads doesn&#x27;t help much.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># NOTE 1: This configuration directive cannot be changed at runtime via</span></span><br><span class="line"><span class="comment"># CONFIG SET. Aso this feature currently does not work when SSL is</span></span><br><span class="line"><span class="comment"># enabled.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># NOTE 2: If you want to test the Redis speedup using redis-benchmark, make</span></span><br><span class="line"><span class="comment"># sure you also run the benchmark itself in threaded mode, using the</span></span><br><span class="line"><span class="comment"># --threads option to match the number of Redis threads, otherwise you&#x27;ll not</span></span><br><span class="line"><span class="comment"># be able to notice the improvements.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">############################ KERNEL OOM CONTROL ##############################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># On Linux, it is possible to hint the kernel OOM killer on what processes</span></span><br><span class="line"><span class="comment"># should be killed first when out of memory.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Enabling this feature makes Redis actively control the oom_score_adj value</span></span><br><span class="line"><span class="comment"># for all its processes, depending on their role. The default scores will</span></span><br><span class="line"><span class="comment"># attempt to have background child processes killed before all others, and</span></span><br><span class="line"><span class="comment"># replicas killed before masters.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Redis supports three options:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># no:       Don&#x27;t make changes to oom-score-adj (default).</span></span><br><span class="line"><span class="comment"># yes:      Alias to &quot;relative&quot; see below.</span></span><br><span class="line"><span class="comment"># absolute: Values in oom-score-adj-values are written as is to the kernel.</span></span><br><span class="line"><span class="comment"># relative: Values are used relative to the initial value of oom_score_adj when</span></span><br><span class="line"><span class="comment">#           the server starts and are then clamped to a range of -1000 to 1000.</span></span><br><span class="line"><span class="comment">#           Because typically the initial value is 0, they will often match the</span></span><br><span class="line"><span class="comment">#           absolute values.</span></span><br><span class="line">oom-score-adj no</span><br><span class="line"></span><br><span class="line"><span class="comment"># When oom-score-adj is used, this directive controls the specific values used</span></span><br><span class="line"><span class="comment"># for master, replica and background child processes. Values range -2000 to</span></span><br><span class="line"><span class="comment"># 2000 (higher means more likely to be killed).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Unprivileged processes (not root, and without CAP_SYS_RESOURCE capabilities)</span></span><br><span class="line"><span class="comment"># can freely increase their value, but not decrease it below its initial</span></span><br><span class="line"><span class="comment"># settings. This means that setting oom-score-adj to &quot;relative&quot; and setting the</span></span><br><span class="line"><span class="comment"># oom-score-adj-values to positive values will always succeed.</span></span><br><span class="line">oom-score-adj-values 0 200 800</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#################### KERNEL transparent hugepage CONTROL ######################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Usually the kernel Transparent Huge Pages control is set to &quot;madvise&quot; or</span></span><br><span class="line"><span class="comment"># or &quot;never&quot; by default (/sys/kernel/mm/transparent_hugepage/enabled), in which</span></span><br><span class="line"><span class="comment"># case this config has no effect. On systems in which it is set to &quot;always&quot;,</span></span><br><span class="line"><span class="comment"># redis will attempt to disable it specifically for the redis process in order</span></span><br><span class="line"><span class="comment"># to avoid latency problems specifically with fork(2) and CoW.</span></span><br><span class="line"><span class="comment"># If for some reason you prefer to keep it enabled, you can set this config to</span></span><br><span class="line"><span class="comment"># &quot;no&quot; and the kernel global to &quot;always&quot;.</span></span><br><span class="line"></span><br><span class="line">disable-thp yes</span><br><span class="line"></span><br><span class="line"><span class="comment">############################## APPEND ONLY MODE ###############################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># By default Redis asynchronously dumps the dataset on disk. This mode is</span></span><br><span class="line"><span class="comment"># good enough in many applications, but an issue with the Redis process or</span></span><br><span class="line"><span class="comment"># a power outage may result into a few minutes of writes lost (depending on</span></span><br><span class="line"><span class="comment"># the configured save points).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The Append Only File is an alternative persistence mode that provides</span></span><br><span class="line"><span class="comment"># much better durability. For instance using the default data fsync policy</span></span><br><span class="line"><span class="comment"># (see later in the config file) Redis can lose just one second of writes in a</span></span><br><span class="line"><span class="comment"># dramatic event like a server power outage, or a single write if something</span></span><br><span class="line"><span class="comment"># wrong with the Redis process itself happens, but the operating system is</span></span><br><span class="line"><span class="comment"># still running correctly.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># AOF and RDB persistence can be enabled at the same time without problems.</span></span><br><span class="line"><span class="comment"># If the AOF is enabled on startup Redis will load the AOF, that is the file</span></span><br><span class="line"><span class="comment"># with the better durability guarantees.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Please check http://redis.io/topics/persistence for more information.</span></span><br><span class="line"><span class="comment"># =&gt; 是否开启aof模式；默认使用rdb方式持久化</span></span><br><span class="line">appendonly no</span><br><span class="line"></span><br><span class="line"><span class="comment"># The name of the append only file (default: &quot;appendonly.aof&quot;)</span></span><br><span class="line"><span class="comment"># =&gt; 使用aof持久化文件的名称</span></span><br><span class="line">appendfilename <span class="string">&quot;appendonly.aof&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The fsync() call tells the Operating System to actually write data on disk</span></span><br><span class="line"><span class="comment"># instead of waiting for more data in the output buffer. Some OS will really flush</span></span><br><span class="line"><span class="comment"># data on disk, some other OS will just try to do it ASAP.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Redis supports three different modes:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># no: don&#x27;t fsync, just let the OS flush the data when it wants. Faster.</span></span><br><span class="line"><span class="comment"># always: fsync after every write to the append only log. Slow, Safest.</span></span><br><span class="line"><span class="comment"># everysec: fsync only one time every second. Compromise.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The default is &quot;everysec&quot;, as that&#x27;s usually the right compromise between</span></span><br><span class="line"><span class="comment"># speed and data safety. It&#x27;s up to you to understand if you can relax this to</span></span><br><span class="line"><span class="comment"># &quot;no&quot; that will let the operating system flush the output buffer when</span></span><br><span class="line"><span class="comment"># it wants, for better performances (but if you can live with the idea of</span></span><br><span class="line"><span class="comment"># some data loss consider the default persistence mode that&#x27;s snapshotting),</span></span><br><span class="line"><span class="comment"># or on the contrary, use &quot;always&quot; that&#x27;s very slow but a bit safer than</span></span><br><span class="line"><span class="comment"># everysec.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># More details please check the following article:</span></span><br><span class="line"><span class="comment"># http://antirez.com/post/redis-persistence-demystified.html</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If unsure, use &quot;everysec&quot;.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># =&gt; 每次修改都会同步；耗费性能</span></span><br><span class="line"><span class="comment"># appendfsync always </span></span><br><span class="line"><span class="comment"># =&gt; 每秒执行一次同步；可能会丢失这一秒的数据</span></span><br><span class="line">appendfsync everysec</span><br><span class="line"><span class="comment"># =&gt; 不执行同步；由操作系统自己同步</span></span><br><span class="line"><span class="comment"># appendfsync no</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># When the AOF fsync policy is set to always or everysec, and a background</span></span><br><span class="line"><span class="comment"># saving process (a background save or AOF log background rewriting) is</span></span><br><span class="line"><span class="comment"># performing a lot of I/O against the disk, in some Linux configurations</span></span><br><span class="line"><span class="comment"># Redis may block too long on the fsync() call. Note that there is no fix for</span></span><br><span class="line"><span class="comment"># this currently, as even performing fsync in a different thread will block</span></span><br><span class="line"><span class="comment"># our synchronous write(2) call.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># In order to mitigate this problem it&#x27;s possible to use the following option</span></span><br><span class="line"><span class="comment"># that will prevent fsync() from being called in the main process while a</span></span><br><span class="line"><span class="comment"># BGSAVE or BGREWRITEAOF is in progress.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This means that while another child is saving, the durability of Redis is</span></span><br><span class="line"><span class="comment"># the same as &quot;appendfsync none&quot;. In practical terms, this means that it is</span></span><br><span class="line"><span class="comment"># possible to lose up to 30 seconds of log in the worst scenario (with the</span></span><br><span class="line"><span class="comment"># default Linux settings).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If you have latency problems turn this to &quot;yes&quot;. Otherwise leave it as</span></span><br><span class="line"><span class="comment"># &quot;no&quot; that is the safest pick from the point of view of durability.</span></span><br><span class="line"></span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line"></span><br><span class="line"><span class="comment"># Automatic rewrite of the append only file.</span></span><br><span class="line"><span class="comment"># Redis is able to automatically rewrite the log file implicitly calling</span></span><br><span class="line"><span class="comment"># BGREWRITEAOF when the AOF log size grows by the specified percentage.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This is how it works: Redis remembers the size of the AOF file after the</span></span><br><span class="line"><span class="comment"># latest rewrite (if no rewrite has happened since the restart, the size of</span></span><br><span class="line"><span class="comment"># the AOF at startup is used).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This base size is compared to the current size. If the current size is</span></span><br><span class="line"><span class="comment"># bigger than the specified percentage, the rewrite is triggered. Also</span></span><br><span class="line"><span class="comment"># you need to specify a minimal size for the AOF file to be rewritten, this</span></span><br><span class="line"><span class="comment"># is useful to avoid rewriting the AOF file even if the percentage increase</span></span><br><span class="line"><span class="comment"># is reached but it is still pretty small.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Specify a percentage of zero in order to disable the automatic AOF</span></span><br><span class="line"><span class="comment"># rewrite feature.</span></span><br><span class="line"></span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"></span><br><span class="line"><span class="comment"># An AOF file may be found to be truncated at the end during the Redis</span></span><br><span class="line"><span class="comment"># startup process, when the AOF data gets loaded back into memory.</span></span><br><span class="line"><span class="comment"># This may happen when the system where Redis is running</span></span><br><span class="line"><span class="comment"># crashes, especially when an ext4 filesystem is mounted without the</span></span><br><span class="line"><span class="comment"># data=ordered option (however this can&#x27;t happen when Redis itself</span></span><br><span class="line"><span class="comment"># crashes or aborts but the operating system still works correctly).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Redis can either exit with an error when this happens, or load as much</span></span><br><span class="line"><span class="comment"># data as possible (the default now) and start if the AOF file is found</span></span><br><span class="line"><span class="comment"># to be truncated at the end. The following option controls this behavior.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If aof-load-truncated is set to yes, a truncated AOF file is loaded and</span></span><br><span class="line"><span class="comment"># the Redis server starts emitting a log to inform the user of the event.</span></span><br><span class="line"><span class="comment"># Otherwise if the option is set to no, the server aborts with an error</span></span><br><span class="line"><span class="comment"># and refuses to start. When the option is set to no, the user requires</span></span><br><span class="line"><span class="comment"># to fix the AOF file using the &quot;redis-check-aof&quot; utility before to restart</span></span><br><span class="line"><span class="comment"># the server.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Note that if the AOF file will be found to be corrupted in the middle</span></span><br><span class="line"><span class="comment"># the server will still exit with an error. This option only applies when</span></span><br><span class="line"><span class="comment"># Redis will try to read more data from the AOF file but not enough bytes</span></span><br><span class="line"><span class="comment"># will be found.</span></span><br><span class="line">aof-load-truncated yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># When rewriting the AOF file, Redis is able to use an RDB preamble in the</span></span><br><span class="line"><span class="comment"># AOF file for faster rewrites and recoveries. When this option is turned</span></span><br><span class="line"><span class="comment"># on the rewritten AOF file is composed of two different stanzas:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   [RDB file][AOF tail]</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># When loading, Redis recognizes that the AOF file starts with the &quot;REDIS&quot;</span></span><br><span class="line"><span class="comment"># string and loads the prefixed RDB file, then continues loading the AOF</span></span><br><span class="line"><span class="comment"># tail.</span></span><br><span class="line">aof-use-rdb-preamble yes</span><br><span class="line"></span><br><span class="line"><span class="comment">################################ LUA SCRIPTING  ###############################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Max execution time of a Lua script in milliseconds.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If the maximum execution time is reached Redis will log that a script is</span></span><br><span class="line"><span class="comment"># still in execution after the maximum allowed time and will start to</span></span><br><span class="line"><span class="comment"># reply to queries with an error.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># When a long running script exceeds the maximum execution time only the</span></span><br><span class="line"><span class="comment"># SCRIPT KILL and SHUTDOWN NOSAVE commands are available. The first can be</span></span><br><span class="line"><span class="comment"># used to stop a script that did not yet call any write commands. The second</span></span><br><span class="line"><span class="comment"># is the only way to shut down the server in the case a write command was</span></span><br><span class="line"><span class="comment"># already issued by the script but the user doesn&#x27;t want to wait for the natural</span></span><br><span class="line"><span class="comment"># termination of the script.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Set it to 0 or a negative value for unlimited execution without warnings.</span></span><br><span class="line">lua-time-limit 5000</span><br><span class="line"></span><br><span class="line"><span class="comment">################################ REDIS CLUSTER  ###############################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Normal Redis instances can&#x27;t be part of a Redis Cluster; only nodes that are</span></span><br><span class="line"><span class="comment"># started as cluster nodes can. In order to start a Redis instance as a</span></span><br><span class="line"><span class="comment"># cluster node enable the cluster support uncommenting the following:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># cluster-enabled yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Every cluster node has a cluster configuration file. This file is not</span></span><br><span class="line"><span class="comment"># intended to be edited by hand. It is created and updated by Redis nodes.</span></span><br><span class="line"><span class="comment"># Every Redis Cluster node requires a different cluster configuration file.</span></span><br><span class="line"><span class="comment"># Make sure that instances running in the same system do not have</span></span><br><span class="line"><span class="comment"># overlapping cluster configuration file names.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># cluster-config-file nodes-6379.conf</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Cluster node timeout is the amount of milliseconds a node must be unreachable</span></span><br><span class="line"><span class="comment"># for it to be considered in failure state.</span></span><br><span class="line"><span class="comment"># Most other internal time limits are a multiple of the node timeout.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># cluster-node-timeout 15000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># A replica of a failing master will avoid to start a failover if its data</span></span><br><span class="line"><span class="comment"># looks too old.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># There is no simple way for a replica to actually have an exact measure of</span></span><br><span class="line"><span class="comment"># its &quot;data age&quot;, so the following two checks are performed:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 1) If there are multiple replicas able to failover, they exchange messages</span></span><br><span class="line"><span class="comment">#    in order to try to give an advantage to the replica with the best</span></span><br><span class="line"><span class="comment">#    replication offset (more data from the master processed).</span></span><br><span class="line"><span class="comment">#    Replicas will try to get their rank by offset, and apply to the start</span></span><br><span class="line"><span class="comment">#    of the failover a delay proportional to their rank.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 2) Every single replica computes the time of the last interaction with</span></span><br><span class="line"><span class="comment">#    its master. This can be the last ping or command received (if the master</span></span><br><span class="line"><span class="comment">#    is still in the &quot;connected&quot; state), or the time that elapsed since the</span></span><br><span class="line"><span class="comment">#    disconnection with the master (if the replication link is currently down).</span></span><br><span class="line"><span class="comment">#    If the last interaction is too old, the replica will not try to failover</span></span><br><span class="line"><span class="comment">#    at all.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The point &quot;2&quot; can be tuned by user. Specifically a replica will not perform</span></span><br><span class="line"><span class="comment"># the failover if, since the last interaction with the master, the time</span></span><br><span class="line"><span class="comment"># elapsed is greater than:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   (node-timeout * cluster-replica-validity-factor) + repl-ping-replica-period</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># So for example if node-timeout is 30 seconds, and the cluster-replica-validity-factor</span></span><br><span class="line"><span class="comment"># is 10, and assuming a default repl-ping-replica-period of 10 seconds, the</span></span><br><span class="line"><span class="comment"># replica will not try to failover if it was not able to talk with the master</span></span><br><span class="line"><span class="comment"># for longer than 310 seconds.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># A large cluster-replica-validity-factor may allow replicas with too old data to failover</span></span><br><span class="line"><span class="comment"># a master, while a too small value may prevent the cluster from being able to</span></span><br><span class="line"><span class="comment"># elect a replica at all.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># For maximum availability, it is possible to set the cluster-replica-validity-factor</span></span><br><span class="line"><span class="comment"># to a value of 0, which means, that replicas will always try to failover the</span></span><br><span class="line"><span class="comment"># master regardless of the last time they interacted with the master.</span></span><br><span class="line"><span class="comment"># (However they&#x27;ll always try to apply a delay proportional to their</span></span><br><span class="line"><span class="comment"># offset rank).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Zero is the only value able to guarantee that when all the partitions heal</span></span><br><span class="line"><span class="comment"># the cluster will always be able to continue.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># cluster-replica-validity-factor 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Cluster replicas are able to migrate to orphaned masters, that are masters</span></span><br><span class="line"><span class="comment"># that are left without working replicas. This improves the cluster ability</span></span><br><span class="line"><span class="comment"># to resist to failures as otherwise an orphaned master can&#x27;t be failed over</span></span><br><span class="line"><span class="comment"># in case of failure if it has no working replicas.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Replicas migrate to orphaned masters only if there are still at least a</span></span><br><span class="line"><span class="comment"># given number of other working replicas for their old master. This number</span></span><br><span class="line"><span class="comment"># is the &quot;migration barrier&quot;. A migration barrier of 1 means that a replica</span></span><br><span class="line"><span class="comment"># will migrate only if there is at least 1 other working replica for its master</span></span><br><span class="line"><span class="comment"># and so forth. It usually reflects the number of replicas you want for every</span></span><br><span class="line"><span class="comment"># master in your cluster.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Default is 1 (replicas migrate only if their masters remain with at least</span></span><br><span class="line"><span class="comment"># one replica). To disable migration just set it to a very large value.</span></span><br><span class="line"><span class="comment"># A value of 0 can be set but is useful only for debugging and dangerous</span></span><br><span class="line"><span class="comment"># in production.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># cluster-migration-barrier 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># By default Redis Cluster nodes stop accepting queries if they detect there</span></span><br><span class="line"><span class="comment"># is at least a hash slot uncovered (no available node is serving it).</span></span><br><span class="line"><span class="comment"># This way if the cluster is partially down (for example a range of hash slots</span></span><br><span class="line"><span class="comment"># are no longer covered) all the cluster becomes, eventually, unavailable.</span></span><br><span class="line"><span class="comment"># It automatically returns available as soon as all the slots are covered again.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># However sometimes you want the subset of the cluster which is working,</span></span><br><span class="line"><span class="comment"># to continue to accept queries for the part of the key space that is still</span></span><br><span class="line"><span class="comment"># covered. In order to do so, just set the cluster-require-full-coverage</span></span><br><span class="line"><span class="comment"># option to no.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># cluster-require-full-coverage yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This option, when set to yes, prevents replicas from trying to failover its</span></span><br><span class="line"><span class="comment"># master during master failures. However the replica can still perform a</span></span><br><span class="line"><span class="comment"># manual failover, if forced to do so.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This is useful in different scenarios, especially in the case of multiple</span></span><br><span class="line"><span class="comment"># data center operations, where we want one side to never be promoted if not</span></span><br><span class="line"><span class="comment"># in the case of a total DC failure.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># cluster-replica-no-failover no</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This option, when set to yes, allows nodes to serve read traffic while the</span></span><br><span class="line"><span class="comment"># the cluster is in a down state, as long as it believes it owns the slots. </span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This is useful for two cases.  The first case is for when an application </span></span><br><span class="line"><span class="comment"># doesn&#x27;t require consistency of data during node failures or network partitions.</span></span><br><span class="line"><span class="comment"># One example of this is a cache, where as long as the node has the data it</span></span><br><span class="line"><span class="comment"># should be able to serve it. </span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The second use case is for configurations that don&#x27;t meet the recommended  </span></span><br><span class="line"><span class="comment"># three shards but want to enable cluster mode and scale later. A </span></span><br><span class="line"><span class="comment"># master outage in a 1 or 2 shard configuration causes a read/write outage to the</span></span><br><span class="line"><span class="comment"># entire cluster without this option set, with it set there is only a write outage.</span></span><br><span class="line"><span class="comment"># Without a quorum of masters, slot ownership will not change automatically. </span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># cluster-allow-reads-when-down no</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># In order to setup your cluster make sure to read the documentation</span></span><br><span class="line"><span class="comment"># available at http://redis.io web site.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">########################## CLUSTER DOCKER/NAT support  ########################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># In certain deployments, Redis Cluster nodes address discovery fails, because</span></span><br><span class="line"><span class="comment"># addresses are NAT-ted or because ports are forwarded (the typical case is</span></span><br><span class="line"><span class="comment"># Docker and other containers).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># In order to make Redis Cluster working in such environments, a static</span></span><br><span class="line"><span class="comment"># configuration where each node knows its public address is needed. The</span></span><br><span class="line"><span class="comment"># following two options are used for this scope, and are:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># * cluster-announce-ip</span></span><br><span class="line"><span class="comment"># * cluster-announce-port</span></span><br><span class="line"><span class="comment"># * cluster-announce-bus-port</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Each instructs the node about its address, client port, and cluster message</span></span><br><span class="line"><span class="comment"># bus port. The information is then published in the header of the bus packets</span></span><br><span class="line"><span class="comment"># so that other nodes will be able to correctly map the address of the node</span></span><br><span class="line"><span class="comment"># publishing the information.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If the above options are not used, the normal Redis Cluster auto-detection</span></span><br><span class="line"><span class="comment"># will be used instead.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Note that when remapped, the bus port may not be at the fixed offset of</span></span><br><span class="line"><span class="comment"># clients port + 10000, so you can specify any port and bus-port depending</span></span><br><span class="line"><span class="comment"># on how they get remapped. If the bus-port is not set, a fixed offset of</span></span><br><span class="line"><span class="comment"># 10000 will be used as usual.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Example:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># cluster-announce-ip 10.1.1.5</span></span><br><span class="line"><span class="comment"># cluster-announce-port 6379</span></span><br><span class="line"><span class="comment"># cluster-announce-bus-port 6380</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################################## SLOW LOG ###################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The Redis Slow Log is a system to log queries that exceeded a specified</span></span><br><span class="line"><span class="comment"># execution time. The execution time does not include the I/O operations</span></span><br><span class="line"><span class="comment"># like talking with the client, sending the reply and so forth,</span></span><br><span class="line"><span class="comment"># but just the time needed to actually execute the command (this is the only</span></span><br><span class="line"><span class="comment"># stage of command execution where the thread is blocked and can not serve</span></span><br><span class="line"><span class="comment"># other requests in the meantime).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># You can configure the slow log with two parameters: one tells Redis</span></span><br><span class="line"><span class="comment"># what is the execution time, in microseconds, to exceed in order for the</span></span><br><span class="line"><span class="comment"># command to get logged, and the other parameter is the length of the</span></span><br><span class="line"><span class="comment"># slow log. When a new command is logged the oldest one is removed from the</span></span><br><span class="line"><span class="comment"># queue of logged commands.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The following time is expressed in microseconds, so 1000000 is equivalent</span></span><br><span class="line"><span class="comment"># to one second. Note that a negative number disables the slow log, while</span></span><br><span class="line"><span class="comment"># a value of zero forces the logging of every command.</span></span><br><span class="line">slowlog-log-slower-than 10000</span><br><span class="line"></span><br><span class="line"><span class="comment"># There is no limit to this length. Just be aware that it will consume memory.</span></span><br><span class="line"><span class="comment"># You can reclaim memory used by the slow log with SLOWLOG RESET.</span></span><br><span class="line">slowlog-max-len 128</span><br><span class="line"></span><br><span class="line"><span class="comment">################################ LATENCY MONITOR ##############################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The Redis latency monitoring subsystem samples different operations</span></span><br><span class="line"><span class="comment"># at runtime in order to collect data related to possible sources of</span></span><br><span class="line"><span class="comment"># latency of a Redis instance.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Via the LATENCY command this information is available to the user that can</span></span><br><span class="line"><span class="comment"># print graphs and obtain reports.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The system only logs operations that were performed in a time equal or</span></span><br><span class="line"><span class="comment"># greater than the amount of milliseconds specified via the</span></span><br><span class="line"><span class="comment"># latency-monitor-threshold configuration directive. When its value is set</span></span><br><span class="line"><span class="comment"># to zero, the latency monitor is turned off.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># By default latency monitoring is disabled since it is mostly not needed</span></span><br><span class="line"><span class="comment"># if you don&#x27;t have latency issues, and collecting data has a performance</span></span><br><span class="line"><span class="comment"># impact, that while very small, can be measured under big load. Latency</span></span><br><span class="line"><span class="comment"># monitoring can easily be enabled at runtime using the command</span></span><br><span class="line"><span class="comment"># &quot;CONFIG SET latency-monitor-threshold &lt;milliseconds&gt;&quot; if needed.</span></span><br><span class="line">latency-monitor-threshold 0</span><br><span class="line"></span><br><span class="line"><span class="comment">############################# EVENT NOTIFICATION ##############################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Redis can notify Pub/Sub clients about events happening in the key space.</span></span><br><span class="line"><span class="comment"># This feature is documented at http://redis.io/topics/notifications</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># For instance if keyspace events notification is enabled, and a client</span></span><br><span class="line"><span class="comment"># performs a DEL operation on key &quot;foo&quot; stored in the Database 0, two</span></span><br><span class="line"><span class="comment"># messages will be published via Pub/Sub:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># PUBLISH __keyspace@0__:foo del</span></span><br><span class="line"><span class="comment"># PUBLISH __keyevent@0__:del foo</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># It is possible to select the events that Redis will notify among a set</span></span><br><span class="line"><span class="comment"># of classes. Every class is identified by a single character:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  K     Keyspace events, published with __keyspace@&lt;db&gt;__ prefix.</span></span><br><span class="line"><span class="comment">#  E     Keyevent events, published with __keyevent@&lt;db&gt;__ prefix.</span></span><br><span class="line"><span class="comment">#  g     Generic commands (non-type specific) like DEL, EXPIRE, RENAME, ...</span></span><br><span class="line"><span class="comment">#  $     String commands</span></span><br><span class="line"><span class="comment">#  l     List commands</span></span><br><span class="line"><span class="comment">#  s     Set commands</span></span><br><span class="line"><span class="comment">#  h     Hash commands</span></span><br><span class="line"><span class="comment">#  z     Sorted set commands</span></span><br><span class="line"><span class="comment">#  x     Expired events (events generated every time a key expires)</span></span><br><span class="line"><span class="comment">#  e     Evicted events (events generated when a key is evicted for maxmemory)</span></span><br><span class="line"><span class="comment">#  t     Stream commands</span></span><br><span class="line"><span class="comment">#  m     Key-miss events (Note: It is not included in the &#x27;A&#x27; class)</span></span><br><span class="line"><span class="comment">#  A     Alias for g$lshzxet, so that the &quot;AKE&quot; string means all the events</span></span><br><span class="line"><span class="comment">#        (Except key-miss events which are excluded from &#x27;A&#x27; due to their</span></span><br><span class="line"><span class="comment">#         unique nature).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  The &quot;notify-keyspace-events&quot; takes as argument a string that is composed</span></span><br><span class="line"><span class="comment">#  of zero or multiple characters. The empty string means that notifications</span></span><br><span class="line"><span class="comment">#  are disabled.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  Example: to enable list and generic events, from the point of view of the</span></span><br><span class="line"><span class="comment">#           event name, use:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  notify-keyspace-events Elg</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  Example 2: to get the stream of the expired keys subscribing to channel</span></span><br><span class="line"><span class="comment">#             name __keyevent@0__:expired use:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  notify-keyspace-events Ex</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  By default all notifications are disabled because most users don&#x27;t need</span></span><br><span class="line"><span class="comment">#  this feature and the feature has some overhead. Note that if you don&#x27;t</span></span><br><span class="line"><span class="comment">#  specify at least one of K or E, no events will be delivered.</span></span><br><span class="line">notify-keyspace-events <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">############################### GOPHER SERVER #################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Redis contains an implementation of the Gopher protocol, as specified in</span></span><br><span class="line"><span class="comment"># the RFC 1436 (https://www.ietf.org/rfc/rfc1436.txt).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The Gopher protocol was very popular in the late &#x27;90s. It is an alternative</span></span><br><span class="line"><span class="comment"># to the web, and the implementation both server and client side is so simple</span></span><br><span class="line"><span class="comment"># that the Redis server has just 100 lines of code in order to implement this</span></span><br><span class="line"><span class="comment"># support.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># What do you do with Gopher nowadays? Well Gopher never *really* died, and</span></span><br><span class="line"><span class="comment"># lately there is a movement in order for the Gopher more hierarchical content</span></span><br><span class="line"><span class="comment"># composed of just plain text documents to be resurrected. Some want a simpler</span></span><br><span class="line"><span class="comment"># internet, others believe that the mainstream internet became too much</span></span><br><span class="line"><span class="comment"># controlled, and it&#x27;s cool to create an alternative space for people that</span></span><br><span class="line"><span class="comment"># want a bit of fresh air.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Anyway for the 10nth birthday of the Redis, we gave it the Gopher protocol</span></span><br><span class="line"><span class="comment"># as a gift.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># --- HOW IT WORKS? ---</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The Redis Gopher support uses the inline protocol of Redis, and specifically</span></span><br><span class="line"><span class="comment"># two kind of inline requests that were anyway illegal: an empty request</span></span><br><span class="line"><span class="comment"># or any request that starts with &quot;/&quot; (there are no Redis commands starting</span></span><br><span class="line"><span class="comment"># with such a slash). Normal RESP2/RESP3 requests are completely out of the</span></span><br><span class="line"><span class="comment"># path of the Gopher protocol implementation and are served as usual as well.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If you open a connection to Redis when Gopher is enabled and send it</span></span><br><span class="line"><span class="comment"># a string like &quot;/foo&quot;, if there is a key named &quot;/foo&quot; it is served via the</span></span><br><span class="line"><span class="comment"># Gopher protocol.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># In order to create a real Gopher &quot;hole&quot; (the name of a Gopher site in Gopher</span></span><br><span class="line"><span class="comment"># talking), you likely need a script like the following:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   https://github.com/antirez/gopher2redis</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># --- SECURITY WARNING ---</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If you plan to put Redis on the internet in a publicly accessible address</span></span><br><span class="line"><span class="comment"># to server Gopher pages MAKE SURE TO SET A PASSWORD to the instance.</span></span><br><span class="line"><span class="comment"># Once a password is set:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   1. The Gopher server (when enabled, not by default) will still serve</span></span><br><span class="line"><span class="comment">#      content via Gopher.</span></span><br><span class="line"><span class="comment">#   2. However other commands cannot be called before the client will</span></span><br><span class="line"><span class="comment">#      authenticate.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># So use the &#x27;requirepass&#x27; option to protect your instance.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Note that Gopher is not currently supported when &#x27;io-threads-do-reads&#x27;</span></span><br><span class="line"><span class="comment"># is enabled.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># To enable Gopher support, uncomment the following line and set the option</span></span><br><span class="line"><span class="comment"># from no (the default) to yes.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># gopher-enabled no</span></span><br><span class="line"></span><br><span class="line"><span class="comment">############################### ADVANCED CONFIG ###############################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Hashes are encoded using a memory efficient data structure when they have a</span></span><br><span class="line"><span class="comment"># small number of entries, and the biggest entry does not exceed a given</span></span><br><span class="line"><span class="comment"># threshold. These thresholds can be configured using the following directives.</span></span><br><span class="line">hash-max-ziplist-entries 512</span><br><span class="line">hash-max-ziplist-value 64</span><br><span class="line"></span><br><span class="line"><span class="comment"># Lists are also encoded in a special way to save a lot of space.</span></span><br><span class="line"><span class="comment"># The number of entries allowed per internal list node can be specified</span></span><br><span class="line"><span class="comment"># as a fixed maximum size or a maximum number of elements.</span></span><br><span class="line"><span class="comment"># For a fixed maximum size, use -5 through -1, meaning:</span></span><br><span class="line"><span class="comment"># -5: max size: 64 Kb  &lt;-- not recommended for normal workloads</span></span><br><span class="line"><span class="comment"># -4: max size: 32 Kb  &lt;-- not recommended</span></span><br><span class="line"><span class="comment"># -3: max size: 16 Kb  &lt;-- probably not recommended</span></span><br><span class="line"><span class="comment"># -2: max size: 8 Kb   &lt;-- good</span></span><br><span class="line"><span class="comment"># -1: max size: 4 Kb   &lt;-- good</span></span><br><span class="line"><span class="comment"># Positive numbers mean store up to _exactly_ that number of elements</span></span><br><span class="line"><span class="comment"># per list node.</span></span><br><span class="line"><span class="comment"># The highest performing option is usually -2 (8 Kb size) or -1 (4 Kb size),</span></span><br><span class="line"><span class="comment"># but if your use case is unique, adjust the settings as necessary.</span></span><br><span class="line">list-max-ziplist-size -2</span><br><span class="line"></span><br><span class="line"><span class="comment"># Lists may also be compressed.</span></span><br><span class="line"><span class="comment"># Compress depth is the number of quicklist ziplist nodes from *each* side of</span></span><br><span class="line"><span class="comment"># the list to *exclude* from compression.  The head and tail of the list</span></span><br><span class="line"><span class="comment"># are always uncompressed for fast push/pop operations.  Settings are:</span></span><br><span class="line"><span class="comment"># 0: disable all list compression</span></span><br><span class="line"><span class="comment"># 1: depth 1 means &quot;don&#x27;t start compressing until after 1 node into the list,</span></span><br><span class="line"><span class="comment">#    going from either the head or tail&quot;</span></span><br><span class="line"><span class="comment">#    So: [head]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[tail]</span></span><br><span class="line"><span class="comment">#    [head], [tail] will always be uncompressed; inner nodes will compress.</span></span><br><span class="line"><span class="comment"># 2: [head]-&gt;[next]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[prev]-&gt;[tail]</span></span><br><span class="line"><span class="comment">#    2 here means: don&#x27;t compress head or head-&gt;next or tail-&gt;prev or tail,</span></span><br><span class="line"><span class="comment">#    but compress all nodes between them.</span></span><br><span class="line"><span class="comment"># 3: [head]-&gt;[next]-&gt;[next]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[prev]-&gt;[prev]-&gt;[tail]</span></span><br><span class="line"><span class="comment"># etc.</span></span><br><span class="line">list-compress-depth 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sets have a special encoding in just one case: when a set is composed</span></span><br><span class="line"><span class="comment"># of just strings that happen to be integers in radix 10 in the range</span></span><br><span class="line"><span class="comment"># of 64 bit signed integers.</span></span><br><span class="line"><span class="comment"># The following configuration setting sets the limit in the size of the</span></span><br><span class="line"><span class="comment"># set in order to use this special memory saving encoding.</span></span><br><span class="line">set-max-intset-entries 512</span><br><span class="line"></span><br><span class="line"><span class="comment"># Similarly to hashes and lists, sorted sets are also specially encoded in</span></span><br><span class="line"><span class="comment"># order to save a lot of space. This encoding is only used when the length and</span></span><br><span class="line"><span class="comment"># elements of a sorted set are below the following limits:</span></span><br><span class="line">zset-max-ziplist-entries 128</span><br><span class="line">zset-max-ziplist-value 64</span><br><span class="line"></span><br><span class="line"><span class="comment"># HyperLogLog sparse representation bytes limit. The limit includes the</span></span><br><span class="line"><span class="comment"># 16 bytes header. When an HyperLogLog using the sparse representation crosses</span></span><br><span class="line"><span class="comment"># this limit, it is converted into the dense representation.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># A value greater than 16000 is totally useless, since at that point the</span></span><br><span class="line"><span class="comment"># dense representation is more memory efficient.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The suggested value is ~ 3000 in order to have the benefits of</span></span><br><span class="line"><span class="comment"># the space efficient encoding without slowing down too much PFADD,</span></span><br><span class="line"><span class="comment"># which is O(N) with the sparse encoding. The value can be raised to</span></span><br><span class="line"><span class="comment"># ~ 10000 when CPU is not a concern, but space is, and the data set is</span></span><br><span class="line"><span class="comment"># composed of many HyperLogLogs with cardinality in the 0 - 15000 range.</span></span><br><span class="line">hll-sparse-max-bytes 3000</span><br><span class="line"></span><br><span class="line"><span class="comment"># Streams macro node max size / items. The stream data structure is a radix</span></span><br><span class="line"><span class="comment"># tree of big nodes that encode multiple items inside. Using this configuration</span></span><br><span class="line"><span class="comment"># it is possible to configure how big a single node can be in bytes, and the</span></span><br><span class="line"><span class="comment"># maximum number of items it may contain before switching to a new node when</span></span><br><span class="line"><span class="comment"># appending new stream entries. If any of the following settings are set to</span></span><br><span class="line"><span class="comment"># zero, the limit is ignored, so for instance it is possible to set just a</span></span><br><span class="line"><span class="comment"># max entries limit by setting max-bytes to 0 and max-entries to the desired</span></span><br><span class="line"><span class="comment"># value.</span></span><br><span class="line">stream-node-max-bytes 4096</span><br><span class="line">stream-node-max-entries 100</span><br><span class="line"></span><br><span class="line"><span class="comment"># Active rehashing uses 1 millisecond every 100 milliseconds of CPU time in</span></span><br><span class="line"><span class="comment"># order to help rehashing the main Redis hash table (the one mapping top-level</span></span><br><span class="line"><span class="comment"># keys to values). The hash table implementation Redis uses (see dict.c)</span></span><br><span class="line"><span class="comment"># performs a lazy rehashing: the more operation you run into a hash table</span></span><br><span class="line"><span class="comment"># that is rehashing, the more rehashing &quot;steps&quot; are performed, so if the</span></span><br><span class="line"><span class="comment"># server is idle the rehashing is never complete and some more memory is used</span></span><br><span class="line"><span class="comment"># by the hash table.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The default is to use this millisecond 10 times every second in order to</span></span><br><span class="line"><span class="comment"># actively rehash the main dictionaries, freeing memory when possible.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If unsure:</span></span><br><span class="line"><span class="comment"># use &quot;activerehashing no&quot; if you have hard latency requirements and it is</span></span><br><span class="line"><span class="comment"># not a good thing in your environment that Redis can reply from time to time</span></span><br><span class="line"><span class="comment"># to queries with 2 milliseconds delay.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># use &quot;activerehashing yes&quot; if you don&#x27;t have such hard requirements but</span></span><br><span class="line"><span class="comment"># want to free memory asap when possible.</span></span><br><span class="line">activerehashing yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># The client output buffer limits can be used to force disconnection of clients</span></span><br><span class="line"><span class="comment"># that are not reading data from the server fast enough for some reason (a</span></span><br><span class="line"><span class="comment"># common reason is that a Pub/Sub client can&#x27;t consume messages as fast as the</span></span><br><span class="line"><span class="comment"># publisher can produce them).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The limit can be set differently for the three different classes of clients:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># normal -&gt; normal clients including MONITOR clients</span></span><br><span class="line"><span class="comment"># replica  -&gt; replica clients</span></span><br><span class="line"><span class="comment"># pubsub -&gt; clients subscribed to at least one pubsub channel or pattern</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The syntax of every client-output-buffer-limit directive is the following:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># client-output-buffer-limit &lt;class&gt; &lt;hard limit&gt; &lt;soft limit&gt; &lt;soft seconds&gt;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># A client is immediately disconnected once the hard limit is reached, or if</span></span><br><span class="line"><span class="comment"># the soft limit is reached and remains reached for the specified number of</span></span><br><span class="line"><span class="comment"># seconds (continuously).</span></span><br><span class="line"><span class="comment"># So for instance if the hard limit is 32 megabytes and the soft limit is</span></span><br><span class="line"><span class="comment"># 16 megabytes / 10 seconds, the client will get disconnected immediately</span></span><br><span class="line"><span class="comment"># if the size of the output buffers reach 32 megabytes, but will also get</span></span><br><span class="line"><span class="comment"># disconnected if the client reaches 16 megabytes and continuously overcomes</span></span><br><span class="line"><span class="comment"># the limit for 10 seconds.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># By default normal clients are not limited because they don&#x27;t receive data</span></span><br><span class="line"><span class="comment"># without asking (in a push way), but just after a request, so only</span></span><br><span class="line"><span class="comment"># asynchronous clients may create a scenario where data is requested faster</span></span><br><span class="line"><span class="comment"># than it can read.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Instead there is a default limit for pubsub and replica clients, since</span></span><br><span class="line"><span class="comment"># subscribers and replicas receive data in a push fashion.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Both the hard or the soft limit can be disabled by setting them to zero.</span></span><br><span class="line">client-output-buffer-limit normal 0 0 0</span><br><span class="line">client-output-buffer-limit replica 256mb 64mb 60</span><br><span class="line">client-output-buffer-limit pubsub 32mb 8mb 60</span><br><span class="line"></span><br><span class="line"><span class="comment"># Client query buffers accumulate new commands. They are limited to a fixed</span></span><br><span class="line"><span class="comment"># amount by default in order to avoid that a protocol desynchronization (for</span></span><br><span class="line"><span class="comment"># instance due to a bug in the client) will lead to unbound memory usage in</span></span><br><span class="line"><span class="comment"># the query buffer. However you can configure it here if you have very special</span></span><br><span class="line"><span class="comment"># needs, such us huge multi/exec requests or alike.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># client-query-buffer-limit 1gb</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># In the Redis protocol, bulk requests, that are, elements representing single</span></span><br><span class="line"><span class="comment"># strings, are normally limited to 512 mb. However you can change this limit</span></span><br><span class="line"><span class="comment"># here, but must be 1mb or greater</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># proto-max-bulk-len 512mb</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Redis calls an internal function to perform many background tasks, like</span></span><br><span class="line"><span class="comment"># closing connections of clients in timeout, purging expired keys that are</span></span><br><span class="line"><span class="comment"># never requested, and so forth.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Not all tasks are performed with the same frequency, but Redis checks for</span></span><br><span class="line"><span class="comment"># tasks to perform according to the specified &quot;hz&quot; value.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># By default &quot;hz&quot; is set to 10. Raising the value will use more CPU when</span></span><br><span class="line"><span class="comment"># Redis is idle, but at the same time will make Redis more responsive when</span></span><br><span class="line"><span class="comment"># there are many keys expiring at the same time, and timeouts may be</span></span><br><span class="line"><span class="comment"># handled with more precision.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The range is between 1 and 500, however a value over 100 is usually not</span></span><br><span class="line"><span class="comment"># a good idea. Most users should use the default of 10 and raise this up to</span></span><br><span class="line"><span class="comment"># 100 only in environments where very low latency is required.</span></span><br><span class="line">hz 10</span><br><span class="line"></span><br><span class="line"><span class="comment"># Normally it is useful to have an HZ value which is proportional to the</span></span><br><span class="line"><span class="comment"># number of clients connected. This is useful in order, for instance, to</span></span><br><span class="line"><span class="comment"># avoid too many clients are processed for each background task invocation</span></span><br><span class="line"><span class="comment"># in order to avoid latency spikes.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Since the default HZ value by default is conservatively set to 10, Redis</span></span><br><span class="line"><span class="comment"># offers, and enables by default, the ability to use an adaptive HZ value</span></span><br><span class="line"><span class="comment"># which will temporarily raise when there are many connected clients.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># When dynamic HZ is enabled, the actual configured HZ will be used</span></span><br><span class="line"><span class="comment"># as a baseline, but multiples of the configured HZ value will be actually</span></span><br><span class="line"><span class="comment"># used as needed once more clients are connected. In this way an idle</span></span><br><span class="line"><span class="comment"># instance will use very little CPU time while a busy instance will be</span></span><br><span class="line"><span class="comment"># more responsive.</span></span><br><span class="line">dynamic-hz yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># When a child rewrites the AOF file, if the following option is enabled</span></span><br><span class="line"><span class="comment"># the file will be fsync-ed every 32 MB of data generated. This is useful</span></span><br><span class="line"><span class="comment"># in order to commit the file to the disk more incrementally and avoid</span></span><br><span class="line"><span class="comment"># big latency spikes.</span></span><br><span class="line">aof-rewrite-incremental-fsync yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># When redis saves RDB file, if the following option is enabled</span></span><br><span class="line"><span class="comment"># the file will be fsync-ed every 32 MB of data generated. This is useful</span></span><br><span class="line"><span class="comment"># in order to commit the file to the disk more incrementally and avoid</span></span><br><span class="line"><span class="comment"># big latency spikes.</span></span><br><span class="line">rdb-save-incremental-fsync yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># Redis LFU eviction (see maxmemory setting) can be tuned. However it is a good</span></span><br><span class="line"><span class="comment"># idea to start with the default settings and only change them after investigating</span></span><br><span class="line"><span class="comment"># how to improve the performances and how the keys LFU change over time, which</span></span><br><span class="line"><span class="comment"># is possible to inspect via the OBJECT FREQ command.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># There are two tunable parameters in the Redis LFU implementation: the</span></span><br><span class="line"><span class="comment"># counter logarithm factor and the counter decay time. It is important to</span></span><br><span class="line"><span class="comment"># understand what the two parameters mean before changing them.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The LFU counter is just 8 bits per key, it&#x27;s maximum value is 255, so Redis</span></span><br><span class="line"><span class="comment"># uses a probabilistic increment with logarithmic behavior. Given the value</span></span><br><span class="line"><span class="comment"># of the old counter, when a key is accessed, the counter is incremented in</span></span><br><span class="line"><span class="comment"># this way:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 1. A random number R between 0 and 1 is extracted.</span></span><br><span class="line"><span class="comment"># 2. A probability P is calculated as 1/(old_value*lfu_log_factor+1).</span></span><br><span class="line"><span class="comment"># 3. The counter is incremented only if R &lt; P.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The default lfu-log-factor is 10. This is a table of how the frequency</span></span><br><span class="line"><span class="comment"># counter changes with a different number of accesses with different</span></span><br><span class="line"><span class="comment"># logarithmic factors:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># +--------+------------+------------+------------+------------+------------+</span></span><br><span class="line"><span class="comment"># | factor | 100 hits   | 1000 hits  | 100K hits  | 1M hits    | 10M hits   |</span></span><br><span class="line"><span class="comment"># +--------+------------+------------+------------+------------+------------+</span></span><br><span class="line"><span class="comment"># | 0      | 104        | 255        | 255        | 255        | 255        |</span></span><br><span class="line"><span class="comment"># +--------+------------+------------+------------+------------+------------+</span></span><br><span class="line"><span class="comment"># | 1      | 18         | 49         | 255        | 255        | 255        |</span></span><br><span class="line"><span class="comment"># +--------+------------+------------+------------+------------+------------+</span></span><br><span class="line"><span class="comment"># | 10     | 10         | 18         | 142        | 255        | 255        |</span></span><br><span class="line"><span class="comment"># +--------+------------+------------+------------+------------+------------+</span></span><br><span class="line"><span class="comment"># | 100    | 8          | 11         | 49         | 143        | 255        |</span></span><br><span class="line"><span class="comment"># +--------+------------+------------+------------+------------+------------+</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># <span class="doctag">NOTE:</span> The above table was obtained by running the following commands:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   redis-benchmark -n 1000000 incr foo</span></span><br><span class="line"><span class="comment">#   redis-cli object freq foo</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># NOTE 2: The counter initial value is 5 in order to give new objects a chance</span></span><br><span class="line"><span class="comment"># to accumulate hits.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The counter decay time is the time, in minutes, that must elapse in order</span></span><br><span class="line"><span class="comment"># for the key counter to be divided by two (or decremented if it has a value</span></span><br><span class="line"><span class="comment"># less &lt;= 10).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The default value for the lfu-decay-time is 1. A special value of 0 means to</span></span><br><span class="line"><span class="comment"># decay the counter every time it happens to be scanned.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># lfu-log-factor 10</span></span><br><span class="line"><span class="comment"># lfu-decay-time 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">########################### ACTIVE DEFRAGMENTATION #######################</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># What is active defragmentation?</span></span><br><span class="line"><span class="comment"># -------------------------------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Active (online) defragmentation allows a Redis server to compact the</span></span><br><span class="line"><span class="comment"># spaces left between small allocations and deallocations of data in memory,</span></span><br><span class="line"><span class="comment"># thus allowing to reclaim back memory.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Fragmentation is a natural process that happens with every allocator (but</span></span><br><span class="line"><span class="comment"># less so with Jemalloc, fortunately) and certain workloads. Normally a server</span></span><br><span class="line"><span class="comment"># restart is needed in order to lower the fragmentation, or at least to flush</span></span><br><span class="line"><span class="comment"># away all the data and create it again. However thanks to this feature</span></span><br><span class="line"><span class="comment"># implemented by Oran Agra for Redis 4.0 this process can happen at runtime</span></span><br><span class="line"><span class="comment"># in a &quot;hot&quot; way, while the server is running.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Basically when the fragmentation is over a certain level (see the</span></span><br><span class="line"><span class="comment"># configuration options below) Redis will start to create new copies of the</span></span><br><span class="line"><span class="comment"># values in contiguous memory regions by exploiting certain specific Jemalloc</span></span><br><span class="line"><span class="comment"># features (in order to understand if an allocation is causing fragmentation</span></span><br><span class="line"><span class="comment"># and to allocate it in a better place), and at the same time, will release the</span></span><br><span class="line"><span class="comment"># old copies of the data. This process, repeated incrementally for all the keys</span></span><br><span class="line"><span class="comment"># will cause the fragmentation to drop back to normal values.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Important things to understand:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 1. This feature is disabled by default, and only works if you compiled Redis</span></span><br><span class="line"><span class="comment">#    to use the copy of Jemalloc we ship with the source code of Redis.</span></span><br><span class="line"><span class="comment">#    This is the default with Linux builds.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 2. You never need to enable this feature if you don&#x27;t have fragmentation</span></span><br><span class="line"><span class="comment">#    issues.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 3. Once you experience fragmentation, you can enable this feature when</span></span><br><span class="line"><span class="comment">#    needed with the command &quot;CONFIG SET activedefrag yes&quot;.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The configuration parameters are able to fine tune the behavior of the</span></span><br><span class="line"><span class="comment"># defragmentation process. If you are not sure about what they mean it is</span></span><br><span class="line"><span class="comment"># a good idea to leave the defaults untouched.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Enabled active defragmentation</span></span><br><span class="line"><span class="comment"># activedefrag no</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Minimum amount of fragmentation waste to start active defrag</span></span><br><span class="line"><span class="comment"># active-defrag-ignore-bytes 100mb</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Minimum percentage of fragmentation to start active defrag</span></span><br><span class="line"><span class="comment"># active-defrag-threshold-lower 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Maximum percentage of fragmentation at which we use maximum effort</span></span><br><span class="line"><span class="comment"># active-defrag-threshold-upper 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Minimal effort for defrag in CPU percentage, to be used when the lower</span></span><br><span class="line"><span class="comment"># threshold is reached</span></span><br><span class="line"><span class="comment"># active-defrag-cycle-min 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Maximal effort for defrag in CPU percentage, to be used when the upper</span></span><br><span class="line"><span class="comment"># threshold is reached</span></span><br><span class="line"><span class="comment"># active-defrag-cycle-max 25</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Maximum number of set/hash/zset/list fields that will be processed from</span></span><br><span class="line"><span class="comment"># the main dictionary scan</span></span><br><span class="line"><span class="comment"># active-defrag-max-scan-fields 1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Jemalloc background thread for purging will be enabled by default</span></span><br><span class="line">jemalloc-bg-thread yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># It is possible to pin different threads and processes of Redis to specific</span></span><br><span class="line"><span class="comment"># CPUs in your system, in order to maximize the performances of the server.</span></span><br><span class="line"><span class="comment"># This is useful both in order to pin different Redis threads in different</span></span><br><span class="line"><span class="comment"># CPUs, but also in order to make sure that multiple Redis instances running</span></span><br><span class="line"><span class="comment"># in the same host will be pinned to different CPUs.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Normally you can do this using the &quot;taskset&quot; command, however it is also</span></span><br><span class="line"><span class="comment"># possible to this via Redis configuration directly, both in Linux and FreeBSD.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># You can pin the server/IO threads, bio threads, aof rewrite child process, and</span></span><br><span class="line"><span class="comment"># the bgsave child process. The syntax to specify the cpu list is the same as</span></span><br><span class="line"><span class="comment"># the taskset command:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Set redis server/io threads to cpu affinity 0,2,4,6:</span></span><br><span class="line"><span class="comment"># server_cpulist 0-7:2</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Set bio threads to cpu affinity 1,3:</span></span><br><span class="line"><span class="comment"># bio_cpulist 1,3</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Set aof rewrite child process to cpu affinity 8,9,10,11:</span></span><br><span class="line"><span class="comment"># aof_rewrite_cpulist 8-11</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Set bgsave child process to cpu affinity 1,10,11</span></span><br><span class="line"><span class="comment"># bgsave_cpulist 1,10-11</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># In some cases redis will emit warnings and even refuse to start if it detects</span></span><br><span class="line"><span class="comment"># that the system is in bad state, it is possible to suppress these warnings</span></span><br><span class="line"><span class="comment"># by setting the following config which takes a space delimited list of warnings</span></span><br><span class="line"><span class="comment"># to suppress</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ignore-warnings ARM64-COW-BUG</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/microservice/Consul%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0/"/>
      <url>/microservice/Consul%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>官网地址：<a href="https://www.consul.io">https://www.consul.io</a></p><h1 id="简介">简介</h1><p>Consul 是一个支持多数据中心分布式高可用的服务发现和配置共享的服务软件，由 HashiCorp 公司用 Go 语言开发, 基于 Mozilla Public License 2.0 的协议进行开源。 Consul 支持 健康检查，并允许 HTTP 、GRPC 和 DNS 协议调用 API 存储键值对。 一致性协议采用 Raft 算法,用来保证服务的高可用。使用 GOSSIP 协议管理成员和广播消息，并且支持 ACL 访问控制。</p><p>Consul 包含多个组件，但作为整体来看的话主要功能是：为基础设施提供服务发现和服务配置的工具，主要提供以下关键特性：</p><ul><li><strong>服务发现</strong>：Consul 的客户端用于注册服务，其他的客户端可以通过 Consul 来中找到这个注册的服务（使用 DNS 或 HTTP）</li><li><strong>健康检查</strong>：Consul 客户端可以提供任意数量的健康检查，要么与给定的服务相关联（“网络服务器是否返回 200 OK”），要么与本地节点（“内存利用率是否低于 90%”）相关联。可以通过这个信息来监控集群健康状况，并且服务发现组件可以使用它来避免将请求路由到不健康的主机上</li><li><strong>KV 存储</strong>：应用程序可以将 Consul 的分层键/值存储用于多种目的，包括动态配置、功能标记、协调、领导选举等。简单的 HTTP API 使其易于使用</li><li><strong>安全服务通信</strong>：Consul 可以为服务生成和分发 TLS 证书，以建立相互的 TLS 连接。 <a href="https://www.consul.io/docs/connect/intentions">意图</a> 可用于定义允许哪些服务进行通信。可以通过实时更改意图轻松管理服务分段，而不是使用复杂的网络拓扑和静态防火墙规则</li><li><strong>多数据中心</strong>：Consul 支持开箱即用的多个数据中心。这意味着 Consul 的用户不必担心构建额外的抽象层以扩展到多个区域</li></ul><span id="more"></span><h1 id="Consul-Agent">Consul Agent</h1><p>每个为 Consul 提供服务的节点都会运行一个 Consul Agent，启动 Consul 必须运行 Agent（可以选择运行为 <code>Server</code> 或 <code>Client</code> 模式。每个数据中心至少要有一台 <code>Server</code>，一个 <code>Client</code>是一个非常轻量级的进程，用于注册服务，运行健康检查和转发对 <code>Server</code> 的查询） 这个 Agent 功能主要在于：</p><ol><li>负责对节点上的服务以及节点本身进行健康检查</li><li>Agent 会与一台或多台 Consul Server 保持通信（Consul Server 用于存储和复制数据）</li><li>Server 会自己选举一个 Leader。虽然 Consul 可以在一台服务器上运行，但建议使用 3 到 5 台以达到高可用。建议为每个数据中心启用 Consul Server 集群</li><li>Server 维护一个目录，这个目录保存着所有 Agent 提交的信息，包括哪些服务可用、哪些节点运行哪些服务、运行状况信息等。可以在<a href="https://www.consul.io/docs/internals/anti-entropy#catalog">此处</a>找到 Agent 和目录的交互方式</li></ol><p>当需要查找 Consul 中注册的服务或者各节点的基础设施组件时可以查询任何 Consul Server 或者 任何 Consul 代理。代理自动将查询转发到 Server。</p><p>每个数据中心都运行一个 Consul 服务器集群。当进行跨数据中心的服务发现或配置请求时，本地 Consul Server 将请求转发到远程数据中心并返回结果。</p><h1 id="Consul-对比">Consul 对比</h1><p>针对服务注册发现有很多中间件都可以做，比如 <code>zookeeper</code>  、<code>Etcd</code> 、<code>doozerd</code> 、<code>eureka</code>，Consul 相比于这些软件优势在于：</p><ul><li>使用 Raft 算法来保证一致性：Raft  比复杂的 Paxos  算法更直接。（<code>zookeeper</code> 采用的是 <code>Paxos</code>,  <code>etcd</code> 使用的则是 <code>Raft</code>）</li><li>支持多数据中心：内外网服务采用不同端口进行监听，多数据中心集群可以避免单数据中心的单点故障。（<code>zookeeper</code> 和 <code>etcd</code> 不支持多数据中心）</li><li>支持健康检查： <code>etcd</code> 不支持此功能</li><li>支持 <code>HTTP</code>/<code>DNS</code> /<code>GPRS</code> 协议接口： <code>zookeeper</code> 集成比较复杂，<code>etcd</code> 只支持 <code>http 协议</code></li><li>官方提供 WEB 管理界面，<code>etcd</code> 无此功能</li></ul><p>综合比较，Consul 作为服务注册和配置管理的新星，还是比较值得关注和研究的。官网：<a href="https://www.consul.io/docs/intro/vs/chef-puppet">Consul Vs Other Software </a>。</p><h1 id="Consul-架构">Consul 架构</h1><p><img src="/images/2021-09-20-04-10-46.png" alt=""></p><p>上图是官网给出的 Consul 架构图，简单了解一下这张图。首先可以看到有两个数据中心，分别标注为 &quot;DATACENTER1&quot;和 “DATACENTER2”。Consul对多个数据中心有天然非常好的支持，并推荐这么做。</p><p>每个数据中心内都混合着 <code>Client</code> 和 <code>Server</code>。推荐是3到5台 Server。这是在权衡故障场景下可用性和性能之间取得平衡给出的建议（随着机器的增加，共识的速度会逐渐变慢）。但Client 的数量没有限制的可以轻松地扩展到数千或数万。</p><p>所有在数据中心的代理都会参与一个<a href="https://www.consul.io/docs/internals/gossip%E3%80%81"><strong>Gossip</strong>协议</a>。这代表有一个 <code>Gossip</code> 池，其中保存着这个数据中心的所有 Agent。这么做目的在于：</p><ol><li>客户端不需要配置 Server地址，发现工作是自动完成的</li><li>检测代理故障的工作不放在单个Server上而是分布式的，使得故障检测的扩展性比原生的心跳方案要强得多。同时还为节点提供了故障检测，如果代理无法到达，那么该节点可能已经发生了故障</li><li>它被用作消息层，当发生重要事件（如Leader 选举）时进行通知</li></ol><p>每个数据中心的 Server 都会参与共同选举出一个 Leader，如果一个 Server 被选中为 Leader 那它会有额外的职责：<strong>Leader负责处理所有查询和事务</strong>。事务也会复制到所有参与选举的 Server。由于这个要求，当 <code>None-Leader Server</code> 收到RPC请求时，会将其转发给集群Leader。</p><blockquote><p>The server agents also operate as part of a WAN gossip pool. This pool is different from the LAN pool as it is optimized for the higher latency of the internet and is expected to contain only other Consul server agents. The purpose of this pool is to allow datacenters to discover each other in a low-touch manner. Bringing a new datacenter online is as easy as joining the existing WAN gossip pool. Because the servers are all operating in this pool, it also enables cross-datacenter requests. When a server receives a request for a different datacenter, it forwards it to a random server in the correct datacenter. That server may then forward to the local leader.</p><p>This results in a very low coupling between datacenters, but because of failure detection, connection caching and multiplexing, cross-datacenter requests are relatively fast and reliable.</p><p>In general, data is not replicated between different Consul datacenters. When a request is made for a resource in another datacenter, the local Consul servers forward an RPC request to the remote Consul servers for that resource and return the results. If the remote datacenter is not available, then those resources will also not be available, but that won’t otherwise affect the local datacenter. There are some special situations where a limited subset of data can be replicated, such as with Consul’s built-in <a href="https://learn.hashicorp.com/tutorials/consul/access-control-replication-multiple-datacenters">ACL replication</a> capability, or external tools like <a href="https://github.com/hashicorp/consul-replicate">consul-replicate</a>.</p><p>In some places, client agents may cache data from the servers to make it available locally for performance and reliability. Examples include Connect certificates and intentions which allow the client agent to make local decisions about inbound connection requests without a round trip to the servers. Some API endpoints also support optional result caching. This helps reliability because the local agent can continue to respond to some queries like service-discovery or Connect authorization from cache even if the connection to the servers is disrupted or the servers are temporarily unavailable.</p></blockquote><h1 id="Consul-安装">Consul 安装</h1><p>安装 Consul 没什么难度。具体参考官网：<a href="https://www.consul.io/docs/install">Consul 安装</a> ，这里只记录如何使用 Docker 安装 Consul。</p><p>准备 Consul 镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull consul <span class="comment"># 默认拉取latest</span></span><br><span class="line">docker pull consul:1.6.1 <span class="comment"># 拉取指定版本</span></span><br></pre></td></tr></table></figure><p>验证安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-01 ~]<span class="comment"># docker exec -it consul /bin/sh</span></span><br><span class="line">/ <span class="comment"># consul </span></span><br><span class="line">Usage: consul [--version] [--<span class="built_in">help</span>] &lt;<span class="built_in">command</span>&gt; [&lt;args&gt;]</span><br><span class="line"></span><br><span class="line">Available commands are:</span><br><span class="line">    acl            Interact with Consul<span class="string">&#x27;s ACLs</span></span><br><span class="line"><span class="string">    agent          Runs a Consul agent</span></span><br><span class="line"><span class="string">    catalog        Interact with the catalog</span></span><br><span class="line"><span class="string">    config         Interact with Consul&#x27;</span>s Centralized Configurations</span><br><span class="line">    connect        Interact with Consul Connect</span><br><span class="line">    debug          Records a debugging archive <span class="keyword">for</span> operators</span><br><span class="line">    event          Fire a new event</span><br><span class="line">    <span class="built_in">exec</span>           Executes a <span class="built_in">command</span> on Consul nodes</span><br><span class="line">    force-leave    Forces a member of the cluster to enter the <span class="string">&quot;left&quot;</span> state</span><br><span class="line">    info           Provides debugging information <span class="keyword">for</span> operators.</span><br><span class="line">    intention      Interact with Connect service intentions</span><br><span class="line">    join           Tell Consul agent to join cluster</span><br><span class="line">    keygen         Generates a new encryption key</span><br><span class="line">    keyring        Manages gossip layer encryption keys</span><br><span class="line">    kv             Interact with the key-value store</span><br><span class="line">    leave          Gracefully leaves the Consul cluster and shuts down</span><br><span class="line">    lock           Execute a <span class="built_in">command</span> holding a lock</span><br><span class="line">    login          Login to Consul using an auth method</span><br><span class="line">    <span class="built_in">logout</span>         Destroy a Consul token created with login</span><br><span class="line">    maint          Controls node or service maintenance mode</span><br><span class="line">    members        Lists the members of a Consul cluster</span><br><span class="line">    monitor        Stream logs from a Consul agent</span><br><span class="line">    operator       Provides cluster-level tools <span class="keyword">for</span> Consul operators</span><br></pre></td></tr></table></figure><h1 id="Consul-Server">Consul Server</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-01 coresrc]<span class="comment"># docker run -d --name=consul_server -p 8500:8500 consul agent -server -bootstrap -ui -node=1 -client=&#x27;0.0.0.0&#x27;</span></span><br><span class="line">355be46f502ca9f9e1498022e4c86fabf96c9e72b161cf4c71deff9c2012338b</span><br></pre></td></tr></table></figure><ul><li><code>agent</code>：启动 agent 进程（前面提过启动 Consul 必须运行 agent）</li><li><code>-server</code>：以 Server 模式启动</li><li><code>bootstrap</code>：表示这个节点是 <code>Server-Leader</code> ，上面说过正常情况下 Leader 是通过 Raft 算法选举出来的，但是集群第一次启动时需要一个引导 Leader，在引导群集后，就不要使用此标志了</li><li><code>node</code>：节点名称（集群中必须是唯一的，默认是该节点的主机名）</li><li><code>-client</code>：Consul 服务监听地址（这个地址提供 HTTP、DNS、RPC 等服务，默认是 <code>127.0.0.1</code> 不对外提供服务，需要对外提供服务改成 <code>0.0.0.0</code>）</li></ul><p>其它参数：</p><ul><li><code>-bootstrap-expect</code> ：在一个数据中心中期望提供的 Server 节点数量，当该值提供的时候，Consul一直等到达到指定 Sever 数目的时候才会引导整个集群，该标记不能和 <code>bootstrap</code> 共用</li><li><code>-bind</code>：该地址用来在集群内部的通讯，集群内的所有节点到地址都必须是可达的，默认是 <code>0.0.0.0</code></li><li><code>ui</code>：启动 Web UI 管理器（默认开放端口 <code>8500</code>）</li><li><code>-rejoin</code>：使 Consul 忽略先前的离开，在再次启动后仍旧尝试加入集群中</li><li><code>-config-dir</code>：配置文件目录，里面所有以.json结尾的文件都会被加载</li></ul><p>查看集群信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-01 ~]<span class="comment"># docker exec -it consul  consul members</span></span><br><span class="line">Node  Address          Status  Type    Build   Protocol  DC   Segment</span><br><span class="line">1     172.17.0.2:8301  alive   server  1.10.2  2         dc1  &lt;all&gt;</span><br></pre></td></tr></table></figure><h1 id="Consul-Server-集群">Consul Server 集群</h1><p>加入两个 Server 模式的 Consul 到集群中。Server 模式在集群中建议是 3个以上，这样更好的避免因为 Server 的宕机导致整个集群挂掉的风险，做到高可用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d  --name=consul_server2  consul  agent -server -bootstrap  -node=2 -client=<span class="string">&#x27;0.0.0.0&#x27;</span> -join=172.17.0.2</span><br><span class="line">docker run -d  --name=consul_server3  consul  agent -server -bootstrap  -node=3 -client=<span class="string">&#x27;0.0.0.0&#x27;</span> -join=172.17.0.2</span><br></pre></td></tr></table></figure><p>查看集群信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-01 ~]<span class="comment"># docker exec -it consul_server  consul members</span></span><br><span class="line">Node  Address          Status  Type    Build   Protocol  DC   Segment</span><br><span class="line">1     172.17.0.2:8301  alive   server  1.10.2  2         dc1  &lt;all&gt;</span><br><span class="line">2     172.17.0.3:8301  alive   server  1.10.2  2         dc1  &lt;all&gt;</span><br><span class="line">3     172.17.0.4:8301  alive   server  1.10.2  2         dc1  &lt;all&gt;</span><br></pre></td></tr></table></figure><h1 id="Consul-Client-加入集群">Consul Client 加入集群</h1><p>Client 在 Consul 集群中起到了代理 Server 的作用，Client 模式不持久化数据。一般情况每台应用服务器都会安装一个 Client ，这样可以减轻跨服务器访问带来性能损耗。也可以减轻 Server 的请求压力。</p><p>加入两个 Client 模式的 Consul：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name=consul_client1 consul agent -client -node=4 -join=172.17.0.2 -client=<span class="string">&#x27;0.0.0.0&#x27;</span></span><br><span class="line">docker run -d --name=consul_client2 consul agent -client -node=5 -join=172.17.0.2 -client=<span class="string">&#x27;0.0.0.0&#x27;</span></span><br></pre></td></tr></table></figure><p>查看集群信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-01 ~]<span class="comment"># docker exec -it consul_server  consul members</span></span><br><span class="line">Node          Address          Status  Type    Build   Protocol  DC   Segment</span><br><span class="line">1             172.17.0.2:8301  alive   server  1.10.2  2         dc1  &lt;all&gt;</span><br><span class="line">2             172.17.0.3:8301  alive   server  1.10.2  2         dc1  &lt;all&gt;</span><br><span class="line">3             172.17.0.4:8301  alive   server  1.10.2  2         dc1  &lt;all&gt;</span><br><span class="line">53c94791711e  172.17.0.5:8301  alive   client  1.10.2  2         dc1  &lt;default&gt;</span><br><span class="line">fa871a7045ec  172.17.0.6:8301  alive   client  1.10.2  2         dc1  &lt;default&gt;</span><br></pre></td></tr></table></figure><h1 id="Consul-对外接口">Consul 对外接口</h1><ul><li><a href="https://links.jianshu.com/go?to=http%3A%2F%2Flocalhost%3A8500%2Fv1%2Fstatus%2Fleader">http://localhost:8500/v1/status/leader</a>: 显示当前集群的Leader</li><li><a href="https://links.jianshu.com/go?to=http%3A%2F%2Flocalhost%3A8500%2Fv1%2Fagent%2Fmembers">http://localhost:8500/v1/agent/members</a>： 查看集群成员的详细信息</li><li><a href="https://links.jianshu.com/go?to=http%3A%2F%2Flocalhost%3A8500%2Fv1%2Fstatus%2Fpeers">http://localhost:8500/v1/status/peers</a>：显示集群中的Server成员</li><li><a href="https://links.jianshu.com/go?to=http%3A%2F%2Flocalhost%3A8500%2Fv1%2Fcatalog%2Fservices">http://localhost:8500/v1/catalog/services</a>： 显示所有服务</li><li><a href="https://links.jianshu.com/go?to=http%3A%2F%2Flocalhost%3A8500%2Fv1%2Fcatalog%2Fnodes">http://localhost:8500/v1/catalog/nodes</a>：显示集群节点的详细信息</li></ul><h1 id="参考：">参考：</h1><ul><li><a href="https://www.consul.io/docs/install">https://www.consul.io/docs/install</a></li><li><a href="https://www.bookstack.cn/read/consul-guide/06_setup_cluster.md">https://www.bookstack.cn/read/consul-guide/06_setup_cluster.md</a></li><li><a href="https://cloud.tencent.com/developer/article/1416526">https://cloud.tencent.com/developer/article/1416526</a></li><li><a href="https://www.jianshu.com/p/b12037fa3249">https://www.jianshu.com/p/b12037fa3249</a></li><li><a href="https://blog.csdn.net/liuzhuchen/article/details/81913562">https://blog.csdn.net/liuzhuchen/article/details/81913562</a></li><li><a href="http://www.liangxiansen.cn/2017/04/06/consul/#%E4%BD%BF%E7%94%A8consul">http://www.liangxiansen.cn/2017/04/06/consul/#使用consul</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/rabbitMq/1.1RabbitMQ%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%89%E8%A3%85/"/>
      <url>/rabbitMq/1.1RabbitMQ%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>消息(<code>Message</code> )是指在应用间传送的数据。消息可以非常简单，比如只包含文本字符串，也可以更复杂，可能包含嵌入对象。</p><p>消息队列（<code>Message Queue</code>）是一种应用间的通信方式，消息发送后可以立即返回，由消息系统来确保消息的可靠传递。消息发布者只管把消息发布到 MQ 中而不用管谁来取，消息使用者只管从MQ中取消息而不管是谁发布的。发布者和使用者都不用知道对方的存在。</p><span id="more"></span><h1 id="消息队列应用场景">消息队列应用场景</h1><p>消息队列是一种应用间的异步协作机制，以常见的订单系统为例，用户点击【下单】按钮之后的业务逻辑可能包括：扣减库存、生成相应单据、发红包、发短信通知。在业务发展初期这些逻辑可能放在一起同步执行，随着业务的发展订单量增长，需要提升系统服务的性能，这时可以将一些不需要立即生效的操作拆分出来异步执行，比如发放红包、发短信通知等。这种场景下就可以用 MQ，在下单的主流程（比如扣减库存、生成相应单据）完成之后发送一条消息到MQ让主流程快速完结，而由另外的单独线程拉取 MQ 的消息（或者由 MQ 推送消息），当发现 MQ 中有发红包或发短信之类的消息时，执行相应的业务逻辑。以上是用于业务解耦的情况，其它常见场景包括最终一致性、广播、错峰流控等。</p><h1 id="Features">Features</h1><p>RabbitMQ 是一个由 <code>Erlang</code> 语言开发的 <code>AMQP</code> 的开源实现。</p><p><strong>AMQP(Advanced Message)</strong></p><p>高级消息队列协议。它是应用层协议的一个开放标准，为面向消息的中间件设计，基于此协议的客户端与消息中间件可传递消息，并不受产品、开发语言等条件的限制。</p><p><strong>可靠性(Reliability)</strong></p><p>RabbitMQ 使用一些机制来保证可靠性，如持久化、传输确认、发布确认。</p><p><strong>灵活的路由(Flexible Routing)</strong></p><p>在消息进入队列之前，通过 Exchange 来路由消息的。对于典型的路由功能，RabbitMQ 已经提供了一些内置的 Exchange 来实现。针对更复杂的路由功能，可以将多个 Exchange绑定在一起，也通过插件机制实现自己的 Exchange。</p><p><strong>消息集群(Clustering)</strong></p><p>多个RabbitMQ服务器可以组成一个集群,形成一个逻辑 Broker。</p><p><strong>高可用(Highly Available Queues)</strong></p><p>队列可以在集群中的机器上进行镜像，使得在部分节点出问题的情况下队列仍然可用。</p><p><strong>可靠性(Reliability)</strong></p><p>RabbitMQ 支持多种消息队列协议，比如 STOMP、MQTT 等。</p><p><strong>多语言客户端(Many Clients)</strong></p><p>RabbitMQ 几乎支持所有常用语言，比如 Java、.NET、Ruby 等。</p><p><strong>管理界面(Management UI)</strong></p><p>RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息Broker的许多方面。</p><p><strong>跟踪机制(Tracing)</strong></p><p>如果消息异常，RabbitMQ 提供了消息跟踪机制，使用者可以找出发生了什么。</p><p><strong>插件机制(Plugin System)</strong></p><p>RabbitMQ 提供了许多插件，来从多方面进行扩展，也可以编写自己的插件。</p><h1 id="概念模型">概念模型</h1><h1 id="消息模型">消息模型</h1><p>所有 MQ 产品从模型抽象上来说都是一样的过程：消费者（consumer）订阅某个队列。生产者（producer）创建消息，然后发布到队列（queue）中，最后将消息发送到监听的消费者。</p><p><img src="/images/2021-09-05-21-40-33.png" alt=""></p><h1 id="RabbitMQ-基本概念">RabbitMQ 基本概念</h1><p>上面只是最简单抽象的描述，具体到 RabbitMQ则有更详细的概念需要解释。上面介绍过 RabbitMQ 是 AMQP协议的一个开源实现，所以其内部实际上也是 AMQP 中的基本概念。</p><p><img src="/images/2021-09-05-21-41-23.png" alt=""></p><h1 id="名词解释">名词解释</h1><p><strong>Message</strong></p><p>消息，消息是不具名的，它由消息头和消息体组成。消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括<code>routing-key</code>（路由键）、<code>priority</code>（相对于其他消息的优先权）、<code>delivery-mode</code>（指出该消息可能需要持久性存储）等。</p><p><strong>Publisher</strong></p><p>消息的生产者，也是一个向交换器发布消息的客户端应用程序。</p><p><strong>Exchange</strong></p><p>交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。</p><p><strong>Binding</strong></p><p>绑定，用于消息队列和交换器之间的关联。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，可以将交换器理解成一个由绑定构成的路由表。</p><p><strong>Queue</strong></p><p>消息队列，用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。</p><p><strong>Connection</strong></p><p>网络连接，比如一个<code>TCP连接</code>。</p><p><strong>Channel</strong></p><p>信道，多路复用连接中的一条独立的双向数据流通道。信道是建立在真实的TCP连接内地虚拟连接，AMQP 命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。因为对于操作系统来说建立和销毁 TCP 都是非常昂贵的开销，所以引入了信道的概念，以复用一条 <code>TCP 连接</code>。</p><p><strong>Consumer</strong></p><p>消息的消费者，表示一个从消息队列中取得消息的客户端应用程序。</p><p><strong>Virtual Host</strong></p><p>虚拟主机，表示一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。每个 <code>vhost</code> 本质上就是一个 <code>mini</code> 版的 RabbitMQ 服务器，拥有自己的队列、交换器、绑定和权限机制。vhost 是 AMQP 概念的基础，必须在连接时指定，RabbitMQ 默认的 vhost 是 <code>/</code>。</p><p><strong>Broker</strong></p><p>表示消息队列服务器实体。</p><p><strong>消息路由</strong></p><p>AMQP中增加了Exchange 和 Binding 的角色。生产者把消息发布到 Exchange 上，消息最终到达队列并被消费者接收，而Binding决定交换器的消息应该发送到哪个队列。</p><p><img src="/images/2021-09-05-21-45-45.png" alt=""></p><h1 id="RabbitMQ安装">RabbitMQ安装</h1><h2 id="Windows">Windows</h2><h3 id="安装Erlang">安装Erlang</h3><blockquote><p>因为RabbitMQ是用Erlang语言编写的，所以要安装RabbitMQ先要安装Erlang</p></blockquote><ol><li>下载地址: <a href="http://www.erlang.org/downloads">http://www.erlang.org/downloads</a> 根据需要选择版本</li><li>下载完成后直接安装，一路<code>next</code>（路径自行选择）</li><li>命令行输入：<code>erl</code>，提示版本信息: <code>Eshell V10.6  (abort with ^G)</code>, 说明Erlang安装成功</li></ol><h3 id="安装RabbitMQ">安装RabbitMQ</h3><ol><li>下载地址:  <a href="https://www.rabbitmq.com/install-windows.html">https://www.rabbitmq.com/install-windows.html</a></li><li>根据需要选择版本(注意：RabbitMQ和Erlang版本可能存在不匹配情况)</li><li>下载完成后直接安装，一路<code>next</code>（路径自行选择）</li></ol><h3 id="环境变量配置">环境变量配置</h3><ol><li>新建环境变量<code>ERLANG_HOME</code>，路径为Erlang安装路径</li><li>新建环境变量<code>RABBITMQ_SERVER</code>，路径为RabbitMQ安装路径</li><li>在<code>Path</code>中添加<code>ERLANG_HOME</code>和<code>RABBITMQ_SERVER</code></li></ol><h3 id="Management-Plugin可视化插件">Management Plugin可视化插件</h3><ol><li>进入到RabbitMQ安装目录, <code>D:\RabbitMQ\rabbitmq_server-3.8.2\sbin</code></li><li>运行命令：<code>rabbitmq-plugins.bat enable rabbitmq_management</code></li><li>浏览器访问：<a href="http://localhost:15672/">http://localhost:15672/</a> 用户名/密码均为: <code>guest</code></li></ol><h2 id="Centos">Centos</h2><p>采用的虚拟机系统为<code>Centos7</code>，采用的安装方式是<code>yum</code>安装，为了简单，直接使用官方提供的 <code>erlang</code> 和 <code>RabbitMQ-server</code> 的自动安装脚本(官方安装文档)，逐行执行下边的代码就可以安装完成 <code>erlang </code>和 <code>RabbitMQ</code>。</p><h4 id="安装socat">安装socat</h4><p><code>yum install socat</code></p><h4 id="安装erlang">安装erlang</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -s https://packagecloud.io/install/repositories/rabbitmq/erlang/script.rpm.sh | sudo bash</span><br><span class="line">yum -y install erlang</span><br></pre></td></tr></table></figure><h4 id="安装rabbitMQ-server">安装rabbitMQ-server</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -s https://packagecloud.io/install/repositories/rabbitmq/rabbitmq-server/script.rpm.sh | sudo bash</span><br><span class="line">yum -y install rabbitmq-server</span><br></pre></td></tr></table></figure><h4 id="启动rabbitMQ服务">启动rabbitMQ服务</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start rabbitmq-server</span><br></pre></td></tr></table></figure><h4 id="添加Web管理插件">添加Web管理插件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_management</span><br></pre></td></tr></table></figure><h4 id="开放端口">开放端口</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=5672/tcp --permanent</span><br><span class="line">firewall-cmd --zone=public --add-port=15672/tcp --permanent</span><br></pre></td></tr></table></figure><h4 id="重新加载防火墙">重新加载防火墙</h4><p><code>firewall-cmd --reload</code></p><h4 id="访问Web界面">访问Web界面</h4><p>默认账号密码都是 <code>guest</code>   ，但是如果使用 <code>guest</code> 登录，会出现报错如下：</p><p><img src="/images/2021-09-05-21-51-59.png" alt=""></p><p>原因是 <code>RabbitMQ3.3</code> 以后，<code>guest</code> 账号只能在本机登录。创建其他登录账号然后重启 <code>RabbitMQ</code> 即可。</p><h4 id="创建用户">创建用户</h4><p>如果是登录虚机中的RabbitMq无法使用<code>guest</code>账户,需要创建其他登录账户</p><p>创建用户名<code>admin</code>，密码<code>admin</code>的用户</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl add_user admin admin</span><br></pre></td></tr></table></figure><p>设置admin为超级管理员</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_user_tags admin administrator</span><br></pre></td></tr></table></figure><p>授权远程访问（也可以登录后可视化配置）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_permissions -p / admin <span class="string">&quot;.&quot;</span> <span class="string">&quot;.&quot;</span> <span class="string">&quot;.*&quot;</span></span><br></pre></td></tr></table></figure><p>创建完成后重启RabbitMQ</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart rabbitmq-server`</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/rabbitMq/1.3%E6%B6%88%E6%81%AF%E7%A1%AE%E8%AE%A4%E5%8F%8A%E6%8C%81%E4%B9%85%E5%8C%96/"/>
      <url>/rabbitMq/1.3%E6%B6%88%E6%81%AF%E7%A1%AE%E8%AE%A4%E5%8F%8A%E6%8C%81%E4%B9%85%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>学习rabbitMq中的消息确认和持久化机制</p><span id="more"></span><h1 id="生产端消息确认">生产端消息确认</h1><h2 id="tx机制">tx机制</h2><blockquote><p>tx机制叫做事务机制，RabbitMQ中有三个与tx机制的方法：<code>txSelect()</code>、<code>txCommit()</code>、<code>txRollback()</code></p></blockquote><ul><li><code>channel.txSelect()</code>： 用于将当前<code>channel</code>设置成<code>transaction</code>模式</li><li><code>channel.txCommit()</code> ：提交事务</li><li><code>channel.txRollback()</code> ：回滚事务</li></ul><p>使用 <code>tx</code> 机制，首先要通过<code>txSelect</code> 方法开启事务，然后发布消息给 <code>broker</code> 服务器，如果 <code>txCommit</code> 提交成功，则说明消息成功被 <code>broker</code> 接收；如果在<code>txCommit</code> 执行之前 <code>broker</code> 异常崩溃或者由于其他原因抛出异常，这个时候可以捕获异常，通过 <code>txRollback</code> 回滚事务。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 生产端消息确认(tx事务机制)</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">[<span class="meta">TestMethod</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PublisherTest_Transaction</span>(<span class="params"></span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    channel.QueueDeclare(queue: queueName, durable: <span class="literal">false</span>, exclusive: <span class="literal">false</span>, autoDelete: <span class="literal">false</span>, arguments: <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> message = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="built_in">byte</span>[] messageBody = Encoding.UTF8.GetBytes(message);</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 开启tx事务机制</span></span><br><span class="line">        channel.TxSelect();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消息发送</span></span><br><span class="line">        channel.BasicPublish(exchange: <span class="string">&quot;&quot;</span>, routingKey: queueName, basicProperties: <span class="literal">null</span>, body: messageBody);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 事务提交</span></span><br><span class="line">        channel.TxCommit();</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Exception ex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 事务回滚</span></span><br><span class="line">        channel.TxRollback();</span><br><span class="line">        Assert.Fail(ex.Message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Confirm模式">Confirm模式</h2><blockquote><p>C#的RabbitMQ API中，有三个与Confirm相关的方法：<code>ConfirmSelect()</code>、<code>WaitForConfirms()</code>、<code>WaitForConfirmOrDie</code></p></blockquote><ul><li><code>channel.ConfirmSelect()</code> ：表示开启Confirm模式</li><li><code>channel.WaitForConfirms()</code> ：等待所有消息确认，如果所有的消息都被服务端成功接收返回true，只要有一条没有被成功接收就返回<code>false</code></li><li><code>channel.WaitForConfirmsOrDie()</code>和<code>WaitForConfirms</code>作用类型，也是等待所有消息确认。区别在于该方法没有返回值(<code>Void</code>)，如果有任意一条消息没有被成功接收，该方法会立即抛出<code>OperationInterrupedException</code>类型异常</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 生产端消息确认(Confirm模式)</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">[<span class="meta">TestMethod</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PublisherTest_Confirm</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    channel.QueueDeclare(queue: queueName, durable: <span class="literal">false</span>, exclusive: <span class="literal">false</span>, autoDelete: <span class="literal">false</span>, arguments: <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> message = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="built_in">byte</span>[] messageBody = Encoding.UTF8.GetBytes(message);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启Confirm模式</span></span><br><span class="line">    channel.ConfirmSelect();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息发送</span></span><br><span class="line">    channel.BasicPublish(exchange: <span class="string">&quot;&quot;</span>, routingKey: queueName, basicProperties: <span class="literal">null</span>, body: messageBody);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// WaitForConfirms确认消息(可以同时确认多条消息)是否发送成功</span></span><br><span class="line">    <span class="keyword">if</span> (channel.WaitForConfirms())</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Message发送成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Assert.Fail();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="消费端消息确认">消费端消息确认</h1><h2 id="自动确认">自动确认</h2><blockquote><p>当RabbbitMQ将消息发送给消费者后，消费者接收到消息后，不等待消息处理结束，立即自动回送一个确认回执。自动确认的用法十分简单，设置消费方法的参数 autoAck 为 true 即可</p></blockquote><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EventingBasicConsumer consumer = <span class="keyword">new</span> EventingBasicConsumer(channel);</span><br><span class="line"></span><br><span class="line">consumer.Received += (model, ea) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> message =</span><br><span class="line">           Encoding.UTF8.GetString(ea.Body.ToArray());</span><br><span class="line">&#125;;</span><br><span class="line">channel.BasicConsume(queue: <span class="string">&quot;hello&quot;</span>, autoAck: <span class="literal">true</span>, consumer: consumer);</span><br></pre></td></tr></table></figure><p>可能存在的问题：</p><ol><li>丢失数据：Broker会在接收到确认回执时删除消息，如果消费者接收到消息并返回了确认回执，然后这个消费者在处理消息时挂了，那么这条消息就再也找不回来了</li><li>只要队列不空，RabbitMQ会源源不断的把消息推送给客户端，而不管客户端能否消费的完，如果其中一个消费端消费的较慢,会极大的浪费性能</li></ol><h2 id="手动确认-BasicAck">手动确认(BasicAck)</h2><blockquote><p>消费从队列中获取消息后，服务器会将该消息处于不可用状态，等待消费者反馈。<code>Resume</code>方法的参数<code>autoAck</code>设置为<code>false</code>，然后在消费端使用代码 <code>channel.BasicAck()</code>/<code>BasicReject()</code>等方法来确认和拒绝消息即可实现手动确认</p></blockquote><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">EventingBasicConsumer consumer = <span class="keyword">new</span> EventingBasicConsumer(channel);</span><br><span class="line"></span><br><span class="line">consumer.Received += (model, ea) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> message =</span><br><span class="line">           Encoding.wUTF8.GetString(ea.Body.ToArray());</span><br><span class="line"> <span class="comment">// 手动ack</span></span><br><span class="line">    channel.BasicAck(</span><br><span class="line">        deliveryTag: ea.DeliveryTag,</span><br><span class="line">        multiple: <span class="literal">false</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">channel.BasicConsume(queue: <span class="string">&quot;hello&quot;</span>,</span><br><span class="line">    autoAck: <span class="literal">false</span>,</span><br><span class="line">    consumer: consumer);</span><br></pre></td></tr></table></figure><p>改为手动确认方式只需改两处</p><ol><li>开启监听时将 <code>autoAck</code> 参数改为 <code>false</code></li><li>消息消费成功后返回确认</li></ol><p>这段代码中，先处理消息，成功后再做 <code>ack</code>响应，失败就不做 <code>ack</code>响应，这样消息会储存在<code>MQ</code>的<code>Unacked</code>消息里，不会丢失，看起来没啥问题，但是如果其中一条消息在处理时抛出了异常，将导致后续所有消息都会无法消费。</p><h1 id="消息拒绝">消息拒绝</h1><h2 id="BasicNack">BasicNack()</h2><blockquote><p>与<code>BasicReject()</code>不同的是同时支持多个消息，可以<code>nack</code> 该消费者先前接收未<code>ack</code> 的所有消息</p></blockquote><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">EventingBasicConsumer consumer =</span><br><span class="line">    <span class="keyword">new</span> EventingBasicConsumer(channel);</span><br><span class="line"></span><br><span class="line">consumer.Received += (model, ea) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> message =</span><br><span class="line">           Encoding.UTF8.GetString(ea.Body.ToArray());</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 消费到某条消息时出错</span></span><br><span class="line"><span class="comment">         * 导致Broker无法拿到正常回执信息引发后续消息都无法被正常消费</span></span><br><span class="line"><span class="comment">         * 如果MQ没得到ack响应，这些消息会堆积在Unacked消息里,不会丢弃,直至客户端断开重连时，才变回ready</span></span><br><span class="line"><span class="comment">         * 如果Consumer客户端不断开连接，这些Unacked消息，永远不会变回ready状态</span></span><br><span class="line"><span class="comment">         * Unacked消息多了,占用内存越来越大,就会异常</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        MessageConsumer(ea);</span><br><span class="line">        channel.BasicAck(</span><br><span class="line">                   deliveryTag: ea.DeliveryTag,</span><br><span class="line">                   multiple: <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Exception ex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 出错了，发nack，并通知MQ把消息塞回的队列头部（不是尾部）</span></span><br><span class="line">        channel.BasicNack(</span><br><span class="line">            deliveryTag: ea.DeliveryTag,</span><br><span class="line">            multiple: <span class="literal">false</span>,</span><br><span class="line">            requeue: <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">channel.BasicConsume(queue: <span class="string">&quot;hello&quot;</span>,</span><br><span class="line">    autoAck: <span class="literal">false</span>,</span><br><span class="line">    consumer: consumer);</span><br></pre></td></tr></table></figure><p>这里将代码调整为消费正常就 <code>ack</code>，不正常就<code>nack</code>，并等下一次重新消费。看起来没问题，但是如果某条消息在消费时又抛出异常，该消息将会被<code>Nack</code>机制重新扔回 <strong>队列头部</strong>，下一步又消费这条会出异常的消息，又出错，塞回队列……进入死循环，所以要谨慎使用<code>Nack</code>机制。这里可以在<code>catch</code>中记录错误日志依旧使用<code>ack</code>确认消费。</p><h2 id="BasicReject">BasicReject()</h2><blockquote><p>消费端告诉服务器这个消息拒绝接收，不处理，可以设置是否放回到队列中还是丢掉(只能一次拒绝一个消息)</p></blockquote><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">MessagePublisher(<span class="string">&quot;hello&quot;</span>, <span class="string">$&quot;1&quot;</span>);</span><br><span class="line">MessagePublisher(<span class="string">&quot;hello&quot;</span>, <span class="string">$&quot;2&quot;</span>);</span><br><span class="line">MessagePublisher(<span class="string">&quot;hello&quot;</span>, <span class="string">$&quot;3&quot;</span>);</span><br><span class="line"></span><br><span class="line">channel.QueueDeclare(</span><br><span class="line">    queue: <span class="string">&quot;hello&quot;</span>,</span><br><span class="line">    durable: <span class="literal">false</span>,</span><br><span class="line">    exclusive: <span class="literal">false</span>,</span><br><span class="line">    autoDelete: <span class="literal">false</span>,</span><br><span class="line">    arguments: <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">EventingBasicConsumer consumer =</span><br><span class="line">    <span class="keyword">new</span> EventingBasicConsumer(channel);</span><br><span class="line"></span><br><span class="line">channel.BasicQos(<span class="number">0</span>, <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">consumer.Received += (model, ea) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> message =</span><br><span class="line">           Encoding.UTF8.GetString(ea.Body.ToArray());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (message == <span class="string">&quot;2&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Message：<span class="subst">&#123;message&#125;</span>&quot;</span>);</span><br><span class="line">        channel.BasicAck(</span><br><span class="line">            deliveryTag: ea.DeliveryTag,</span><br><span class="line">            multiple: <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;拒绝处理&quot;</span>);</span><br><span class="line">        <span class="comment">/* BasicReject用于拒绝消息</span></span><br><span class="line"><span class="comment">           requeue参数指定了拒绝后是否重新放回queue</span></span><br><span class="line"><span class="comment">           一次只能拒绝一条消息</span></span><br><span class="line"><span class="comment">           设置为true: 消息会被重新仍回queue中</span></span><br><span class="line"><span class="comment">           设置为false:消息将被丢弃</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        channel.BasicReject(</span><br><span class="line">            deliveryTag: ea.DeliveryTag,</span><br><span class="line">            requeue: <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">channel.BasicConsume(queue: <span class="string">&quot;hello&quot;</span>,</span><br><span class="line">    autoAck: <span class="literal">false</span>,</span><br><span class="line">    consumer: consumer);</span><br></pre></td></tr></table></figure><h2 id="BasicRecover">BasicRecover()</h2><blockquote><p>路由不成功的消息可以使用<code>recovery</code>重新发送到队列中,参数是是否requeue，true则重新入队列，并且尽可能的将之前recover的消息投递给其他消费者消费，而不是自己再次消费。false则消息会重新被投递给自己</p></blockquote><h1 id="消息持久化-Persistent">消息持久化 Persistent</h1><table><thead><tr><th>参数</th><th>重启RabbitMQ</th></tr></thead><tbody><tr><td>exchange.durable=fasle/queue.durable=false</td><td>exchange/queue将会被丢弃</td></tr><tr><td>exchange.durable=fasle</td><td>exchange将会被丢弃</td></tr><tr><td>queue.durable=fasle</td><td>queue将会被丢弃</td></tr><tr><td>exchange.durable=fasle/queue.durable=true</td><td>exchange将会被丢弃,queue虽然会存在,但队列内消息会全部丢失</td></tr><tr><td>exchange.durable=true/queue.durable=true</td><td>exchange/queue会存在,但队列内消息会全部丢失</td></tr><tr><td>exchange.durable=true&amp;&amp;queue.durable=true/消息发布时(persistent=true)</td><td>消息真正的持久化</td></tr></tbody></table><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">byte</span>[] messageBody = Encoding.UTF8.GetBytes(i.ToString());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置消息持久化</span></span><br><span class="line">    <span class="keyword">var</span> props = channel.CreateBasicProperties();</span><br><span class="line">    props.Persistent = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息发送</span></span><br><span class="line">    channel.BasicPublish(</span><br><span class="line">        exchange: <span class="string">&quot;TestExchange&quot;</span>,</span><br><span class="line">        routingKey: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        basicProperties: props,</span><br><span class="line">        body: messageBody);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="消息优先级-Priority">消息优先级 Priority</h1><blockquote><p>queue是先进先出的，即先发送的消息先被消费。但是在具体业务中可能会遇到要提前处理某些消息的需求，如一个常见的需求：普通客户的消息按先进先出的顺序处理，vip客户的消息要提前处理。消息实现优先级控制的实现方式是：首先在声明queue是设置队列的<code>x-max-priority</code>属性，然后在<code>publish</code>消息时，设置消息的优先级等级即可</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 消息优先级</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">[<span class="meta">TestMethod</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PublisherTest_Priority</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    channel.QueueDeclare(queue: queueName, durable: <span class="literal">false</span>, exclusive: <span class="literal">false</span>, autoDelete: <span class="literal">false</span>,</span><br><span class="line">                       arguments: <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">object</span>&gt;() &#123;</span><br><span class="line">                       <span class="comment">// 队列优先级最高为10，不加x-max-priority的话，消息发布时设置了消息的优先级也不会生效</span></span><br><span class="line">                       &#123;<span class="string">&quot;x-max-priority&quot;</span>,<span class="number">10</span> &#125;</span><br><span class="line">                       &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试数据</span></span><br><span class="line">    <span class="built_in">string</span>[] msgs = &#123; <span class="string">&quot;vip1&quot;</span>, <span class="string">&quot;hello1&quot;</span>, <span class="string">&quot;hello2&quot;</span>, <span class="string">&quot;hello3&quot;</span>, <span class="string">&quot;vip5&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置消息优先级</span></span><br><span class="line">    IBasicProperties props = channel.CreateBasicProperties();</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="built_in">string</span> msg <span class="keyword">in</span> msgs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// vip开头的消息，优先级设置为9,其他消息优先级为1</span></span><br><span class="line">        <span class="keyword">if</span> (msg.StartsWith(<span class="string">&quot;vip&quot;</span>))</span><br><span class="line">            props.Priority = <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            props.Priority = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        channel.BasicPublish(exchange: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                               routingKey: queueName,</span><br><span class="line">                               basicProperties: props,</span><br><span class="line">                               body: Encoding.UTF8.GetBytes(msg));</span><br><span class="line">    &#125;</span><br><span class="line">    Assert.IsTrue(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/rabbitMq/1.4%E4%B8%A4%E7%A7%8D%E6%B6%88%E8%B4%B9%E6%A8%A1%E5%BC%8F%E5%92%8CQOS%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/rabbitMq/1.4%E4%B8%A4%E7%A7%8D%E6%B6%88%E8%B4%B9%E6%A8%A1%E5%BC%8F%E5%92%8CQOS%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>学习rabbitMq的消费模式</p><span id="more"></span><h1 id="消费模式">消费模式</h1><h2 id="EventingBasicConsumer">EventingBasicConsumer</h2><p><code>EventingBasicConsumer </code>是发布/订阅模式的消费者，即只要订阅的 <code>queue</code> 中有了新消息，Broker就会立即把消息推送给消费者，这种模式可以保证消息及时地被消费者接收到。<code>EventingBasicConsumer </code>是长连接的，只需要创建一个 <code>Connection</code> ,然后在 <code>Connection</code> 的基础上创建通道 <code>channel</code>，消息的发送都是通过 <code>channel</code> 来执行的，这样可以减少 <code>Connection</code> 的创建，比较节省资源。之前一直使用的就是 <code>EventingBasicConsumer</code> 不再赘述。</p><h2 id="BasicGet">BasicGet</h2><p><code>EventingBasicConsumer</code> 可以让消费者最及时地获取到消息，使用 <code>EventingBasicConsumer</code> 模式时消费者在被动的接收消息，即消息是推送过来的，<code>Broker</code>是主动的一方，如果想让消费者作为主动的一方什么时候想要消息了，就自己发送一个请求去找<code>Broker</code>可以使用<code>Get</code>方式。<code>Get</code>方式是短连接的，消费者每次想要消息的时候，首先建立一个<code>connection</code>，发送一次请求，<code>Broker</code>接收到请求后，响应一条消息给消费者，然后断开连接。RabbitMQ中Get方式和HTTP的请求响应流程基本一样，Get方式的实时性比较差，也比较耗费资源。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BasicGetResult result = channel.BasicGet(queue: <span class="string">&quot;test&quot;</span>, autoAck: <span class="literal">true</span>);</span><br><span class="line">Assert.IsNotNull(result.Body.ToArray());</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;接收到消息<span class="subst">&#123;Encoding.UTF8.GetString(result.Body.ToArray())&#125;</span>&quot;</span>);</span><br><span class="line"><span class="comment">// 打印exchange和routingKey</span></span><br><span class="line">Console.WriteLine(<span class="string">$&quot;exchange：<span class="subst">&#123;result.Exchange&#125;</span>,routingKey:<span class="subst">&#123;result.RoutingKey&#125;</span>&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="QueueBaicConsumer">QueueBaicConsumer</h2><p>用法和Get方式类似，QueueBaicConsumer在官方API中标记已过时，不再介绍。</p><h1 id="BasicQos">BasicQos</h1><ul><li>当消息有十万，百万条时，一股脑把消息发送给消费者，可能会造成消费者内存爆满</li><li>当消息处理比较慢的时，单一的消费者处理这些消息可能很长时间，自然想到再添加一个消费者加快消息的处理速度，但是这些消息都被原来的消费者接收了，状态为<code>Unacked</code>，所以这些消息不会再发送给新添加的消费者</li></ul><p>RabbitMQ提供的<code>Qos(服务质量)</code>可以完美解决上边的问题，使用<code>Qos</code>时，<code>Broke</code>不会再把消息全部发送给消费者，可以设置每次传输给消费者的消息条数<code>n</code>，消费者把这n条消息处理完成后，再获取n条数据进行处理，这样就不用担心消息丢失、服务端内存爆满的问题，因为没有发送的消息状态都是<code>Ready</code>，所以新增一个消费者时，消息也可以立即发送给新增的消费者。</p><p>使用<code>Qos</code>的方式十分简单,在消费端调用<code>channel.BasicQos()</code>方法即可。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.BasicQos(prefetchSize: <span class="number">0</span>, prefetchCount: <span class="number">2</span>, <span class="keyword">global</span>: <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/rabbitMq/1.5Channel%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95/"/>
      <url>/rabbitMq/1.5Channel%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>记录rabbitMq中Channel常见的方法</p><span id="more"></span><h1 id="channel-exchangeDeclare">channel.exchangeDeclare()</h1><ul><li><code>type</code>：direct、fanout、topic</li><li><code>durable</code>：(<code>true、false</code>) true：服务器重启会保留下来Exchange。警告：仅设置此选项，不代表消息持久化。即不保证重启后消息还在。</li></ul><blockquote><p>原文：true if we are declaring a durable exchange (the exchange will survive a server restart</p></blockquote><ul><li><code>autoDelete</code>：(<code>true、false</code>) true：当已经没有消费者时，服务器是否可以删除该Exchange</li></ul><blockquote><p>原文：true if the server should delete the exchange when it is no longer in use</p></blockquote><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Declare an exchange.</span></span><br><span class="line"><span class="comment">    * @see com.rabbitmq.client.AMQP.Exchange.Declare</span></span><br><span class="line"><span class="comment">    * @see com.rabbitmq.client.AMQP.Exchange.DeclareOk</span></span><br><span class="line"><span class="comment">    * @param exchange the name of the exchange</span></span><br><span class="line"><span class="comment">    * @param type the exchange type</span></span><br><span class="line"><span class="comment">    * @param durable true if we are declaring a durable exchange (the exchange will survive a server restart)</span></span><br><span class="line"><span class="comment">    * @param autoDelete true if the server should delete the exchange when it is no longer in use</span></span><br><span class="line"><span class="comment">    * @param arguments other properties (construction arguments) for the exchange</span></span><br><span class="line"><span class="comment">    * @return a declaration-confirm method to indicate the exchange was successfully declared</span></span><br><span class="line"><span class="comment">    * @throws java.io.IOException if an error is encountered</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   Exchange.<span class="function">DeclareOk <span class="title">exchangeDeclare</span>(<span class="params">String exchange, String type, boolean durable, boolean autoDelete,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      Map&lt;String, Object&gt; arguments</span>) throws IOException</span>;</span><br></pre></td></tr></table></figure><h1 id="chanel-basicQos">chanel.basicQos()</h1><ul><li><code>prefetchSize</code>：0</li><li><code>prefetchCount</code>：会告诉RabbitMQ不要同时给一个消费者推送多于N个消息，即一旦有N个消息还没有ack，则该consumer将block掉，直到有消息ack</li><li><code>global</code>：<code>true\false</code> 是否将上面设置应用于channel，简单点说，就是上面限制是<code>channel</code>级别的还是<code>consumer</code>级别</li></ul><p>备注：据说prefetchSize 和global这两项，rabbitmq没有实现，暂且不研究</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Request specific &quot;quality of service&quot; settings.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * These settings impose limits on the amount of data the server</span></span><br><span class="line"><span class="comment"> * will deliver to consumers before requiring acknowledgements.</span></span><br><span class="line"><span class="comment"> * Thus they provide a means of consumer-initiated flow control.</span></span><br><span class="line"><span class="comment"> * @see com.rabbitmq.client.AMQP.Basic.Qos</span></span><br><span class="line"><span class="comment"> * @param prefetchSize maximum amount of content (measured in</span></span><br><span class="line"><span class="comment"> * octets) that the server will deliver, 0 if unlimited</span></span><br><span class="line"><span class="comment"> * @param prefetchCount maximum number of messages that the server</span></span><br><span class="line"><span class="comment"> * will deliver, 0 if unlimited</span></span><br><span class="line"><span class="comment"> * @param global true if the settings should be applied to the</span></span><br><span class="line"><span class="comment"> * entire channel rather than each consumer</span></span><br><span class="line"><span class="comment"> * @throws java.io.IOException if an error is encountered</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">basicQos</span>(<span class="params"><span class="built_in">int</span> prefetchSize, <span class="built_in">int</span> prefetchCount, boolean <span class="keyword">global</span></span>) throws IOException</span>;</span><br></pre></td></tr></table></figure><h1 id="channel-basicPublish">channel.basicPublish()</h1><ul><li><code>routingKey</code>：路由键，#匹配0个或多个单词，*匹配一个单词，在topic exchange做消息转发用</li><li><code>mandatory</code>：true：如果exchange根据自身类型和消息routeKey无法找到一个符合条件的queue，那么会调用basic.return方法将消息返还给生产者。false：出现上述情形broker会直接将消息扔掉</li><li><code>immediate</code>：true：如果exchange在将消息route到queue(s)时发现对应的queue上没有消费者，那么这条消息不会放入队列中。当与消息routeKey关联的所有queue(一个或多个)都没有消费者时，该消息会通过basic.return方法返还给生产者。</li><li><code>BasicProperties</code> ：需要注意的是<code>BasicProperties.deliveryMode</code>，0:不持久化 1：持久化 这里指的是消息的持久化，配合channel(durable=true),queue(durable)可以实现，即使服务器宕机，消息仍然保留</li></ul><blockquote><p>简单来说：<code>mandatory</code>标志告诉服务器至少将该消息route到一个队列中，否则将消息返还给生产者；<code>immediate</code>标志告诉服务器如果该消息关联的queue上有消费者，则马上将消息投递给它，如果所有queue都没有消费者，直接把消息返还给生产者，不用将消息入队列等待消费者了</p></blockquote><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Publish a message.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * Publishing to a non-existent exchange will result in a channel-level</span></span><br><span class="line"><span class="comment">   * protocol exception, which closes the channel.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * Invocations of &lt;code&gt;Channel#basicPublish&lt;/code&gt; will eventually block if a</span></span><br><span class="line"><span class="comment">   * &lt;a href=&quot;http://www.rabbitmq.com/alarms.html&quot;&gt;resource-driven alarm&lt;/a&gt; is in effect.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @see com.rabbitmq.client.AMQP.Basic.Publish</span></span><br><span class="line"><span class="comment">   * @see &lt;a href=&quot;http://www.rabbitmq.com/alarms.html&quot;&gt;Resource-driven alarms&lt;/a&gt;.</span></span><br><span class="line"><span class="comment">   * @param exchange the exchange to publish the message to</span></span><br><span class="line"><span class="comment">   * @param routingKey the routing key</span></span><br><span class="line"><span class="comment">   * @param mandatory true if the &#x27;mandatory&#x27; flag is to be set</span></span><br><span class="line"><span class="comment">   * @param immediate true if the &#x27;immediate&#x27; flag is to be</span></span><br><span class="line"><span class="comment">   * set. Note that the RabbitMQ server does not support this flag.</span></span><br><span class="line"><span class="comment">   * @param props other properties for the message - routing headers etc</span></span><br><span class="line"><span class="comment">   * @param body the message body</span></span><br><span class="line"><span class="comment">   * @throws java.io.IOException if an error is encountered</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">basicPublish</span>(<span class="params">String exchange, String routingKey, boolean mandatory, boolean immediate, BasicProperties props, <span class="built_in">byte</span>[] body</span>)</span></span><br><span class="line"><span class="function">          throws IOException</span>;</span><br></pre></td></tr></table></figure><h1 id="channel-basicAck">channel.basicAck()</h1><ul><li><code>deliveryTag</code>：该消息的index</li><li><code>multiple</code>：是否批量；true:将一次性ack所有小于deliveryTag的消息</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Acknowledge one or several received</span></span><br><span class="line"><span class="comment"> * messages. Supply the deliveryTag from the &#123;@link com.rabbitmq.client.AMQP.Basic.GetOk&#125;</span></span><br><span class="line"><span class="comment"> * or &#123;@link com.rabbitmq.client.AMQP.Basic.Deliver&#125; method</span></span><br><span class="line"><span class="comment"> * containing the received message being acknowledged.</span></span><br><span class="line"><span class="comment"> * @see com.rabbitmq.client.AMQP.Basic.Ack</span></span><br><span class="line"><span class="comment"> * @param deliveryTag the tag from the received &#123;@link com.rabbitmq.client.AMQP.Basic.GetOk&#125; or &#123;@link com.rabbitmq.client.AMQP.Basic.Deliver&#125;</span></span><br><span class="line"><span class="comment"> * @param multiple true to acknowledge all messages up to and</span></span><br><span class="line"><span class="comment"> * including the supplied delivery tag; false to acknowledge just</span></span><br><span class="line"><span class="comment"> * the supplied delivery tag.</span></span><br><span class="line"><span class="comment"> * @throws java.io.IOException if an error is encountered</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">basicAck</span>(<span class="params"><span class="built_in">long</span> deliveryTag, boolean multiple</span>) throws IOException</span>;</span><br></pre></td></tr></table></figure><h1 id="channel-basicNack-delivery-getEnvelope-getDeliveryTag-false-true">channel.basicNack(delivery.getEnvelope().getDeliveryTag(), false, true)</h1><ul><li><code>deliveryTag</code>：该消息的index</li><li><code>multiple</code>：是否批量.true:将一次性拒绝所有小于deliveryTag的消息</li><li><code>requeue</code>：被拒绝的是否重新入队列</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Reject one or several received messages.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Supply the &lt;code&gt;deliveryTag&lt;/code&gt; from the &#123;@link com.rabbitmq.client.AMQP.Basic.GetOk&#125;</span></span><br><span class="line"><span class="comment"> * or &#123;@link com.rabbitmq.client.AMQP.Basic.GetOk&#125; method containing the message to be rejected.</span></span><br><span class="line"><span class="comment"> * @see com.rabbitmq.client.AMQP.Basic.Nack</span></span><br><span class="line"><span class="comment"> * @param deliveryTag the tag from the received &#123;@link com.rabbitmq.client.AMQP.Basic.GetOk&#125; or &#123;@link com.rabbitmq.client.AMQP.Basic.Deliver&#125;</span></span><br><span class="line"><span class="comment"> * @param multiple true to reject all messages up to and including</span></span><br><span class="line"><span class="comment"> * the supplied delivery tag; false to reject just the supplied</span></span><br><span class="line"><span class="comment"> * delivery tag.</span></span><br><span class="line"><span class="comment"> * @param requeue true if the rejected message(s) should be requeued rather</span></span><br><span class="line"><span class="comment"> * than discarded/dead-lettered</span></span><br><span class="line"><span class="comment"> * @throws java.io.IOException if an error is encountered</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">basicNack</span>(<span class="params"><span class="built_in">long</span> deliveryTag, boolean multiple, boolean requeue</span>)</span></span><br><span class="line"><span class="function">        throws IOException</span>;</span><br></pre></td></tr></table></figure><h1 id="channel-basicReject-delivery-getEnvelope-getDeliveryTag-false">channel.basicReject(delivery.getEnvelope().getDeliveryTag(), false)</h1><ul><li><code>deliveryTag</code>：该消息的index</li><li><code>requeue</code>：被拒绝的是否重新入队列</li></ul><blockquote><p>channel.basicNack 与 channel.basicReject 的区别在于basicNack可以拒绝多条消息，而basicReject一次只能拒绝一条消息</p></blockquote><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Reject a message. Supply the deliveryTag from the &#123;@link com.rabbitmq.client.AMQP.Basic.GetOk&#125;</span></span><br><span class="line"><span class="comment">    * or &#123;@link com.rabbitmq.client.AMQP.Basic.Deliver&#125; method</span></span><br><span class="line"><span class="comment">    * containing the received message being rejected.</span></span><br><span class="line"><span class="comment">    * @see com.rabbitmq.client.AMQP.Basic.Reject</span></span><br><span class="line"><span class="comment">    * @param deliveryTag the tag from the received &#123;@link com.rabbitmq.client.AMQP.Basic.GetOk&#125; or &#123;@link com.rabbitmq.client.AMQP.Basic.Deliver&#125;</span></span><br><span class="line"><span class="comment">    * @param requeue true if the rejected message should be requeued rather than discarded/dead-lettered</span></span><br><span class="line"><span class="comment">    * @throws java.io.IOException if an error is encountered</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">basicReject</span>(<span class="params"><span class="built_in">long</span> deliveryTag, boolean requeue</span>) throws IOException</span>;</span><br></pre></td></tr></table></figure><h1 id="channel-basicConsume-queueName-true-consumer">channel.basicConsume(queueName, true, consumer)</h1><ul><li><code>autoAck</code>：是否自动<code>ack</code>，如果不自动<code>ack</code>，需要使用<code>channel.ack</code>、<code>channel.nack</code>、<code>channel.basicReject</code> 进行消息应答</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Start a non-nolocal, non-exclusive consumer, with</span></span><br><span class="line"><span class="comment"> * a server-generated consumerTag.</span></span><br><span class="line"><span class="comment"> * @param queue the name of the queue</span></span><br><span class="line"><span class="comment"> * @param autoAck true if the server should consider messages</span></span><br><span class="line"><span class="comment"> * acknowledged once delivered; false if the server should expect</span></span><br><span class="line"><span class="comment"> * explicit acknowledgements</span></span><br><span class="line"><span class="comment"> * @param callback an interface to the consumer object</span></span><br><span class="line"><span class="comment"> * @return the consumerTag generated by the server</span></span><br><span class="line"><span class="comment"> * @throws java.io.IOException if an error is encountered</span></span><br><span class="line"><span class="comment"> * @see com.rabbitmq.client.AMQP.Basic.Consume</span></span><br><span class="line"><span class="comment"> * @see com.rabbitmq.client.AMQP.Basic.ConsumeOk</span></span><br><span class="line"><span class="comment"> * @see #basicConsume(String, boolean, String, boolean, boolean, Map, Consumer)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">String <span class="title">basicConsume</span>(<span class="params">String queue, boolean autoAck, Consumer callback</span>) throws IOException</span>;</span><br></pre></td></tr></table></figure><h1 id="chanel-exchangeBind">chanel.exchangeBind()</h1><p><code>channel.queueBind(queueName, EXCHANGE_NAME, bindingKey)</code>；用于通过绑定<code>bindingKey</code>将<code>queue</code>到<code>Exchange</code>，之后便可以进行消息接收</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Bind an exchange to an exchange, with no extra arguments.</span></span><br><span class="line"><span class="comment"> * @see com.rabbitmq.client.AMQP.Exchange.Bind</span></span><br><span class="line"><span class="comment"> * @see com.rabbitmq.client.AMQP.Exchange.BindOk</span></span><br><span class="line"><span class="comment"> * @param destination the name of the exchange to which messages flow across the binding</span></span><br><span class="line"><span class="comment"> * @param source the name of the exchange from which messages flow across the binding</span></span><br><span class="line"><span class="comment"> * @param routingKey the routine key to use for the binding</span></span><br><span class="line"><span class="comment"> * @return a binding-confirm method if the binding was successfully created</span></span><br><span class="line"><span class="comment"> * @throws java.io.IOException if an error is encountered</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Exchange.<span class="function">BindOk <span class="title">exchangeBind</span>(<span class="params">String destination, String source, String routingKey</span>) throws IOException</span>;</span><br></pre></td></tr></table></figure><h1 id="channel-queueDeclare-queueName-false-false-false-null">channel.queueDeclare(queueName, false, false, false, null)</h1><ul><li><code>durable</code>：(true、false) true：在服务器重启时，能够存活</li><li><code>exclusive</code> ：是否为当前连接的专用队列，在连接断开后，会自动删除该队列，生产环境中应该很少用到</li><li><code>autodelete</code>：当没有任何消费者使用时，自动删除该队列</li></ul><blockquote><p>this means that the queue will be deleted when there are no more processes consuming messages from it.)</p></blockquote><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Declare a queue</span></span><br><span class="line"><span class="comment">    * @see com.rabbitmq.client.AMQP.Queue.Declare</span></span><br><span class="line"><span class="comment">    * @see com.rabbitmq.client.AMQP.Queue.DeclareOk</span></span><br><span class="line"><span class="comment">    * @param queue the name of the queue</span></span><br><span class="line"><span class="comment">    * @param durable true if we are declaring a durable queue (the queue will survive a server restart)</span></span><br><span class="line"><span class="comment">    * @param exclusive true if we are declaring an exclusive queue (restricted to this connection)</span></span><br><span class="line"><span class="comment">    * @param autoDelete true if we are declaring an autodelete queue (server will delete it when no longer in use)</span></span><br><span class="line"><span class="comment">    * @param arguments other properties (construction arguments) for the queue</span></span><br><span class="line"><span class="comment">    * @return a declaration-confirm method to indicate the queue was successfully declared</span></span><br><span class="line"><span class="comment">    * @throws java.io.IOException if an error is encountered</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   Queue.<span class="function">DeclareOk <span class="title">queueDeclare</span>(<span class="params">String queue, boolean durable, boolean exclusive, boolean autoDelete,</span></span></span><br><span class="line"><span class="params"><span class="function">                                Map&lt;String, Object&gt; arguments</span>) throws IOException</span>;</span><br></pre></td></tr></table></figure><p><code>arguments</code>中可以设置的常用属性</p><table><thead><tr><th style="text-align:left">参数名</th><th style="text-align:left">作用</th><th>示例</th><th>示例描述</th></tr></thead><tbody><tr><td style="text-align:left">Message TTL</td><td style="text-align:left">设置队列中消息的有效时间</td><td>{ “x-message-ttl”,1000*8}</td><td>设置队列中的所有消息的有效期为8s</td></tr><tr><td style="text-align:left">Auto expire</td><td style="text-align:left">一定的时间内队列没有被使用，则自动删除队列</td><td>{“x-expires”,1000*60}</td><td>如果60s没有队列被访问，则删除队列</td></tr><tr><td style="text-align:left">Max length</td><td style="text-align:left">队列能保存消息的最大条数</td><td>{“x-max-length”,100 }</td><td>设置队列最多保存100条消息</td></tr><tr><td style="text-align:left">Max length bytes</td><td style="text-align:left">队列中ready类型消息的总字节数</td><td>{“x-max-length-bytes”,1000 }</td><td>设置队列中ready类型消息总共不能超过1000字节</td></tr><tr><td style="text-align:left">Overflow behaviour</td><td style="text-align:left">当队列消息满了时，再接收消息时的处理方法。有两种处理方案：默认为&quot;drop-head&quot;模式，表示从队列头部丢弃消息；&quot;reject-publish&quot;表示不接收后续的消息</td><td>{“x-overflow”,“reject-publish” }</td><td>设置当队列消息满了时,丢弃传来后续消息</td></tr><tr><td style="text-align:left">Dead letter exchange</td><td style="text-align:left">用于存储被丢弃的消息的交换机名。Overflow behaviour 的两种处理方案中丢弃的消息都会发送到这个交换机</td><td>{“x-dead-letter-exchange”,“beiyongExchange” }</td><td>设置丢弃的消息发送到名字为beiyongExchange的交换机</td></tr><tr><td style="text-align:left">Dead letter routing key</td><td style="text-align:left">被丢弃的消息发送到Dead letter exchange时的使用的routing Key</td><td>{“x-dead-letter-routing-key”,“deadKey” }</td><td>设置丢弃的消息发送到beiyongExchange交换机时的RoutingKey值是&quot;deadKey&quot;</td></tr><tr><td style="text-align:left">Maximum priority</td><td style="text-align:left">设置队列中消息优先级的最大等级，在publish消息时可以设置单条消息的优先级等级</td><td>{“x-max-priority”,10 }</td><td>设置中消息优先级的最大等级为10</td></tr><tr><td style="text-align:left">Lazy mode</td><td style="text-align:left">设置队列的模式，如果设置为Lazy表示队列中消息尽可能存放在磁盘中，以减少内存占用；不设置时消息都存放在队列中，用以尽可能快的处理消息</td><td>{“x-queue-mode”,“lazy”}</td><td>3.6以后版本可用，设置队列中消息尽可能存放在磁盘中，以减少内存占用。在消息拥堵时和消息持久化配置使用可以减少内存占用</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/rabbitMq/1.6RabbitMQ%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/rabbitMq/1.6RabbitMQ%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>记录rabbitMq中常见的命令</p><span id="more"></span><h1 id="用户角色分类">用户角色分类</h1><h2 id="none">none</h2><p>通常就是普通的生产者和消费者,无法登录控制台,不能访问 <code>management plugin</code> ，通常就是普通的生产者和消费者。</p><h2 id="management">management</h2><p><strong>普通管理者</strong>，仅可登陆管理控制台(启用 <code>management plugin</code> 的情况下)，无法看到节点信息，也无法对 <code>policies</code> 进行管理。可以通过 <code>AMQP</code> 做的任何事外加：</p><ul><li>列出自己可以通过<code>AMQP</code>登入的 <code>virtual hosts</code></li><li>查看自己的 <code>virtual hosts</code> 中的 <code>queues, exchanges</code> 和 <code>bindings</code></li><li>查看和关闭自己的 <code>channels</code> 和 <code>connections</code></li><li>查看有关自己的 <code>virtual hosts</code>的全局统计信息，包含其他用户在这些 <code>virtual hosts</code>中的活动</li></ul><h2 id="policymaker">policymaker</h2><p><strong>策略制定者</strong>，<code>management</code>可以做的任何事外加：</p><p>查看、创建和删除自己的 <code>virtual hosts</code>所属的 <code>policies</code>和 <code>parameters</code></p><h2 id="monitoring">monitoring</h2><p><strong>监控者</strong>，<code>management</code>可以做的任何事外加：</p><p>列出所有<code>virtual hosts</code>，包括他们不能登录的<code>virtual hosts</code></p><p>查看其他用户的 <code>connections</code>和 <code>channels</code></p><p>查看节点级别的数据如 <code>clustering</code>和 <code>memory</code>使用情况</p><p>查看真正的关于所有 <code>virtual hosts</code>的全局的统计信息</p><p>同时可以查看 <code>rabbitmq</code>节点的相关信息(进程数，内存使用情况，磁盘使用情况等)</p><h2 id="administrator">administrator</h2><p><strong>超级管理员</strong>，<code>policymaker</code>和<code>monitoring</code>可以做的任何事外加:</p><p>创建和删除<code>virtual hosts</code></p><p>查看、创建和删除 <code>users</code></p><p>查看创建和删除 <code>permissions</code></p><p>关闭其他用户的 <code>connections</code></p><h1 id="RabbitMQ-Control">RabbitMQ Control</h1><p>使用Web管理界面可以实现RabbitMQ的大部分常用功能，但是有些功能WebUI是做不到的，如：开启/关闭RabbitMQ应用程序和集群的管理等。RabbitMQ Control是RabbitMQ的命令行管理工具，可以调用所有的RabbitMQ内置功能，主命令是 <code>rabbitmqctl</code>。</p><h2 id="创建用户-v2">创建用户</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl add_user &#123;用户名&#125; &#123;密码&#125;</span><br></pre></td></tr></table></figure><h2 id="设置权限">设置权限</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_user_tags &#123;用户名&#125; &#123;权限&#125;</span><br></pre></td></tr></table></figure><p>比如：创建一个超级用户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl add_user admin1 admin1</span><br><span class="line">rabbitmqctl set_user_tags admin1 administrator</span><br></pre></td></tr></table></figure><h2 id="查看用户列表">查看用户列表</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl list_users</span><br></pre></td></tr></table></figure><h2 id="为用户赋权">为用户赋权</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 使用户user1具有vhost1这个virtual host中所有资源的配置、写、读权限以便管理其中的资源</span><br><span class="line">rabbitmqctl  set_permissions -p vhost1 user1 <span class="string">&#x27;.*&#x27;</span> <span class="string">&#x27;.*&#x27;</span> <span class="string">&#x27; .*&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="查看权限">查看权限</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl list_user_permissions user1</span><br><span class="line">rabbitmqctl list_permissions -p vhost1</span><br></pre></td></tr></table></figure><h2 id="清除权限">清除权限</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl clear_permissions [-p VHostPath] User</span><br></pre></td></tr></table></figure><h2 id="删除用户">删除用户</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl delete_user Username</span><br></pre></td></tr></table></figure><h2 id="修改用户密码">修改用户密码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl change_password Username Newpassword</span><br></pre></td></tr></table></figure><h1 id="Management-Plugin">Management Plugin</h1><p>找到安装rabbitMQ的路径，然后切换到<code>sbin</code>的文件夹，管理员运行Shell脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-pluginsenable rabbitmq_managementrabbitmqctl clear_permissions [-p VHostPath] User</span><br></pre></td></tr></table></figure><h2 id="启动监控管理器">启动监控管理器</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_management</span><br></pre></td></tr></table></figure><h2 id="关闭监控管理器">关闭监控管理器</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins <span class="built_in">disable</span> rabbitmq_management</span><br></pre></td></tr></table></figure><h2 id="启动rabbitmq">启动rabbitmq</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net start RabbitMQ</span><br></pre></td></tr></table></figure><h2 id="关闭rabbitmq">关闭rabbitmq</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net stop RabbitMQ</span><br></pre></td></tr></table></figure><h2 id="查看所有的队列">查看所有的队列</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl list_queues</span><br></pre></td></tr></table></figure><h2 id="清除所有的队列">清除所有的队列</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl reset</span><br></pre></td></tr></table></figure><h2 id="查看已有用户及角色">查看已有用户及角色</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl list_users</span><br></pre></td></tr></table></figure><h2 id="新增虚拟主机">新增虚拟主机</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl add_vhost vhost_name</span><br></pre></td></tr></table></figure><h2 id="将新虚拟主机授权给新用户">将新虚拟主机授权给新用户</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_permissions -p vhost_name username <span class="string">&#x27;.*&#x27;</span> <span class="string">&#x27;.*&#x27;</span> <span class="string">&#x27;.*&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="设置用户权限">设置用户权限</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_permissions -p VHostPath username ConfP WriteP ReadP</span><br></pre></td></tr></table></figure><h2 id="查看-指定hostpath-所有用户的权限信息">查看(指定hostpath)所有用户的权限信息</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl list_permissions [-p VHostPath]</span><br></pre></td></tr></table></figure><h2 id="查看指定用户的权限信息">查看指定用户的权限信息</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl list_user_permissions username</span><br></pre></td></tr></table></figure><h2 id="清除用户的权限信息">清除用户的权限信息</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl clear_permissions [-p VHostPath] username</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/rabbitMq/1.7RabbitMQ%E5%B8%B8%E8%A7%81%E7%AD%96%E7%95%A5/"/>
      <url>/rabbitMq/1.7RabbitMQ%E5%B8%B8%E8%A7%81%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<p>rabbitMq策略学习</p><span id="more"></span><h1 id="死信队列">死信队列</h1><p>死信队列：DLX，<code>dead-letter-exchang</code>，利用DLX，当消息在一个队列中变成死信 (dead message) 之后，它能被重新publish到另一个Exchange，这个Exchange就是DLX。</p><h2 id="死信判断条件">死信判断条件</h2><ul><li>消息被拒绝(<code>basic.reject</code> / <code>basic.nack</code>)，并且 <code>requeue = false</code></li><li>消息 <code>TTL</code> 过期</li><li>队列达到最大长度</li></ul><h2 id="死信处理过程">死信处理过程</h2><ul><li>DLX也是一个正常的Exchange，和一般的Exchange没有区别，它能在任何的队列上被指定，实际上就是设置某个队列的属性</li><li>当这个队列中有死信时，RabbitMQ就会自动的将这个消息重新发布到设置的Exchange上去，进而被路由到另一个队列</li><li>可以通过监听这个死信队列的消息做相应的处理</li></ul><h2 id="死信队列设置">死信队列设置</h2><p>首先设置死信队列的 <code>exchange</code> 和 <code>queue</code>，然后进行绑定</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> dlxExchangeName = <span class="string">&quot;test.dlx.exchange&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> dlxQueueName = <span class="string">&quot;test.dlx.queue&quot;</span>;</span><br><span class="line">channel.ExchangeDeclare(dlxExchangeName, type: <span class="string">&quot;topic&quot;</span>);</span><br><span class="line">channel.QueueDeclare(queue: dlxQueueName, durable: <span class="literal">false</span>, exclusive: <span class="literal">false</span>, autoDelete: <span class="literal">false</span>, arguments: <span class="literal">null</span>);</span><br><span class="line"><span class="comment">// #表示只要有消息到达了死信的exchange,都会路由到这个死信队列</span></span><br><span class="line">channel.QueueBind(queue: dlxQueueName, exchange: dlxExchangeName, routingKey: <span class="string">&quot;#&quot;</span>);</span><br></pre></td></tr></table></figure><p>定义业务队列，并设置死信参数</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明队列时添加死信参数</span></span><br><span class="line">Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">object</span>&gt; agruments = <span class="keyword">new</span>()</span><br><span class="line">&#123;</span><br><span class="line">    &#123; <span class="string">&quot;x-dead-letter-exchange&quot;</span>, dlxExchangeName &#125;</span><br><span class="line">&#125;;</span><br><span class="line">channel.QueueDeclare(queue: queueName, durable: <span class="literal">false</span>, exclusive: <span class="literal">false</span>, autoDelete: <span class="literal">false</span>, arguments: agruments);</span><br></pre></td></tr></table></figure><p>Pub 完整代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Pub:死信队列.DLXs the pub test.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">[<span class="meta">TestMethod</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dlx_PubTest</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> dlxExchangeName = <span class="string">&quot;test.dlx.exchange&quot;</span>;</span><br><span class="line">    <span class="built_in">string</span> dlxQueueName = <span class="string">&quot;test.dlx.queue&quot;</span>;</span><br><span class="line">    channel.ExchangeDeclare(dlxExchangeName, type: <span class="string">&quot;topic&quot;</span>);</span><br><span class="line">    channel.QueueDeclare(queue: dlxQueueName, durable: <span class="literal">false</span>, exclusive: <span class="literal">false</span>, autoDelete: <span class="literal">false</span>, arguments: <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// # 表示只要有消息到达了死信的exchange,都会路由到这个死信队列</span></span><br><span class="line">    channel.QueueBind(queue: dlxQueueName, exchange: dlxExchangeName, routingKey: <span class="string">&quot;#&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明队列时添加死信参数</span></span><br><span class="line">    Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">object</span>&gt; agruments = <span class="keyword">new</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        &#123; <span class="string">&quot;x-dead-letter-exchange&quot;</span>, dlxExchangeName &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    channel.QueueDeclare(queue: queueName, durable: <span class="literal">false</span>, exclusive: <span class="literal">false</span>, autoDelete: <span class="literal">false</span>, arguments: agruments);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        channel.BasicPublish(exchange: <span class="string">&quot;&quot;</span>, routingKey: queueName, basicProperties: <span class="literal">null</span>, body: Encoding.UTF8.GetBytes(i.ToString()));</span><br><span class="line">    &#125;</span><br><span class="line">    Assert.IsTrue(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/2021-09-14-17-07-50.png" alt=""></p><p>消费完毕，死信queue加了一条数据。</p><blockquote><p>实际环境还需要对死信队列进行一个监听和处理，具体的处理逻辑和业务相关，这里只简单演示死信队列是否生效。</p></blockquote><h1 id="延时队列">延时队列</h1><blockquote><p>延迟队列就是进入该队列的消息会被延迟消费的队列。而一般的队列，消息一旦入队了之后就会被消费者马上消费</p></blockquote><p>延迟队列能做什么？延迟队列多用于需要延迟工作的场景。最常见的是以下两种场景：</p><ul><li>延迟消费。比如：用户生成订单之后，需要过一段时间校验订单的支付状态，如果订单仍未支付则需要及时关闭订单</li><li>延迟重试。比如消费者从队列里消费消息时失败了，但是想要延迟一段时间后自动重试</li></ul><p><strong>实现思路</strong></p><p>实现依赖于RabbitMQ的两个特性</p><p><code>Time-To-Live Extensions</code></p><p>RabbitMQ允许我们为消息或者队列设置TTL（time to live），也就是过期时间。TTL表明了一条消息可在队列中存活的最大时间，单位为毫秒。也就是说，当某条消息被设置了TTL或者当某条消息进入了设置了TTL的队列时，这条消息会在经过TTL秒后“死亡”，成为Dead Letter。如果既配置了消息的TTL，又配置了队列的TTL，那么较小的那个值会被取用。更多资料请查阅<a href="https://www.rabbitmq.com/ttl.html">官方文档</a>。</p><p><code>Dead Letter Exchanges</code></p><p>被设置了TTL的消息在过期后会成为Dead Letter。</p><p>之前说过在RabbitMQ中，一共有三种消息的“死亡”形式：</p><ul><li>消息被拒绝。通过调用<code>basic.reject</code>或者<code>basic.nack</code>并且设置的<code>requeue</code>参数为<code>false</code></li><li>消息因为设置了<code>TTL</code>而过期</li><li>消息进入了一条已经达到最大长度的队列</li></ul><p>如果队列设置了<code>Dead Letter Exchange（DLX）</code>，那么这些<code>Dead Letter</code>就会被重新<code>publish</code>到<code>Dead Letter Exchange</code>，通过<code>Dead Letter Exchange</code>路由到其他队列。</p><h1 id="延迟消费">延迟消费</h1><p>生产者产生的消息首先会进入缓冲队列（图中红色队列）。通过RabbitMQ提供的TTL扩展，这些消息会被设置过期时间，也就是延迟消费的时间。等消息过期之后，这些消息会通过配置好的DLX转发到实际消费队列（图中蓝色队列），以此达到延迟消费的效果。</p><p><img src="/images/2021-09-05-23-01-21.png" alt=""></p><h1 id="延时重试">延时重试</h1><p>消费者发现该消息处理出现了异常，比如是因为网络波动引起的异常。那么如果不等待一段时间，直接就重试的话，很可能会导致在这期间内一直无法成功，造成一定的资源浪费。可以将其先放在缓冲队列中（图中红色队列，可以理解为重试定义的exchange），等消息经过一段的延迟时间后再次进入实际消费队列中（图中蓝色队列），此时由于已经过了“较长”的时间了，异常的一些波动通常已经恢复，这些消息可以被正常消费。</p><p><img src="/images/2021-09-05-23-01-44.png" alt=""></p><p>RabbitMQ<code>channel.basicNack()</code>能够让消息回到队列中，这样可以实现重试。但是无法明确重试次数，如果当前的消息一直重试的话，则后面的消息就会堆积起来，导致后面的消息无法消费。这是一个致命的缺点。因此需要设置重试次数来解决类似问题。</p><ul><li>使用<code>redis</code>或者<code>mongo</code>等第三方存储当前重试次数</li><li>在<code>header</code>中添加重试次数,使用<code>channel.basicPublish()</code>方法重新将消息发送后将重试次数加1</li></ul><p>可以设置重试次数到达阈值时转发到指定的<code>exchange</code>。</p><p><strong>代码示例：</strong></p><p><a href="https://github.com/wangpengliang815/CodeSnippet">https://github.com/wangpengliang815/CodeSnippet</a></p><p><strong>参考：</strong></p><ul><li><a href="https://www.rabbitmq.com/ttl.html">https://www.rabbitmq.com/ttl.html</a></li><li><a href="https://www.cnblogs.com/xishuai/p/spring-boot-rabbitmq-delay-queue.html">https://www.cnblogs.com/xishuai/p/spring-boot-rabbitmq-delay-queue.html</a></li><li><a href="https://www.cnblogs.com/lori/p/9984760.html">https://www.cnblogs.com/lori/p/9984760.html</a></li><li><a href="https://www.jianshu.com/p/537cb84ba72f">https://www.jianshu.com/p/537cb84ba72f</a></li><li><a href="https://www.jianshu.com/p/986ee5eb78bc">https://www.jianshu.com/p/986ee5eb78bc</a></li><li><a href="https://www.cnblogs.com/wyy1234/category/1321800.html">https://www.cnblogs.com/wyy1234/category/1321800.html</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/rabbitMq/1.2%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D/"/>
      <url>/rabbitMq/1.2%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p>使用C#连接rabbitMq测试各工作模式区别</p><span id="more"></span><p>C#创建RabbitMq连接</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">RabbitMQPublisher</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> RabbitMQ.Client;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">BasePublisher</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ConnectionFactory <span class="title">CreateRabbitMqConnection</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// RabbitMQ连接工厂</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConnectionFactory()</span><br><span class="line">            &#123;</span><br><span class="line">                HostName = <span class="string">&quot;localhost&quot;</span>,</span><br><span class="line">                <span class="comment">// 用户名</span></span><br><span class="line">                UserName = <span class="string">&quot;guest&quot;</span>,</span><br><span class="line">                <span class="comment">// 密码</span></span><br><span class="line">                Password = <span class="string">&quot;guest&quot;</span>,</span><br><span class="line">                <span class="comment">// 网络故障自动恢复连接</span></span><br><span class="line">                AutomaticRecoveryEnabled = <span class="literal">true</span>,</span><br><span class="line">                <span class="comment">// 心跳处理</span></span><br><span class="line">                RequestedHeartbeat = <span class="keyword">new</span> TimeSpan(<span class="number">5000</span>)</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="工作模式">工作模式</h1><p>Rabbitmq的几种工作模式，具体可参考官网给出的Demo：<a href="https://www.rabbitmq.com/getstarted.html%EF%BC%8C">https://www.rabbitmq.com/getstarted.html，</a> <code>RPC</code> 模式类似常用的请求-响应模式，这里不过多解释，感兴趣可以参考官网文档：<a href="https://www.rabbitmq.com/tutorials/tutorial-six-dotnet.html%E3%80%82">https://www.rabbitmq.com/tutorials/tutorial-six-dotnet.html。</a> 这里只学习其中的1-5种，也可以分类成两种：不使用交换机和使用交换机。</p><blockquote><p>其实还是使用了交换机的，简单队列和work模式是绑定到了默认的 <code>AMQP default</code>。只不过没有显式声明和绑定而已</p></blockquote><p><img src="/images/RabbitMQ.png" alt=""></p><h1 id="简单队列">简单队列</h1><blockquote><p>“ P”是生产者，“ C”是消费者。中间的框是一个队列-RabbitMQ代表保留的消息缓冲区，这个模式很简单，其实就是只有一个消费者，简单的保证操作的顺序性</p></blockquote><p><img src="https://www.rabbitmq.com/img/tutorials/python-one-overall.png#align=left&amp;display=inline&amp;height=100&amp;margin=%5Bobject%20Object%5D&amp;originHeight=100&amp;originWidth=288&amp;status=done&amp;style=none&amp;width=288" alt=""></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">RabbitMQPublisher</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> RabbitMQ.Client;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> System;</span><br><span class="line">    <span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 点对点:最简单的工作模式</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">PointToPointPublisher</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">readonly</span> <span class="keyword">static</span> <span class="built_in">string</span> queueName = <span class="string">&quot;test.pointToPoint.queue&quot;</span>;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;消息发布者:模式&#123;点对点&#125;=&gt;输入消息内容&quot;</span>);</span><br><span class="line">                <span class="built_in">string</span> message = Console.ReadLine();</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">string</span>.IsNullOrEmpty(message))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// RabbitMQ连接工厂</span></span><br><span class="line">                    ConnectionFactory factory = BasePublisher.CreateRabbitMqConnection();</span><br><span class="line">                    <span class="comment">// 建立连接</span></span><br><span class="line">                    <span class="keyword">using</span> IConnection connection = factory.CreateConnection();</span><br><span class="line">                    <span class="comment">// 创建信道</span></span><br><span class="line">                    <span class="keyword">using</span> IModel channel = connection.CreateModel();</span><br><span class="line">                    <span class="comment">// 声明队列</span></span><br><span class="line">                    channel.QueueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 消息发送</span></span><br><span class="line">                    channel.BasicPublish(exchange: <span class="string">&quot;&quot;</span>, routingKey: queueName, basicProperties: <span class="literal">null</span>, body: Encoding.UTF8.GetBytes(message));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认的传统队列是：发布者发布消息，只有一个消费者消费。但是如果消费者多开默认采用轮询(均摊)机制。</p><blockquote><p>均摊消费，如果每个消费者速度不一样的情况下，均摊消费是不公平的，应该是能者多劳</p></blockquote><p><img src="/images/2021-09-11-20-57-16.png" alt=""></p><h1 id="Worker">Worker</h1><blockquote><p>Worker模式是一对多的模式，但是这个一对多并不是像发布订阅那种，而是将消息顺序传输给每个接收者。<strong>其实就是简单队列模式下的消费者多开</strong></p></blockquote><p><img src="https://www.rabbitmq.com/img/tutorials/python-two.png#align=left&amp;display=inline&amp;height=111&amp;margin=%5Bobject%20Object%5D&amp;originHeight=111&amp;originWidth=332&amp;status=done&amp;style=none&amp;width=332" alt=""></p><h1 id="ExchangesType">ExchangesType</h1><p>Exchange分发消息时根据类型的不同分发策略有区别：<code>direct</code>、<code>fanout</code>、<code>topic</code>、<code>headers</code> 。<code>headers</code> 匹配 AMQP 消息的 <code>header</code> 而不是路由键，此外 <code>headers</code> 交换器和 <code>direct</code>交换器完全一致，但性能差很多，目前几乎用不到了，所以直接看另外三种类型。</p><h1 id="Fanout">Fanout</h1><blockquote><p>发布订阅模式(fanout)，消息发送到Exchange，所有订阅了当前Exchange的Queue都可以收到消息。<em>fanout 交换器不处理路由键，只是简单的将队列绑定到交换器上</em>。每个发到 fanout 类型交换器的消息都会分发到所有绑定的队列上去。很像子网广播，每台子网内的主机都获得了一份复制的消息。fanout 类型转发消息是最快的</p></blockquote><p><img src="/images/2021-09-05-22-04-12.png" alt=""></p><p>生产者</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">RabbitMQPublisher</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> EasyNetQ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> RabbitMQ.Client;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> System;</span><br><span class="line">    <span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 发布订阅模式(fanout),消息会发送到exchange,所有订阅了exchange的queue都可以收到消息</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> type=fanout：routingKey不会生效</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">FanoutPublisher</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;消息发布者:模式&#123;fanout&#125;=&gt;输入消息内容&quot;</span>);</span><br><span class="line">                <span class="built_in">string</span> message = Console.ReadLine();</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">string</span>.IsNullOrEmpty(message))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// RabbitMQ连接工厂</span></span><br><span class="line">                    ConnectionFactory factory = BasePublisher.CreateRabbitMqConnection();</span><br><span class="line">                    <span class="comment">// 建立连接</span></span><br><span class="line">                    <span class="keyword">using</span> IConnection connection = factory.CreateConnection();</span><br><span class="line">                    <span class="comment">// 创建信道</span></span><br><span class="line">                    <span class="keyword">using</span> IModel channel = connection.CreateModel();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 声明交换机</span></span><br><span class="line">                    <span class="built_in">string</span> exchangeName = <span class="string">$&quot;test.exchange.fanout&quot;</span>;</span><br><span class="line">                    channel.ExchangeDeclare(exchange: exchangeName, type: <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 声明队列</span></span><br><span class="line">                    <span class="built_in">string</span> queue1 = <span class="string">&quot;test.fanout.queue1&quot;</span>;</span><br><span class="line">                    channel.QueueDeclare(queue1, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">string</span> queue2 = <span class="string">&quot;test.fanout.queue2&quot;</span>;</span><br><span class="line">                    channel.QueueDeclare(queue2, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 将队列与交换机进行绑定</span></span><br><span class="line">                    channel.QueueBind(queue: queue1, exchange: exchangeName, routingKey: <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    channel.QueueBind(queue: queue2, exchange: exchangeName, routingKey: <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    channel.BasicPublish(exchange: exchangeName, routingKey: <span class="string">&quot;&quot;</span>, basicProperties: <span class="literal">null</span>, body: Encoding.UTF8.GetBytes(message));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/2021-09-11-21-41-32.png" alt=""></p><p>这里虽然绑定 <code>q1</code> 时指定了 <code>routingkey=&quot;fanout&quot;</code> 但是<code>q1/q2</code> 都正常收到了消息，证实上面说的“fanout 交换器不处理路由键”。</p><p>消费者</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">RabbitMQConsumer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> RabbitMQ.Client;</span><br><span class="line">    <span class="keyword">using</span> RabbitMQ.Client.Events;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> System;</span><br><span class="line">    <span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">FanoutConsumer</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;input queueName...&quot;</span>);</span><br><span class="line">            <span class="keyword">var</span> input = Console.ReadLine();</span><br><span class="line">            ConnectionFactory factory = BaseConsumer.CreateRabbitMqConnection();</span><br><span class="line">            <span class="keyword">using</span> IConnection connection = factory.CreateConnection();</span><br><span class="line">            <span class="keyword">using</span> IModel channel = connection.CreateModel();</span><br><span class="line">            EventingBasicConsumer consumer = <span class="keyword">new</span>(channel);</span><br><span class="line">            channel.BasicQos(<span class="number">0</span>, <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">switch</span> (input)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                    channel.BasicConsume(queue: <span class="string">&quot;test.fanout.queue1&quot;</span>, autoAck: <span class="literal">false</span>, consumer: consumer);</span><br><span class="line">                    <span class="comment">// 绑定消息接收后的事件委托</span></span><br><span class="line">                    consumer.Received += (model, message) =&gt;</span><br><span class="line">                    &#123;</span><br><span class="line">                        Console.WriteLine(<span class="string">$&quot;Message:<span class="subst">&#123;Encoding.UTF8.GetString(message.Body.ToArray())&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">                        channel.BasicAck(</span><br><span class="line">                            deliveryTag: message.DeliveryTag,</span><br><span class="line">                            <span class="comment">// 是否一次性确认多条数据</span></span><br><span class="line">                            multiple: <span class="literal">false</span>);</span><br><span class="line">                    &#125;;</span><br><span class="line">                    Console.ReadLine();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;2&quot;</span>:</span><br><span class="line">                    channel.BasicConsume(queue: <span class="string">&quot;test.fanout.queue2&quot;</span>, autoAck: <span class="literal">false</span>, consumer: consumer);</span><br><span class="line">                    <span class="comment">// 绑定消息接收后的事件委托</span></span><br><span class="line">                    consumer.Received += (model, message) =&gt;</span><br><span class="line">                    &#123;</span><br><span class="line">                        Console.WriteLine(<span class="string">$&quot;Message:<span class="subst">&#123;Encoding.UTF8.GetString(message.Body.ToArray())&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">                        channel.BasicAck(</span><br><span class="line">                            deliveryTag: message.DeliveryTag,</span><br><span class="line">                            <span class="comment">// 是否一次性确认多条数据</span></span><br><span class="line">                            multiple: <span class="literal">false</span>);</span><br><span class="line">                    &#125;;</span><br><span class="line">                    Console.ReadLine();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Direct">Direct</h1><blockquote><p>direct跟fanout的区别在于多了routekey，消息发送到Exchange，所有订阅了当前Exchange并且routingKey完全匹配的Queue才可以收到消息。消息中的路由键（routing key）如果和 Binding 中的 binding key 一致，交换器就将消息发到对应的队列中。路由键与队列名完全匹配，如果一个队列绑定到交换机要求路由键为“dog”，则只转发 routing key标记为“dog”的消息，不会转发“dog.puppy”，也不会转发“dog.guard”等等。它是完全匹配、单播的模式。</p></blockquote><p><img src="/images/2021-09-05-22-07-05.png" alt=""></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">RabbitMQPublisher</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> System;</span><br><span class="line">    <span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> RabbitMQ.Client;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 路由模式(direct),消息会发送到exchange</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 所有订阅了当前Exchange并且routingKey完全匹配的Queue都可以收到消息</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">DirectPublisher</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;消息发布者:模式&#123;direct&#125;=&gt;输入消息内容&quot;</span>);</span><br><span class="line">                <span class="built_in">string</span> message = Console.ReadLine();</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">string</span>.IsNullOrEmpty(message))</span><br><span class="line">                &#123;</span><br><span class="line">                    ConnectionFactory factory = BasePublisher.CreateRabbitMqConnection();</span><br><span class="line">                    <span class="keyword">using</span> <span class="keyword">var</span> connection = factory.CreateConnection();</span><br><span class="line">                    <span class="keyword">using</span> <span class="keyword">var</span> channel = connection.CreateModel();</span><br><span class="line">                    <span class="comment">// 声明交换机</span></span><br><span class="line">                    <span class="built_in">string</span> exchangeName = <span class="string">$&quot;test.exchange.direct&quot;</span>;</span><br><span class="line">                    channel.ExchangeDeclare(exchange: exchangeName, type: <span class="string">&quot;direct&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 声明队列</span></span><br><span class="line">                    <span class="built_in">string</span> queue1 = <span class="string">&quot;test.direct.queue1&quot;</span>;</span><br><span class="line">                    channel.QueueDeclare(queue1, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">string</span> queue2 = <span class="string">&quot;test.direct.queue2&quot;</span>;</span><br><span class="line">                    channel.QueueDeclare(queue2, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//将队列与交换机进行绑定</span></span><br><span class="line">                    channel.QueueBind(queue: queue1, exchange: exchangeName, routingKey: <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    channel.QueueBind(queue: queue2, exchange: exchangeName, routingKey: <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 只有queue1可以收到消息,因为queue2的routingKey不匹配</span></span><br><span class="line">                    channel.BasicPublish(exchange: exchangeName, routingKey: <span class="string">&quot;fanout&quot;</span>, basicProperties: <span class="literal">null</span>, body: Encoding.UTF8.GetBytes(message));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Topic">Topic</h1><blockquote><p>topic符模式与路由模式一致，只不过通配符模式中的路由可以声明为模糊查询，RabbitMQ拥有两个通配符；topic 交换器通过模式匹配分配消息的路由键属性，将路由键和某个模式进行匹配，此时队列需要绑定到一个模式上。它将路由键和绑定键的字符串切分成单词，这些单词之间用点隔开。它同样也会识别两个通配符：符号 <code>#</code> 和符号 <code>*</code>。<code>#</code> 匹配0个或多个单词，<code>* </code>匹配一个单词</p></blockquote><p><img src="/images/2021-09-05-22-07-45.png" alt=""></p><ul><li><code>#</code>：匹配0-n个字符语句</li><li><code>*</code>：匹配一个字符语句</li></ul><p>注意：RabbitMQ中通配符并不像正则中的单个字符，而是一个以“.”分割的字符串，如 ”topic1.*“匹配的规则以topic1开始并且&quot;.&quot;后只有一段语句的路由。例：“topic1.aaa”，“<a href="http://topic1.bb">topic1.bb</a>”</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">RabbitMQPublisher</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> System;</span><br><span class="line">    <span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> RabbitMQ.Client;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 路由模式(topic),消息会发送到exchange</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> topic与direct模式区别在于routingKey可以声明为模糊查询，RabbitMQ拥有两个通配符</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> #：匹配0-n个字符语句</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> *：匹配一个字符语句</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">TopicPublisher</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;消息发布者:模式&#123;topic&#125;=&gt;输入消息内容&quot;</span>);</span><br><span class="line">                <span class="built_in">string</span> message = Console.ReadLine();</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">string</span>.IsNullOrEmpty(message))</span><br><span class="line">                &#123;</span><br><span class="line">                    ConnectionFactory factory = BasePublisher.CreateRabbitMqConnection();</span><br><span class="line">                    <span class="keyword">using</span> <span class="keyword">var</span> connection = factory.CreateConnection();</span><br><span class="line">                    <span class="keyword">using</span> <span class="keyword">var</span> channel = connection.CreateModel();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 声明交换机</span></span><br><span class="line">                    <span class="built_in">string</span> exchangeName = <span class="string">$&quot;test.exchange.topic&quot;</span>;</span><br><span class="line">                    channel.ExchangeDeclare(exchange: exchangeName, type: <span class="string">&quot;topic&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 声明队列</span></span><br><span class="line">                    <span class="built_in">string</span> queue1 = <span class="string">&quot;test.topic.queue1&quot;</span>;</span><br><span class="line">                    channel.QueueDeclare(queue1, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">string</span> queue2 = <span class="string">&quot;test.topic.queue2&quot;</span>;</span><br><span class="line">                    channel.QueueDeclare(queue2, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//将队列与交换机进行绑定</span></span><br><span class="line">                    channel.QueueBind(queue: queue1, exchange: exchangeName, routingKey: <span class="string">&quot;topic.*&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    channel.QueueBind(queue: queue2, exchange: exchangeName, routingKey: <span class="string">&quot;topic.#&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> debug</span></span><br><span class="line">                    <span class="comment">// queue1和queue2都可以收到消息</span></span><br><span class="line">                    channel.BasicPublish(</span><br><span class="line">                        exchange: exchangeName,</span><br><span class="line">                        routingKey: <span class="string">&quot;topic.test&quot;</span>,</span><br><span class="line">                        basicProperties: <span class="literal">null</span>,</span><br><span class="line">                        body: Encoding.UTF8.GetBytes(message));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                    <span class="comment">// 只有queue2可以收到消息,因为.#可以匹配一个或者多个字符语句而.*只能匹配单个</span></span><br><span class="line">                    channel.BasicPublish(</span><br><span class="line">                        exchange: exchangeName,</span><br><span class="line">                        routingKey: <span class="string">&quot;topic.test.test&quot;</span>,</span><br><span class="line">                        basicProperties: <span class="literal">null</span>,</span><br><span class="line">                        body: Encoding.UTF8.GetBytes(message));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发布,路由,通配符这三种模式可以算为一种模式，区别仅仅是交互机类型不同.发送者将消息发送发送到交换机，接收者创建各自的消息队列绑定到交换机。</p><p><img src="/images/2021-09-05-22-08-53.png" alt=""></p><h1 id="Mandatory参数">Mandatory参数</h1><p>注意：<code>channel.BasicPublish()</code>，<code>mandatory</code> 参数指定交换器无法根据自身类型和路由键找到一个符合条件的队列时的处理方式。</p><ul><li><em>true：RabbitMQ会调用Basic.Return命令将消息返回给生产者</em></li><li><em>false：RabbitMQ会把消息直接丢弃</em></li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">PointToPointPublisher</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">readonly</span> <span class="keyword">static</span> <span class="built_in">string</span> queueName = <span class="string">&quot;test.pointToPoint.queue&quot;</span>;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;消息发布者:模式&#123;点对点&#125;=&gt;输入消息内容&quot;</span>);</span><br><span class="line">                <span class="built_in">string</span> message = Console.ReadLine();</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">string</span>.IsNullOrEmpty(message))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// RabbitMQ连接工厂</span></span><br><span class="line">                    ConnectionFactory factory = BasePublisher.CreateRabbitMqConnection();</span><br><span class="line">                    <span class="comment">// 建立连接</span></span><br><span class="line">                    <span class="keyword">using</span> IConnection connection = factory.CreateConnection();</span><br><span class="line">                    <span class="comment">// 创建信道</span></span><br><span class="line">                    <span class="keyword">using</span> IModel channel = connection.CreateModel();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> mandatory</span></span><br><span class="line">                    <span class="comment">// 声明队列</span></span><br><span class="line">                    channel.QueueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                    <span class="comment">// 消息发送</span></span><br><span class="line">                    channel.BasicPublish(exchange: <span class="string">&quot;&quot;</span>, routingKey: queueName, basicProperties: <span class="literal">null</span>, body: Encoding.UTF8.GetBytes(message));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里发送消息时<code>rabbitMq</code> 中并没有名称为 <code>test.pointToPoint.queue</code>  的队列，这里没有设置 <code>mandatory</code> 参数所以消息会默认被丢弃，可以使用<code>BasicReturn</code> 来获取没有正常发送到队列中的消息。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 消息发送</span></span><br><span class="line">channel.BasicPublish(exchange: <span class="string">&quot;&quot;</span>, routingKey: queueName, basicProperties: <span class="literal">null</span>, body: Encoding.UTF8.GetBytes(message), mandatory: <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取没有正常发送到队列中的消息</span></span><br><span class="line">channel.BasicReturn += (sender, message) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(Encoding.UTF8.GetString(message.Body.ToArray()));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="Exchange：AMQP-default">Exchange：AMQP default</h1><blockquote><p>Default exchange：</p><p>The default exchange is implicitly bound to every queue, with a routing key equal to the queue name. It is not possible to explicitly bind to, or unbind from the default exchange. It also cannot be deleted.</p></blockquote><blockquote><p>译：默认交换器隐式地绑定到每个队列，<strong>其路由键等于队列名</strong>。 不可能显式地绑定到默认交换，或从默认交换取消绑定。 也不能删除。</p></blockquote><p>这里是说每个 <code>queue</code> 都会默认绑定到这个<code>AMQP default</code> 这个交换器，不能显式手动绑定也不能解绑或者删除。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 消息发送</span></span><br><span class="line">channel.BasicPublish(exchange: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                     routingKey: <span class="string">&quot;test.pointToPoint.queue&quot;</span>,</span><br><span class="line">                     basicProperties: <span class="literal">null</span>, </span><br><span class="line">                     body: Encoding.UTF8.GetBytes(message));</span><br></pre></td></tr></table></figure><p>这里发布消息时没有指定 <code>exchange</code>，队列名称就是<code>routingKey</code>。</p><h1 id="Qos机制">Qos机制</h1><p>当生产者将消息发布到rabbitmq之后，如果在未配置 <code>QOS</code> 的情况下，rabbitmq尽可能快速地发送队列中的所有消息到消费者端，如果消息比较多，消费者来不及处理，就会缓存这些消息，当消息堆积过多，可能导致服务器内存不足而影响其他进程，rabbitmq的QOS可以很好的解决这类问题，<code>QOS</code> 就是限制消费者一次性从rabbitmq中获取消息的个数，而不是获取所有消息。比如设置rabbitmq的QOS为10，也就是 <code>prefetch=10</code> ，就是说哪怕rabbitmq中有100条消息，消费者也只是一次性获取10条，然后消费者消费这10条消息，剩下的交给其他消费者，当10条消息中的 <code>unacked</code> 个数少于prefetch * 消费者数目时，会继续从rabbitmq获取消息，如果在工作模式中，不使用QOS，你会发现所有的消息都被一个消费者消费了。</p><p></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/linux/Centos%E5%AE%89%E8%A3%85/"/>
      <url>/linux/Centos%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>记录一下windows下如何安装centos7</p><span id="more"></span><h1 id="软件准备">软件准备</h1><p>软件：<code>VMware</code><br>镜像：<code>CentOS7</code></p><h1 id="虚拟机准备">虚拟机准备</h1><p>打开 <code>VMware</code> 选择新建虚拟机</p><p><img src="/images/2021-09-03-14-54-03.png" alt=""></p><p>典型安装与自定义安装</p><ul><li>典型安装：<code>VMware</code> 会将主流的配置应用在虚拟机的操作系统上，对于新手来很友好</li><li>自定义安装：自定义安装可以针对性的把一些资源加强，把不需要的资源移除。避免资源浪费</li></ul><p><strong>这里选择典型安装</strong></p><p><img src="/images/2021-09-03-14-54-59.png" alt="">x</p><p><strong>选择稍后安装操作系统</strong></p><p><img src="/images/2021-09-03-14-55-14.png" alt=""></p><p><strong>选择操作系统为Linux</strong></p><p><img src="/images/2021-09-03-14-55-43.png" alt=""></p><p><strong>输入虚机名称和存储位置</strong></p><p><img src="/images/2021-09-03-14-55-58.png" alt=""></p><p><strong>设置虚机磁盘大小</strong></p><p><img src="/images/2021-09-03-14-56-11.png" alt=""></p><p><strong>自定义硬件</strong></p><p><img src="/images/2021-09-03-14-56-26.png" alt=""></p><p><img src="/images/2021-09-03-14-56-53.png" alt=""></p><p>根据自己电脑实际情况分配</p><ul><li>内存：2G</li><li>处理器数量：2 / 内核数量：2</li><li>网络适配器：NAT 模式</li><li>移除打印机和声卡</li></ul><h1 id="Centos安装">Centos安装</h1><p>在创建好的虚机上右键设置</p><p><img src="/images/2021-09-03-14-57-26.png" alt=""></p><p>开启虚拟机</p><p><img src="/images/2021-09-03-14-57-39.png" alt=""></p><p>安装操作系统<br>开启虚拟机后会出现以下界面:</p><ul><li><code>Install CentOS 7</code> 安装<code>CentOS 7</code></li><li><code>Test this media &amp; install CentOS 7</code> 测试安装文件并安装CentOS 7</li><li><code>Troubleshooting</code> 修复故障</li></ul><p>选择第一项，安装CentOS 7，回车进入下面的界面</p><p><img src="/images/2021-09-03-14-57-54.png" alt=""></p><p>选择安装过程中使用的语言</p><p><img src="/images/2021-09-03-14-58-08.png" alt=""></p><p>安装位置及分区设置；这里分区使用自动配置</p><p><img src="/images/2021-09-03-14-58-32.png" alt=""></p><p>软件选择：最小安装</p><p><img src="/images/2021-09-03-14-59-04.png" alt=""></p><p>网络和主机名：设置主机名称开启网络连接</p><p><img src="/images/2021-09-03-14-59-41.png" alt=""></p><p>开始安装</p><p><img src="/images/2021-09-03-15-00-03.png" alt=""></p><p>设置<code>Root</code>密码并创建新的用户<code>admin</code></p><p><img src="/images/2021-09-03-15-00-26.png" alt=""></p><p>等待安装完成重启系统即可</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/linux/Centos%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"/>
      <url>/linux/Centos%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="网络模式">网络模式</h1><ul><li>VMnet0（桥接模式）</li><li>VMnet1（仅主机模式）</li><li>VMnet8（NAT模式）</li></ul><span id="more"></span><h2 id="NAT-地址转换-VMnet8">NAT(地址转换)-VMnet8</h2><p>虚拟机要联网得先通过宿主机才能和外面进行通信。</p><p><code>NAT</code> 模式下的虚拟系统的 <code>TCP/IP</code> 配置信息是由 <code>VMnet8(NAT)</code> 虚拟网络的 <code>DHCP</code> 服务器提供的，无法进行手工修改，因此虚拟系统也就无法和本局域网中的其他真实主机进行通讯。使得虚拟局域网内的虚拟机在对外访问时，使用的则是宿主机的IP地址，这样从外部网络来看只能看到宿主机，完全看不到新建的虚拟局域网。就是虚拟系统会通过宿主机的网络来访问外网，而这里的宿主机相当于有两个网卡，一个是真实网卡，一个是虚拟网卡，真实网卡相当于链接了现实世界的真实路由器，而宿主机的虚拟网卡，相当于连接了一个可以认为是虚拟交换机。</p><p><img src="/images/2021-09-03-15-22-27.png" alt=""></p><blockquote><p>虚拟机可以上网可以ping通主机，但是主机ping不通虚拟机</p></blockquote><h2 id="Bridged-桥接-VMnet0">Bridged(桥接)-VMnet0</h2><p>虚拟机和宿主机在网络上就是平级的关系，相当于连接在同一交换机上。</p><p>需要手工为虚拟系统配置<code>IP地址</code>、<code>子网掩码</code>，而且还要和宿主机器处于同一网段，这样虚拟机才能和宿主机器进行通信，实现通过局域网的网关或路由器访问互联网。使用 Bridged 模式的虚拟系统和宿主机器的关系，就像连接在同一个Hub上的两台电脑。相当于在一个局域网内创立了一个单独的主机，他可以访问这个局域网内的所有的主机，但是需要手动配置IP地址，子网掩码，并且需要和真实主机在同一网段（nat是两个网段）。</p><p><img src="/images/2021-09-03-15-23-07.png" alt=""></p><blockquote><p>这个模式里，虚拟机和宿主机可以互相ping通</p></blockquote><h1 id="查看本机IP及网卡信息">查看本机IP及网卡信息</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip addr</span><br></pre></td></tr></table></figure><p><img src="/images/2021-09-03-15-23-43.png" alt=""></p><h1 id="使用VI模式编辑网卡信息">使用<code>VI</code>模式编辑网卡信息</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/sysconfig/network-scripts/ifcfg-ens33</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">TYPE=Ethernet</span><br><span class="line">BOOTPROTO=static #修改成static</span><br><span class="line">DEFROUTE=yes</span><br><span class="line">IPV4_FAILURE_FATAL=no</span><br><span class="line">IPV6INIT=yes</span><br><span class="line">IPV6_AUTOCONF=yes</span><br><span class="line">IPV6_DEFROUTE=yes</span><br><span class="line">IPV6_FAILURE_FATAL=no</span><br><span class="line">NAME=eno16777736</span><br><span class="line">UUID=bf5337ab-c044-4af7-9143-12da0d493b89</span><br><span class="line">DEVICE=eno16777736</span><br><span class="line">ONBOOT=yes #修改成yes</span><br><span class="line">PEERDNS=yes</span><br><span class="line">PEERROUTES=yes</span><br><span class="line">IPV6_PEERDNS=yes</span><br><span class="line">IPV6_PEERROUTES=yes</span><br><span class="line">IPADDR=192.168.31.32  # 自定义虚拟机的ip地址（主机是192.168.31.31），必须与主机在同一网段</span><br><span class="line">NETMASK=255.255.255.0 # 设置子网掩码，跟宿主一样</span><br><span class="line">GATEWAY=192.168.31.1  # 默认网关，跟宿主一样</span><br><span class="line">DNS1=192.168.31.1 # DNS，跟宿主一样</span><br></pre></td></tr></table></figure><h1 id="重启network">重启network</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service network restart</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/linux/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/linux/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>记录常用的Linux命令</p><span id="more"></span><h1 id="系统级别">系统级别</h1><table><thead><tr><th>描述</th><th>示例</th><th>备注</th></tr></thead><tbody><tr><td>显示机器的处理器架构</td><td><code>arch</code></td><td></td></tr><tr><td>显示机器的处理器架构</td><td><code>uname -m</code></td><td></td></tr><tr><td>显示正在使用的内核版本</td><td><code>uname -r</code></td><td></td></tr><tr><td>显示硬件系统部件 - (SMBIOS / DMI)</td><td><code>dmidecode -q</code></td><td></td></tr><tr><td>罗列一个磁盘的架构特性</td><td><code>hdparm -i /dev/hda</code></td><td></td></tr><tr><td>在磁盘上执行测试性读取操作</td><td><code>hdparm -tT /dev/sda</code></td><td></td></tr><tr><td>显示CPU info的信息</td><td><code>cat /proc/cpuinfo</code></td><td></td></tr><tr><td>显示中断</td><td><code>cat /proc/interrupts</code></td><td></td></tr><tr><td>校验内存使用</td><td><code>cat /proc/meminfo</code></td><td></td></tr><tr><td>显示哪些swap被使用</td><td><code>cat /proc/swaps</code></td><td></td></tr><tr><td>显示内核的版本</td><td><code>cat /proc/version</code></td><td></td></tr><tr><td>显示网络适配器及统计</td><td><code>cat /proc/net/dev</code></td><td></td></tr><tr><td>显示已加载的文件系统</td><td><code>cat /proc/mounts</code></td><td></td></tr><tr><td>罗列 PCI 设备</td><td><code>lspci -tv</code></td><td></td></tr><tr><td>显示 USB 设备</td><td><code>lsusb -tv</code></td><td></td></tr><tr><td>显示系统日期</td><td><code>date</code></td><td></td></tr><tr><td>显示2007年的日历表</td><td><code>cal 2007</code></td><td></td></tr><tr><td>设置日期和时间 - 月日时分年.秒</td><td><code>date 041217002007.00</code></td><td></td></tr><tr><td>将时间修改保存到 BIOS</td><td><code>clock -w</code></td><td></td></tr><tr><td>关闭系统</td><td><code>shutdown -h now</code></td><td></td></tr><tr><td>关闭系统</td><td><code>telinit 0</code></td><td></td></tr><tr><td>取消按预定时间关闭系统</td><td><code>shutdown -c</code></td><td></td></tr><tr><td>重启</td><td><code>shutdown -r now</code></td><td></td></tr><tr><td>重启</td><td><code>reboot</code></td><td></td></tr><tr><td>注销</td><td><code>logout</code></td><td></td></tr></tbody></table><h1 id="目录相关">目录相关</h1><table><thead><tr><th>描述</th><th>示例</th><th>备注</th></tr></thead><tbody><tr><td>进入指定目录</td><td><code>cd /home</code></td><td></td></tr><tr><td>返回上一级目录</td><td><code>cd ..</code></td><td></td></tr><tr><td>返回上两级目录</td><td><code>cd ../..</code></td><td></td></tr><tr><td>进入个人主目录</td><td><code>cd</code></td><td></td></tr><tr><td>进入上次操作所在目录</td><td><code>cd -</code></td><td></td></tr><tr><td>显示当前工作路径</td><td><code>pwd</code></td><td></td></tr><tr><td>查看目录中的文件</td><td><code>ls</code></td><td></td></tr><tr><td>查看目录中的文件</td><td><code>ls -F</code></td><td></td></tr><tr><td>显示文件和目录的详细信息</td><td><code>ls -l</code></td><td></td></tr><tr><td>显示隐藏文件</td><td><code>ls -a</code></td><td></td></tr><tr><td>显示包含数字的文件名和目录名</td><td><code>ls *[0-9]*</code></td><td></td></tr><tr><td>显示文件和目录由根目录开始的树形结构</td><td><code>tree</code></td><td><code>yum install tree -y</code></td></tr><tr><td>创建目录</td><td><code>mkdir dir</code></td><td></td></tr><tr><td>创建多个目录</td><td><code>mkdir dir1 dir2</code></td><td></td></tr><tr><td>创建目录树</td><td><code>mkdir -p /tmp/dir1/dir2</code></td><td></td></tr><tr><td>删除文件</td><td><code>rm -f file1</code></td><td></td></tr><tr><td>删除目录</td><td><code>rmdir dir1</code></td><td></td></tr><tr><td>删除目录并同时删除内容</td><td><code>rm -rf dir1</code></td><td></td></tr><tr><td>同时删除多个目录及内容</td><td><code>rm -rf dir1 dir2</code></td><td></td></tr><tr><td>重命名/移动 目录</td><td><code>mv dir1 new_dir</code></td><td></td></tr><tr><td>复制文件</td><td><code>cp file1 file2</code></td><td></td></tr><tr><td>复制目录下的所有文件到当前工作目录</td><td><code>cp dir/* .</code></td><td></td></tr><tr><td>复制目录到当前工作目录</td><td><code>cp -a /tmp/dir1.</code></td><td></td></tr><tr><td>复制目录</td><td><code>cp -a dir1 dir2</code></td><td></td></tr><tr><td>创建一个指向文件或目录的软链接</td><td><code>ln -s file1 lnk1</code></td><td></td></tr><tr><td>创建一个指向文件或目录的物理链接</td><td><code>ln file1 lnk1</code></td><td></td></tr><tr><td>修改一个文件或目录的时间戳 - (YYMMDDhhmm)</td><td><code>touch -t 0712250000 file1</code></td><td></td></tr></tbody></table><h1 id="网络相关">网络相关</h1><table><thead><tr><th>描述</th><th>示例</th><th>备注</th></tr></thead><tbody><tr><td>查看本机IP及网卡信息</td><td><code>ip addr</code></td><td></td></tr><tr><td>重启网络</td><td><code>service network restart</code></td><td></td></tr><tr><td>防火墙添加端口例外</td><td><code>firewall-cmd --add-port=8080/tcp --permanent</code></td><td></td></tr><tr><td>重新加载防火墙</td><td><code>firewall-cmd --reload</code></td><td></td></tr><tr><td>启动防火墙，也可以使用 <code>service firewalld start</code></td><td><code>systemctl start firewalld.service</code></td><td></td></tr><tr><td>停止防火墙，也可以使用 <code>service firewalld stop</code></td><td><code>systemctl stop firewalld.service</code></td><td></td></tr><tr><td>启用防火墙</td><td><code>systemctl enable firewalld.service</code></td><td></td></tr><tr><td>重启防火墙</td><td><code>service firewalld restart</code></td><td></td></tr><tr><td>查看端口列表，也可以使用 <code>firewall-cmd --list-all</code></td><td><code>firewall-cmd --permanent --list-port</code></td><td></td></tr></tbody></table><h1 id="其他命令">其他命令</h1><p>使用 VI 编辑文件。使用<code>vi</code>进入文本后，按<code>i</code>编辑文本</p><p>按<code>ESC</code>键：</p><ul><li><code>:q!</code>  不保存文件，强制退出vi命令</li><li><code>:w</code>   保存文件，不退出vi命令</li><li><code>:wq</code>  保存文件，退出vi命令</li></ul><h2 id=""></h2><h2 id="-v2"></h2><h2 id="-v3"></h2><h2 id="-v4"></h2><h2 id="-v5"></h2><h2 id="-v6"></h2><h2 id="-v7"></h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/linux/Linux%E7%9B%AE%E5%BD%95%E8%AF%B4%E6%98%8E/"/>
      <url>/linux/Linux%E7%9B%AE%E5%BD%95%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<p>记录下Linux各目录的说明</p><span id="more"></span><table><thead><tr><th style="text-align:center">目录</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>/boot</code></td><td style="text-align:left">该目录默认下存放的是Linux的启动文件和内核</td></tr><tr><td style="text-align:center"><code>/bin</code></td><td style="text-align:left">Binary的缩写，该目录中存放Linux的常用命令</td></tr><tr><td style="text-align:center"><code>/sbin</code></td><td style="text-align:left">Supaer User；该目录用来存放系统管理员使用的管理程序</td></tr><tr><td style="text-align:center"><code>/var</code></td><td style="text-align:left">该目录存放那些经常被修改的文件，包括各种日志、数据文件</td></tr><tr><td style="text-align:center"><code>/etc</code></td><td style="text-align:left">该目录存放系统管理时要用到的各种配置文件和子目录，例如网络配置文件、文件系统、系统配置文件、设备配置信息、设置用户信息等</td></tr><tr><td style="text-align:center"><code>/dev</code></td><td style="text-align:left">d是Device的缩写；该目录包含了Linux系统中使用的所有外部设备，它实际上是访问这些外部设备的端口，访问这些外部设备与访问一个文件或一个目录没有区别</td></tr><tr><td style="text-align:center"><code>/mnt</code></td><td style="text-align:left">临时将别的文件系统挂在该目录下</td></tr><tr><td style="text-align:center"><code>/root</code></td><td style="text-align:left">如果你是以超级用户的身份登录的，这个就是超级用户的主目录</td></tr><tr><td style="text-align:center"><code>/home</code></td><td style="text-align:left">如果建立一个名为“xx”的用户，那么在/home目录下就有一个对应的“/home/xx”路径，用来存放该用户的主目录</td></tr><tr><td style="text-align:center"><code>/usr</code></td><td style="text-align:left">用户的应用程序和文件几乎都存放在该目录下</td></tr><tr><td style="text-align:center"><code>/lib</code></td><td style="text-align:left">该目录用来存放系统动态链接共享库，几乎所有的应用程序都会用到该目录下的共享库</td></tr><tr><td style="text-align:center"><code>/opt</code></td><td style="text-align:left">第三方软件在安装时默认会找这个目录,所以你没有安装此类软件时它是空的,但如果你一旦把它删除了,以后在安装此类软件时就有可能碰到麻烦</td></tr><tr><td style="text-align:center"><code>/tmp</code></td><td style="text-align:left">用来存放不同程序执行时产生的临时文件，该目录会被系统自动清理干净</td></tr><tr><td style="text-align:center"><code>/lost＋found</code></td><td style="text-align:left">该目录在大多数情况下都是空的。但当突然停电、或者非正常关机后，有些文件就临时存放在此</td></tr><tr><td style="text-align:center"><code>/proc</code></td><td style="text-align:left">可以在该目录下获取系统信息，这些信息是在内存中由系统自己产生的，该目录的内容不在硬盘上而在内存里</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/microservice/1.1%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8%E4%B9%8B%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/"/>
      <url>/microservice/1.1%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8%E4%B9%8B%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>此系列旨在复习微服务的相关知识，示例代码中不会出现聚合、聚合根、服务拆分等相关概念（不会涉及到领域驱动相关知识），只使用最简单的<code>.Net Core Web</code>程序，主要关注点在于：</p><ul><li>如何使用 Docker 部署 <code>.NetCore</code> 应用</li><li>应用程序的 DockerFile 编写</li><li>服务注册和服务发现是什么？解决了什么问题？</li><li>网关用来做什么？服务治理相关（熔断/限流/降级/链路追踪/缓存…）</li></ul><span id="more"></span><h1 id="微服务概念">微服务概念</h1><p>关于微服务的概念解释网上有很多，每个人的理解都不同。至于为什么要使用微服务？微服务的优缺点等相关问题每个人理解不同。个人理解：微服务是一种系统架构模式，和语言无关，框架无关，工具无关，服务器环境无关，微服务目的是：将传统单体系统按照业务拆分成多个职责单一、且可独立运行的服务。至于服务如何拆分，没有明确的定义。采用微服务优点是：每个服务的职责单一且可独立部署、不同服务间采用轻量级的通信协议作为通信原则，松耦合。这样不同服务就可以使用不同的技术栈（优势语言），缺点的话是：微服务架构避免不了会引入更多技术栈、中间件等等增加系统复杂度。（微服务不是银弹，要根据实际业务体量考虑是否使用，否则只会徒增不必要的麻烦）</p><h1 id="项目结构搭建">项目结构搭建</h1><p><img src="/images/2021-09-17-17-31-42.png" alt=""></p><ul><li><code>Order.Api</code>：订单服务</li><li><code>Web.Client</code>：测试使用的客户端</li></ul><p>创建项目时启用Docker支持，或者之后添加也可以。添加基础代码，简单的返回服务名称、当前时间、服务IP、端口：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Mvc;</span><br><span class="line"><span class="keyword">using</span> Microsoft.Extensions.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Order.Api.Controller</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Route(<span class="meta-string">&quot;[Controller]&quot;</span>)</span>]</span><br><span class="line">    [<span class="meta">ApiController</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OrdersController</span> : <span class="title">ControllerBase</span></span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="meta">HttpGet</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> IActionResult <span class="title">Index</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> result = <span class="string">$&quot;订单服务：<span class="subst">&#123;DateTime.Now:yyyy-MM-dd HH:mm:ss&#125;</span>,-<span class="subst">&#123;Request.HttpContext.Connection.LocalIpAddress&#125;</span>:<span class="subst">&#123;Request.HttpContext.Connection.LocalPort&#125;</span>&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> Ok(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="容器化部署">容器化部署</h1><p>代码就写这么简单，下面使用Docker来部署订单服务。这里先了解一下如果启用了Docker支持，VS默认生成的 <code>Dockerfile</code> 文件如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#See https://aka.ms/containerfastmode to understand how Visual Studio uses this Dockerfile to build your images for faster debugging.</span><br><span class="line"></span><br><span class="line">FROM mcr.microsoft.com/dotnet/aspnet:5.0 AS base</span><br><span class="line">WORKDIR /app</span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line">FROM mcr.microsoft.com/dotnet/sdk:5.0 AS build</span><br><span class="line">WORKDIR /src</span><br><span class="line">COPY [&quot;Order.Api/Order.Api.csproj&quot;, &quot;Order.Api/&quot;]</span><br><span class="line">RUN dotnet restore &quot;Order.Api/Order.Api.csproj&quot;</span><br><span class="line">COPY . .</span><br><span class="line">WORKDIR &quot;/src/Order.Api&quot;</span><br><span class="line">RUN dotnet build &quot;Order.Api.csproj&quot; -c Release -o /app/build</span><br><span class="line"></span><br><span class="line">FROM build AS publish</span><br><span class="line">RUN dotnet publish &quot;Order.Api.csproj&quot; -c Release -o /app/publish</span><br><span class="line"></span><br><span class="line">FROM base AS final</span><br><span class="line">WORKDIR /app</span><br><span class="line">COPY --from=publish /app/publish .</span><br><span class="line">ENTRYPOINT [&quot;dotnet&quot;, &quot;Order.Api.dll&quot;]</span><br></pre></td></tr></table></figure><p>关于<code>Dockerfile</code> 各个命令的作用这里不再解释，可以参考  <a href="https://wpl.wiki/docker/1.8Dockerfile">【Dockerfile】</a>。这里的 <code>Dockerfile</code> 文件不能直接使用，因为我采用的方式是：将发布后的应用部署到 <code>Centos</code> =&gt; <code>docker build镜像</code>=&gt;<code>运行容器</code>。跳过了这里的 <code>dotnet restore</code> 和 <code>dotnet publish</code>。修改后的 <code>Dockerfile</code>如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># See https://aka.ms/containerfastmode to understand how Visual Studio uses this Dockerfile to build your images for faster debugging.</span></span><br><span class="line"><span class="comment"># 指定基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> mcr.microsoft.com/dotnet/aspnet:<span class="number">5.0</span> AS base</span><br><span class="line"><span class="comment"># 设置工作目录,如不存在会被创建</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="comment"># Copy release文件夹内容到工作目录app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . /app</span></span><br><span class="line"><span class="comment"># 运行.dll</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;dotnet&quot;</span>, <span class="string">&quot;Order.Api.dll&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>将发布后的包扔到虚机指定目录中：</p><p><img src="/images/2021-09-17-17-52-17.png" alt=""></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入目录</span></span><br><span class="line">[root@centos-01 ~]<span class="comment"># cd /usr/dotnetcore_src/order.api.release/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看本地镜像列表</span></span><br><span class="line">[root@centos-01 order.api.release]<span class="comment"># docker image ls</span></span><br><span class="line">REPOSITORY                        TAG          IMAGE ID       CREATED        SIZE</span><br><span class="line">&lt;none&gt;                            &lt;none&gt;       16ff5dcb1c6d   2 hours ago    206MB</span><br><span class="line">&lt;none&gt;                            &lt;none&gt;       6d3756023f75   25 hours ago   210MB</span><br><span class="line">&lt;none&gt;                            &lt;none&gt;       3f41b63e8f79   25 hours ago   210MB</span><br><span class="line">mcr.microsoft.com/dotnet/sdk      5.0          da19c23a5531   2 days ago     631MB</span><br><span class="line">mcr.microsoft.com/dotnet/aspnet   5.0          a2be3e478ffa   2 days ago     205MB</span><br><span class="line">consul                            latest       b74a0a01afc4   2 weeks ago    116MB</span><br><span class="line">rabbitmq                          management   0bfe221339ae   7 weeks ago    253MB</span><br><span class="line">mongo                             latest       aad77ae58e0c   7 weeks ago    682MB</span><br><span class="line">redis                             latest       08502081bff6   2 months ago   105MB</span><br><span class="line">portainer/portainer               latest       580c0e4e98b0   6 months ago   79.1MB</span><br><span class="line">elasticsearch                     7.1.1        b0e9f9f047e6   2 years ago    894MB</span><br><span class="line"></span><br><span class="line"><span class="comment"># build镜像</span></span><br><span class="line">[root@centos-01 order.api.release]<span class="comment"># docker build -t order.api .</span></span><br><span class="line">Sending build context to Docker daemon  1.184MB</span><br><span class="line">Step 1/4 : FROM mcr.microsoft.com/dotnet/aspnet:5.0 AS base</span><br><span class="line"> ---&gt; a2be3e478ffa</span><br><span class="line">Step 2/4 : WORKDIR /app</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 9f551bd1698a</span><br><span class="line">Step 3/4 : COPY . /app</span><br><span class="line"> ---&gt; 04334af56137</span><br><span class="line">Step 4/4 : ENTRYPOINT [<span class="string">&quot;dotnet&quot;</span>, <span class="string">&quot;Order.Api.dll&quot;</span>]</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 44daedf04664</span><br><span class="line">Removing intermediate container 44daedf04664</span><br><span class="line"> ---&gt; 58968d65acff</span><br><span class="line">Successfully built 58968d65acff</span><br><span class="line">Successfully tagged order.api:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看最新本地镜像列表发现 order.api 镜像</span></span><br><span class="line">[root@centos-01 order.api.release]<span class="comment"># docker image ls</span></span><br><span class="line">REPOSITORY                        TAG          IMAGE ID       CREATED              SIZE</span><br><span class="line">order.api                         latest       58968d65acff   About a minute ago   206MB</span><br><span class="line">&lt;none&gt;                            &lt;none&gt;       16ff5dcb1c6d   2 hours ago          206MB</span><br><span class="line">&lt;none&gt;                            &lt;none&gt;       6d3756023f75   25 hours ago         210MB</span><br><span class="line">&lt;none&gt;                            &lt;none&gt;       3f41b63e8f79   25 hours ago         210MB</span><br><span class="line">mcr.microsoft.com/dotnet/sdk      5.0          da19c23a5531   2 days ago           631MB</span><br><span class="line">mcr.microsoft.com/dotnet/aspnet   5.0          a2be3e478ffa   2 days ago           205MB</span><br><span class="line">consul                            latest       b74a0a01afc4   2 weeks ago          116MB</span><br><span class="line">rabbitmq                          management   0bfe221339ae   7 weeks ago          253MB</span><br><span class="line">mongo                             latest       aad77ae58e0c   7 weeks ago          682MB</span><br><span class="line">redis                             latest       08502081bff6   2 months ago         105MB</span><br><span class="line">portainer/portainer               latest       580c0e4e98b0   6 months ago         79.1MB</span><br><span class="line">elasticsearch                     7.1.1        b0e9f9f047e6   2 years ago          894MB</span><br><span class="line">[root@centos-01 order.api.release]<span class="comment"># </span></span><br></pre></td></tr></table></figure><p>有了镜像之后就可以基于镜像创建容器:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-01 order.api.release]<span class="comment"># docker run -d --name order.api -p 80:80 order.api</span></span><br><span class="line">eaa1d05afe39ccdc6a07347df78c994f57c654267db1e40b64d21e030b565903</span><br></pre></td></tr></table></figure><p>容器启动成功后，在宿主机上输入IP地址加端口测试访问：</p><p><img src="/images/2021-09-17-19-07-41.png" alt=""></p><p>至此订单服务就部署完毕。下面使用 <code>Web.Client</code> 客户端测试，这里的客户端是泛指，实际可能是各种业务系统、手机端、小程序等等。</p><h1 id="客户端调用">客户端调用</h1><p>这里使用 <code>RestSharp</code>作为Http请求客户端，<code>Nuget</code> 搜索 <a href="https://github.com/restsharp/RestSharp">【RestSharp】</a> 安装即可。</p><p>核心代码如下：</p><p>IServiceHelper.cs：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IServiceHelper</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Task&lt;<span class="built_in">string</span>&gt; <span class="title">GetOrder</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ServiceHelper.cs：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ServiceHelper</span> : <span class="title">IServiceHelper</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;<span class="built_in">string</span>&gt; <span class="title">GetOrder</span>(<span class="params"></span>)</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="comment">// 订单服务地址</span></span><br><span class="line">         <span class="built_in">string</span> serviceUrl = <span class="string">&quot;http://192.168.31.191:80&quot;</span>;</span><br><span class="line">         <span class="keyword">var</span> Client = <span class="keyword">new</span> RestClient(serviceUrl);</span><br><span class="line">         <span class="keyword">var</span> request = <span class="keyword">new</span> RestRequest(<span class="string">&quot;/orders&quot;</span>, Method.GET);</span><br><span class="line">         <span class="keyword">var</span> response = <span class="keyword">await</span> Client.ExecuteAsync(request);</span><br><span class="line">         <span class="keyword">return</span> response.Content;</span><br><span class="line">     &#125;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Startup.cs：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    services.AddControllersWithViews();</span><br><span class="line">    <span class="comment">// 注入IServiceHelper</span></span><br><span class="line">    services.AddSingleton&lt;IServiceHelper, ServiceHelper&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HomeController.cs：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HomeController</span> : <span class="title">Controller</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ILogger&lt;HomeController&gt; logger;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IServiceHelper serviceHelper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HomeController</span>(<span class="params">ILogger&lt;HomeController&gt; logger, IServiceHelper serviceHelper</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.logger = logger;</span><br><span class="line">        <span class="keyword">this</span>.serviceHelper = serviceHelper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">IndexAsync</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ViewBag.OrderData = <span class="keyword">await</span> serviceHelper.GetOrder();</span><br><span class="line">        <span class="keyword">return</span> View();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IActionResult <span class="title">Privacy</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> View();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">ResponseCache(Duration = 0, Location = ResponseCacheLocation.None, NoStore = true)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IActionResult <span class="title">Error</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> View(<span class="keyword">new</span> ErrorViewModel &#123; RequestId = Activity.Current?.Id ?? HttpContext.TraceIdentifier &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Index.cshtml：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@&#123;</span><br><span class="line">    ViewData[&quot;Title&quot;] = &quot;Home Page&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;text-center&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;display-4&quot;</span>&gt;</span>Welcome<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        @ViewBag.OrderData</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>启动项目浏览器访问：</p><p><img src="/images/2021-09-17-19-16-22.png" alt=""></p><p>到这里服务已经独立部署运行，客户端也可以正常调用了。但是思考一个问题：如果这个服务挂掉了怎么办？微服务中非常重要的原则就是&quot;高可用&quot;，以上的做法明显不能满足。要解决这个问题一般都会采用集群方式。</p><h1 id="简单服务集群">简单服务集群</h1><p>既然单个服务实例有挂掉的风险，那么部署多个服务实例试试，只要不同时挂掉就可以保证正常访问。下面使用Docker运行多个服务实例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-01 ~]<span class="comment"># docker run -d --name order.api -p 80:80 order.api</span></span><br><span class="line">c4a974a607b54377115a32a4227fa0f9d2ca4332405875b3763cca2696932c1c</span><br><span class="line">[root@centos-01 ~]<span class="comment"># docker run -d --name order.api1 -p 81:80 order.api</span></span><br><span class="line">992f0b2975f60320ba92c2e79b33ae066c17b3b26f54e74b96ad7677d54042d7</span><br><span class="line">[root@centos-01 ~]<span class="comment"># docker run -d --name order.api2 -p 82:80 order.api</span></span><br><span class="line">dca6a0cd36a4bca3111b5694f34c8f8ffbcc81d6dbbadb45a2d3209afa7b0595</span><br></pre></td></tr></table></figure><p>现在订单服务增加到三个服务实例，分别映射到<code>80</code>/<code>81</code>/<code>82</code>端口。需要修改一下客户端代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;<span class="built_in">string</span>&gt; <span class="title">GetOrder</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 服务实例集合</span></span><br><span class="line">    <span class="built_in">string</span>[] serviceUrls = &#123; <span class="string">&quot;http://192.168.31.191:80&quot;</span>, <span class="string">&quot;http://192.168.31.191:81&quot;</span>, <span class="string">&quot;http://192.168.31.191:82&quot;</span> &#125;;</span><br><span class="line">    <span class="comment">// 每次随机访问一个服务实例</span></span><br><span class="line">    <span class="keyword">var</span> client = <span class="keyword">new</span> RestClient(serviceUrls[<span class="keyword">new</span> Random().Next(<span class="number">0</span>, <span class="number">3</span>)]);</span><br><span class="line">    <span class="keyword">var</span> request = <span class="keyword">new</span> RestRequest(<span class="string">&quot;/orders&quot;</span>, Method.GET);</span><br><span class="line">    <span class="keyword">var</span> response = <span class="keyword">await</span> client.ExecuteAsync(request);</span><br><span class="line">    <span class="keyword">return</span> response.Content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里拿到服务地址可以自己做复杂的负载均衡策略，比如轮询，随机，权重等或者使用nginx都可以。这不是重点，所以这里只是简单随机访问一个服务实例</p></blockquote><p>这里已经做到了将请求随机分配到一个服务实例，但这种做法依旧存在问题：</p><ol><li>如果随机访问到的实例刚好挂掉，依然无法正常访问</li><li>如果到某个地址的请求连续多次失败，应该移除这个地址保证其他请求不会再访问到</li><li>实际应用中，上层的业务系统可能非常多，为了保证可用性，每个业务系统都需要考虑服务实例运行状态吗？而且实际应用中服务实例的数量或者地址大多数时候是不固定的，比如：流量高峰期，增加服务实例，这时候每个业务系统再去配置文件里配置地址？高峰期过了又去把配置删掉？显然是不现实的。服务必须要做到可灵活伸缩</li></ol><p>要做到可灵活伸缩就引入了另一个名词：服务注册与发现。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/microservice/1.2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8%E4%B9%8B%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0/"/>
      <url>/microservice/1.2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8%E4%B9%8B%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="前言-v2">前言</h1><p>上一篇说到要做到服务的灵活伸缩需要有一种机制来实现，这个机制就是服务注册与发现。这并不是必须的，如果服务实例很少并且很稳定，就没有必要使用。</p><span id="more"></span><h1 id="概念-v2">概念</h1><ul><li>服务注册：简单理解就是有一个注册中心，每个服务实例启动时都去注册中心注册，告诉注册中心地址，端口等信息。同样删除时，也需要去注册中心删除，注册中心负责维护这些服务实例的信息</li><li>服务发现：既然注册中心维护了各个服务实例的信息，那么客户端通过注册中心就很容易能发现服务的变化。有了服务注册与发现，客户端就不用再去配置各个服务实例的地址，改为从注册中心统一获取</li><li>健康检查：注册中心要保证每个地址的可用状态，挂掉的实例不应该被客户端获取到，所以需要：健康检查。每个服务都需要提供一个用于健康检查的接口，这个接口不具备任何业务功能。服务注册时把这个接口的地址也告诉注册中心，注册中心会定时调用这个接口来检测服务是否正常，如果不正常，则将它移除，这样来保证了服务的可用性</li></ul><p>常见注册中心有 <code>Consul</code>、<code>ZooKeeper</code>、<code>etcd</code>、<code>Eureka</code>。</p><h1 id="Consul">Consul</h1><p>Consul官网：<a href="https://www.consul.io">https://www.consul.io</a>，主要功能有服务注册与发现、健康检查、K-V存储、多数据中心等，这里不做详细介绍。</p><ul><li>安装：直接在官网下载解压即可</li><li>运行：在 <code>consul.exe</code> 目录下打开命令行执行 <code>consul.exe agent -dev</code></li><li>浏览器访问：<a href="http://localhost:8500">http://localhost:8500</a></li></ul><p>这里选择使用Docker来部署Consul：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull consul </span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8500:8500 --restart=always --name=consul consul:latest agent -server -bootstrap -ui -node=1 -client=<span class="string">&#x27;0.0.0.0&#x27;</span></span><br></pre></td></tr></table></figure><ul><li><code>agent</code>： 表示启动 Agent 进程</li><li><code>server</code>：表示启动 Consul Server 模式</li><li><code>client</code>：表示启动 Consul Cilent 模式</li><li><code>bootstrap</code>：表示这个节点是 Server-Leader ，每个数据中心只能运行一台服务器。技术角度上来看 Leader 是通过 Raft 算法选举的，但是集群第一次启动时需要一个引导 Leader，在引导群集后，建议不要使用此标志</li><li><code>ui</code>：表示启动 Web UI 管理器，默认开放端口 <code>8500</code>，所以上面使用 Docker 命令把 <code>8500</code> 端口对外开放</li><li><code>node</code>：节点的名称，集群中必须是唯一的，默认是该节点的主机名</li><li><code>client</code>：Consul服务监听地址，这提供<code>HTTP</code>、<code>DNS</code>、<code>RPC</code>等服务，默认是 <code>127.0.0.1</code> 所以不对外提供服务，如果要对外提供服务改成 <code>0.0.0.0</code></li><li><code>join</code>：表示加入到某一个集群中。 如：<code>-json=192.168.0.11</code></li></ul><p><img src="/images/2021-09-17-20-00-01.png" alt=""></p><p>这里看到Consul已经成功运行。</p><h1 id="服务注册">服务注册</h1><p>订单服务项目使用<code>Nuget</code> 安装 <code>Consul</code>，然后添加相关代码：</p><p>ConsulHelper.cs：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">ConsulHelper</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 服务注册</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;app&quot;&gt;</span>The application.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;configuration&quot;&gt;</span>The configuration.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;lifetime&quot;&gt;</span>The lifetime.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IApplicationBuilder <span class="title">RegisterConsul</span>(<span class="params"><span class="keyword">this</span> IApplicationBuilder app</span></span></span><br><span class="line"><span class="params"><span class="function">        , IConfiguration configuration</span></span></span><br><span class="line"><span class="params"><span class="function">        , IHostApplicationLifetime lifetime</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> consulClient = <span class="keyword">new</span> ConsulClient(c =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            c.Address = <span class="keyword">new</span> Uri(configuration[<span class="string">&quot;ConsulSetting:ConsulAddress&quot;</span>]);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> registration = <span class="keyword">new</span> AgentServiceRegistration()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 服务实例唯一标识</span></span><br><span class="line">            ID = Guid.NewGuid().ToString(),</span><br><span class="line">            <span class="comment">// 服务名称</span></span><br><span class="line">            Name = configuration[<span class="string">&quot;ConsulSetting:ServiceName&quot;</span>],</span><br><span class="line">            <span class="comment">// 服务IP地址</span></span><br><span class="line">            Address = configuration[<span class="string">&quot;ConsulSetting:ServiceIP&quot;</span>],</span><br><span class="line">            <span class="comment">// 服务端口：因为要运行多个实例，端口不能在appsettings.json里配置而是在docker容器运行时传入</span></span><br><span class="line">            Port = <span class="built_in">int</span>.Parse(configuration[<span class="string">&quot;ConsulSetting:ServicePort&quot;</span>]),</span><br><span class="line">            Check = <span class="keyword">new</span> AgentServiceCheck()</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 服务启动多久后注册</span></span><br><span class="line">                DeregisterCriticalServiceAfter = TimeSpan.FromSeconds(<span class="number">3</span>),</span><br><span class="line">                <span class="comment">// 健康检查时间间隔</span></span><br><span class="line">                Interval = TimeSpan.FromSeconds(<span class="number">10</span>),</span><br><span class="line">                <span class="comment">// 健康检查地址</span></span><br><span class="line">                HTTP = <span class="string">$&quot;http://<span class="subst">&#123;configuration[<span class="string">&quot;ConsulSetting:ServiceIP&quot;</span>]&#125;</span>:<span class="subst">&#123;configuration[<span class="string">&quot;ConsulSetting:ServicePort&quot;</span>]&#125;</span><span class="subst">&#123;configuration[<span class="string">&quot;ConsulSetting:ServiceHealthCheck&quot;</span>]&#125;</span>&quot;</span>,</span><br><span class="line">                <span class="comment">// 超时时间</span></span><br><span class="line">                Timeout = TimeSpan.FromSeconds(<span class="number">5</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 服务注册</span></span><br><span class="line">        consulClient.Agent.ServiceRegister(registration).Wait();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 应用程序终止时，取消注册</span></span><br><span class="line">        lifetime.ApplicationStopping.Register(() =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            consulClient.Agent.ServiceDeregister(registration.ID).Wait();</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> app;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>appsettings.json：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;Logging&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;LogLevel&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;Default&quot;</span>: <span class="string">&quot;Information&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;Microsoft&quot;</span>: <span class="string">&quot;Warning&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;Microsoft.Hosting.Lifetime&quot;</span>: <span class="string">&quot;Information&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;AllowedHosts&quot;</span>: <span class="string">&quot;*&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;ConsulSetting&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;ServiceName&quot;</span>: <span class="string">&quot;order.service&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;ServiceIP&quot;</span>: <span class="string">&quot;192.168.31.191&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;ServiceHealthCheck&quot;</span>: <span class="string">&quot;/healthcheck&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;ConsulAddress&quot;</span>: <span class="string">&quot;http://192.168.31.191:8500&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：这里没有配置ServicePort，所以如果本地直接运行项目会报错</p></blockquote><p>Startup.cs：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app, IWebHostEnvironment env, IHostApplicationLifetime lifetime</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (env.IsDevelopment())</span><br><span class="line">    &#123; &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123; &#125;</span><br><span class="line"></span><br><span class="line">    app.UseStaticFiles();</span><br><span class="line"></span><br><span class="line">    app.UseRouting();</span><br><span class="line">    app.UseEndpoints(endpoints =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        endpoints.MapControllers();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启用服务注册</span></span><br><span class="line">    app.RegisterConsul(Configuration, lifetime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OrdersController.cs：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Route(<span class="meta-string">&quot;[Controller]&quot;</span>)</span>]</span><br><span class="line">[<span class="meta">ApiController</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OrdersController</span> : <span class="title">ControllerBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IConfiguration configuration;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrdersController</span>(<span class="params">IConfiguration configuration</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.configuration = configuration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">HttpGet</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IActionResult <span class="title">Index</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> result = <span class="string">$&quot;订单服务：<span class="subst">&#123;DateTime.Now:yyyy-MM-dd HH:mm:ss&#125;</span>,-<span class="subst">&#123;Request.HttpContext.Connection.LocalIpAddress&#125;</span>:<span class="subst">&#123;configuration[<span class="string">&quot;ConsulSetting:ServicePort&quot;</span>]&#125;</span>&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> Ok(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HealthCheckController.cs：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Route(<span class="meta-string">&quot;[controller]&quot;</span>)</span>]</span><br><span class="line">[<span class="meta">ApiController</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HealthCheckController</span> : <span class="title">ControllerBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 健康检查接口</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    [<span class="meta">HttpGet</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IActionResult <span class="title">Get</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Ok(<span class="string">&quot;Pong.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此就完成了服务注册、取消注册、健康检查的代码编写，下面重新 <code>build</code> 镜像（过程略过）运行新的容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-01 order.api.release]<span class="comment"># docker run -d --name order.api -p 80:80 order.api  --ConsulSetting:ServicePort=&quot;80&quot;</span></span><br><span class="line">89acc7d7035f2041a91bc1e1299464a5460290dd66b12161ee4e994d5548def2</span><br><span class="line">[root@centos-01 order.api.release]<span class="comment"># docker run -d --name order.api1 -p 81:80 order.api --ConsulSetting:ServicePort=&quot;81&quot;</span></span><br><span class="line">223be73a41e501e168fdc44459cd6f5851d565e60817dbd0047dff7718394e22</span><br><span class="line">[root@centos-01 order.api.release]<span class="comment"># docker run -d --name order.api2 -p 82:80 order.api --ConsulSetting:ServicePort=&quot;82&quot;</span></span><br></pre></td></tr></table></figure><p><img src="/images/2021-09-17-20-36-21.png" alt=""><br><img src="/images/2021-09-17-20-36-40.png" alt=""></p><p>至此，3个服务实例都已运行，并且成功注册到 Consul。测试一下服务停止会不会从Consul移除：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-01 order.api.release]<span class="comment"># docker stop order.api</span></span><br></pre></td></tr></table></figure><p><img src="/images/2021-09-17-20-39-00.png" alt=""></p><p>这里需要注意：程序发生异常，健康检查不能正确响应的话，Consul也会移除。至此注册、发现、健康检查功能都完成了，下一步考虑客户端如何拿到这些服务实例的地址。</p><h1 id="客户端">客户端</h1><p>上面已经成功将服务注册到 Consul中，接下来就该客户端通过 Consul 去做服务发现了。客户端项目同样使用<code>Nuget</code> 安装 Consul，然后调整相关代码：</p><p>ServiceHelper.cs：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Consul;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> Microsoft.Extensions.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> RestSharp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Concurrent;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Web.Client</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IServiceHelper</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">Task&lt;<span class="built_in">string</span>&gt; <span class="title">GetOrder</span>(<span class="params"></span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ServiceHelper</span> : <span class="title">IServiceHelper</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> IConfiguration configuration;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ServiceHelper</span>(<span class="params">IConfiguration configuration</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.configuration = configuration;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;<span class="built_in">string</span>&gt; <span class="title">GetOrder</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> consulClient = <span class="keyword">new</span> ConsulClient(c =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                c.Address = <span class="keyword">new</span> Uri(configuration[<span class="string">&quot;ConsulSetting:ConsulAddress&quot;</span>]);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取健康的服务</span></span><br><span class="line">            <span class="keyword">var</span> services = consulClient.Health.Service(<span class="string">&quot;order.service&quot;</span>, <span class="literal">null</span>, <span class="literal">true</span>, <span class="literal">null</span>).Result.Response;</span><br><span class="line">            <span class="comment">// 获取订单服务地址列表</span></span><br><span class="line">            <span class="built_in">string</span>[] serviceUrls = services.Select(p =&gt; <span class="string">$&quot;http://<span class="subst">&#123;p.Service.Address + <span class="string">&quot;:&quot;</span> + p.Service.Port&#125;</span>&quot;</span>).ToArray();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!serviceUrls.Any())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">await</span> Task.FromResult(<span class="string">&quot;【订单服务】服务列表为空&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 每次随机访问一个服务实例</span></span><br><span class="line">            <span class="keyword">var</span> client = <span class="keyword">new</span> RestClient(serviceUrls[<span class="keyword">new</span> Random().Next(<span class="number">0</span>, serviceUrls.Length)]);</span><br><span class="line">            <span class="keyword">var</span> request = <span class="keyword">new</span> RestRequest(<span class="string">&quot;/orders&quot;</span>, Method.GET);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> response = <span class="keyword">await</span> client.ExecuteAsync(request);</span><br><span class="line">            <span class="keyword">return</span> response.Content;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>appsettings.json：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;Logging&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;LogLevel&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;Default&quot;</span>: <span class="string">&quot;Information&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;Microsoft&quot;</span>: <span class="string">&quot;Warning&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;Microsoft.Hosting.Lifetime&quot;</span>: <span class="string">&quot;Information&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;AllowedHosts&quot;</span>: <span class="string">&quot;*&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;ConsulSetting&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;ConsulAddress&quot;</span>: <span class="string">&quot;http://192.168.31.191:8500&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码就完成了对服务列表的获取，浏览器访问测试一下：</p><p><img src="/images/2021-09-17-20-48-22.png" alt=""></p><p>这时候如果停止其中一个服务实例，Consul中也会同步下线，客户端也就访问不到了，但是只要三个实例活着一个就可以正常访问。虽然这里解决了服务发现的问题，但是新的问题又来了：客户端每次调用服务都需要先去Consul中获取服务地址，不仅浪费资源还增加了请求的响应时间。如何保证不要每次请求都需要去Consul 获取地址的同时又可以拿到可用的地址列表呢？Consul 提供的解决方案是：Blocking Queries （阻塞的请求）。详情见官网：<a href="https://www.consul.io/api-docs/features/blocking">Blocking Queries</a> 。</p><h1 id="Blocking-Queries">Blocking Queries</h1><p>简单来说就是当客户端请求 Consul 获取地址列表时，需要携带一个版本号信息，Consul 会比较这个客户端版本号是否和 Consul 服务端的版本号一致，如果一致，则 Consul 会阻塞这个请求，直到 Consul 中的服务列表发生变化，或者到达阻塞时间上限；如果版本号不一致，则立即返回。这个阻塞时间默认是5分钟，支持自定义。如果启动一个线程专门去做这件事，就不会影响每次的用户请求了。这样既保证了客户端服务列表的准确性，又节约了客户端请求服务列表的次数。</p><p>调整代码：</p><p>IServiceHelper.cs 增加获取服务列表的接口方法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Consul;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> Microsoft.Extensions.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> RestSharp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Concurrent;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Web.Client</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IServiceHelper</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">Task&lt;<span class="built_in">string</span>&gt; <span class="title">GetOrder</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">GetServices</span>(<span class="params"></span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ServiceHelper</span> : <span class="title">IServiceHelper</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> IConfiguration configuration;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> ConsulClient consulClient;</span><br><span class="line">        <span class="keyword">private</span> ConcurrentBag&lt;<span class="built_in">string</span>&gt; orderServiceUrls;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ServiceHelper</span>(<span class="params">IConfiguration configuration</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.configuration = configuration;</span><br><span class="line">            <span class="keyword">this</span>.consulClient = <span class="keyword">new</span> ConsulClient(c =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                c.Address = <span class="keyword">new</span> Uri(configuration[<span class="string">&quot;ConsulSetting:ConsulAddress&quot;</span>]);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;<span class="built_in">string</span>&gt; <span class="title">GetOrder</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (orderServiceUrls == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">await</span> Task.FromResult(<span class="string">&quot;【订单服务】初始化服务列表...&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> client = <span class="keyword">new</span> RestClient(orderServiceUrls.ElementAt(<span class="keyword">new</span> Random().Next(<span class="number">0</span>, orderServiceUrls.Count())));</span><br><span class="line">            <span class="keyword">var</span> request = <span class="keyword">new</span> RestRequest(<span class="string">&quot;/orders&quot;</span>, Method.GET);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> response = <span class="keyword">await</span> client.ExecuteAsync(request);</span><br><span class="line">            <span class="keyword">return</span> response.Content;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetServices</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> serviceNames = <span class="keyword">new</span> <span class="built_in">string</span>[] &#123; <span class="string">&quot;order.service&quot;</span> &#125;;</span><br><span class="line">            Array.ForEach(serviceNames, p =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                Task.Run(() =&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// WaitTime默认为5分钟</span></span><br><span class="line">                    <span class="keyword">var</span> queryOptions = <span class="keyword">new</span> QueryOptions &#123; WaitTime = TimeSpan.FromMinutes(<span class="number">10</span>) &#125;;</span><br><span class="line">                    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        GetServices(queryOptions, p);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">GetServices</span>(<span class="params">QueryOptions queryOptions, <span class="built_in">string</span> serviceName</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> res = consulClient.Health.Service(serviceName, <span class="literal">null</span>, <span class="literal">true</span>, queryOptions).Result;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 打印服务列表的响应时间等信息</span></span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;DateTime.Now&#125;</span>获取<span class="subst">&#123;serviceName&#125;</span>：queryOptions.WaitIndex：<span class="subst">&#123;queryOptions.WaitIndex&#125;</span>  LastIndex：<span class="subst">&#123;res.LastIndex&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 版本号不一致 说明服务列表发生变化</span></span><br><span class="line">            <span class="keyword">if</span> (queryOptions.WaitIndex != res.LastIndex)</span><br><span class="line">            &#123;</span><br><span class="line">                queryOptions.WaitIndex = res.LastIndex;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//服务地址列表</span></span><br><span class="line">                <span class="keyword">var</span> serviceUrls = res.Response.Select(p =&gt; <span class="string">$&quot;http://<span class="subst">&#123;p.Service.Address + <span class="string">&quot;:&quot;</span> + p.Service.Port&#125;</span>&quot;</span>).ToArray();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (serviceName == <span class="string">&quot;order.service&quot;</span>)</span><br><span class="line">                    orderServiceUrls = <span class="keyword">new</span> ConcurrentBag&lt;<span class="built_in">string</span>&gt;(serviceUrls);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/2021-09-17-21-02-33.png" alt=""></p><p>至此不需要每次都先请求服务列表，如果服务列表没有更新的话，获取列表的请求会一直阻塞直到设置的10分钟。这时候又发现新的问题：</p><ol><li>每个客户端系统都去维护服务地址是否合理</li><li>服务的IP端口直接暴露给所有客户端是否安全</li><li>该模式下怎么做到客户端的统一管理</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/microservice/1.3%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8%E4%B9%8B%E7%BD%91%E5%85%B3/"/>
      <url>/microservice/1.3%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8%E4%B9%8B%E7%BD%91%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="前言-v3">前言</h1><p>上一篇使用 Consul 完成了服务的注册与发现，实际中光有服务注册与发现往往是不够的，需要一个统一的入口来连接客户端与服务。</p><span id="more"></span><h1 id="Ocelot">Ocelot</h1><p>官网：<a href="https://ocelot.readthedocs.io">https://ocelot.readthedocs.io</a> ，Ocelot 正是为.Net微服务体系提供一个统一的入口点，称为：Gateway（网关）。</p><p>首先创建一个空的 <code>asp.net core web</code> 项目：</p><p><img src="/images/2021-09-19-04-33-35.png" alt=""></p><blockquote><p>注意：<code>ocelot.json</code> 是Ocelot的配置文件，设置生成时需要复制到输出目录。<code>ocelot.json</code> 文件名不是固定的可以自己定义</p></blockquote><p>使用 <code>NuGet</code> 安装 <code>Ocelot</code>，简单修改几处默认代码：</p><p>Program.cs：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        CreateHostBuilder(args).Build().Run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IHostBuilder <span class="title">CreateHostBuilder</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> =&gt;</span><br><span class="line">        Host.CreateDefaultBuilder(args)</span><br><span class="line">            .ConfigureAppConfiguration((hostingContext, config) =&gt;</span><br><span class="line">             &#123;</span><br><span class="line">                 config.AddJsonFile(<span class="string">&quot;ocelot.json&quot;</span>, optional: <span class="literal">false</span>, reloadOnChange: <span class="literal">true</span>);</span><br><span class="line">             &#125;)</span><br><span class="line">            .ConfigureWebHostDefaults(webBuilder =&gt;</span><br><span class="line">             &#123;</span><br><span class="line">                 webBuilder.UseStartup&lt;Startup&gt;();</span><br><span class="line">             &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Startup.cs：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 添加ocelot服务</span></span><br><span class="line">    services.AddOcelot();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This method gets called by the runtime. Use this method to configure the HTTP request pipeline.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app, IWebHostEnvironment env</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 启用Ocelot中间件</span></span><br><span class="line">    app.UseOcelot().Wait();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ocelot.json：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;Routes&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;DownstreamPathTemplate&quot;</span>: <span class="string">&quot;/orders&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;DownstreamScheme&quot;</span>: <span class="string">&quot;http&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;DownstreamHostAndPorts&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;Host&quot;</span>: <span class="string">&quot;192.168.31.191&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;Port&quot;</span>: <span class="number">80</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;Host&quot;</span>: <span class="string">&quot;192.168.31.191&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;Port&quot;</span>: <span class="number">81</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;Host&quot;</span>: <span class="string">&quot;192.168.31.191&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;Port&quot;</span>: <span class="number">82</span></span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;UpstreamPathTemplate&quot;</span>: <span class="string">&quot;/orders&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;UpstreamHttpMethod&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;Get&quot;</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;LoadBalancerOptions&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;Type&quot;</span>: <span class="string">&quot;RoundRobin&quot;</span> <span class="comment">//负载均衡，轮询机制 LeastConnection/RoundRobin/NoLoadBalancer/CookieStickySessions</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;GlobalConfiguration&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;BaseUrl&quot;</span>: <span class="string">&quot;http://localhost:5000&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里将服务实例的地址写在配置文件中。</p><p><code>Routes</code> 节点用来配置路由：</p><ul><li><code>Downstream</code> 代表下游，也就是服务实例</li><li><code>Upstream</code> 代表上游，也就是客户端。这里路径比较简单，只有 <code>/orders</code> 路径中如果有不固定参数则使用 <code>&#123;&#125;</code> 匹配。</li></ul><p>这里配置的意思是：客户端访问网关的 <code>/orders</code>，网关会转发给服务实例的 <code>/orders</code> 。注意：上游的路径不一定要和下游一致，比如上游路径可以配置成 <code>/api/orders</code>。</p><p><code>LoadBalancerOptions</code> 节点用来配置负载均衡，Ocelot 内置了 <code>LeastConnection</code> 、<code>RoundRobin</code> 、<code>NoLoadBalancer</code> 、<code>CookieStickySessions</code>  4种负载均衡策略：</p><ul><li><code>LeastConnection</code> 最少连接，跟踪哪些服务正在处理请求，并把新请求发送到现有请求最少的服务上。该算法状态不在整个Ocelot集群中分布</li><li><code>RoundRobin</code> 轮询可用的服务并发送请求。 该算法状态不在整个Ocelot集群中分布</li><li><code>NoLoadBalancer</code> 不负载均衡，从配置或服务发现提供程序中取第一个可用的下游服务</li><li><code>CookieStickySessions</code> 使用cookie关联所有相关的请求到制定的服务</li></ul><p><code>BaseUrl</code> 节点用来配置 Ocelot 网关将要运行的地址。</p><p>浏览器访问：</p><p><img src="/images/2021-09-17-21-18-20.png" alt=""></p><h1 id="客户端-v2">客户端</h1><p>上面实现通过 Ocelot 网关访问服务实例，调整客户端代码：这里选择直接新建 <code>GatewayServiceHelper</code>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> RestSharp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Web.Client</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 通过OcelotGateway调用服务</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GatewayServiceHelper</span> : <span class="title">IServiceHelper</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;<span class="built_in">string</span>&gt; <span class="title">GetOrder</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> client = <span class="keyword">new</span> RestClient(<span class="string">&quot;http://localhost:5000&quot;</span>);</span><br><span class="line">            <span class="keyword">var</span> request = <span class="keyword">new</span> RestRequest(<span class="string">&quot;/orders&quot;</span>, Method.GET);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> response = <span class="keyword">await</span> client.ExecuteAsync(request);</span><br><span class="line">            <span class="keyword">return</span> response.Content;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetServices</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NotImplementedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Startup.cs：修改注入类型</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">services.AddSingleton&lt;IServiceHelper, GatewayServiceHelper&gt;();</span><br></pre></td></tr></table></figure><p>下面获取服务地址的代码也不需要了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 程序启动时获取服务列表</span><br><span class="line">serviceHelper.GetServices();</span><br></pre></td></tr></table></figure><p>经过以上调整现在客户端对服务的调用都通过网关进行中转，客户端不再关心服务实例的地址，只需要知道网关地址就可以。另外服务端也避免了服务地址直接暴露给客户端。这样做对客户端，服务都非常友好。但是又出现了一个新的问题：目前服务地址写在 <code>ocelot.json</code> 配置文件中，一旦服务变化，需要人为的修改配置文件，这又显得不太合理。这里比较常用的方案是：结合Consul来实现服务发现。</p><h1 id="服务发现">服务发现</h1><p><code>NuGet</code> 安装<code>Ocelot.Provider.Consul</code>后，修改Startup.cs：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 添加Ocelot服务并添加Consul支持</span></span><br><span class="line">    services.AddOcelot().AddConsul();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改ocelot.json配置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;Routes&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;DownstreamPathTemplate&quot;</span>: <span class="string">&quot;/orders&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;DownstreamScheme&quot;</span>: <span class="string">&quot;http&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;UpstreamPathTemplate&quot;</span>: <span class="string">&quot;/orders&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;UpstreamHttpMethod&quot;</span>: [ <span class="string">&quot;Get&quot;</span> ],</span><br><span class="line">      <span class="attr">&quot;ServiceName&quot;</span>: <span class="string">&quot;order.service&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;LoadBalancerOptions&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;Type&quot;</span>: <span class="string">&quot;RoundRobin&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;GlobalConfiguration&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;BaseUrl&quot;</span>: <span class="string">&quot;http://localhost:5000&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;ServiceDiscoveryProvider&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;Scheme&quot;</span>: <span class="string">&quot;http&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;Host&quot;</span>: <span class="string">&quot;192.168.31.191&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;Port&quot;</span>: <span class="number">8500</span>,</span><br><span class="line">      <span class="attr">&quot;Type&quot;</span>: <span class="string">&quot;Consul&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个配置很好理解，就是把 <code>DownstreamHostAndPorts</code> 节点去掉然后增加了 <code>ServiceDiscoveryProvider</code> 服务发现相关配置。</p><blockquote><p>注意，Ocelot 除了支持 Consul 服务发现以外，还有 Eureka 也可以，Eureka 也是一个类似的注册中心</p></blockquote><p>浏览器测试：</p><p><img src="/images/2021-09-17-21-35-46.png" alt=""></p><p>至此就实现了服务注册与发现和api网关的基本功能。接下来就要提到：服务治理。</p><h1 id="服务治理">服务治理</h1><p>服务治理没有非常明确的定义。它的作用简单来说，就是帮我们更好的管理服务，提升服务的可用性。缓存、限流、熔断、链路追踪等等都属于常用的服务治理手段。之前讲的负载均衡，服务发现也可以算是服务治理。</p><h2 id="缓存">缓存</h2><p>在 Ocelot 中启用缓存，需要<code>NuGet</code> 安装<code>Ocelot.Cache.CacheManager</code>，修改<code>Startup.cs</code> 中的 <code>ConfigureServices()</code> 方法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    services.AddOcelot()</span><br><span class="line">            .AddConsul()</span><br><span class="line">            .AddCacheManager(p =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                p.WithDictionaryHandle();</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 <code>ocelot.json</code> 配置文件：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;Routes&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;DownstreamPathTemplate&quot;</span>: <span class="string">&quot;/orders&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;DownstreamScheme&quot;</span>: <span class="string">&quot;http&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;UpstreamPathTemplate&quot;</span>: <span class="string">&quot;/orders&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;UpstreamHttpMethod&quot;</span>: [ <span class="string">&quot;Get&quot;</span> ],</span><br><span class="line">      <span class="attr">&quot;ServiceName&quot;</span>: <span class="string">&quot;order.service&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;LoadBalancerOptions&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;Type&quot;</span>: <span class="string">&quot;RoundRobin&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 缓存</span></span><br><span class="line">      <span class="attr">&quot;FileCacheOptions&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;TtlSeconds&quot;</span>: <span class="number">5</span>,</span><br><span class="line">        <span class="attr">&quot;Region&quot;</span>: <span class="string">&quot;regionname&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;GlobalConfiguration&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;BaseUrl&quot;</span>: <span class="string">&quot;http://localhost:5000&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;ServiceDiscoveryProvider&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;Scheme&quot;</span>: <span class="string">&quot;http&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;Host&quot;</span>: <span class="string">&quot;192.168.31.191&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;Port&quot;</span>: <span class="number">8500</span>,</span><br><span class="line">      <span class="attr">&quot;Type&quot;</span>: <span class="string">&quot;Consul&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Routes 路由配置中增加 <code>FileCacheOptions</code>：</p><ul><li><code>TtlSeconds</code> 缓存的过期时间</li><li><code>Region</code> 缓冲区名称，目前用不到</li></ul><p>代码修改完编译重启一下网关项目，然后打开浏览器测试会发现5秒之内的请求都是同样的缓存数据。Ocelot也支持自定义缓存。</p><h2 id="限流">限流</h2><p>限流就是限制客户端一定时间内的请求次数。</p><p>修改 <code>ocelot.json</code> 配置文件：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;Routes&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;DownstreamPathTemplate&quot;</span>: <span class="string">&quot;/orders&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;DownstreamScheme&quot;</span>: <span class="string">&quot;http&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;UpstreamPathTemplate&quot;</span>: <span class="string">&quot;/orders&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;UpstreamHttpMethod&quot;</span>: [ <span class="string">&quot;Get&quot;</span> ],</span><br><span class="line">      <span class="attr">&quot;ServiceName&quot;</span>: <span class="string">&quot;order.service&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;LoadBalancerOptions&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;Type&quot;</span>: <span class="string">&quot;RoundRobin&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 缓存</span></span><br><span class="line">      <span class="attr">&quot;FileCacheOptions&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;TtlSeconds&quot;</span>: <span class="number">5</span>,</span><br><span class="line">        <span class="attr">&quot;Region&quot;</span>: <span class="string">&quot;regionname&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 限流</span></span><br><span class="line">      <span class="attr">&quot;RateLimitOptions&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;ClientWhitelist&quot;</span>: [ <span class="string">&quot;SuperClient&quot;</span> ],</span><br><span class="line">        <span class="attr">&quot;EnableRateLimiting&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">&quot;Period&quot;</span>: <span class="string">&quot;2s&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;PeriodTimespan&quot;</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">&quot;Limit&quot;</span>: <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;GlobalConfiguration&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;BaseUrl&quot;</span>: <span class="string">&quot;http://localhost:5000&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;ServiceDiscoveryProvider&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;Scheme&quot;</span>: <span class="string">&quot;http&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;Host&quot;</span>: <span class="string">&quot;192.168.31.191&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;Port&quot;</span>: <span class="number">8500</span>,</span><br><span class="line">      <span class="attr">&quot;Type&quot;</span>: <span class="string">&quot;Consul&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;RateLimitOptions&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;DisableRateLimitHeaders&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;QuotaExceededMessage&quot;</span>: <span class="string">&quot;too many requests...&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;HttpStatusCode&quot;</span>: <span class="number">999</span>,</span><br><span class="line">      <span class="attr">&quot;ClientIdHeader&quot;</span>: <span class="string">&quot;Test&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Routes 路由配置中增加 <code>RateLimitOptions</code> ：</p><ul><li><code>ClientWhitelist</code> 客户端白名单（白名单中的客户端不受限流影响）</li><li><code>EnableRateLimiting</code> 是否限流</li><li><code>Period</code> 限流的单位时间，例如1s、5m、1h、1d等</li><li><code>PeriodTimespan</code> 客户端达到请求上限多少秒后可以重试</li><li><code>Limit</code> 客户端在定义的时间内可以发出的最大请求数</li></ul><p>在 GlobalConfiguration  配置中也增加 <code>RateLimitOptions</code>：</p><ul><li><code>DisableRateLimitHeaders</code> 是否禁用 <code>X-Rate-Limit</code> 和 <code>Retry-After</code> 标头（请求达到上限时response header中的限制数和多少秒后能重试）</li><li><code>QuotaExceededMessage</code> ：请求达到上限时返回给客户端的消息</li><li><code>HttpStatusCode</code> ：请求达到上限时返回给客户端的 <code>HTTP状态码</code></li><li><code>ClientIdHeader</code> 可以允许自定义用于标识客户端的标头。默认情况下为 <code>ClientId</code></li></ul><p>代码修改完编译重启一下网关项目，然后打开浏览器测试会发现限制已经生效。</p><h2 id="超时-熔断">超时/熔断</h2><ul><li>超时：网关请求服务时可容忍的最长响应时间</li><li>熔断：当请求某个服务的异常次数达到一定量时，网关在一定时间内就不再对这个服务发起请求直接熔断</li></ul><p>在 Ocelot 中启用超时/熔断，需要 <code>NuGet</code> 安装<code>Ocelot.Provider.Polly</code>，修改<code>Startup.cs</code> 中的 <code>ConfigureServices()</code> 方法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    services.AddOcelot()</span><br><span class="line">            .AddConsul()</span><br><span class="line">            .AddCacheManager(p =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                p.WithDictionaryHandle();</span><br><span class="line">            &#125;).AddPolly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 <code>ocelot.json</code> 配置文件：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;Routes&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;DownstreamPathTemplate&quot;</span>: <span class="string">&quot;/orders&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;DownstreamScheme&quot;</span>: <span class="string">&quot;http&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;UpstreamPathTemplate&quot;</span>: <span class="string">&quot;/orders&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;UpstreamHttpMethod&quot;</span>: [ <span class="string">&quot;Get&quot;</span> ],</span><br><span class="line">      <span class="attr">&quot;ServiceName&quot;</span>: <span class="string">&quot;order.service&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;LoadBalancerOptions&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;Type&quot;</span>: <span class="string">&quot;RoundRobin&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 缓存</span></span><br><span class="line">      <span class="attr">&quot;FileCacheOptions&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;TtlSeconds&quot;</span>: <span class="number">5</span>,</span><br><span class="line">        <span class="attr">&quot;Region&quot;</span>: <span class="string">&quot;regionname&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 限流</span></span><br><span class="line">      <span class="attr">&quot;RateLimitOptions&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;ClientWhitelist&quot;</span>: [ <span class="string">&quot;SuperClient&quot;</span> ],</span><br><span class="line">        <span class="attr">&quot;EnableRateLimiting&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">&quot;Period&quot;</span>: <span class="string">&quot;2s&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;PeriodTimespan&quot;</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">&quot;Limit&quot;</span>: <span class="number">1</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 超时熔断</span></span><br><span class="line">      <span class="attr">&quot;QoSOptions&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;ExceptionsAllowedBeforeBreaking&quot;</span>: <span class="number">3</span>,</span><br><span class="line">        <span class="attr">&quot;DurationOfBreak&quot;</span>: <span class="number">10000</span>,</span><br><span class="line">        <span class="attr">&quot;TimeoutValue&quot;</span>: <span class="number">5000</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;GlobalConfiguration&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;BaseUrl&quot;</span>: <span class="string">&quot;http://localhost:5000&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;ServiceDiscoveryProvider&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;Scheme&quot;</span>: <span class="string">&quot;http&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;Host&quot;</span>: <span class="string">&quot;192.168.201.191&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;Port&quot;</span>: <span class="number">8500</span>,</span><br><span class="line">      <span class="attr">&quot;Type&quot;</span>: <span class="string">&quot;Consul&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;RateLimitOptions&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;DisableRateLimitHeaders&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;QuotaExceededMessage&quot;</span>: <span class="string">&quot;too many requests...&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;HttpStatusCode&quot;</span>: <span class="number">999</span>,</span><br><span class="line">      <span class="attr">&quot;ClientIdHeader&quot;</span>: <span class="string">&quot;Test&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>ExceptionsAllowedBeforeBreaking</code> 发生错误的次数</li><li><code>DurationOfBreak</code> 熔断时间</li><li><code>TimeoutValue</code> 超时时间</li></ul><p>以上配置意思是当请求服务发生3次错误时，就熔断10秒，期间客户端的请求直接返回错误，10秒后恢复。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/microservice/1.5%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8%E4%B9%8BDockerCompose/"/>
      <url>/microservice/1.5%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8%E4%B9%8BDockerCompose/</url>
      
        <content type="html"><![CDATA[<h1 id="前言-v4">前言</h1><p>上一篇中使用 CAP 完成了一个简单的 <code>Eventbus</code>，实现了服务之间的解耦和异步调用，并且做到数据的最终一致性。搞到这里系统环境已经比较复杂了，想把整个系统运行起来会非常繁琐：要运行 Consul、订单服务、产品服务、网关、<s>鉴权中心</s>、RabbitMQ，本篇将使用 <code>Docker Compose</code> 来解决以上问题，仅需一个简单的命令，即可启动整个环境。</p><span id="more"></span><h1 id="Docker-Compose">Docker Compose</h1><p>什么是Docker Compose？</p><blockquote><p>Compose 是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose可以使用 YML 文件来配置应用程序需要的所有服务。然后，使用一个命令，就可以从 YML 文件配置中创建并启动所有服务</p></blockquote><p>简单来理解，Compose类似一个批量工具，可以执行一组命令，支持批量构建镜像，批量启动容器，批量删除容器等等功能。Windows的 Docker Desktop 中已经包括了 Compose，Linux下 Compose 则需要单独安装。关于 Compose 更多信息参考 <a href="https://wpl.wiki/docker/1.9Docker%E4%B8%89%E5%89%91%E5%AE%A2%E4%B9%8BDockerCompose">【Docker三剑客之DockerCompose】</a>。</p><h1 id="yml-file">yml file</h1><p>yml 文件是使用 Compose 必不可少的，在编写 yml 文件之前需要准备Dockerfile。之前的章节中，网关服务不是在 Docker 中运行的，现在全部放到Docker中。确保解决方案中每个项目都添加Docker支持。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># See https://aka.ms/containerfastmode to understand how Visual Studio uses this Dockerfile to build your images for faster debugging.</span></span><br><span class="line"><span class="comment"># 基于 `mcr.microsoft.com/dotnet/aspnet:5.0 AS base` 来构建镜像</span></span><br><span class="line"><span class="keyword">FROM</span> mcr.microsoft.com/dotnet/aspnet:<span class="number">5.0</span> AS base</span><br><span class="line"><span class="comment"># 设置工作目录,如不存在会被创建</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="comment"># Copy release文件夹内容到工作目录app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . /app</span></span><br><span class="line"><span class="comment"># 运行.dll</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;dotnet&quot;</span>, <span class="string">&quot;Ocelot.Geteway.dll&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>新建 <code>docker-compose.yml</code> 文件，以下是 <code>docker-compose.yml</code>文件内容：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&#x27;3.4&#x27;</span></span><br><span class="line">services:</span><br><span class="line">    apigateway: </span><br><span class="line">        image: gateway</span><br><span class="line">        build: </span><br><span class="line">            context: .</span><br><span class="line">            dockerfile: ./gateway.release/Dockerfile</span><br><span class="line">        ports: </span><br><span class="line">            - <span class="string">&#x27;8080:8080&#x27;</span></span><br><span class="line">        environment: </span><br><span class="line">            - ASPNETCORE_URLS=http://+:<span class="number">8080</span></span><br><span class="line">        networks:</span><br><span class="line">            - my-testnet</span><br><span class="line">        depends_on: </span><br><span class="line">            - orderapi1</span><br><span class="line">            - orderapi2</span><br><span class="line">            - orderapi3</span><br><span class="line">            - productapi1</span><br><span class="line">            - productapi2</span><br><span class="line">            - productapi3</span><br><span class="line"></span><br><span class="line">    orderapi1:</span><br><span class="line">        image: order.api</span><br><span class="line">        build: </span><br><span class="line">            context: .</span><br><span class="line">            dockerfile: ./order.api.release/Dockerfile</span><br><span class="line">        ports: </span><br><span class="line">            - <span class="number">80</span>:<span class="number">80</span></span><br><span class="line">        environment:</span><br><span class="line">            - ASPNETCORE_URLS=http://+:<span class="number">80</span> </span><br><span class="line">            - ConsulSetting:ServiceIP=<span class="number">80</span></span><br><span class="line">            - ConsulSetting:ServicePort=<span class="number">80</span></span><br><span class="line">        networks: </span><br><span class="line">            - my-testnet</span><br><span class="line">        depends_on: </span><br><span class="line">            - consul</span><br><span class="line">            - rabbitmq</span><br><span class="line">    orderapi2:</span><br><span class="line">        image: order.api</span><br><span class="line">        ports: </span><br><span class="line">            - <span class="string">&#x27;81:80&#x27;</span></span><br><span class="line">        environment: </span><br><span class="line">            - ASPNETCORE_URLS=http://+:<span class="number">81</span></span><br><span class="line">            - ConsulSetting:ServiceIP=orderapi2</span><br><span class="line">            - ConsulSetting:ServicePort=<span class="number">81</span></span><br><span class="line">        networks: </span><br><span class="line">            - my-testnet</span><br><span class="line">        depends_on: </span><br><span class="line">            - orderapi1</span><br><span class="line">    orderapi3:</span><br><span class="line">        image: order.api</span><br><span class="line">        ports: </span><br><span class="line">            - <span class="string">&#x27;82:80&#x27;</span></span><br><span class="line">        environment: </span><br><span class="line">            - ASPNETCORE_URLS=http://+:<span class="number">82</span></span><br><span class="line">            - ConsulSetting:ServiceIP=orderapi3</span><br><span class="line">            - ConsulSetting:ServicePort=<span class="number">82</span></span><br><span class="line">        networks: </span><br><span class="line">            - my-testnet</span><br><span class="line">        depends_on: </span><br><span class="line">            - orderapi1</span><br><span class="line"></span><br><span class="line">    productapi1: </span><br><span class="line">        image: product.api </span><br><span class="line">        build: </span><br><span class="line">            context: .</span><br><span class="line">            dockerfile: ./product.api.release/Dockerfile</span><br><span class="line">        ports: </span><br><span class="line">            - <span class="string">&#x27;85:80&#x27;</span></span><br><span class="line">        environment: </span><br><span class="line">            - ASPNETCORE_URLS=http://+:<span class="number">85</span></span><br><span class="line">            - ConsulSetting:ServiceIP=productapi1 </span><br><span class="line">            - ConsulSetting:ServicePort=<span class="number">85</span></span><br><span class="line">        networks: </span><br><span class="line">            - my-testnet</span><br><span class="line">        depends_on: </span><br><span class="line">            - consul</span><br><span class="line">            - rabbitmq</span><br><span class="line">    productapi2:</span><br><span class="line">        image: product.api</span><br><span class="line">        ports: </span><br><span class="line">            - <span class="string">&#x27;86:80&#x27;</span></span><br><span class="line">        environment: </span><br><span class="line">            - ASPNETCORE_URLS=http://+:<span class="number">86</span></span><br><span class="line">            - ConsulSetting:ServiceIP=productapi2</span><br><span class="line">            - ConsulSetting:ServicePort=<span class="number">86</span></span><br><span class="line">        networks: </span><br><span class="line">            - my-testnet</span><br><span class="line">        depends_on: </span><br><span class="line">            - productapi1</span><br><span class="line">    productapi3:</span><br><span class="line">        image: product.api</span><br><span class="line">        ports: </span><br><span class="line">            - <span class="string">&#x27;87:80&#x27;</span></span><br><span class="line">        environment: </span><br><span class="line">            - ASPNETCORE_URLS=http://+:<span class="number">87</span></span><br><span class="line">            - ConsulSetting:ServiceIP=productapi3 </span><br><span class="line">            - ConsulSetting:ServicePort=<span class="number">87</span></span><br><span class="line">        networks: </span><br><span class="line">            - my-testnet</span><br><span class="line">        depends_on: </span><br><span class="line">            - productapi1</span><br><span class="line">    </span><br><span class="line">    consul:</span><br><span class="line">        image: consul</span><br><span class="line">        container_name: consul</span><br><span class="line">        ports: </span><br><span class="line">            - <span class="string">&#x27;8500:8500&#x27;</span></span><br><span class="line">        networks: </span><br><span class="line">            - my-testnet</span><br><span class="line"></span><br><span class="line">    rabbitmq:</span><br><span class="line">        image: rabbitmq:<span class="number">3.9</span>.<span class="number">5</span>-management </span><br><span class="line">        container_name: rabbitmq</span><br><span class="line">        ports:</span><br><span class="line">            - <span class="number">15672</span>:<span class="number">15672</span></span><br><span class="line">            - <span class="number">5672</span>:<span class="number">5672</span></span><br><span class="line">        networks: </span><br><span class="line">            - my-testnet</span><br><span class="line"></span><br><span class="line">networks: </span><br><span class="line">    my-testnet: </span><br><span class="line">        driver: bridge</span><br></pre></td></tr></table></figure><p>以上 <code>yml</code> 文件定义了网关服务、订单服务、产品服务、Consul，rabbitMQ 9个服务（容器），和一个容器网络 <code>my-testnet</code>。这里 <code>product.api</code>和 <code>order.api</code> 是基于同样的镜像各运行了3个容器，真实开发中他们应该分布在多个docker主机中。将 <code>yml</code>文件扔到虚机目录中（这里为了快速测试，真实不会这么搞）。</p><p><img src="/images/2021-09-19-04-36-38.png" alt=""></p><h1 id="容器网络">容器网络</h1><p>之前容器之间通讯是通过容器的IP访问，虽然是可以访问但不友好。更好的方式是：自定义一个bridge网络，将所有服务（容器）加入这个网络中，那么容器之间就可以直接通过服务名称通信了。（这里暂时没这么做）bridge 模式只是docker网络模式中的一种，更多信息参考：<a href="https://wpl.wiki/docker/1.7Docker%E9%AB%98%E7%BA%A7%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE#%E5%AE%B9%E5%99%A8%E8%B7%A8%E7%BD%91%E6%A1%A5%E9%80%9A%E4%BF%A1">【Docker高级网络配置#容器跨网桥通信】</a>。</p><h1 id="构建与启动">构建与启动</h1><p>完成以上操作后，进入虚机目录执行<code>docker-compose up -d</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-01 dotnetcore_src]<span class="comment"># docker-compose up -d</span></span><br><span class="line">Creating rabbitmq ... </span><br><span class="line">Creating consul ... </span><br><span class="line">Creating rabbitmq</span><br><span class="line">Creating rabbitmq ... <span class="keyword">done</span></span><br><span class="line">Creating dotnetcoresrc_productapi1_1 ... </span><br><span class="line">Creating dotnetcoresrc_orderapi1_1 ... </span><br><span class="line">Creating dotnetcoresrc_productapi1_1</span><br><span class="line">Creating dotnetcoresrc_orderapi1_1 ... <span class="keyword">done</span></span><br><span class="line">Creating dotnetcoresrc_productapi1_1 ... <span class="keyword">done</span></span><br><span class="line">Creating dotnetcoresrc_orderapi2_1 ... </span><br><span class="line">Creating dotnetcoresrc_productapi3_1 ... </span><br><span class="line">Creating dotnetcoresrc_orderapi3_1</span><br><span class="line">Creating dotnetcoresrc_productapi2_1 ... </span><br><span class="line">Creating dotnetcoresrc_productapi3_1</span><br><span class="line">Creating dotnetcoresrc_orderapi2_1</span><br><span class="line">Creating dotnetcoresrc_orderapi3_1 ... <span class="keyword">done</span></span><br><span class="line">Creating dotnetcoresrc_apigateway_1 ... </span><br><span class="line">Creating dotnetcoresrc_apigateway_1 ... <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@centos-01 dotnetcore_src]<span class="comment"># docker ps -a</span></span><br><span class="line">CONTAINER ID   IMAGE                       COMMAND                  CREATED         STATUS         PORTS                                                                                                                                                 NAMES</span><br><span class="line">82e1221c03b5   gateway                     <span class="string">&quot;dotnet Ocelot.Gatew…&quot;</span>   6 seconds ago   Up 5 seconds   0.0.0.0:8080-&gt;8080/tcp, :::8080-&gt;8080/tcp                                                                                                             dotnetcoresrc_apigateway_1</span><br><span class="line">90a760680cba   product.api                 <span class="string">&quot;dotnet Product.Api.…&quot;</span>   7 seconds ago   Up 6 seconds   0.0.0.0:86-&gt;80/tcp, :::86-&gt;80/tcp                                                                                                                     dotnetcoresrc_productapi2_1</span><br><span class="line">352c6bce65e6   product.api                 <span class="string">&quot;dotnet Product.Api.…&quot;</span>   7 seconds ago   Up 6 seconds   0.0.0.0:87-&gt;80/tcp, :::87-&gt;80/tcp                                                                                                                     dotnetcoresrc_productapi3_1</span><br><span class="line">eafce74e7582   order.api                   <span class="string">&quot;dotnet Order.Api.dll&quot;</span>   7 seconds ago   Up 6 seconds   0.0.0.0:81-&gt;80/tcp, :::81-&gt;80/tcp                                                                                                                     dotnetcoresrc_orderapi2_1</span><br><span class="line">6b9c45e89c55   order.api                   <span class="string">&quot;dotnet Order.Api.dll&quot;</span>   7 seconds ago   Up 6 seconds   0.0.0.0:82-&gt;80/tcp, :::82-&gt;80/tcp                                                                                                                     dotnetcoresrc_orderapi3_1</span><br><span class="line">2acb5ed6125e   order.api                   <span class="string">&quot;dotnet Order.Api.dll&quot;</span>   8 seconds ago   Up 7 seconds   0.0.0.0:80-&gt;80/tcp, :::80-&gt;80/tcp                                                                                                                     dotnetcoresrc_orderapi1_1</span><br><span class="line">e9c6a88e6a72   product.api                 <span class="string">&quot;dotnet Product.Api.…&quot;</span>   8 seconds ago   Up 7 seconds   0.0.0.0:85-&gt;80/tcp, :::85-&gt;80/tcp                                                                                                                     dotnetcoresrc_productapi1_1</span><br><span class="line">84b03969229f   consul                      <span class="string">&quot;docker-entrypoint.s…&quot;</span>   9 seconds ago   Up 8 seconds   8300-8302/tcp, 8301-8302/udp, 8600/tcp, 8600/udp, 0.0.0.0:8500-&gt;8500/tcp, :::8500-&gt;8500/tcp                                                           consul</span><br><span class="line">aff9066b3ff0   rabbitmq:3.9.5-management   <span class="string">&quot;docker-entrypoint.s…&quot;</span>   9 seconds ago   Up 8 seconds   4369/tcp, 5671/tcp, 0.0.0.0:5672-&gt;5672/tcp, :::5672-&gt;5672/tcp, 15671/tcp, 15691-15692/tcp, 25672/tcp, 0.0.0.0:15672-&gt;15672/tcp, :::15672-&gt;15672/tcp   rabbitmq</span><br><span class="line">[root@centos-01 dotnetcore_src]<span class="comment"># </span></span><br></pre></td></tr></table></figure><p>浏览器访问网关测试：</p><p><img src="/images/2021-09-19-16-52-59.png" alt=""></p><p>Postman调用下单接口：<br><img src="/images/2021-09-19-16-54-27.png" alt=""></p><p>查看数据库：<br><img src="/images/2021-09-19-16-55-07.png" alt=""></p><p>至此就完成了使用 <code>docker-compose</code> 一键启动整个环境，想要摧毁这个环境也很简单，只需要一句 <code>docker-compose down</code>。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/microservice/1.4%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8%E4%B9%8B%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF/"/>
      <url>/microservice/1.4%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8%E4%B9%8B%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="前言-v5">前言</h1><p>上一篇中已经完成了 Ocelot + Consul 的搭建，这篇简单说一下事件总线（<code>EventBus</code>)。</p><span id="more"></span><h1 id="事件总线">事件总线</h1><p>什么是事件总线？</p><blockquote><p>事件总线是对观察者（发布-订阅）模式的一种实现。它是一种集中式事件处理机制，允许不同的组件之间进行彼此通信而又不需要相互依赖，达到解耦的目的</p></blockquote><p>为什么要使用事件总线？</p><blockquote><ol><li>以当前项目举例，假设有一个订单服务，一个产品服务。客户端有一个下单功能，下单时调用订单服务的下单接口，下单接口需要调用产品服务的减库存接口，这涉及到服务与服务之间的调用。服务之间调用可以选择 <code>RestAPI</code> 或者效率更高的 <code>gRPC</code>。可能这两者各有各的使用场景，但是它们都存在服务之间的耦合问题，或者难以做到异步调用</li><li>假设下单调用订单服务，订单服务需要调用产品服务，产品服务又要调用物流服务，物流服务再去调用xx服务等等，如果每个服务处理时间需要2s，不使用异步处理的话，响应时间可想而知。如果使用EventBus的话，那么订单服务只需要向EventBus发一个“下单事件”就可以了。产品服务会订阅“下单事件”，当产品服务收到下单事件时，自己去减库存。这样就避免了两个服务之间直接调用的耦合性，并且真正做到了异步调用</li></ol></blockquote><p>既然涉及到多个服务之间的异步调用，那么就不得不提分布式事务。分布式事务并不是微服务独有的问题，而是所有的分布式系统都会存在的问题。关于分布式事务，可以查一下 “CAP原则” 和 “BASE理论” 了解更多。如今分布式系统更多时候会追求事务的最终一致性。</p><p>下面使用开源框架 <code>CAP</code>来演示 <code>EventBus</code> 的基本使用。之所以使用 <code>CAP</code> 是因为它既能解决分布式系统的最终一致性，同时又是一个 <code>EventBus</code>，它具备<code>EventBus</code> 的所有功能。<a href="https://www.cnblogs.com/savorboard/p/cap.html">点击了解更多</a>。</p><h1 id="CAP">CAP</h1><p>目前 CAP 支持使用 <code>RabbitMQ</code> ，<code>Kafka</code>，<code>Azure Service Bus</code> 等进行底层之间的消息发送，不需要具备这些消息队列的使用经验就可以轻松的集成到项目中。CAP 目前支持使用 <code>Sql Server</code>，<code>MySql</code>，<code>PostgreSql</code>，<code>MongoDB</code> 数据库的项目。这里选择：消息组件使用 <code>RabbitMq</code>，数据库存储使用 <code>SqlServer</code>。</p><p><code>Nuget</code> 安装 :</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Microsoft.EntityFrameworkCore</span><br><span class="line">Microsoft.EntityFrameworkCore.Tools</span><br><span class="line">Microsoft.EntityFrameworkCore.SqlServer</span><br><span class="line">DotNetCore.CAP</span><br><span class="line">DotNetCore.CAP.RabbitMQ</span><br><span class="line">DotNetCore.CAP.SqlServer</span><br></pre></td></tr></table></figure><h1 id="Product-Api">Product.Api</h1><p>新增 <code>Product.Api</code> 作为产品服务，代码结构与 <code>Order.Api</code> 结构类似：</p><p><img src="/images/2021-09-19-01-07-00.png" alt=""></p><h2 id="ProductsController-cs">ProductsController.cs</h2><p>增加减库存接口：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> DotNetCore.CAP;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Mvc;</span><br><span class="line"><span class="keyword">using</span> Microsoft.EntityFrameworkCore;</span><br><span class="line"><span class="keyword">using</span> Microsoft.Extensions.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> Newtonsoft.Json;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> Product.Api.Models;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Product.Api.Controller</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Route(<span class="meta-string">&quot;[Controller]&quot;</span>)</span>]</span><br><span class="line">    [<span class="meta">ApiController</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ProductsController</span> : <span class="title">ControllerBase</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> IConfiguration configuration;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> ICapPublisher capBus;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> ProductContext context;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ProductsController</span>(<span class="params">IConfiguration configuration, ICapPublisher capBus, ProductContext context</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.configuration = configuration;</span><br><span class="line">            <span class="keyword">this</span>.capBus = capBus;</span><br><span class="line">            <span class="keyword">this</span>.context = context;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">HttpGet</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> IActionResult <span class="title">Index</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> result = <span class="string">$&quot;产品服务：<span class="subst">&#123;DateTime.Now:yyyy-MM-dd HH:mm:ss&#125;</span>,-<span class="subst">&#123;Request.HttpContext.Connection.LocalIpAddress&#125;</span>:<span class="subst">&#123;configuration[<span class="string">&quot;ConsulSetting:ServicePort&quot;</span>]&#125;</span>&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> Ok(result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 减库存 订阅下单事件</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;message&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        [<span class="meta">NonAction</span>]</span><br><span class="line">        [<span class="meta">CapSubscribe(<span class="meta-string">&quot;order.services.createorder&quot;</span>)</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">ReduceStock</span>(<span class="params">CreateOrderMessageDto message</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;message:&quot;</span> + JsonConvert.SerializeObject(message));</span><br><span class="line">            <span class="keyword">var</span> product = <span class="keyword">await</span> context.Products.FirstOrDefaultAsync(p =&gt; p.ID == message.ProductID);</span><br><span class="line">            product.Stock -= message.Count;</span><br><span class="line">            <span class="keyword">await</span> context.SaveChangesAsync();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CreateOrderMessageDto-cs">CreateOrderMessageDto.cs</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Product.Api.Models</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 下单事件消息</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CreateOrderMessageDto</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 产品ID</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> ProductID &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 购买数量</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Count &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Product-cs">Product.cs</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.ComponentModel.DataAnnotations;</span><br><span class="line"><span class="keyword">using</span> System.ComponentModel.DataAnnotations.Schema;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Product.Api.Models</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Product</span></span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="meta">Key</span>]</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> ID &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 产品名称</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        [<span class="meta">Required</span>]</span><br><span class="line">        [<span class="meta">Column(TypeName = <span class="meta-string">&quot;VARCHAR(16)&quot;</span>)</span>]</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 库存</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        [<span class="meta">Required</span>]</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Stock &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ProductContext-cs">ProductContext.cs</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Microsoft.EntityFrameworkCore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Product.Api</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ProductContext</span> : <span class="title">DbContext</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ProductContext</span>(<span class="params">DbContextOptions&lt;ProductContext&gt; options</span>)</span></span><br><span class="line"><span class="function">           : <span class="title">base</span>(<span class="params">options</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> DbSet&lt;Models.Product&gt; Products &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//初始化种子数据</span></span><br><span class="line">            modelBuilder.Entity&lt;Models.Product&gt;().HasData(<span class="keyword">new</span> Models.Product</span><br><span class="line">            &#123;</span><br><span class="line">                ID = <span class="number">1</span>,</span><br><span class="line">                Name = <span class="string">&quot;ThinkPad&quot;</span>,</span><br><span class="line">                Stock = <span class="number">100</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">new</span> Models.Product</span><br><span class="line">            &#123;</span><br><span class="line">                ID = <span class="number">2</span>,</span><br><span class="line">                Name = <span class="string">&quot;Mac&quot;</span>,</span><br><span class="line">                Stock = <span class="number">100</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="appsettings-json-v2">appsettings.json</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;Logging&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;LogLevel&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;Default&quot;</span>: <span class="string">&quot;Information&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;Microsoft&quot;</span>: <span class="string">&quot;Warning&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;Microsoft.Hosting.Lifetime&quot;</span>: <span class="string">&quot;Information&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;AllowedHosts&quot;</span>: <span class="string">&quot;*&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;ConsulSetting&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;ServiceName&quot;</span>: <span class="string">&quot;product.service&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;ServiceIP&quot;</span>: <span class="string">&quot;192.168.31.191&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;ServiceHealthCheck&quot;</span>: <span class="string">&quot;/healthcheck&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;ConsulAddress&quot;</span>: <span class="string">&quot;http://192.168.31.191:8500&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;ConnectionString&quot;</span>: <span class="string">&quot;Server=192.168.31.210;Database=Microservice.Sample.Product;user id=sa;password=wpl19950815;MultipleActiveResultSets=true&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Startup-cs">Startup.cs</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void ConfigureServices(IServiceCollection services)</span><br><span class="line">&#123;</span><br><span class="line">    services<span class="selector-class">.AddControllers</span>();</span><br><span class="line"></span><br><span class="line">    services<span class="selector-class">.AddDbContext</span>&lt;ProductContext&gt;(opt =&gt; opt<span class="selector-class">.UseSqlServer</span>(Configuration<span class="selector-attr">[<span class="string">&quot;ConnectionString&quot;</span>]</span>));</span><br><span class="line"></span><br><span class="line">    services<span class="selector-class">.AddCap</span>(x =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        x<span class="selector-class">.UseEntityFramework</span>&lt;ProductContext&gt;()<span class="selector-class">.UseRabbitMQ</span>(option =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            option<span class="selector-class">.HostName</span> = &quot;<span class="number">192.168</span>.<span class="number">31.191</span>&quot;;</span><br><span class="line">            option<span class="selector-class">.UserName</span> = &quot;guest&quot;;</span><br><span class="line">            option<span class="selector-class">.Password</span> = &quot;guest&quot;;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Order-Api">Order.Api</h1><h2 id="OrdersController-cs">OrdersController.cs</h2><p>增加下单接口：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> DotNetCore.CAP;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Mvc;</span><br><span class="line"><span class="keyword">using</span> Microsoft.Extensions.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> Order.Api.Models;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Order.Api.Controller</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Route(<span class="meta-string">&quot;[Controller]&quot;</span>)</span>]</span><br><span class="line">    [<span class="meta">ApiController</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OrdersController</span> : <span class="title">ControllerBase</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> IConfiguration configuration;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> ICapPublisher capBus;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> OrderContext context;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">OrdersController</span>(<span class="params">IConfiguration configuration, ICapPublisher capBus, OrderContext context</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.configuration = configuration;</span><br><span class="line">            <span class="keyword">this</span>.capBus = capBus;</span><br><span class="line">            <span class="keyword">this</span>.context = context;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">HttpGet</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> IActionResult <span class="title">Index</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> result = <span class="string">$&quot;订单服务：<span class="subst">&#123;DateTime.Now:yyyy-MM-dd HH:mm:ss&#125;</span>,-<span class="subst">&#123;Request.HttpContext.Connection.LocalIpAddress&#125;</span>:<span class="subst">&#123;configuration[<span class="string">&quot;ConsulSetting:ServicePort&quot;</span>]&#125;</span>&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> Ok(result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 创建订单</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;order&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        [<span class="meta">Route(<span class="meta-string">&quot;Create&quot;</span>)</span>]</span><br><span class="line">        [<span class="meta">HttpPost</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">CreateOrder</span>(<span class="params">Models.Order order</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">using</span> (<span class="keyword">var</span> trans = context.Database.BeginTransaction(capBus, autoCommit: <span class="literal">true</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                order.CreateTime = DateTime.Now;</span><br><span class="line">                context.Orders.Add(order);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">var</span> result = <span class="keyword">await</span> context.SaveChangesAsync() &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (result)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 发布下单事件</span></span><br><span class="line">                    <span class="keyword">await</span> capBus.PublishAsync(<span class="string">&quot;order.services.createorder&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> CreateOrderMessageDto() &#123; Count = order.Count, ProductID = order.ProductID &#125;);</span><br><span class="line">                    <span class="keyword">return</span> Ok();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> BadRequest();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CreateOrderMessageDto-cs-v2">CreateOrderMessageDto.cs</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Order.Api.Models</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 下单事件消息</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CreateOrderMessageDto</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 产品ID</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> ProductID &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 购买数量</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Count &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Order-cs">Order.cs</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.ComponentModel.DataAnnotations;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Order.Api.Models</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Order</span></span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="meta">Key</span>]</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> ID &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 下单时间</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        [<span class="meta">Required</span>]</span><br><span class="line">        <span class="keyword">public</span> DateTime CreateTime &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 产品ID</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        [<span class="meta">Required</span>]</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> ProductID &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 购买数量</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        [<span class="meta">Required</span>]</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Count &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="OrderContext-cs">OrderContext.cs</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Microsoft.EntityFrameworkCore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Order.Api</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OrderContext</span> : <span class="title">DbContext</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">OrderContext</span>(<span class="params">DbContextOptions&lt;OrderContext&gt; options</span>)</span></span><br><span class="line"><span class="function">           : <span class="title">base</span>(<span class="params">options</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> DbSet&lt;Models.Order&gt; Orders &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="appsettings-json-v3">appsettings.json</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;Logging&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;LogLevel&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;Default&quot;</span>: <span class="string">&quot;Information&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;Microsoft&quot;</span>: <span class="string">&quot;Warning&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;Microsoft.Hosting.Lifetime&quot;</span>: <span class="string">&quot;Information&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;AllowedHosts&quot;</span>: <span class="string">&quot;*&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;ConsulSetting&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;ServiceName&quot;</span>: <span class="string">&quot;order.service&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;ServiceIP&quot;</span>: <span class="string">&quot;192.168.31.191&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;ServiceHealthCheck&quot;</span>: <span class="string">&quot;/healthcheck&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;ConsulAddress&quot;</span>: <span class="string">&quot;http://192.168.31.191:8500&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;ConnectionString&quot;</span>: <span class="string">&quot;Server=192.168.31.210;Database=Microservice.Sample.Order;user id=sa;password=wpl19950815;MultipleActiveResultSets=true&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Startup-cs-v2">Startup.cs</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    services.AddControllers();</span><br><span class="line"></span><br><span class="line">    services.AddDbContext&lt;OrderContext&gt;(opt =&gt; opt.UseSqlServer(Configuration[<span class="string">&quot;ConnectionString&quot;</span>]));</span><br><span class="line"></span><br><span class="line">    services.AddCap(x =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        x.UseEntityFramework&lt;OrderContext&gt;().UseRabbitMQ(option =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            option.HostName = <span class="string">&quot;192.168.31.191&quot;</span>;</span><br><span class="line">            option.UserName = <span class="string">&quot;guest&quot;</span>;</span><br><span class="line">            option.Password = <span class="string">&quot;guest&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/2021-09-19-01-20-20.png" alt=""></p><p>以上就是产品服务的新增以及订单服务的部分代码调整，功能很简单：各自添加自己的数据库表，订单服务增加下单接口，下单接口会发出“下单事件”。产品服务增加减库存接口，减库存接口会订阅“下单事件”。然后客户端调用下单接口下单时，产品服务会减去相应的库存。关于EF数据库迁移之类的基本使用不做介绍。</p><h1 id="重新构建镜像">重新构建镜像</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-01 dotnetcore_src]<span class="comment"># cd order.api.release/</span></span><br><span class="line">[root@centos-01 order.api.release]<span class="comment"># docker build -t order.api .</span></span><br><span class="line">Sending build context to Docker daemon  16.05MB</span><br><span class="line">Step 1/4 : FROM mcr.microsoft.com/dotnet/aspnet:5.0 AS base</span><br><span class="line"> ---&gt; a2be3e478ffa</span><br><span class="line">Step 2/4 : WORKDIR /app</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 9f551bd1698a</span><br><span class="line">Step 3/4 : COPY . /app</span><br><span class="line"> ---&gt; e19ab440e8a5</span><br><span class="line">Step 4/4 : ENTRYPOINT [<span class="string">&quot;dotnet&quot;</span>, <span class="string">&quot;Order.Api.dll&quot;</span>]</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 3d1e4110f02e</span><br><span class="line">Removing intermediate container 3d1e4110f02e</span><br><span class="line"> ---&gt; 06322a6c6e83</span><br><span class="line">Successfully built 06322a6c6e83</span><br><span class="line">Successfully tagged order.api:latest</span><br><span class="line"></span><br><span class="line">[root@centos-01 order.api.release]<span class="comment"># cd ../product.api.release/</span></span><br><span class="line">[root@centos-01 product.api.release]<span class="comment"># docker build -t product.api .</span></span><br><span class="line">Sending build context to Docker daemon  16.38MB</span><br><span class="line">Step 1/4 : FROM mcr.microsoft.com/dotnet/aspnet:5.0 AS base</span><br><span class="line"> ---&gt; a2be3e478ffa</span><br><span class="line">Step 2/4 : WORKDIR /app</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 9f551bd1698a</span><br><span class="line">Step 3/4 : COPY . /app</span><br><span class="line"> ---&gt; 6f6d08e02d78</span><br><span class="line">Step 4/4 : ENTRYPOINT [<span class="string">&quot;dotnet&quot;</span>, <span class="string">&quot;Product.Api.dll&quot;</span>]</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 7616a505741e</span><br><span class="line">Removing intermediate container 7616a505741e</span><br><span class="line"> ---&gt; 6be08521c6fe</span><br><span class="line">Successfully built 6be08521c6fe</span><br><span class="line">Successfully tagged product.api:latest</span><br></pre></td></tr></table></figure><p>运行订单服务，产品服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name order.api -p 80:80 order.api  --ConsulSetting:ServicePort=<span class="string">&quot;80&quot;</span></span><br><span class="line">docker run -d --name order.api1 -p 81:80 order.api --ConsulSetting:ServicePort=<span class="string">&quot;81&quot;</span></span><br><span class="line">docker run -d --name order.api2 -p 82:80 order.api --ConsulSetting:ServicePort=<span class="string">&quot;82&quot;</span></span><br><span class="line">docker run -d --name product.api -p 85:80 product.api --ConsulSetting:ServicePort=<span class="string">&quot;85&quot;</span></span><br><span class="line">docker run -d --name product.api1 -p 86:80 product.api --ConsulSetting:ServicePort=<span class="string">&quot;86&quot;</span></span><br><span class="line">docker run -d --name product.api2 -p 87:80 product.api --ConsulSetting:ServicePort=<span class="string">&quot;87&quot;</span></span><br></pre></td></tr></table></figure><p><img src="/images/2021-09-19-01-51-19.png" alt=""></p><p><code>ocelot.json</code> 增加路由配置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;Routes&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 路由规则匹配</span></span><br><span class="line">      <span class="attr">&quot;DownstreamPathTemplate&quot;</span>: <span class="string">&quot;/orders/&#123;url&#125;&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;DownstreamScheme&quot;</span>: <span class="string">&quot;http&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;UpstreamPathTemplate&quot;</span>: <span class="string">&quot;/orders/&#123;url&#125;&quot;</span>,</span><br><span class="line">      <span class="comment">// 增加Post请求</span></span><br><span class="line">      <span class="attr">&quot;UpstreamHttpMethod&quot;</span>: [ <span class="string">&quot;Get&quot;</span>, <span class="string">&quot;Post&quot;</span> ],</span><br><span class="line">      <span class="attr">&quot;ServiceName&quot;</span>: <span class="string">&quot;order.service&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;LoadBalancerOptions&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;Type&quot;</span>: <span class="string">&quot;RoundRobin&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 缓存</span></span><br><span class="line">      <span class="attr">&quot;FileCacheOptions&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;TtlSeconds&quot;</span>: <span class="number">5</span>,</span><br><span class="line">        <span class="attr">&quot;Region&quot;</span>: <span class="string">&quot;regionname&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 限流</span></span><br><span class="line">      <span class="attr">&quot;RateLimitOptions&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;ClientWhitelist&quot;</span>: [ <span class="string">&quot;SuperClient&quot;</span> ],</span><br><span class="line">        <span class="attr">&quot;EnableRateLimiting&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">&quot;Period&quot;</span>: <span class="string">&quot;2s&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;PeriodTimespan&quot;</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">&quot;Limit&quot;</span>: <span class="number">1</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 超时熔断</span></span><br><span class="line">      <span class="attr">&quot;QoSOptions&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;ExceptionsAllowedBeforeBreaking&quot;</span>: <span class="number">3</span>,</span><br><span class="line">        <span class="attr">&quot;DurationOfBreak&quot;</span>: <span class="number">10000</span>,</span><br><span class="line">        <span class="attr">&quot;TimeoutValue&quot;</span>: <span class="number">5000</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;DownstreamPathTemplate&quot;</span>: <span class="string">&quot;/products&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;DownstreamScheme&quot;</span>: <span class="string">&quot;http&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;UpstreamPathTemplate&quot;</span>: <span class="string">&quot;/products&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;UpstreamHttpMethod&quot;</span>: [ <span class="string">&quot;Get&quot;</span> ],</span><br><span class="line">      <span class="attr">&quot;ServiceName&quot;</span>: <span class="string">&quot;product.service&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;LoadBalancerOptions&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;Type&quot;</span>: <span class="string">&quot;RoundRobin&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 缓存</span></span><br><span class="line">      <span class="attr">&quot;FileCacheOptions&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;TtlSeconds&quot;</span>: <span class="number">5</span>,</span><br><span class="line">        <span class="attr">&quot;Region&quot;</span>: <span class="string">&quot;regionname&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 限流</span></span><br><span class="line">      <span class="attr">&quot;RateLimitOptions&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;ClientWhitelist&quot;</span>: [ <span class="string">&quot;SuperClient&quot;</span> ],</span><br><span class="line">        <span class="attr">&quot;EnableRateLimiting&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">&quot;Period&quot;</span>: <span class="string">&quot;2s&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;PeriodTimespan&quot;</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">&quot;Limit&quot;</span>: <span class="number">1</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 超时熔断</span></span><br><span class="line">      <span class="attr">&quot;QoSOptions&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;ExceptionsAllowedBeforeBreaking&quot;</span>: <span class="number">3</span>,</span><br><span class="line">        <span class="attr">&quot;DurationOfBreak&quot;</span>: <span class="number">10000</span>,</span><br><span class="line">        <span class="attr">&quot;TimeoutValue&quot;</span>: <span class="number">5000</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;GlobalConfiguration&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;BaseUrl&quot;</span>: <span class="string">&quot;http://localhost:5000&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;ServiceDiscoveryProvider&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;Scheme&quot;</span>: <span class="string">&quot;http&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;Host&quot;</span>: <span class="string">&quot;192.168.31.191&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;Port&quot;</span>: <span class="number">8500</span>,</span><br><span class="line">      <span class="attr">&quot;Type&quot;</span>: <span class="string">&quot;Consul&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;RateLimitOptions&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;DisableRateLimitHeaders&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;QuotaExceededMessage&quot;</span>: <span class="string">&quot;too many requests...&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;HttpStatusCode&quot;</span>: <span class="number">999</span>,</span><br><span class="line">      <span class="attr">&quot;ClientIdHeader&quot;</span>: <span class="string">&quot;Test&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此整个环境就有点复杂了。要确保 SqlServer，RabbitMQ，Consul，服务实例、Gateway都正常运行：</p><p><img src="/images/2021-09-19-02-13-24.png" alt=""></p><p><img src="/images/2021-09-19-02-00-46.png" alt=""></p><p><img src="/images/2021-09-19-02-01-06.png" alt=""></p><p><code>cap.published</code> 表和 <code>cap.received</code> 表由 <code>CAP</code> 自动生成，内部使用本地消息表+MQ来实现异步确保。</p><h1 id="测试-v3">测试</h1><p>使用Postman作为客户端调用下单接口（5000是Ocelot网关端口）：</p><p><img src="/images/2021-09-19-02-19-58.png" alt=""></p><p>订单库：<br><img src="/images/2021-09-19-02-30-39.png" alt=""></p><p>产品库：<br><img src="/images/2021-09-19-02-30-59.png" alt=""></p><p>至此虽然功能很简单，但是实现了服务的解耦，异步调用，和最终一致性。要注意的是：</p><ol><li>这里的事务是指：订单持久化到数据库/和下单事件保存到 <code>cap.published</code>表（保存到 <code>cap.published</code> 表理论上代表消息正常发送到MQ），要么一同成功，要么一同失败。如果这个事务成功，那么就可以认为这个业务流程是成功的</li><li>产品服务的减库存是否成功那是产品服务的事，理论上也应该是成功的。因为消息已经确保发到了MQ，产品服务必然会收到消息。CAP也提供了失败重试，和失败回调机制，要理解 “CAP 是基于MQ加本地消息表来实现异步确保”</li><li>如果下单成功但是库存不足导致减库存失败了怎么办，是否需要回滚订单表的数据？如果产生这种想法，说明还没有真正理解最终一致性的思想。首先下单前肯定会检查一下库存数量，既然允许下单那么必然是库存充足的。（高并发下保证不超卖是另一个问题这里不考虑）如果非要数据回滚也是能实现的，CAP的 <code>ICapPublisher.Publish</code> 方法提供一个<code>callbackName</code> 参数，当减库存时，可以触发这个回调。其本质也是通过发布订阅完成，但不推荐</li><li>CAP无法保证消息不重复，实际使用中需要自己考虑一下实现消息的重复过滤和幂等</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/linux/Centos7%E5%8D%87%E7%BA%A7gcc%E7%89%88%E6%9C%AC/"/>
      <url>/linux/Centos7%E5%8D%87%E7%BA%A7gcc%E7%89%88%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<p>记录一下centos7如何升级gcc</p><span id="more"></span><p>Centos 7默认gcc版本为4.8，有时需要更高版本的，这里以升级至8.3.1版本为例，分别执行下面三条命令即可，无需手动<a href="http://ftp.gnu.org/gnu/gcc/">下载源码</a>编译</p><p>1、安装centos-release-scl</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install centos-release-scl</span><br></pre></td></tr></table></figure><p>2、安装devtoolset，注意：如果想安装7.* 版本的，就改成devtoolset-7-gcc，以此类推</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install devtoolset-8-gcc*</span><br></pre></td></tr></table></figure><p>3、激活对应的devtoolset，可以一次安装多个版本的devtoolset，需要的时候用下面这条命令切换到对应的版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scl <span class="built_in">enable</span> devtoolset-8 bash</span><br></pre></td></tr></table></figure><p>搞定，查看一下gcc版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -v</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang ~]<span class="comment"># gcc -v</span></span><br><span class="line">Using built-in specs.</span><br><span class="line">COLLECT_GCC=gcc</span><br><span class="line">COLLECT_LTO_WRAPPER=/opt/rh/devtoolset-8/root/usr/libexec/gcc/x86_64-redhat-linux/8/lto-wrapp</span><br><span class="line">erTarget: x86_64-redhat-linux</span><br><span class="line">Configured with: ../configure --enable-bootstrap --enable-languages=c,c++,fortran,lto --prefi</span><br><span class="line">x=/opt/rh/devtoolset-8/root/usr --mandir=/opt/rh/devtoolset-8/root/usr/share/man --infodir=/opt/rh/devtoolset-8/root/usr/share/info --with-bugurl=http://bugzilla.redhat.com/bugzilla --enable-shared --enable-threads=posix --enable-checking=release --enable-multilib --with-system-zlib --enable-__cxa_atexit --disable-libunwind-exceptions --enable-gnu-unique-object --enable-linker-build-id --with-gcc-major-version-only --with-linker-hash-style=gnu --with-default-libstdcxx-abi=gcc4-compatible --enable-plugin --enable-initfini-array --with-isl=/builddir/build/BUILD/gcc-8.3.1-20190311/obj-x86_64-redhat-linux/isl-install --disable-libmpx --enable-gnu-indirect-function --with-tune=generic --with-arch_32=x86-64 --build=x86_64-redhat-linuxThread model: posix</span><br><span class="line">gcc version 8.3.1 20190311 (Red Hat 8.3.1-3) (GCC) </span><br><span class="line">[root@wangpengliang ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>显示为 gcc version 8.3.1 20190311 (Red Hat 8.3.1-3) (GCC)</p><p>补充：这条激活命令只对本次会话有效，重启会话后还是会变回原来的4.8.5版本，要想随意切换可按如下操作。</p><p>首先，安装的devtoolset是在 <code>/opt/rh</code>  目录下的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang rh]# ls</span><br><span class="line">devtoolset-8  devtoolset-9</span><br><span class="line">[root@wangpengliang rh]#</span><br></pre></td></tr></table></figure><p>每个版本的目录下面都有个 enable 文件，如果需要启用某个版本，只需要执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ./<span class="built_in">enable</span></span><br></pre></td></tr></table></figure><p>所以要想切换到某个版本，只需要执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /opt/rh/devtoolset-8/<span class="built_in">enable</span></span><br></pre></td></tr></table></figure><p>可以将对应版本的切换命令写个shell文件放在配了环境变量的目录下，需要时随时切换，或者开机自启</p><p>4、直接替换旧的gcc<br>旧的gcc是运行的 <code>/usr/bin/gcc</code> ，所以将该目录下的gcc/g++替换为刚安装的新版本gcc软连接，免得每次 <code>enable</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mv /usr/bin/gcc /usr/bin/gcc-4.8.5</span><br><span class="line">ln -s /opt/rh/devtoolset-8/root/bin/gcc /usr/bin/gcc</span><br><span class="line"></span><br><span class="line">mv /usr/bin/g++ /usr/bin/g++-4.8.5</span><br><span class="line">ln -s /opt/rh/devtoolset-8/root/bin/g++ /usr/bin/g++</span><br><span class="line"></span><br><span class="line">gcc --version</span><br><span class="line">g++ --version</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/go/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/GPM%E5%8E%9F%E7%90%86%E4%B8%8E%E8%B0%83%E5%BA%A6/"/>
      <url>/go/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/GPM%E5%8E%9F%E7%90%86%E4%B8%8E%E8%B0%83%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="动态栈">动态栈</h1><p>操作系统的线程一般都有固定的栈内存（通常为 <code>2MB</code> ）,而 Go 语言中的 <code>goroutine</code> 非常轻量级，一个 <code>goroutine</code> 的初始栈空间很小（一般为 <code>2KB</code> ），所以在 Go 语言中一次创建数万个 goroutine 也是可能的。并且 goroutine 的栈不是固定的，可以根据需要动态地增大或缩小， Go 的 runtime 会自动为 goroutine 分配合适的栈空间。</p><h1 id="goroutine调度">goroutine调度</h1><p>操作系统的线程会被操作系统内核调度时会挂起当前执行的线程并将它的寄存器内容保存到内存中，选出下一次要执行的线程并从内存中恢复该线程的寄存器信息，然后恢复执行该线程的现场并开始执行线程。从一个线程切换到另一个线程需要完整的上下文切换。因为可能需要多次内存访问，索引这个切换上下文的操作开销较大，会增加运行的cpu周期。</p><p>区别于操作系统内核调度操作系统线程，goroutine 的调度是Go语言运行时（runtime）层面的实现，是完全由 Go 语言本身实现的一套调度系统——go scheduler。它的作用是按照一定的规则将所有的 goroutine 调度到操作系统线程上执行。</p><p>在经历数个版本的迭代之后，目前 Go 语言的调度器采用的是 <code>GPM</code> 调度模型。</p><p><img src="https://www.liwenzhou.com/images/Go/concurrence/gpm.png" alt="gpm"></p><p>其中：</p><ul><li>G：表示 goroutine，每执行一次<code>go f()</code>就创建一个 G，包含要执行的函数和上下文信息。</li><li>全局队列（Global Queue）：存放等待运行的 G。</li><li>P：表示 goroutine 执行所需的资源，最多有 GOMAXPROCS 个。</li><li>P 的本地队列：同全局队列类似，存放的也是等待运行的G，存的数量有限，不超过256个。新建 G 时，G 优先加入到 P 的本地队列，如果本地队列满了会批量移动部分 G 到全局队列。</li><li>M：线程想运行任务就得获取 P，从 P 的本地队列获取 G，当 P 的本地队列为空时，M 也会尝试从全局队列或其他 P 的本地队列获取 G。M 运行 G，G 执行之后，M 会从 P 获取下一个 G，不断重复下去。</li><li>Goroutine 调度器和操作系统调度器是通过 M 结合起来的，每个 M 都代表了1个内核线程，操作系统调度器负责把内核线程分配到 CPU 的核上执行。</li></ul><p>单从线程调度讲，Go语言相比起其他语言的优势在于OS线程是由OS内核来调度的， goroutine 则是由Go运行时（runtime）自己的调度器调度的，完全是在用户态下完成的， 不涉及内核态与用户态之间的频繁切换，包括内存的分配与释放，都是在用户态维护着一块大的内存池， 不直接调用系统的malloc函数（除非内存池需要改变），成本比调度OS线程低很多。 另一方面充分利用了多核的硬件资源，近似的把若干goroutine均分在物理线程上， 再加上本身 goroutine 的超轻量级，以上种种特性保证了 goroutine 调度方面的性能。</p><h1 id="GOMAXPROCS">GOMAXPROCS</h1><p>Go运行时的调度器使用 <code>GOMAXPROCS</code> 参数来确定需要使用多少个 OS 线程来同时执行 Go 代码。默认值是机器上的 CPU 核心数。例如在一个 8 核心的机器上，GOMAXPROCS 默认为 8。Go语言中可以通过 <code>runtime.GOMAXPROCS</code> 函数设置当前程序并发时占用的 CPU逻辑核心数。（Go1.5版本之前，默认使用的是单核心执行。Go1.5 版本之后，默认使用全部的CPU 逻辑核心数）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/go/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/channel/"/>
      <url>/go/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/channel/</url>
      
        <content type="html"><![CDATA[<h1 id="channel">channel</h1><p>上一章学习了 <code>goroutine</code> 的使用方式。但是单纯的将函数并发执行并没有意义。函数与函数间需要交换数据才能体现并发执行的意义。虽然可以使用共享内存进行数据交换，但是共享内存在不同的 <code>goroutine</code> 中容易发生竞态问题。为了保证数据交换的正确性，很多并发模型中必须使用互斥量对内存进行加锁，但这种做法势必造成性能问题。</p><p>Go语言采用的并发模型是 <code>CSP（Communicating Sequential Processes）</code> 提倡：<strong>通过通信共享内存</strong>而不是<strong>通过共享内存实现通信</strong>。</p><p>如果把 <code>goroutine</code> 比作是Go程序并发的执行体，<code>channel</code>就是它们之间的连接。<code>channel</code> 是可以让一个 <code>goroutine</code> 发送特定值到另一个 <code>goroutine</code> 的通信机制。</p><p>Go语言中的通道 <code>channel</code> 是一种特殊的类型。通道像一个传送带或者队列，总是遵循先入先出（<code>First In First Out</code>）的规则，保证收发数据的顺序。每一个通道都是一个具体类型的导管，也就是说：声明 <code>channel</code>  时需要为其指定元素类型。</p><h2 id="channel-类型">channel 类型</h2><p><code>channel</code> 是 Go 语言中一种特有的类型。声明格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名称 <span class="keyword">chan</span> 元素类型</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>chan</code> ：关键字</li><li>元素类型：是指通道中传递元素的类型</li></ul><p>比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch1 <span class="keyword">chan</span> <span class="keyword">int</span>   <span class="comment">// 声明一个传递整型的通道</span></span><br><span class="line"><span class="keyword">var</span> ch2 <span class="keyword">chan</span> <span class="keyword">bool</span>  <span class="comment">// 声明一个传递布尔型的通道</span></span><br><span class="line"><span class="keyword">var</span> ch3 <span class="keyword">chan</span> []<span class="keyword">int</span> <span class="comment">// 声明一个传递int切片的通道</span></span><br></pre></td></tr></table></figure><h2 id="channel-零值">channel 零值</h2><p>未初始化的通道类型变量其默认零值是 <code>nil</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">fmt.Println(ch) <span class="comment">// &lt;nil&gt;</span></span><br></pre></td></tr></table></figure><h2 id="channel-初始化">channel 初始化</h2><p>声明的通道类型变量需要使用内置的 <code>make</code> 函数初始化之后才能使用。格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>(<span class="keyword">chan</span> 元素类型, [缓冲大小])</span><br></pre></td></tr></table></figure><p>其中：<code>channel</code> 的缓冲大小是可选的。比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch4 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">ch5 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">1</span>)  <span class="comment">// 声明一个缓冲区大小为1的通道</span></span><br></pre></td></tr></table></figure><h2 id="channel-操作">channel 操作</h2><p>通道共有 <code>发送（send）</code>、<code>接收(receive）</code>和 <code>关闭（close）</code> 三种操作。发送和接收操作都使用<code>&lt;-</code>符号。</p><p>比如定义一个通道：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure><h3 id="发送-send">发送 send</h3><p>将一个值发送到通道中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- <span class="number">10</span> <span class="comment">// 把10发送到ch中</span></span><br></pre></td></tr></table></figure><h3 id="接收-receive">接收 receive</h3><p>从一个通道中接收值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x := &lt;- ch <span class="comment">// 从ch中接收值并赋值给变量x</span></span><br><span class="line">&lt;-ch       <span class="comment">// 从ch中接收值，忽略结果</span></span><br></pre></td></tr></table></figure><h3 id="关闭-close">关闭 close</h3><p>通过调用内置的<code>close</code>函数来关闭通道。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">close</span>(ch)</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：通道值是可以被垃圾回收掉的。通道通常由发送方执行关闭操作，并且只有在接收方明确等待通道关闭的信号时才需要执行关闭操作。它和关闭文件不一样，通常在结束操作之后关闭文件是必须要做的，但关闭通道不是必须的。</p><p>关闭后的通道有以下特点：</p><ol><li>对一个关闭的通道再发送值会导致 <code>panic</code></li><li>对一个关闭的通道进行接收会一直获取值直到通道为空</li><li>对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值</li><li>关闭一个已经关闭的通道会导致 <code>panic</code></li></ol><h2 id="无缓冲的通道">无缓冲的通道</h2><p>无缓冲的通道又称为阻塞的通道。看如下代码片段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chan1</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">ch &lt;- <span class="number">10</span></span><br><span class="line">fmt.Println(<span class="string">&quot;发送成功&quot;</span>) <span class="comment">// fatal error: all goroutines are asleep - deadlock!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码能够通过编译，但是执行的时候会出现以下错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br></pre></td></tr></table></figure><p><code>deadlock</code> 表示程序中的  <code>goroutine</code>  都被挂起导致程序死锁。导致死锁的原因在于：</p><blockquote><p><code>ch := make(chan int)</code> 创建的是无缓冲的通道，<strong>无缓冲的通道只有在有接收方能够接收值的时候才能发送成功，否则会一直处于等待发送的阶段</strong>。同理如果对一个无缓冲通道执行接收操作时，没有任何向通道中发送值的操作那么也会导致接收操作阻塞。简单理解就是：<strong>无缓冲的通道必须有至少一个接收方才能发送成功</strong></p></blockquote><p>上面的代码会阻塞在 <code>ch &lt;- 10</code> 这一行代码形成死锁，解决这个问题其中一种可行的方法是创建一个  <code>goroutine</code>  去接收值，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chan2</span><span class="params">()</span></span> &#123;</span><br><span class="line">value := <span class="number">10</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">value := &lt;-ch</span><br><span class="line">fmt.Printf(<span class="string">&quot;接收成功,value=%d \n&quot;</span>, value)</span><br><span class="line">&#125;(ch)</span><br><span class="line">    </span><br><span class="line">ch &lt;- value</span><br><span class="line">fmt.Printf(<span class="string">&quot;发送成功,value=%d \n&quot;</span>, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先无缓冲通道  <code>ch</code> 上的发送操作会阻塞，直到另一个 <code>goroutine</code>  在该通道上执行接收操作，这时数字10才能发送成功，两个 <code>goroutine</code>  将继续执行。相反，如果接收操作先执行，接收方所在的 <code>goroutine</code>  将阻塞，直到 <code>main goroutine</code>  中向该通道发送数字10。</p><p>使用无缓冲通道进行通信将导致发送和接收的 <code>goroutine</code> 同步化。因此无缓冲通道也被称为 <code>同步通道</code>。</p><h2 id="有缓冲的通道">有缓冲的通道</h2><p>还有另外一种解决上面死锁问题的方法是：使用有缓冲区的通道。可以在使用 <code>make</code> 函数初始化通道时为其指定通道的容量，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>) <span class="comment">// 创建一个容量为1的有缓冲区通道</span></span><br><span class="line">ch &lt;- <span class="number">10</span></span><br><span class="line">fmt.Println(<span class="string">&quot;发送成功&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要通道的容量大于零，那么该通道就属于有缓冲的通道，通道的容量表示通道中最大能存放的元素数量。当通道内已有元素数达到最大容量后，再向通道执行发送操作就会阻塞，除非有从通道执行接收操作。可以使用内置的 <code>len</code> 函数获取通道内元素的数量，使用 <code>cap</code> 函数获取通道的容量但很少会这么做。</p><h2 id="多返回值模式">多返回值模式</h2><p>当向通道中发送完数据时可以通过 <code>close</code> 函数来关闭通道。当一个通道被关闭后，再往该通道发送值会引发<code>panic</code>，从该通道取值的操作会先取完通道中的值。通道内的值被接收完后再对通道执行接收操作得到的值会一直都是对应元素类型的零值。那如何判断一个通道是否被关闭呢？</p><p>对一个通道执行接收操作时支持使用如下多返回值模式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value, ok := &lt;- ch</span><br></pre></td></tr></table></figure><p>其中</p><ul><li><code>value</code> ：从通道中取出的值，如果通道被关闭则返回对应类型的零值</li><li><code>ok</code> ：通道关闭时返回 <code>false</code>，否则返回 <code>true</code></li></ul><p>循环从通道<code>ch</code>中接收所有值，直到通道被关闭后退出。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chan4</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line">ch &lt;- i</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(ch)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 循环接收值，直到通道被关闭后退出</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">v, ok := &lt;-ch</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">wg.Done()</span><br><span class="line">fmt.Printf(<span class="string">&quot;v=%v ok=%v \n&quot;</span>, v, ok)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;(ch)</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="for-range接收值">for range接收值</h2><p>通常会选择使用 <code>for range</code> 循环从通道中接收值，当通道被关闭后会在通道内的所有值被接收完毕后会自动退出循环。上面示例使用 <code>for range</code> 改写后会很简洁。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chan5</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line">ch &lt;- i</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(ch)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> ch &#123;</span><br><span class="line">fmt.Println(v)</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：目前Go语言中并没有提供一个不对通道进行读取操作就能判断通道是否被关闭的方法。不能简单的通过 <code>len(ch)</code> 操作来判断通道是否被关闭。</p><h2 id="单向通道">单向通道</h2><p>某些场景下可能会将通道作为参数在多个任务函数间进行传递，通常会选择在不同的任务函数中对通道的使用进行限制，比如限制通道在某个函数中只能执行发送或只能执行接收操作。比如：现在有 <code>Producer</code> 和 <code>Consumer</code> 两个函数，其中 <code>Producer</code> 函数会返回一个通道，并且会持续将符合条件的数据发送至该通道，并在发送完成后将该通道关闭。而 <code>Consumer</code> 函数的任务是从通道中接收值进行计算，这两个函数之间通过 <code>Processer</code> 函数返回的通道进行通信。示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Producer 返回一个通道</span></span><br><span class="line"><span class="comment">// 并持续将符合条件的数据发送至返回的通道中</span></span><br><span class="line"><span class="comment">// 数据发送完成后会将返回的通道关闭</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Producer</span><span class="params">()</span> <span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// 创建一个新的goroutine执行发送数据的任务</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">ch &lt;- i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(ch) <span class="comment">// 任务完成后关闭通道</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Consumer 从通道中接收数据进行计算</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Consumer</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> ch &#123;</span><br><span class="line">fmt.Println(v)</span><br><span class="line">sum += v</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := Producer()</span><br><span class="line">res := Consumer(ch)</span><br><span class="line">fmt.Println(res) <span class="comment">// 25</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的示例代码中可以看出正常情况下 <code>Consumer</code> 函数中只会对通道进行接收操作，但这不代表不可以在 <code>Consumer</code> 函数中对通道进行发送操作。作为 <code>Producer</code> 函数的提供者在返回通道的时候可能只希望调用方拿到返回的通道后只能对其进行接收操作。但是没有办法阻止在 <code>Consumer</code> 函数中对通道进行发送操作。比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Producer2</span><span class="params">()</span> <span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// 创建一个新的goroutine执行发送数据的任务</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">ch &lt;- i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(ch) <span class="comment">// 任务完成后关闭通道</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Consumer 从通道中接收数据进行计算同时可以向通道中写值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Consumer2</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line">ch &lt;- <span class="number">100</span></span><br><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> ch &#123;</span><br><span class="line">sum += v</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go语言中提供了<strong>单向通道</strong>来处理这种需要限制通道只能进行某种操作的情况。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;- <span class="keyword">chan</span> <span class="keyword">int</span> <span class="comment">// 只接收通道，只能接收不能发送</span></span><br><span class="line"><span class="keyword">chan</span> &lt;- <span class="keyword">int</span> <span class="comment">// 只发送通道，只能发送不能接收</span></span><br></pre></td></tr></table></figure><p>其中，箭头 <code>&lt;-</code> 和关键字 <code>chan</code> 的相对位置表明了当前通道允许的操作，这种限制将在编译阶段进行检测。另外对一个只接收通道执行 <code>close</code> 也是不允许的，因为默认通道的关闭操作应该由发送方来完成。</p><p>使用单向通道将上面的示例代码进行如下改造。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Producer3 返回一个接收通道</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Producer3</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">ch &lt;- i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(ch)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Consumer3 参数为接收通道</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Consumer3</span><span class="params">(ch &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> ch &#123;</span><br><span class="line">sum += v</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Producer3</code> 函数返回的是一个只接收通道，这就从代码层面限制了该函数返回的通道只能进行接收操作，保证了数据安全。并且返回限制操作的单向通道也会让代码语义更清晰、更易读。</p><p>在函数传参及任何赋值操作中全向通道（正常通道）可以转换为单向通道，但是无法反向转换。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// channel类型转换</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convertChannel</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 双向通道</span></span><br><span class="line"><span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="keyword">int</span> = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单向写</span></span><br><span class="line"><span class="keyword">var</span> sendCh <span class="keyword">chan</span>&lt;- <span class="keyword">int</span> = <span class="built_in">make</span>(<span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单向读</span></span><br><span class="line"><span class="keyword">var</span> recvCh &lt;-<span class="keyword">chan</span> <span class="keyword">int</span> = <span class="built_in">make</span>(&lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双向channel 可以 隐式转换为 任意一种单向channel</span></span><br><span class="line">sendCh = ch</span><br><span class="line">recvCh = ch</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单向 channel 不能转换为 双向 channel</span></span><br><span class="line"><span class="comment">//ch = recvCh // cannot use recvCh (variable of type &lt;-chan int) as chan int value in assignment</span></span><br><span class="line"><span class="comment">//ch = sendCh // cannot use sendCh (variable of type chan&lt;- int) as chan int value in assignment</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;sendCh:%T,recvTh:%T&quot;</span>, sendCh, recvCh)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结-v3">总结</h2><p>表格中总结了对不同状态下的通道执行相应操作的结果。</p><p><img src="/images/2022-04-02-10-09-09.png" alt=""></p><p><strong>注意</strong>：对已经关闭的通道再执行 <code>close</code> 也会引发  <code>panic</code>。</p><h1 id="select-多路复用">select 多路复用</h1><p>某些场景下可能需要同时从多个通道接收数据。通道在接收数据时，如果没有数据可以被接收那么当前 <code>goroutine</code> 将会发生阻塞。可能会写出如下代码尝试使用遍历的方式来实现从多个通道中接收值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line">    <span class="comment">// 尝试从ch1接收值</span></span><br><span class="line">    data, ok := &lt;-ch1</span><br><span class="line">    <span class="comment">// 尝试从ch2接收值</span></span><br><span class="line">    data, ok := &lt;-ch2</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式虽然可以实现从多个通道接收值的需求，但是程序的运行性能比较差。Go 语言内置了<code>select</code>关键字，使用它可以同时响应多个通道的操作。</p><p><code>select</code> 的使用方式类似于 <code>switch</code> 语句，它也有一系列 case 分支和一个默认的分支。每个 case 分支会对应一个通道的通信（接收或发送）过程。<code>select</code> 会一直等待，直到其中的某个 case 的通信操作完成时，就会执行该 case 分支对应的语句。格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ch1:</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">case</span> data := &lt;-ch2:</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">case</span> ch3 &lt;- <span class="number">10</span>:</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">//默认操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>select</code> 语句具有以下特点：</p><ul><li>可处理一个或多个 <code>channel</code> 的发送/接收操作</li><li>如果多个 case 同时满足，<code>select</code> 会<strong>随机</strong>选择一个执行</li><li>对于没有 case 的 select 会一直阻塞，可用于阻塞 main 函数，防止退出</li></ul><p>下面示例代码能够在终端打印出10以内的奇数，借助这个代码片段来看一下 select 的具体使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> x := &lt;-ch:</span><br><span class="line">fmt.Println(x)</span><br><span class="line"><span class="keyword">case</span> ch &lt;- i:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码输出内容如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">7</span><br><span class="line">9</span><br></pre></td></tr></table></figure><p>示例中的代码首先是创建了一个缓冲区大小为1的通道 ch，在进入 for 循环后，此时 i = 1，select 语句中包含两个 case 分支，此时由于通道中没有值可以接收，所以<code>x := &lt;-c</code> 这个 case 分支不满足，而<code>ch &lt;- i</code>这个分支可以执行，会把1发送到通道中，结束本次 for 循环；第二次 for 循环时，i = 2，由于通道缓冲区已满，所以<code>ch &lt;- i</code>这个分支不满足，而<code>x := &lt;-ch</code>这个分支可以执行，从通道接收值1并赋值给变量 x ，所以会在终端打印出 1；后续的 for 循环同理会依次打印出3、5、7、9。</p><h1 id="通道误用示例">通道误用示例</h1><p>接下来，我们将展示两个因误用通道导致程序出现 bug 的代码片段，希望能够加深读者对通道操作的印象。</p><h2 id="示例1">示例1</h2><p>各位读者可以查看以下示例代码，尝试找出其中存在的问题。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo1 通道误用导致的bug</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo1</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg := sync.WaitGroup&#123;&#125;</span><br><span class="line"></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">ch &lt;- i</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(ch)</span><br><span class="line"></span><br><span class="line">wg.Add(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">3</span>; j++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">task := &lt;-ch</span><br><span class="line"><span class="comment">// 这里假设对接收的数据执行某些操作</span></span><br><span class="line">fmt.Println(task)</span><br><span class="line">&#125;</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上述代码编译执行后，匿名函数所在的 goroutine 并不会按照预期在通道被关闭后退出。因为<code>task := &lt;- ch</code>的接收操作在通道被关闭后会一直接收到零值，而不会退出。此处的接收操作应该使用<code>task, ok := &lt;- ch</code>，通过判断布尔值<code>ok</code>为假时退出；或者使用select 来处理通道。</p><h2 id="示例2">示例2</h2><p>各位读者阅读下方代码片段，尝试找出其中存在的问题。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo2 通道误用导致的bug</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo2</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 这里假设执行一些耗时的操作</span></span><br><span class="line">time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">ch &lt;- <span class="string">&quot;job result&quot;</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> result := &lt;-ch:</span><br><span class="line">fmt.Println(result)</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(time.Second): <span class="comment">// 较小的超时时间</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码片段可能导致 goroutine 泄露（goroutine 并未按预期退出并销毁）。由于 select 命中了超时逻辑，导致通道没有消费者（无接收操作），而其定义的通道为无缓冲通道，因此 goroutine 中的<code>ch &lt;- &quot;job result&quot;</code>操作会一直阻塞，最终导致 goroutine 泄露。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/go/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/goroutine/"/>
      <url>/go/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/goroutine/</url>
      
        <content type="html"><![CDATA[<p>并发编程在当前软件领域是一个非常重要的概念，随着CPU等硬件的发展，都希望让程序运行的更快。Go语言在语言层面天生支持并发（基于 <code>goroutine</code> 的高并发），充分利用现代CPU的多核优势，这也是Go语言能够大范围流行的一个很重要的原因。</p><h1 id="概念了解-v2">概念了解</h1><h2 id="串行-并发-并行">串行/并发/并行</h2><p><strong>串行</strong>：按照一定顺序先后执行</p><p><strong>并发</strong>：同一时间段内执行多个任务，逻辑上的同时发生。一个处理器（在不同时刻或者说在同一时间间隔内）&quot;同时&quot;处理多个任务。宏观上是并发的，微观上是按排队等待、唤醒、执行的步骤序列执行</p><p><strong>并行</strong>：物理上的同时发生。多核处理器或多个处理器（在同一时刻）同时处理多个任务。并行性允许多个程序同一时刻可在不同 CPU 上同时执行</p><h2 id="进程-线程-协程">进程/线程/协程</h2><p>进程（process）：程序在操作系统中的一次执行过程，系统进行资源分配和调度的一个独立单位</p><p>线程（thread）：操作系统基于进程开启的轻量级进程，是操作系统调度执行的最小单位</p><p>协程（coroutine）：非操作系统提供而是由用户自行创建和控制的 <code>用户态线程</code>，比线程更轻量级</p><h2 id="阻塞-非阻塞">阻塞/非阻塞</h2><p><strong>阻塞</strong>：阻塞是进程(也可以是线程、协程)的状态之一（新建、就绪、运行、阻塞、终止). 指的是当数据未准备就绪，这个进程(线程、协程)一直等待，这就是阻塞</p><p><strong>非阻塞</strong>： 当数据为准备就绪，该进程(线程、协程)不等待可以继续执行，这就是非阻塞</p><h2 id="同步-异步">同步/异步</h2><p><strong>同步</strong>： 发起一个调用时，在没有得到结果之前，这个调用就不返回。调用过程一直在等待。这是同步</p><p><strong>异步</strong>：发起调用后就立刻返回，这次调用过程就结束了，等到有结果了被调用方主动通知调用者结果。这是异步</p><h1 id="goroutine">goroutine</h1><p><code>goroutine</code> 是 Go 语言支持并发的核心，一个 <code>goroutine</code> 会以一个很小的栈开始其生命周期，一般只需要 <code>2KB</code> 。与操作系统线程区别在于：操作系统线程由系统内核进行调度， <code>goroutine</code> 是由Go运行时（runtime）负责调度。Go运行时会智能地将 m个 <code>goroutine</code> 合理地分配给 <code>n</code> 个操作系统线程，实现类似 <code>m:n</code> 的调度机制，不再需要Go开发者自行在代码层面维护一个线程池。</p><p><code>goroutine</code> 是 Go 程序中最基本的并发执行单元。每一个 Go 程序都至少包含一个 goroutine（<code>main goroutine</code>），Go程序启动时它会自动创建。Go语言编程中不需要去自己写进程、线程、协程，当需要让某个任务并发执行的时候，只需要把这个任务包装成一个函数，开启一个 <code>goroutine</code> 去执行这个函数就可以了。</p><h1 id="go关键字">go关键字</h1><p>Go语言中只需要在函数或方法调用前加上<code>go</code>关键字就可以创建一个 <code>goroutine</code> ，让该函数或方法在新创建的 <code>goroutine</code> 中执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> test()  <span class="comment">// 创建一个新的 goroutine 运行函数test</span></span><br></pre></td></tr></table></figure><p>匿名函数也支持使用 <code>go</code> 关键字创建 <code>goroutine</code> 执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>一个 <code>goroutine</code> 必定对应一个函数/方法，可以创建多个 <code>goroutine</code> 去执行相同的函数/方法。</p><h2 id="启动单个goroutine">启动单个goroutine</h2><p>先看一个在 main 函数中执行普通函数调用的示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line">fmt.Println(<span class="string">&quot;end...&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">end...</span><br></pre></td></tr></table></figure><p>代码会顺序打印 <code>hello </code> 和 <code>end...</code> 是串行的。接下来在匿名函数前加上关键字 <code>go</code>，启动一个 <code>goroutine</code> 去执行这个函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line">fmt.Println(<span class="string">&quot;end...&quot;</span>) <span class="comment">// 这里只会输出end...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">end...</span><br></pre></td></tr></table></figure><p>这一次的执行结果只在终端打印了 <code>end...</code> 并没有打印 <code>hello</code>，原因在于：</p><blockquote><p>Go程序启动时会为 main 函数创建一个默认的 <code>goroutine</code> 。上面代码中在 main 函数中使用 go 关键字创建了另外一个 <code>goroutine</code> 去执行匿名函数，而此时 <code>main goroutine</code> 还在继续往下执行，程序中此时存在两个并发执行的 <code>goroutine</code> 。当 main 函数结束时整个程序也就结束了，同时 main goroutine 也结束了，所有由 <code>main goroutine</code>  创建的 <code>goroutine</code> 也会一同退出。也就是说 main 函数退出太快，另外一个 <code>goroutine</code> 中的函数还未执行完程序就退出了，导致未打印出“hello”。其实跟C#中主线程退出导致所有的子线程都会退出一个道理。</p></blockquote><p>使用 <code>time.Sleeep</code> 让 <code>main goroutine</code> 等待一下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line">fmt.Println(<span class="string">&quot;end...&quot;</span>) <span class="comment">// 先输出:end... 再输出:hello</span></span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新编译后再次执行，程序会在终端输出如下结果，并且会短暂停顿一下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">end...</span><br><span class="line">hello</span><br></pre></td></tr></table></figure><p>这里 <code>end...</code> 会首先被输出的原因在于：程序中创建 <code>goroutine</code> 执行函数需要一定的开销，而此时 main 函数所在的 <code>goroutine</code> 是继续执行的，所以会先输出 <code>end...</code>。</p><p>上面代码中使用 <code>time.Sleep</code> 让 <code>main goroutine</code> 等待匿名函数执行结束是不优雅也是不准确的，Go 语言中 <code>sync</code> 包提供了一些常用的并发原语。当并不关心并发操作结果或者有其它方式收集并发操作的结果时，<code>WaitGroup</code> 是实现等待一组并发操作完成的好方法。简单试一下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>) <span class="comment">// 启动一个goroutine登记+1</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done() <span class="comment">// goroutine结束登记-1</span></span><br><span class="line">fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line">fmt.Println(<span class="string">&quot;end...&quot;</span>)</span><br><span class="line">wg.Wait() <span class="comment">// 等待所有线程执行完,先输出:end... 再输出:hello</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将代码编译后执行，得到的输出结果和之前一致，但是这一次程序不再会有多余的停顿， 匿名函数的 <code>goroutine</code> 执行完毕后程序直接退出。</p><h2 id="启动多个goroutine">启动多个goroutine</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printHello</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">fmt.Println(<span class="string">&quot;hello&quot;</span>, i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> printHello(i)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多次执行上面的代码会发现每次终端上打印数字的顺序都不一致。因为10个 <code>goroutine</code> 是并发执行的，而 <code>goroutine</code> 的调度是随机的。</p><p>再来看个问题，将 <code>printHello()</code> 修改为匿名函数实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printHello</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done() <span class="comment">// goroutine结束就登记-1</span></span><br><span class="line">fmt.Println(<span class="string">&quot;hello:&quot;</span>, i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用匿名函数发现多次输出同一个值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closure2</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="comment">// 这里匿名函数的i是由外层循环提供的其实就是一个闭包</span></span><br><span class="line">fmt.Println(<span class="string">&quot;hello:&quot;</span>, i)</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">closure2()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多次执行上面的代码会发现每次终端上可能存在多次输出同一个值的问题，问题在于：匿名函数这里形成了一个闭包</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="comment">// 这里匿名函数的i是由外层循环提供的其实就是一个闭包</span></span><br><span class="line">fmt.Println(<span class="string">&quot;hello:&quot;</span>, i)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>解决办法也很简单：修改一下将参数 <code>i</code> 传入匿名函数中使用新变量接收：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closure3</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">fmt.Println(<span class="string">&quot;hello:&quot;</span>, i)</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/go/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/"/>
      <url>/go/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="原子操作">原子操作</h1><p>针对整数数据类型（int32、uint32、int64、uint64）我们还可以使用原子操作来保证并发安全，通常直接使用原子操作比使用锁操作效率更高。Go语言中原子操作由内置的标准库<code>sync/atomic</code>提供。</p><h2 id="atomic包">atomic包</h2><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:center">func LoadInt32(addr *int32) (val int32) func LoadInt64(addr *int64) (val int64) func LoadUint32(addr *uint32) (val uint32) func LoadUint64(addr *uint64) (val uint64) func LoadUintptr(addr *uintptr) (val uintptr) func LoadPointer(addr *unsafe.Pointer) (val unsafe.Pointer)</td><td style="text-align:center">读取操作</td></tr><tr><td style="text-align:center">func StoreInt32(addr *int32, val int32) func StoreInt64(addr *int64, val int64) func StoreUint32(addr *uint32, val uint32) func StoreUint64(addr *uint64, val uint64) func StoreUintptr(addr *uintptr, val uintptr) func StorePointer(addr *unsafe.Pointer, val unsafe.Pointer)</td><td style="text-align:center">写入操作</td></tr><tr><td style="text-align:center">func AddInt32(addr *int32, delta int32) (new int32) func AddInt64(addr *int64, delta int64) (new int64) func AddUint32(addr *uint32, delta uint32) (new uint32) func AddUint64(addr *uint64, delta uint64) (new uint64) func AddUintptr(addr *uintptr, delta uintptr) (new uintptr)</td><td style="text-align:center">修改操作</td></tr><tr><td style="text-align:center">func SwapInt32(addr *int32, new int32) (old int32) func SwapInt64(addr *int64, new int64) (old int64) func SwapUint32(addr *uint32, new uint32) (old uint32) func SwapUint64(addr *uint64, new uint64) (old uint64) func SwapUintptr(addr *uintptr, new uintptr) (old uintptr) func SwapPointer(addr *unsafe.Pointer, new unsafe.Pointer) (old unsafe.Pointer)</td><td style="text-align:center">交换操作</td></tr><tr><td style="text-align:center">func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool) func CompareAndSwapInt64(addr *int64, old, new int64) (swapped bool) func CompareAndSwapUint32(addr *uint32, old, new uint32) (swapped bool) func CompareAndSwapUint64(addr *uint64, old, new uint64) (swapped bool) func CompareAndSwapUintptr(addr *uintptr, old, new uintptr) (swapped bool) func CompareAndSwapPointer(addr *unsafe.Pointer, old, new unsafe.Pointer) (swapped bool)</td><td style="text-align:center">比较并交换操作</td></tr></tbody></table><h2 id="示例">示例</h2><p>我们填写一个示例来比较下互斥锁和原子操作的性能。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Counter <span class="keyword">interface</span> &#123;</span><br><span class="line">Inc()</span><br><span class="line">Load() <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通版</span></span><br><span class="line"><span class="keyword">type</span> CommonCounter <span class="keyword">struct</span> &#123;</span><br><span class="line">counter <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c CommonCounter)</span> <span class="title">Inc</span><span class="params">()</span></span> &#123;</span><br><span class="line">c.counter++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c CommonCounter)</span> <span class="title">Load</span><span class="params">()</span> <span class="title">int64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> c.counter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 互斥锁版</span></span><br><span class="line"><span class="keyword">type</span> MutexCounter <span class="keyword">struct</span> &#123;</span><br><span class="line">counter <span class="keyword">int64</span></span><br><span class="line">lock    sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MutexCounter)</span> <span class="title">Inc</span><span class="params">()</span></span> &#123;</span><br><span class="line">m.lock.Lock()</span><br><span class="line"><span class="keyword">defer</span> m.lock.Unlock()</span><br><span class="line">m.counter++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MutexCounter)</span> <span class="title">Load</span><span class="params">()</span> <span class="title">int64</span></span> &#123;</span><br><span class="line">m.lock.Lock()</span><br><span class="line"><span class="keyword">defer</span> m.lock.Unlock()</span><br><span class="line"><span class="keyword">return</span> m.counter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原子操作版</span></span><br><span class="line"><span class="keyword">type</span> AtomicCounter <span class="keyword">struct</span> &#123;</span><br><span class="line">counter <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *AtomicCounter)</span> <span class="title">Inc</span><span class="params">()</span></span> &#123;</span><br><span class="line">atomic.AddInt64(&amp;a.counter, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *AtomicCounter)</span> <span class="title">Load</span><span class="params">()</span> <span class="title">int64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> atomic.LoadInt64(&amp;a.counter)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(c Counter)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">start := time.Now()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">c.Inc()</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">end := time.Now()</span><br><span class="line">fmt.Println(c.Load(), end.Sub(start))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c1 := CommonCounter&#123;&#125; <span class="comment">// 非并发安全</span></span><br><span class="line">test(c1)</span><br><span class="line">c2 := MutexCounter&#123;&#125; <span class="comment">// 使用互斥锁实现并发安全</span></span><br><span class="line">test(&amp;c2)</span><br><span class="line">c3 := AtomicCounter&#123;&#125; <span class="comment">// 并发安全且比互斥锁效率更高</span></span><br><span class="line">test(&amp;c3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>atomic</code>包提供了底层的原子级内存操作，对于同步算法的实现很有用。这些函数必须谨慎地保证正确使用。除了某些特殊的底层应用，使用通道或者 sync 包的函数/类型实现同步更好。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/go/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E5%92%8C%E9%94%81/"/>
      <url>/go/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E5%92%8C%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="并发安全和锁">并发安全和锁</h1><p>有时候我们的代码中可能会存在多个 goroutine 同时操作一个资源（临界区）的情况，这种情况下就会发生<code>竞态问题</code>（数据竞态）。这就好比现实生活中十字路口被各个方向的汽车竞争，还有火车上的卫生间被车厢里的人竞争。</p><p>我们用下面的代码演示一个数据竞争的示例。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">x <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line">wg sync.WaitGroup <span class="comment">// 等待组</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// add 对全局变量x执行5000次加1操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++ &#123;</span><br><span class="line">x = x + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> add()</span><br><span class="line"><span class="keyword">go</span> add()</span><br><span class="line"></span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将上面的代码编译后执行，不出意外每次执行都会输出诸如9537、5865、6527等不同的结果。这是为什么呢？</p><p>在上面的示例代码片中，我们开启了两个 goroutine 分别执行 add 函数，这两个 goroutine 在访问和修改全局的<code>x</code>变量时就会存在数据竞争，某个 goroutine 中对全局变量<code>x</code>的修改可能会覆盖掉另一个 goroutine 中的操作，所以导致最后的结果与预期不符。</p><h2 id="互斥锁">互斥锁</h2><p>互斥锁是一种常用的控制共享资源访问的方法，它能够保证同一时间只有一个 goroutine 可以访问共享资源。Go 语言中使用<code>sync</code>包中提供的<code>Mutex</code>类型来实现互斥锁。</p><p><code>sync.Mutex</code>提供了两个方法供我们使用。</p><table><thead><tr><th style="text-align:center">方法名</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">func (m *Mutex) Lock()</td><td style="text-align:center">获取互斥锁</td></tr><tr><td style="text-align:center">func (m *Mutex) Unlock()</td><td style="text-align:center">释放互斥锁</td></tr></tbody></table><p>我们在下面的示例代码中使用互斥锁限制每次只有一个 goroutine 才能修改全局变量<code>x</code>，从而修复上面代码中的问题。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// sync.Mutex</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">x <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line">wg sync.WaitGroup <span class="comment">// 等待组</span></span><br><span class="line"></span><br><span class="line">m sync.Mutex <span class="comment">// 互斥锁</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// add 对全局变量x执行5000次加1操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++ &#123;</span><br><span class="line">m.Lock() <span class="comment">// 修改x前加锁</span></span><br><span class="line">x = x + <span class="number">1</span></span><br><span class="line">m.Unlock() <span class="comment">// 改完解锁</span></span><br><span class="line">&#125;</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> add()</span><br><span class="line"><span class="keyword">go</span> add()</span><br><span class="line"></span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面的代码编译后多次执行，每一次都会得到预期中的结果——10000。</p><p>使用互斥锁能够保证同一时间有且只有一个 goroutine 进入临界区，其他的 goroutine 则在等待锁；当互斥锁释放后，等待的 goroutine 才可以获取锁进入临界区，多个 goroutine 同时等待一个锁时，唤醒的策略是随机的。</p><h2 id="读写互斥锁">读写互斥锁</h2><p>互斥锁是完全互斥的，但是实际上有很多场景是读多写少的，当我们并发的去读取一个资源而不涉及资源修改的时候是没有必要加互斥锁的，这种场景下使用读写锁是更好的一种选择。读写锁在 Go 语言中使用<code>sync</code>包中的<code>RWMutex</code>类型。</p><p><code>sync.RWMutex</code>提供了以下5个方法。</p><table><thead><tr><th style="text-align:center">方法名</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">func (rw *RWMutex) Lock()</td><td style="text-align:center">获取写锁</td></tr><tr><td style="text-align:center">func (rw *RWMutex) Unlock()</td><td style="text-align:center">释放写锁</td></tr><tr><td style="text-align:center">func (rw *RWMutex) RLock()</td><td style="text-align:center">获取读锁</td></tr><tr><td style="text-align:center">func (rw *RWMutex) RUnlock()</td><td style="text-align:center">释放读锁</td></tr><tr><td style="text-align:center">func (rw *RWMutex) RLocker() Locker</td><td style="text-align:center">返回一个实现Locker接口的读写锁</td></tr></tbody></table><p>读写锁分为两种：读锁和写锁。当一个 goroutine 获取到读锁之后，其他的 goroutine 如果是获取读锁会继续获得锁，如果是获取写锁就会等待；而当一个 goroutine 获取写锁之后，其他的 goroutine 无论是获取读锁还是写锁都会等待。</p><p>下面我们使用代码构造一个读多写少的场景，然后分别使用互斥锁和读写锁查看它们的性能差异。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">x       <span class="keyword">int64</span></span><br><span class="line">wg      sync.WaitGroup</span><br><span class="line">mutex   sync.Mutex</span><br><span class="line">rwMutex sync.RWMutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// writeWithLock 使用互斥锁的写操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeWithLock</span><span class="params">()</span></span> &#123;</span><br><span class="line">mutex.Lock() <span class="comment">// 加互斥锁</span></span><br><span class="line">x = x + <span class="number">1</span></span><br><span class="line">time.Sleep(<span class="number">10</span> * time.Millisecond) <span class="comment">// 假设读操作耗时10毫秒</span></span><br><span class="line">mutex.Unlock()                    <span class="comment">// 解互斥锁</span></span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// readWithLock 使用互斥锁的读操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readWithLock</span><span class="params">()</span></span> &#123;</span><br><span class="line">mutex.Lock()                 <span class="comment">// 加互斥锁</span></span><br><span class="line">time.Sleep(time.Millisecond) <span class="comment">// 假设读操作耗时1毫秒</span></span><br><span class="line">mutex.Unlock()               <span class="comment">// 释放互斥锁</span></span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// writeWithLock 使用读写互斥锁的写操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeWithRWLock</span><span class="params">()</span></span> &#123;</span><br><span class="line">rwMutex.Lock() <span class="comment">// 加写锁</span></span><br><span class="line">x = x + <span class="number">1</span></span><br><span class="line">time.Sleep(<span class="number">10</span> * time.Millisecond) <span class="comment">// 假设读操作耗时10毫秒</span></span><br><span class="line">rwMutex.Unlock()                  <span class="comment">// 释放写锁</span></span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// readWithRWLock 使用读写互斥锁的读操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readWithRWLock</span><span class="params">()</span></span> &#123;</span><br><span class="line">rwMutex.RLock()              <span class="comment">// 加读锁</span></span><br><span class="line">time.Sleep(time.Millisecond) <span class="comment">// 假设读操作耗时1毫秒</span></span><br><span class="line">rwMutex.RUnlock()            <span class="comment">// 释放读锁</span></span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">(wf, rf <span class="keyword">func</span>()</span>, <span class="title">wc</span>, <span class="title">rc</span> <span class="title">int</span>)</span> &#123;</span><br><span class="line">start := time.Now()</span><br><span class="line"><span class="comment">// wc个并发写操作</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; wc; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> wf()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  rc个并发读操作</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; rc; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> rf()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wg.Wait()</span><br><span class="line">cost := time.Since(start)</span><br><span class="line">fmt.Printf(<span class="string">&quot;x:%v cost:%v\n&quot;</span>, x, cost)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们假设每一次读操作都会耗时1ms，而每一次写操作会耗时10ms，我们分别测试使用互斥锁和读写互斥锁执行10次并发写和1000次并发读的耗时数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用互斥锁，10并发写，1000并发读</span></span><br><span class="line">do(writeWithLock, readWithLock, <span class="number">10</span>, <span class="number">1000</span>) <span class="comment">// x:10 cost:1.466500951s</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用读写互斥锁，10并发写，1000并发读</span></span><br><span class="line">do(writeWithRWLock, readWithRWLock, <span class="number">10</span>, <span class="number">1000</span>) <span class="comment">// x:10 cost:117.207592ms</span></span><br></pre></td></tr></table></figure><p>从最终的执行结果可以看出，使用读写互斥锁在读多写少的场景下能够极大地提高程序的性能。不过需要注意的是如果一个程序中的读操作和写操作数量级差别不大，那么读写互斥锁的优势就发挥不出来。</p><h2 id="sync-WaitGroup">sync.WaitGroup</h2><p>在代码中生硬的使用<code>time.Sleep</code>肯定是不合适的，Go语言中可以使用<code>sync.WaitGroup</code>来实现并发任务的同步。 <code>sync.WaitGroup</code>有以下几个方法：</p><table><thead><tr><th style="text-align:center">方法名</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">func (wg * WaitGroup) Add(delta int)</td><td style="text-align:center">计数器+delta</td></tr><tr><td style="text-align:center">(wg *WaitGroup) Done()</td><td style="text-align:center">计数器-1</td></tr><tr><td style="text-align:center">(wg *WaitGroup) Wait()</td><td style="text-align:center">阻塞直到计数器变为0</td></tr></tbody></table><p><code>sync.WaitGroup</code>内部维护着一个计数器，计数器的值可以增加和减少。例如当我们启动了 N 个并发任务时，就将计数器值增加N。每个任务完成时通过调用 Done 方法将计数器减1。通过调用 Wait 来等待并发任务执行完，当计数器值为 0 时，表示所有并发任务已经完成。</p><p>我们利用<code>sync.WaitGroup</code>将上面的代码优化一下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">fmt.Println(<span class="string">&quot;Hello Goroutine!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> hello() <span class="comment">// 启动另外一个goroutine去执行hello函数</span></span><br><span class="line">fmt.Println(<span class="string">&quot;main goroutine done!&quot;</span>)</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意<code>sync.WaitGroup</code>是一个结构体，进行参数传递的时候要传递指针。</p><h2 id="sync-Once">sync.Once</h2><p>在某些场景下我们需要确保某些操作即使在高并发的场景下也只会被执行一次，例如只加载一次配置文件等。</p><p>Go语言中的<code>sync</code>包中提供了一个针对只执行一次场景的解决方案——<code>sync.Once</code>，<code>sync.Once</code>只有一个<code>Do</code>方法，其签名如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span> <span class="title">Do</span><span class="params">(f <span class="keyword">func</span>()</span>)</span></span><br></pre></td></tr></table></figure><p>**注意：**如果要执行的函数<code>f</code>需要传递参数就需要搭配闭包来使用。</p><h2 id="加载配置文件示例">加载配置文件示例</h2><p>延迟一个开销很大的初始化操作到真正用到它的时候再执行是一个很好的实践。因为预先初始化一个变量（比如在init函数中完成初始化）会增加程序的启动耗时，而且有可能实际执行过程中这个变量没有用上，那么这个初始化操作就不是必须要做的。我们来看一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> icons <span class="keyword">map</span>[<span class="keyword">string</span>]image.Image</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadIcons</span><span class="params">()</span></span> &#123;</span><br><span class="line">icons = <span class="keyword">map</span>[<span class="keyword">string</span>]image.Image&#123;</span><br><span class="line"><span class="string">&quot;left&quot;</span>:  loadIcon(<span class="string">&quot;left.png&quot;</span>),</span><br><span class="line"><span class="string">&quot;up&quot;</span>:    loadIcon(<span class="string">&quot;up.png&quot;</span>),</span><br><span class="line"><span class="string">&quot;right&quot;</span>: loadIcon(<span class="string">&quot;right.png&quot;</span>),</span><br><span class="line"><span class="string">&quot;down&quot;</span>:  loadIcon(<span class="string">&quot;down.png&quot;</span>),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Icon 被多个goroutine调用时不是并发安全的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Icon</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">image</span>.<span class="title">Image</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> icons == <span class="literal">nil</span> &#123;</span><br><span class="line">loadIcons()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> icons[name]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多个 goroutine 并发调用Icon函数时不是并发安全的，现代的编译器和CPU可能会在保证每个 goroutine 都满足串行一致的基础上自由地重排访问内存的顺序。loadIcons函数可能会被重排为以下结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadIcons</span><span class="params">()</span></span> &#123;</span><br><span class="line">icons = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]image.Image)</span><br><span class="line">icons[<span class="string">&quot;left&quot;</span>] = loadIcon(<span class="string">&quot;left.png&quot;</span>)</span><br><span class="line">icons[<span class="string">&quot;up&quot;</span>] = loadIcon(<span class="string">&quot;up.png&quot;</span>)</span><br><span class="line">icons[<span class="string">&quot;right&quot;</span>] = loadIcon(<span class="string">&quot;right.png&quot;</span>)</span><br><span class="line">icons[<span class="string">&quot;down&quot;</span>] = loadIcon(<span class="string">&quot;down.png&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种情况下就会出现即使判断了<code>icons</code>不是nil也不意味着变量初始化完成了。考虑到这种情况，我们能想到的办法就是添加互斥锁，保证初始化<code>icons</code>的时候不会被其他的 goroutine 操作，但是这样做又会引发性能问题。</p><p>使用<code>sync.Once</code>改造的示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> icons <span class="keyword">map</span>[<span class="keyword">string</span>]image.Image</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> loadIconsOnce sync.Once</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadIcons</span><span class="params">()</span></span> &#123;</span><br><span class="line">icons = <span class="keyword">map</span>[<span class="keyword">string</span>]image.Image&#123;</span><br><span class="line"><span class="string">&quot;left&quot;</span>:  loadIcon(<span class="string">&quot;left.png&quot;</span>),</span><br><span class="line"><span class="string">&quot;up&quot;</span>:    loadIcon(<span class="string">&quot;up.png&quot;</span>),</span><br><span class="line"><span class="string">&quot;right&quot;</span>: loadIcon(<span class="string">&quot;right.png&quot;</span>),</span><br><span class="line"><span class="string">&quot;down&quot;</span>:  loadIcon(<span class="string">&quot;down.png&quot;</span>),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Icon 是并发安全的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Icon</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">image</span>.<span class="title">Image</span></span> &#123;</span><br><span class="line">loadIconsOnce.Do(loadIcons)</span><br><span class="line"><span class="keyword">return</span> icons[name]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="并发安全的单例模式">并发安全的单例模式</h2><p>下面是借助<code>sync.Once</code>实现的并发安全的单例模式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> singleton</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> singleton <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance *singleton</span><br><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">()</span> *<span class="title">singleton</span></span> &#123;</span><br><span class="line">    once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        instance = &amp;singleton&#123;&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sync.Once</code>其实内部包含一个互斥锁和一个布尔值，互斥锁保证布尔值和数据的安全，而布尔值用来记录初始化是否完成。这样设计就能保证初始化操作的时候是并发安全的并且初始化操作也不会被执行多次。</p><h2 id="sync-Map">sync.Map</h2><p>Go 语言中内置的 map 不是并发安全的，请看下面这段示例代码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> m[key]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">set</span><span class="params">(key <span class="keyword">string</span>, value <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">m[key] = value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg := sync.WaitGroup&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">key := strconv.Itoa(n)</span><br><span class="line">set(key, n)</span><br><span class="line">fmt.Printf(<span class="string">&quot;k=:%v,v:=%v\n&quot;</span>, key, get(key))</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面的代码编译后执行，会报出<code>fatal error: concurrent map writes</code>错误。我们不能在多个 goroutine 中并发对内置的 map 进行读写操作，否则会存在数据竞争问题。</p><p>像这种场景下就需要为 map 加锁来保证并发的安全性了，Go语言的<code>sync</code>包中提供了一个开箱即用的并发安全版 map——<code>sync.Map</code>。开箱即用表示其不用像内置的 map 一样使用 make 函数初始化就能直接使用。同时<code>sync.Map</code>内置了诸如<code>Store</code>、<code>Load</code>、<code>LoadOrStore</code>、<code>Delete</code>、<code>Range</code>等操作方法。</p><table><thead><tr><th style="text-align:center">方法名</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">func (m *Map) Store(key, value interface{})</td><td style="text-align:center">存储key-value数据</td></tr><tr><td style="text-align:center">func (m *Map) Load(key interface{}) (value interface{}, ok bool)</td><td style="text-align:center">查询key对应的value</td></tr><tr><td style="text-align:center">func (m *Map) LoadOrStore(key, value interface{}) (actual interface{}, loaded bool)</td><td style="text-align:center">查询或存储key对应的value</td></tr><tr><td style="text-align:center">func (m *Map) LoadAndDelete(key interface{}) (value interface{}, loaded bool)</td><td style="text-align:center">查询并删除key</td></tr><tr><td style="text-align:center">func (m *Map) Delete(key interface{})</td><td style="text-align:center">删除key</td></tr><tr><td style="text-align:center">func (m *Map) Range(f func(key, value interface{}) bool)</td><td style="text-align:center">对map中的每个key-value依次调用f</td></tr></tbody></table><p>下面的代码示例演示了并发读写<code>sync.Map</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并发安全的map</span></span><br><span class="line"><span class="keyword">var</span> m = sync.Map&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg := sync.WaitGroup&#123;&#125;</span><br><span class="line"><span class="comment">// 对m执行20个并发的读写操作</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">20</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">key := strconv.Itoa(n)</span><br><span class="line">m.Store(key, n)         <span class="comment">// 存储key-value</span></span><br><span class="line">value, _ := m.Load(key) <span class="comment">// 根据key取值</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;k=:%v,v:=%v\n&quot;</span>, key, value)</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="-v8"></h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/go/%E6%A0%87%E5%87%86%E5%BA%93/flag/"/>
      <url>/go/%E6%A0%87%E5%87%86%E5%BA%93/flag/</url>
      
        <content type="html"><![CDATA[<p>Go语言内置的<code>flag</code>包实现了命令行参数的解析，使得开发命令行工具更为简单。</p><h1 id="os-Args">os.Args</h1><p>如果只是简单的想要获取命令行参数，可以像下面的代码示例一样使用 <code>os.Args</code> 来获取命令行参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最简单的获取命令行参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getOsArgs</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// os.Args是一个[]string</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(os.Args) &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">for</span> index, arg := <span class="keyword">range</span> os.Args &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;args[%d]=%v\n&quot;</span>, index, arg)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PS D:\GoProject\src&gt; go run .\flagTest.go <span class="string">&quot;a&quot;</span> <span class="string">&quot;s&quot;</span> <span class="string">&quot;1&quot;</span></span><br><span class="line">args[0]=C:\Users\ADMINI~1\AppData\Local\Temp\go-build752076497\b001\exe\flagTest.exe</span><br><span class="line">args[1]=a</span><br><span class="line">args[2]=s</span><br><span class="line">args[3]=1</span><br></pre></td></tr></table></figure><p><code>os.Args</code> 是一个存储命令行参数的字符串切片，第一个元素是执行文件的名称。</p><h1 id="flag包使用">flag包使用</h1><p>介绍 <code>flag</code> 包的常用函数和基本用法，更详细的内容请查看<a href="https://studygolang.com/pkgdoc">官方文档</a>。</p><h1 id="导入flag包">导入flag包</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> flag</span><br></pre></td></tr></table></figure><h1 id="flag参数类型">flag参数类型</h1><p><code>flag</code>  包支持的命令行参数类型有<code>bool</code>、<code>int</code>、<code>int64</code>、<code>uint</code>、<code>uint64</code>、<code>float</code> <code>float64</code>、<code>string</code>、<code>duration</code>。</p><table><thead><tr><th style="text-align:center">flag参数</th><th style="text-align:center">有效值</th></tr></thead><tbody><tr><td style="text-align:center">字符串flag</td><td style="text-align:center">合法字符串</td></tr><tr><td style="text-align:center">整数flag</td><td style="text-align:center">1234、0664、0x1234等类型，也可以是负数。</td></tr><tr><td style="text-align:center">浮点数flag</td><td style="text-align:center">合法浮点数</td></tr><tr><td style="text-align:center">bool类型flag</td><td style="text-align:center">1, 0, t, f, T, F, true, false, TRUE, FALSE, True, False。</td></tr><tr><td style="text-align:center">时间段flag</td><td style="text-align:center">任何合法的时间段字符串。如”300ms”、”-1.5h”。 合法的单位有”ns”、”us” /“µs”、”ms”、”s”、”m”、”h”。</td></tr></tbody></table><h1 id="定义命令行flag参数">定义命令行flag参数</h1><p>有以下两种常用的定义命令行 <code>flag</code> 参数的方法。</p><h3 id="flag-Type">flag.Type()</h3><p>基本格式：<code>flag.Type(flag名, 默认值, 帮助信息)*Type</code></p><p>例如：要定义姓名、年龄、婚否三个命令行参数可以按如下方式定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name := flag.String(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三&quot;</span>, <span class="string">&quot;姓名&quot;</span>)</span><br><span class="line">age := flag.Int(<span class="string">&quot;age&quot;</span>, <span class="number">18</span>, <span class="string">&quot;年龄&quot;</span>)</span><br><span class="line">married := flag.Bool(<span class="string">&quot;m&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;婚否&quot;</span>)</span><br><span class="line">delay := flag.Duration(<span class="string">&quot;d&quot;</span>, <span class="number">0</span>, <span class="string">&quot;时间间隔&quot;</span>)</span><br></pre></td></tr></table></figure><p>需要注意：此时<code>name</code>、<code>age</code>、<code>married</code>、<code>delay</code>均为对应类型的指针。</p><h3 id="flag-TypeVar">flag.TypeVar()</h3><p>基本格式： <code>flag.TypeVar(Type指针, flag名, 默认值, 帮助信息)</code></p><p>例如要定义姓名、年龄、婚否三个命令行参数，可以按如下方式定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> age <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> married <span class="keyword">bool</span></span><br><span class="line"><span class="keyword">var</span> delay time.Duration</span><br><span class="line">flag.StringVar(&amp;name, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三&quot;</span>, <span class="string">&quot;姓名&quot;</span>)</span><br><span class="line">flag.IntVar(&amp;age, <span class="string">&quot;age&quot;</span>, <span class="number">18</span>, <span class="string">&quot;年龄&quot;</span>)</span><br><span class="line">flag.BoolVar(&amp;married, <span class="string">&quot;m&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;婚否&quot;</span>)</span><br><span class="line">flag.DurationVar(&amp;delay, <span class="string">&quot;d&quot;</span>, <span class="number">0</span>, <span class="string">&quot;时间间隔&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="解析命令行参数">解析命令行参数</h1><p>通过以上两种方法定义好命令行flag参数后，需要通过调用<code>flag.Parse()</code>来对命令行参数进行解析</p><p>支持的命令行参数格式有以下几种：</p><ul><li><code>-flag xxx</code> （使用空格，一个<code>-</code>符号）</li><li><code>--flag xxx</code> （使用空格，两个<code>-</code>符号）</li><li><code>-flag=xxx</code> （使用等号，一个<code>-</code>符号）</li><li><code>--flag=xxx</code> （使用等号，两个<code>-</code>符号）</li></ul><p>其中，布尔类型的参数必须使用等号的方式指定。</p><p>Flag 解析在第一个非flag参数（单个”-“不是flag参数）之前停止，或者在终止符”–“之后停止。</p><h1 id="flag其他函数">flag其他函数</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flag.Args()  <span class="comment">// 返回命令行参数后的其他参数，以[]string类型</span></span><br><span class="line">flag.NArg()  <span class="comment">// 返回命令行参数后的其他参数个数</span></span><br><span class="line">flag.NFlag() <span class="comment">// 返回使用的命令行参数个数</span></span><br></pre></td></tr></table></figure><h1 id="使用示例">使用示例</h1><p>命令行参数使用提示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PS D:\GoProject\src&gt; go run .\flagTest.go -<span class="built_in">help</span> </span><br><span class="line">Usage of C:\Users\ADMINI~1\AppData\Local\Temp\go-build3280475971\b001\exe\flagTest.exe:</span><br><span class="line">  -age int</span><br><span class="line">        年龄 (default 18)</span><br><span class="line">  -d duration</span><br><span class="line">        时间间隔</span><br><span class="line">  -m    婚否</span><br><span class="line">  -name string</span><br><span class="line">        姓名 (default <span class="string">&quot;张三&quot;</span>)</span><br></pre></td></tr></table></figure><p>正常使用命令行flag参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PS D:\GoProject\src&gt; go run .\flagTest.go -name=wpl -age=18 -m=<span class="literal">false</span> --d=1h</span><br><span class="line">wpl 18 <span class="literal">false</span> 1h0m0s</span><br><span class="line">[]</span><br><span class="line">0 </span><br><span class="line">4 </span><br></pre></td></tr></table></figure><p>使用非flag命令行参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PS D:\GoProject\src&gt; go run .\flagTest.go  a b c                           </span><br><span class="line">张三 18 <span class="literal">false</span> 0s</span><br><span class="line">[a b c]</span><br><span class="line">3      </span><br><span class="line">0     </span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/go/%E6%A0%87%E5%87%86%E5%BA%93/fmt/"/>
      <url>/go/%E6%A0%87%E5%87%86%E5%BA%93/fmt/</url>
      
        <content type="html"><![CDATA[<p><code>fmt</code> 包实现了类似C#语言 <code>Console.Writeline</code> 和 <code>Console.ReadLine</code> 的格式化I/O。主要分为输出内容和获取输入两部分。</p><h1 id="输出">输出</h1><p>标准库 <code>fmt</code> 提供了以下几种输出相关函数。</p><h2 id="Print">Print</h2><p><code>Print </code> 系列函数会将内容输出到系统的标准输出，区别在于<code>Print</code>函数直接输出内容，<code>Printf</code>函数支持格式化输出字符串，<code>Println</code> 函数会在输出内容的结尾添加一个换行符。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Print</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Printf</span><span class="params">(format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Println</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fmtPrint</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Print(<span class="string">&quot;在终端打印该信息&quot;</span>)</span><br><span class="line">name := <span class="string">&quot;wangpengliang&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;我是：%s\n&quot;</span>, name)</span><br><span class="line">fmt.Println(<span class="string">&quot;在终端打印单独一行显示&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在终端打印该信息我是：wangpengliang</span><br><span class="line">在终端打印单独一行显示</span><br></pre></td></tr></table></figure><h2 id="Fprint">Fprint</h2><p><code>Fprint</code> 系列函数会将内容输出到一个 <code>io.Writer</code> 接口类型的变量 <code>w</code> 中，通常用这个函数往文件中写入内容。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fprint</span><span class="params">(w io.Writer, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fprintf</span><span class="params">(w io.Writer, format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fprintln</span><span class="params">(w io.Writer, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fmtFprint</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 向标准输出写入内容</span></span><br><span class="line">fmt.Fprintln(os.Stdout, <span class="string">&quot;向标准输出写入内容&quot;</span>)</span><br><span class="line">fileObj, err := os.OpenFile(<span class="string">&quot;./fprintTest.txt&quot;</span>, os.O_CREATE|os.O_WRONLY|os.O_APPEND, <span class="number">0644</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;打开文件出错，err:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">name := <span class="string">&quot;wangpengliang&quot;</span></span><br><span class="line"><span class="comment">// 向打开的文件句柄中写入内容</span></span><br><span class="line">fmt.Fprintf(fileObj, <span class="string">&quot;往文件中写入信息：%s&quot;</span>, name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：只要满足 <code>io.Writer</code> 接口的类型都支持写入。</p><h2 id="Sprint">Sprint</h2><p><code>Sprint</code>系列函数会把传入的数据生成并返回一个字符串。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sprint</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sprintf</span><span class="params">(format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sprintln</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fmtSprint</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="string">&quot;wangpengliang&quot;</span></span><br><span class="line">s1 := fmt.Sprint(s)</span><br><span class="line"></span><br><span class="line">s2 := fmt.Sprintf(<span class="string">&quot;name:%s,age:%d&quot;</span>, <span class="string">&quot;wangpengliang&quot;</span>, <span class="number">18</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(s1, s2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Errorf">Errorf</h2><p><code>Errorf</code> 函数根据 <code>format</code> 参数生成格式化字符串并返回一个包含该字符串的错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Errorf</span><span class="params">(format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure><p>通常使用这种方式来自定义错误类型，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err := fmt.Errorf(<span class="string">&quot;这是一个错误&quot;</span>)</span><br></pre></td></tr></table></figure><p>Go1.13 版本为 <code>fmt.Errorf</code> 函数新加了一个<code>%w</code>占位符用来生成一个可以包裹 <code>Error</code> 的 <code>Wrapping Error</code> 。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">errorof</span><span class="params">()</span></span> &#123;</span><br><span class="line">e := errors.New(<span class="string">&quot;原始错误e&quot;</span>)</span><br><span class="line">w := fmt.Errorf(<span class="string">&quot;Wrap了一个错误%w&quot;</span>, e)</span><br><span class="line">fmt.Println(w)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="格式化占位符">格式化占位符</h1><p><code>*printf</code> 系列函数都支持 <code>format</code> 格式化参数，这里按照占位符将被替换的变量类型划分，方便查询和记忆。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">%v，原样输出</span><br><span class="line">%T，打印类型</span><br><span class="line">%t，<span class="keyword">bool</span>类型</span><br><span class="line">%s，字符串</span><br><span class="line">%f，浮点</span><br><span class="line">%d，<span class="number">10</span>进制的整数</span><br><span class="line">%b，<span class="number">2</span>进制的整数</span><br><span class="line">%o，<span class="number">8</span>进制</span><br><span class="line">%x，%X，<span class="number">16</span>进制</span><br><span class="line">%x：<span class="number">0</span><span class="number">-9</span>，a-f</span><br><span class="line">%X：<span class="number">0</span><span class="number">-9</span>，A-F</span><br><span class="line">%c，打印字符</span><br><span class="line">%p，打印内存地址</span><br></pre></td></tr></table></figure><h2 id="通用占位符">通用占位符</h2><table><thead><tr><th style="text-align:center">占位符</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>%v</code></td><td style="text-align:center">值的默认格式表示</td></tr><tr><td style="text-align:center"><code>%+v</code></td><td style="text-align:center">类似%v，但输出结构体时会添加字段名</td></tr><tr><td style="text-align:center"><code>%#v</code></td><td style="text-align:center">值的Go语法表示</td></tr><tr><td style="text-align:center"><code>%T</code></td><td style="text-align:center">打印值的类型</td></tr><tr><td style="text-align:center"><code>%%</code></td><td style="text-align:center">百分号</td></tr></tbody></table><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generalPlaceholder</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, <span class="number">100</span>)   <span class="comment">// %v：默认格式输出</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, <span class="literal">false</span>) <span class="comment">// %v：默认格式输出</span></span><br><span class="line">o := <span class="keyword">struct</span>&#123; name <span class="keyword">string</span> &#125;&#123;<span class="string">&quot;wangpengliang&quot;</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, o)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, o) <span class="comment">// %+v：类似%v，但输出结构体时会添加字段名</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, o) <span class="comment">// %#v：值的Go语法表示</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, o)  <span class="comment">// %T：打印值的类型</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;100%%\n&quot;</span>)  <span class="comment">// %%：百分号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">100</span><br><span class="line">false</span><br><span class="line">&#123;wangpengliang&#125;</span><br><span class="line">&#123;name:wangpengliang&#125;</span><br><span class="line">struct &#123; name string &#125;&#123;name:&quot;wangpengliang&quot;&#125;</span><br><span class="line">struct &#123; name string &#125;</span><br><span class="line"><span class="meta">100%</span></span><br></pre></td></tr></table></figure><h2 id="布尔型">布尔型</h2><table><thead><tr><th style="text-align:center">占位符</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>%t</code></td><td style="text-align:center">true或false</td></tr></tbody></table><h2 id="整型">整型</h2><table><thead><tr><th style="text-align:center">占位符</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>%b</code></td><td style="text-align:center">表示为二进制</td></tr><tr><td style="text-align:center"><code>%c</code></td><td style="text-align:center">该值对应的unicode码值</td></tr><tr><td style="text-align:center"><code>%d</code></td><td style="text-align:center">表示为十进制</td></tr><tr><td style="text-align:center"><code>%o</code></td><td style="text-align:center">表示为八进制</td></tr><tr><td style="text-align:center"><code>%x</code></td><td style="text-align:center">表示为十六进制，使用a-f</td></tr><tr><td style="text-align:center"><code>%X</code></td><td style="text-align:center">表示为十六进制，使用A-F</td></tr><tr><td style="text-align:center"><code>%U</code></td><td style="text-align:center">表示为Unicode格式：U+1234，等价于”U+%04X”</td></tr><tr><td style="text-align:center"><code>%q</code></td><td style="text-align:center">该值对应的单引号括起来的go语法字符字面值，必要时会采用安全的转义表示</td></tr></tbody></table><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intPlaceholderTest</span><span class="params">()</span></span> &#123;</span><br><span class="line">n := <span class="number">65</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%b\n&quot;</span>, n) <span class="comment">// %b：二进制输出</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%c\n&quot;</span>, n) <span class="comment">// %c：输出对应的unicode编码</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%d\n&quot;</span>, n) <span class="comment">// %d:十进制输出</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%o\n&quot;</span>, n) <span class="comment">// %o:八进制输出</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%x\n&quot;</span>, n) <span class="comment">// %x:十六进制输出,使用a-f</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%X\n&quot;</span>, n) <span class="comment">// %X:十六进制输出，使用A-F</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1000001</span><br><span class="line">A  </span><br><span class="line">65 </span><br><span class="line">101</span><br><span class="line">41 </span><br><span class="line">41</span><br></pre></td></tr></table></figure><h2 id="浮点数与复数">浮点数与复数</h2><table><thead><tr><th style="text-align:center">占位符</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>%b</code></td><td style="text-align:center">无小数部分、二进制指数的科学计数法，如-123456p-78</td></tr><tr><td style="text-align:center"><code>%e</code></td><td style="text-align:center">科学计数法，如-1234.456e+78</td></tr><tr><td style="text-align:center"><code>%E</code></td><td style="text-align:center">科学计数法，如-1234.456E+78</td></tr><tr><td style="text-align:center"><code>%f</code></td><td style="text-align:center">有小数部分但无指数部分，如123.456</td></tr><tr><td style="text-align:center"><code>%F</code></td><td style="text-align:center">等价于%f</td></tr><tr><td style="text-align:center"><code>%g</code></td><td style="text-align:center">根据实际情况采用%e或%f格式（以获得更简洁、准确的输出）</td></tr><tr><td style="text-align:center"><code>%G</code></td><td style="text-align:center">根据实际情况采用%E或%F格式（以获得更简洁、准确的输出）</td></tr></tbody></table><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">floatPlaceholder</span><span class="params">()</span></span> &#123;</span><br><span class="line">f := <span class="number">12.34</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%b\n&quot;</span>, f) <span class="comment">// %b：无小数部分、二进制指数的科学计数法</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%e\n&quot;</span>, f) <span class="comment">// %e: 科学计数法,如-1234.456e+78</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%E\n&quot;</span>, f) <span class="comment">// %E: 科学计数法,如-1234.456E+78</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%f\n&quot;</span>, f) <span class="comment">// %f: 有小数部分但无指数部分，如123.456</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%g\n&quot;</span>, f) <span class="comment">// %g: 根据实际情况采用%e或%f格式（以获得更简洁、准确的输出）</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%G\n&quot;</span>, f) <span class="comment">// %G: 根据实际情况采用%E或%F格式（以获得更简洁、准确的输出）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">6946802425218990p-49</span><br><span class="line">1.234000e+01</span><br><span class="line">1.234000E+01</span><br><span class="line">12.340000   </span><br><span class="line">12.34       </span><br><span class="line">12.34</span><br></pre></td></tr></table></figure><h2 id="字符串和-byte">字符串和[]byte</h2><table><thead><tr><th style="text-align:center">占位符</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>%s</code></td><td style="text-align:center">直接输出字符串或者[]byte</td></tr><tr><td style="text-align:center"><code>%q</code></td><td style="text-align:center">该值对应的双引号括起来的go语法字符串字面值，必要时会采用安全的转义表示</td></tr><tr><td style="text-align:center"><code>%x</code></td><td style="text-align:center">每个字节用两字符十六进制数表示（使用a-f)</td></tr><tr><td style="text-align:center"><code>%X</code></td><td style="text-align:center">每个字节用两字符十六进制数表示（使用A-F）</td></tr></tbody></table><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stringPlaceholder</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="string">&quot;wangpengliang&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, s) <span class="comment">// %s：直接输出字符串或者[]byte</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, s) <span class="comment">// %q: 该值对应的双引号括起来的go语法字符串字面值，必要时会采用安全的转义表示</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%x\n&quot;</span>, s) <span class="comment">// %x: 每个字节用两字符十六进制数表示（使用a-f)</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%X\n&quot;</span>, s) <span class="comment">// %X: 每个字节用两字符十六进制数表示（使用A-F)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wangpengliang</span><br><span class="line"><span class="string">&quot;wangpengliang&quot;</span></span><br><span class="line">77616e6770656e676c69616e67</span><br><span class="line">77616E6770656E676C69616E67</span><br></pre></td></tr></table></figure><h2 id="指针">指针</h2><table><thead><tr><th style="text-align:center">占位符</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>%p</code></td><td style="text-align:center">表示为十六进制，并加上前导的<code>0x</code></td></tr></tbody></table><p>示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pointerPlaceholder</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="number">10</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, &amp;a)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#p\n&quot;</span>, &amp;a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0xc000012088</span><br><span class="line">c000012088</span><br></pre></td></tr></table></figure><h2 id="宽度标识符">宽度标识符</h2><p>宽度通过一个紧跟在百分号后面的十进制数指定，如果未指定宽度，则表示值时除必需之外不作填充。精度通过（可选的）宽度后跟点号后跟的十进制数指定。如果未指定精度，会使用默认精度；如果点号后没有跟数字，表示精度为0。举例如下：</p><table><thead><tr><th style="text-align:center">占位符</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>%f</code></td><td style="text-align:center">默认宽度，默认精度</td></tr><tr><td style="text-align:center"><code>%9f</code></td><td style="text-align:center">宽度9，默认精度</td></tr><tr><td style="text-align:center"><code>%.2f</code></td><td style="text-align:center">默认宽度，精度2</td></tr><tr><td style="text-align:center"><code>%9.2f</code></td><td style="text-align:center">宽度9，精度2</td></tr><tr><td style="text-align:center"><code>%9.f</code></td><td style="text-align:center">宽度9，精度0</td></tr></tbody></table><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">breadth</span><span class="params">()</span></span> &#123;</span><br><span class="line">n := <span class="number">12.34</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%f\n&quot;</span>, n)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%9f\n&quot;</span>, n)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%.2f\n&quot;</span>, n)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%9.2f\n&quot;</span>, n)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%9.f\n&quot;</span>, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">12.340000</span><br><span class="line">12.340000</span><br><span class="line">12.34    </span><br><span class="line">    12.34</span><br><span class="line">       12</span><br></pre></td></tr></table></figure><h2 id="其他flag">其他flag</h2><table><thead><tr><th style="text-align:center">占位符</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>’+’</code></td><td style="text-align:center">总是输出数值的正负号；对%q（%+q）会生成全部是ASCII字符的输出（通过转义）</td></tr><tr><td style="text-align:center"><code>’ ‘</code></td><td style="text-align:center">对数值，正数前加空格而负数前加负号；对字符串采用%x或%X时（% x或% X）会给各打印的字节之间加空格</td></tr><tr><td style="text-align:center"><code>’-’</code></td><td style="text-align:center">在输出右边填充空白而不是默认的左边（即从默认的右对齐切换为左对齐）</td></tr><tr><td style="text-align:center"><code>’#’</code></td><td style="text-align:center">八进制数前加0（%#o），十六进制数前加0x（%#x）或0X（%#X），指针去掉前面的0x（%#p）对%q（%#q），对%U（%#U）会输出空格和单引号括起来的go字面值</td></tr><tr><td style="text-align:center"><code>‘0’</code></td><td style="text-align:center">使用0而不是空格填充，对于数值类型会把填充的0放在正负号后面</td></tr></tbody></table><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">otherPlaceholder</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="string">&quot;wangpengliang&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, s)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%5s\n&quot;</span>, s)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%-5s\n&quot;</span>, s)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%5.7s\n&quot;</span>, s)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%-5.7s\n&quot;</span>, s)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%5.2s\n&quot;</span>, s)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%05s\n&quot;</span>, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wangpengliang</span><br><span class="line">wangpengliang</span><br><span class="line">wangpengliang</span><br><span class="line">wangpen      </span><br><span class="line">wangpen</span><br><span class="line">   wa</span><br><span class="line">wangpengliang</span><br></pre></td></tr></table></figure><h1 id="获取输入">获取输入</h1><p>Go语言<code>fmt</code>包下有<code>fmt.Scan</code>、<code>fmt.Scanf</code>、<code>fmt.Scanln</code>三个函数，可以在程序运行过程中从标准输入获取用户的输入。</p><h2 id="fmt-Scan">fmt.Scan</h2><p>函数签名如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Scan</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure><ul><li>Scan从标准输入扫描文本，读取由空白符分隔的值保存到传递给本函数的参数中，换行符视为空白符</li><li>本函数返回成功扫描的数据个数和遇到的任何错误。如果读取的数据个数比提供的参数少，会返回一个错误报告原因</li></ul><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fmtScan</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;please input you name&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> input <span class="keyword">string</span></span><br><span class="line">fmt.Scanln(&amp;input) <span class="comment">//读取键盘输入，通过操作地址赋值给input.阻塞式</span></span><br><span class="line">fmt.Println(<span class="string">&quot;you name is：&quot;</span> + input)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;please input you name,age,sex&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age  <span class="keyword">int</span></span><br><span class="line">sex  <span class="keyword">bool</span></span><br><span class="line">)</span><br><span class="line">fmt.Scan(&amp;name, &amp;age, &amp;sex)</span><br><span class="line">fmt.Printf(<span class="string">&quot;扫描结果 name:%s age:%d sex:%t \n&quot;</span>, name, age, sex)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">please input you name</span><br><span class="line">wangpengliang</span><br><span class="line">you name is：wangpengliang   </span><br><span class="line">please input you name,age,sex</span><br><span class="line">wangpengliang 18 <span class="literal">true</span></span><br><span class="line">扫描结果 name:wangpengliang age:18 sex:<span class="literal">true</span></span><br></pre></td></tr></table></figure><p><code>fmt.Scan</code> 从标准输入中扫描用户输入的数据，将以空白符分隔的数据分别存入指定的参数。</p><h2 id="fmt-Scanf">fmt.Scanf</h2><p>函数签名如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Scanf</span><span class="params">(format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure><ul><li>Scanf从标准输入扫描文本，根据 <code>format</code> 参数指定的格式去读取由空白符分隔的值保存到传递给本函数的参数中</li><li>本函数返回成功扫描的数据个数和遇到的任何错误</li></ul><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fmtScanf</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age  <span class="keyword">int</span></span><br><span class="line">sex  <span class="keyword">bool</span></span><br><span class="line">)</span><br><span class="line">fmt.Scanf(<span class="string">&quot;1:%s 2:%d 3:%t&quot;</span>, &amp;name, &amp;age, &amp;sex)</span><br><span class="line">fmt.Printf(<span class="string">&quot;扫描结果 name:%s age:%d sex:%t \n&quot;</span>, name, age, sex)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面的代码编译后在终端执行，在终端按照指定的格式依次输入<code>1:wpl 2:18 3:true</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PS D:\GoProject\src\golang.basic&gt; go run .\fmtTest.go</span><br><span class="line">1:wpl 2:18 3:<span class="literal">true</span></span><br><span class="line">扫描结果 name:wpl age:18 sex:<span class="literal">true</span> </span><br></pre></td></tr></table></figure><p><code>fmt.Scanf</code> 不同于 <code>fmt.Scan</code> 简单的以空格作为输入数据的分隔符，<code>fmt.Scanf </code>为输入数据指定了具体的输入内容格式，只有按照格式输入数据才会被扫描并存入对应变量。</p><h2 id="fmt-Scanln">fmt.Scanln</h2><p>函数签名如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Scanln</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure><ul><li>Scanln类似Scan，它在遇到换行时才停止扫描。最后一个数据后面必须有换行或者到达结束位置</li><li>本函数返回成功扫描的数据个数和遇到的任何错误</li></ul><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fmtScanlnfTest</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age  <span class="keyword">int</span></span><br><span class="line">sex  <span class="keyword">bool</span></span><br><span class="line">)</span><br><span class="line">fmt.Scanln(&amp;name, &amp;age, &amp;sex)</span><br><span class="line">fmt.Printf(<span class="string">&quot;扫描结果 name:%s age:%d sex:%t \n&quot;</span>, name, age, sex)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面的代码编译后在终端执行，在终端依次输入<code>1</code>、<code>2</code>和<code>false</code>使用空格分隔。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PS D:\GoProject\src\golang.basic&gt; go run .\fmtTest.go</span><br><span class="line">1 2 <span class="literal">false</span></span><br><span class="line">扫描结果 name:1 age:2 sex:<span class="literal">false</span></span><br></pre></td></tr></table></figure><p><code>fmt.Scanln</code> 遇到回车就结束扫描了，这个比较常用。</p><h2 id="bufio-NewReader">bufio.NewReader</h2><p>有时候需要完整获取输入的内容，而输入的内容可能包含空格，这种情况下可以使用 <code>bufio</code> 包来实现。比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bufioTest</span><span class="params">()</span></span> &#123;</span><br><span class="line">reader := bufio.NewReader(os.Stdin) <span class="comment">// 从标准输入生成读对象</span></span><br><span class="line">fmt.Print(<span class="string">&quot;请输入内容：&quot;</span>)</span><br><span class="line">text, _ := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>) <span class="comment">// 读到换行</span></span><br><span class="line">text = strings.TrimSpace(text)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, text)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">请输入内容：1 2 3 43 435</span><br><span class="line">&quot;1 2 3 43 435&quot;</span><br></pre></td></tr></table></figure><h2 id="Fscan-系列">Fscan 系列</h2><p>这几个函数功能分别类似于 <code>fmt.Scan</code>、<code>fmt.Scanf</code>、<code>fmt.Scanln</code>三个函数，只不过它们不是从标准输入中读取数据而是从 <code>io.Reader</code> 中读取数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fscan</span><span class="params">(r io.Reader, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fscanln</span><span class="params">(r io.Reader, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fscanf</span><span class="params">(r io.Reader, format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure><h2 id="Sscan-系列">Sscan 系列</h2><p>这几个函数功能分别类似于 <code>fmt.Scan</code> 、 <code>fmt.Scanf</code> 、<code>fmt.Scanln</code> 三个函数，只不过它们不是从标准输入中读取数据而是从指定字符串中读取数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sscan</span><span class="params">(str <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sscanln</span><span class="params">(str <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sscanf</span><span class="params">(str <span class="keyword">string</span>, format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/go/%E6%A0%87%E5%87%86%E5%BA%93/log/"/>
      <url>/go/%E6%A0%87%E5%87%86%E5%BA%93/log/</url>
      
        <content type="html"><![CDATA[<p>Go语言内置的 <code>log</code> 包实现了简单的日志服务。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/go/%E6%A0%87%E5%87%86%E5%BA%93/time/"/>
      <url>/go/%E6%A0%87%E5%87%86%E5%BA%93/time/</url>
      
        <content type="html"><![CDATA[<p>学习Go语言内置的 <code>time</code> 包的基本用法，<code>time</code> 包提供了时间的显示和计算用的函数。日历计算采用公历。</p><p>时间可分为时间点与时间段，Go 提供了以下两种基础类型</p><ul><li>时间点 <code>Time</code></li><li>时间段 <code>Duration</code></li></ul><p>除此之外也提供了以下类型，做一些特定的业务</p><ul><li>时区 <code>Location</code></li><li><code>Ticker</code></li><li>定时器 <code>Timer</code></li></ul><h1 id="时间点">时间点</h1><p>一般使用的所有与时间相关的业务都是基于点而延伸的，两点组成一个时间段，大多数应用也都是围绕这些点与面去做逻辑处理。</p><h2 id="初始化">初始化</h2><p>go 针对不同的参数类型提供了以下初始化的方式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func Now() Time</span></span><br><span class="line">fmt.Println(time.Now())</span><br><span class="line"></span><br><span class="line"><span class="comment">// func Parse(layout, value string) (Time, error)</span></span><br><span class="line">time.Parse(<span class="string">&quot;2016-01-02 15:04:05&quot;</span>, <span class="string">&quot;2018-04-23 12:24:51&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// func ParseInLocation(layout, value string, loc *Location) (Time, error) (layout已带时区时可直接用Parse)</span></span><br><span class="line">time.ParseInLocation(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>, <span class="string">&quot;2017-05-11 14:06:06&quot;</span>, time.Local)</span><br><span class="line"></span><br><span class="line"><span class="comment">// func Unix(sec int64, nsec int64) Time</span></span><br><span class="line">time.Unix(<span class="number">1e9</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// func Date(year int, month Month, day, hour, min, sec, nsec int, loc *Location) Time</span></span><br><span class="line">time.Date(<span class="number">2018</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">15</span>, <span class="number">30</span>, <span class="number">10</span>, <span class="number">0</span>, time.Local)</span><br><span class="line"></span><br><span class="line"><span class="comment">// func (t Time) In(loc *Location) Time 当前时间对应指定时区的时间</span></span><br><span class="line">loc, _ := time.LoadLocation(<span class="string">&quot;America/Los_Angeles&quot;</span>)</span><br><span class="line">fmt.Println(time.Now().In(loc))</span><br><span class="line"></span><br><span class="line"><span class="comment">// func (t Time) Local() Time</span></span><br></pre></td></tr></table></figure><p>获取到时间点之后为了满足业务和设计，需要转换成需要的格式，也就是所谓的时间格式化。</p><h2 id="格式化">格式化</h2><h3 id="to-string">to string</h3><p>格式化为字符串我们需要使用 time.Format 方法来转换成我们想要的格式</p><pre><code>  fmt.Println(time.Now().Format(&quot;2006-01-02 15:04:05&quot;))  // 2018-04-24 10:11:20  fmt.Println(time.Now().Format(time.UnixDate))         // Tue Apr 24 09:59:02 CST 2018</code></pre><p>Format 函数中可以指定你想使用的格式，同时 time 包中也给了一些我们常用的格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">    ANSIC       = &quot;Mon Jan _2 15:04:05 2006&quot;</span><br><span class="line">    UnixDate    = &quot;Mon Jan _2 15:04:05 MST 2006&quot;</span><br><span class="line">    RubyDate    = &quot;Mon Jan 02 15:04:05 -0700 2006&quot;</span><br><span class="line">    RFC822      = &quot;02 Jan 06 15:04 MST&quot;</span><br><span class="line">    RFC822Z     = &quot;02 Jan 06 15:04 -0700&quot; // RFC822 with numeric zone</span><br><span class="line">    RFC850      = &quot;Monday, 02-Jan-06 15:04:05 MST&quot;</span><br><span class="line">    RFC1123     = &quot;Mon, 02 Jan 2006 15:04:05 MST&quot;</span><br><span class="line">    RFC1123Z    = &quot;Mon, 02 Jan 2006 15:04:05 -0700&quot; // RFC1123 with numeric zone</span><br><span class="line">    RFC3339     = &quot;2006-01-02T15:04:05Z07:00&quot;</span><br><span class="line">    RFC3339Nano = &quot;2006-01-02T15:04:05.999999999Z07:00&quot;</span><br><span class="line">    Kitchen     = &quot;3:04PM&quot;</span><br><span class="line">    // Handy time stamps.</span><br><span class="line">    Stamp      = &quot;Jan _2 15:04:05&quot;</span><br><span class="line">    StampMilli = &quot;Jan _2 15:04:05.000&quot;</span><br><span class="line">    StampMicro = &quot;Jan _2 15:04:05.000000&quot;</span><br><span class="line">    StampNano  = &quot;Jan _2 15:04:05.000000000&quot;</span><br><span class="line">)     </span><br></pre></td></tr></table></figure><p>注意: galang 中指定的特定时间格式为 “2006-01-02 15:04:05 -0700 MST”， 为了记忆方便，按照美式时间格式 月日时分秒年 外加时区 排列起来依次是 01/02 03:04:05PM ‘06 -0700，刚开始使用时需要注意。</p><h3 id="to-time-stamp">to time stamp</h3><p>​      func (t Time) Unix() int64<br>​      func (t Time) UnixNano() int64</p><pre><code>  fmt.Println(time.Now().Unix())  // 获取指定日期的时间戳  dt, _ := time.Parse(&quot;2016-01-02 15:04:05&quot;, &quot;2018-04-23 12:24:51&quot;)  fmt.Println(dt.Unix())  fmt.Println(time.Date(2018, 1,2,15,30,10,0, time.Local).Unix())</code></pre><h3 id="其他">其他</h3><p>time 包还提供了一些常用的方法，基本覆盖了大多数业务，从方法名就能知道代表的含义就不一一说明了。</p><pre><code>  func (t Time) Date() (year int, month Month, day int)  func (t Time) Clock() (hour, min, sec int)  func (t Time) Year() int  func (t Time) Month() Month  func (t Time) Day() int  func (t Time) Hour() int  func (t Time) Minute() int  func (t Time) Second() int  func (t Time) Nanosecond() int  func (t Time) YearDay() int  func (t Time) Weekday() Weekday  func (t Time) ISOWeek() (year, week int)  func (t Time) IsZero() bool  func (t Time) Local() Time  func (t Time) Location() *Location  func (t Time) Zone() (name string, offset int)  func (t Time) Unix() int64</code></pre><h1 id="时间类型">时间类型</h1><p><code>time.Time</code> 类型表示时间。可以通过 <code>time.Now()</code> 函数获取当前的时间对象，然后获取时间对象的年月日时分秒等信息。</p><p>示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getTimeNow</span><span class="params">()</span></span> &#123;</span><br><span class="line">now := time.Now() <span class="comment">//获取当前时间</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;current time:%v\n&quot;</span>, now)</span><br><span class="line"></span><br><span class="line">year := now.Year()     <span class="comment">//年</span></span><br><span class="line">month := now.Month()   <span class="comment">//月</span></span><br><span class="line">day := now.Day()       <span class="comment">//日</span></span><br><span class="line">hour := now.Hour()     <span class="comment">//小时</span></span><br><span class="line">minute := now.Minute() <span class="comment">//分钟</span></span><br><span class="line">second := now.Second() <span class="comment">//秒</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%d-%02d-%02d %02d:%02d:%02d\n&quot;</span>, year, month, day, hour, minute, second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="时间戳">时间戳</h1><p>时间戳是自 <code>1970年1月1日（08:00:00GMT）</code>至当前时间的总毫秒数。也被称为 <code>Unix时间戳</code>。</p><p>示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取时间戳</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getUnix</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 获取时间戳</span></span><br><span class="line">timestamp1 := time.Now().Unix()     <span class="comment">//时间戳</span></span><br><span class="line">timestamp2 := time.Now().UnixNano() <span class="comment">//纳秒时间戳</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;current timestamp1:%v\n&quot;</span>, timestamp1)</span><br><span class="line">fmt.Printf(<span class="string">&quot;current timestamp2:%v\n&quot;</span>, timestamp2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>time.Unix()</code> 函数可以将时间戳转为时间格式。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unixConverTime</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 将时间戳转换为时间格式</span></span><br><span class="line">timestamp := time.Now().Unix() <span class="comment">//时间戳</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;current timestamp1:%v\n&quot;</span>, timestamp)</span><br><span class="line"></span><br><span class="line">timeObj := time.Unix(timestamp, <span class="number">0</span>) <span class="comment">//将时间戳转为时间格式</span></span><br><span class="line">fmt.Println(timeObj)</span><br><span class="line">year := timeObj.Year()     <span class="comment">//年</span></span><br><span class="line">month := timeObj.Month()   <span class="comment">//月</span></span><br><span class="line">day := timeObj.Day()       <span class="comment">//日</span></span><br><span class="line">hour := timeObj.Hour()     <span class="comment">//小时</span></span><br><span class="line">minute := timeObj.Minute() <span class="comment">//分钟</span></span><br><span class="line">second := timeObj.Second() <span class="comment">//秒</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%d-%02d-%02d %02d:%02d:%02d\n&quot;</span>, year, month, day, hour, minute, second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="时间间隔">时间间隔</h1><p><code>time.Duration</code> 是 <code>time</code> 包定义的一个类型，它代表两个时间点之间经过的时间，以纳秒为单位。<code>time.Duration</code> 表示一段时间间隔，可表示的最长时间段大约290年。</p><p><code>time</code> 包中定义的时间间隔类型的常量如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Nanosecond  Duration = <span class="number">1</span></span><br><span class="line">    Microsecond          = <span class="number">1000</span> * Nanosecond</span><br><span class="line">    Millisecond          = <span class="number">1000</span> * Microsecond</span><br><span class="line">    Second               = <span class="number">1000</span> * Millisecond</span><br><span class="line">    Minute               = <span class="number">60</span> * Second</span><br><span class="line">    Hour                 = <span class="number">60</span> * Minute</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>例如：<code>time.Duration</code> 表示1纳秒，<code>time.Second</code> 表示1秒。</p><h1 id="时间操作">时间操作</h1><h2 id="Add">Add</h2><p>求时间+n后的时间：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Add</span><span class="params">(d Duration)</span> <span class="title">Time</span></span></span><br></pre></td></tr></table></figure><p>示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">timeAdd</span><span class="params">()</span></span> &#123;</span><br><span class="line">now := time.Now()</span><br><span class="line">value := now.Add(time.Hour) <span class="comment">// 当前时间加1小时后的时间</span></span><br><span class="line">fmt.Println(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Sub">Sub</h2><p>求两个时间之间的差值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Sub</span><span class="params">(u Time)</span> <span class="title">Duration</span></span></span><br></pre></td></tr></table></figure><p>示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func timeSub() &#123;</span><br><span class="line">now := time.Now()</span><br><span class="line">value := now.Sub(now.Add(time.Hour))</span><br><span class="line">fmt.Println(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回一个时间段 <code>t-u</code>。如果结果超出了 <code>Duration</code> 可以表示的最大值/最小值，将返回最大值/最小值。要获取时间点 <code>t-d</code>（d为Duration），可以使用 <code>t.Add(-d)</code>。</p><h2 id="Equal">Equal</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Equal</span><span class="params">(u Time)</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure><p>判断两个时间是否相同，会考虑时区的影响，因此不同时区标准的时间也可以正确比较。本方法和用 <code>t==u</code> 不同，这种方法还会比较地点和时区信息。</p><h2 id="Before">Before</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Before</span><span class="params">(u Time)</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure><p>如果t代表的时间点在u之前，返回真；否则返回假。</p><h2 id="After">After</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">After</span><span class="params">(u Time)</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure><p>如果t代表的时间点在u之后，返回真；否则返回假。</p><p>定时器</p><p>使用<code>time.Tick(时间间隔)</code>来设置定时器，定时器的本质上是一个通道（channel）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tickDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">ticker := time.Tick(time.Second) <span class="comment">//定义一个1秒间隔的定时器</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> ticker &#123;</span><br><span class="line">fmt.Println(i)<span class="comment">//每秒都会执行的任务</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="时间格式化">时间格式化</h1><p>时间类型有一个自带的方法<code>Format</code>进行格式化，需要注意的是Go语言中格式化时间模板不是常见的<code>Y-m-d H:M:S</code>而是使用Go的诞生时间2006年1月2号15点04分（记忆口诀为2006 1 2 3 4）。也许这就是技术人员的浪漫吧。</p><p>补充：如果想格式化为12小时方式，需指定<code>PM</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">formatDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">now := time.Now()</span><br><span class="line"><span class="comment">// 格式化的模板为Go的出生时间2006年1月2号15点04分 Mon Jan</span></span><br><span class="line"><span class="comment">// 24小时制</span></span><br><span class="line">fmt.Println(now.Format(<span class="string">&quot;2006-01-02 15:04:05.000 Mon Jan&quot;</span>))</span><br><span class="line"><span class="comment">// 12小时制</span></span><br><span class="line">fmt.Println(now.Format(<span class="string">&quot;2006-01-02 03:04:05.000 PM Mon Jan&quot;</span>))</span><br><span class="line">fmt.Println(now.Format(<span class="string">&quot;2006/01/02 15:04&quot;</span>))</span><br><span class="line">fmt.Println(now.Format(<span class="string">&quot;15:04 2006/01/02&quot;</span>))</span><br><span class="line">fmt.Println(now.Format(<span class="string">&quot;2006/01/02&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="解析字符串格式的时间">解析字符串格式的时间</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">now := time.Now()</span><br><span class="line">fmt.Println(now)</span><br><span class="line"><span class="comment">// 加载时区</span></span><br><span class="line">loc, err := time.LoadLocation(<span class="string">&quot;Asia/Shanghai&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 按照指定时区和指定格式解析字符串时间</span></span><br><span class="line">timeObj, err := time.ParseInLocation(<span class="string">&quot;2006/01/02 15:04:05&quot;</span>, <span class="string">&quot;2019/08/04 14:15:20&quot;</span>, loc)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(timeObj)</span><br><span class="line">fmt.Println(timeObj.Sub(now))</span><br></pre></td></tr></table></figure><p>练习题：</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/go/06%E5%88%87%E7%89%87/"/>
      <url>/go/06%E5%88%87%E7%89%87/</url>
      
        <content type="html"><![CDATA[<h1 id="切片定义">切片定义</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sliceDeclar</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> s1 []<span class="keyword">int</span>    <span class="comment">// 定义存放int类型的切片</span></span><br><span class="line"><span class="keyword">var</span> s2 []<span class="keyword">string</span> <span class="comment">// 定义存放string类型的切片</span></span><br><span class="line">fmt.Println(s1, s2)</span><br><span class="line">fmt.Println(s1 == <span class="literal">nil</span>, s2 == <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建切片和创建数组非常相似，如果在 <code>[]</code> 指定了值，那么创建的是一个数组，反之就是一个切片</p><h1 id="创建空切片">创建空切片</h1><p>空切片在底层数组包含 0 个元素，也没有分配任何存储空间。一般用于表示空集合。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createEmptySlice</span><span class="params">()</span></span> &#123;</span><br><span class="line">slice1 := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">slice2 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">fmt.Println(slice1, slice2)</span><br><span class="line">fmt.Println(slice1 == <span class="literal">nil</span>, slice2 == <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="基于数组得到切片">基于数组得到切片</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createSliceByArray</span><span class="params">()</span></span> &#123;</span><br><span class="line">arr := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">fmt.Println(arr)</span><br><span class="line">fmt.Println(arr[<span class="number">0</span>:<span class="number">4</span>]) <span class="comment">// =&gt;[1 2 3 4] 基于数组得到切片,从0开始到第4个结束（不包含4）.原则：左包含右不包含</span></span><br><span class="line">fmt.Println(arr[:<span class="number">4</span>])  <span class="comment">// =&gt;[1 2 3 4] 省略第一个参数，默认从0开始</span></span><br><span class="line">fmt.Println(arr[<span class="number">3</span>:])  <span class="comment">// =&gt;[4 5 6 7 8 9] 省略第二个参数，默认到len(a1)结束</span></span><br><span class="line">fmt.Println(arr[:])   <span class="comment">// =&gt;[1 2 3 4 5 6 7 8 9] 两个参数都省略，默认从0开始到len(a1-1)结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[1 2 3 4 5 6 7 8 9]</span><br><span class="line">[1 2 3 4]</span><br><span class="line">[1 2 3 4]</span><br><span class="line">[4 5 6 7 8 9]      </span><br><span class="line">[1 2 3 4 5 6 7 8 9]</span><br></pre></td></tr></table></figure><h1 id="基于切片得到切片">基于切片得到切片</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createSliceBySlice</span><span class="params">()</span></span> &#123;</span><br><span class="line">arr := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">arr1 := arr[<span class="number">0</span>:<span class="number">4</span>]</span><br><span class="line">fmt.Println(arr1)</span><br><span class="line">fmt.Printf(<span class="string">&quot;len(s5):%d cap(s5):%d \n&quot;</span>, <span class="built_in">len</span>(arr1), <span class="built_in">cap</span>(arr1))</span><br><span class="line"><span class="comment">//由切片得到切片</span></span><br><span class="line">arr2 := arr1[<span class="number">2</span>:<span class="number">4</span>]</span><br><span class="line">fmt.Println(arr2)</span><br><span class="line">fmt.Printf(<span class="string">&quot;len(s5):%d cap(s5):%d \n&quot;</span>, <span class="built_in">len</span>(arr2), <span class="built_in">cap</span>(arr2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[1 2 3 4]</span><br><span class="line">len(s5):4 cap(s5):9 </span><br><span class="line">[3 4]</span><br><span class="line">len(s5):2 cap(s5):7 </span><br></pre></td></tr></table></figure><h1 id="直接创建并初始化">直接创建并初始化</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createSlice</span><span class="params">()</span></span> &#123;</span><br><span class="line">s1 := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">67</span>, <span class="number">88</span>&#125;</span><br><span class="line">s2 := []<span class="keyword">string</span>&#123;<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>, <span class="string">&quot;山西&quot;</span>&#125;</span><br><span class="line">fmt.Println(s1, s2)</span><br><span class="line">fmt.Println(s1 == <span class="literal">nil</span>, s2 == <span class="literal">nil</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;len(s1):%d cap(s1):%d \n&quot;</span>, <span class="built_in">len</span>(s1), <span class="built_in">cap</span>(s1))</span><br><span class="line">fmt.Printf(<span class="string">&quot;len(s2):%d cap(s2):%d \n&quot;</span>, <span class="built_in">len</span>(s2), <span class="built_in">cap</span>(s2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用-make-创建切片">使用 make 创建切片</h1><p>以上大部分都是基于数组来创建切片，如果需要动态的创建一个切片，可以使用内置的<code>make()</code>函数，格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make([]T, size, <span class="built_in">cap</span>)</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>T</code>:切片的元素类型</li><li><code>size</code>:切片中元素的数量</li><li><code>cap</code>:切片的容量</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createSliceByMake</span><span class="params">()</span></span> &#123;</span><br><span class="line">slice1 := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">5</span>)</span><br><span class="line"><span class="comment">// 使用make创建一个长度5，容量为10的切片</span></span><br><span class="line">slice2 := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line">fmt.Println(slice1, slice2)</span><br><span class="line"><span class="comment">// fmt.Println(slice2[6]) // 虽然创建的切片对应底层数组的大小为 10，但是不能访问索引值 5 以后的元素,其实相当于底层数组长度是10但是切片只覆盖到了0~5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要说明的是，切片对应的底层数组的大小为指定的容量。比如对于上面的例子，指定了 <code>slice2</code> 的容量为 10，那么 <code>slice2</code> 对应的底层数组的大小就是 10。虽然创建的切片对应底层数组的大小为 10，但是不能访问索引值 5 以后的元素，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(slice2[<span class="number">6</span>])</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">panic: runtime error: index out of range [6] with length 5</span><br></pre></td></tr></table></figure><p>虽然创建的切片对应底层数组的大小为 10，但是不能访问索引值 5 以后的元素，其实相当于：底层数组长度是10但是切片 <code>slice2</code> 只覆盖到了 <code>0~5</code>。</p><h1 id="切片的长度和容量">切片的长度和容量</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br></pre></td></tr></table></figure><p>示例一：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s1 := arr[<span class="number">3</span>:] <span class="comment">// [4 5 6 7 8 9]</span></span><br><span class="line">fmt.Println(s1)</span><br><span class="line"><span class="comment">// 切片的长度是元素的个数,切片的容量是底层数组从切片的第一个元素到最后一个元素,</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;len(s1):%d cap(s1):%d \n&quot;</span>, <span class="built_in">len</span>(s1), <span class="built_in">cap</span>(s1))</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[4 5 6 7 8 9]</span><br><span class="line">len(s1):6 cap(s1):6 </span><br></pre></td></tr></table></figure><p>示例二：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s2 := arr[<span class="number">4</span>:<span class="number">8</span>] <span class="comment">// [5 6 7 8]</span></span><br><span class="line">fmt.Println(s2)</span><br><span class="line"><span class="comment">// 切片的长度是元素的个数,所以len=4,切片的容量是底层数组从切片的第一个元素到最后一个元素,所以这里就是从4到9</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;len(s2):%d cap(s2):%d \n&quot;</span>, <span class="built_in">len</span>(s2), <span class="built_in">cap</span>(s2))</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[5 6 7 8]</span><br><span class="line">len(s2):4 cap(s2):5 </span><br></pre></td></tr></table></figure><h1 id="切片的本质">切片的本质</h1><p>切片的本质就是对底层数组的封装，它包含了三个信息：底层数组的指针、切片的长度 <code>len</code> 和切片的容量 <code>cap</code>。参考自：  <a href="https://www.liwenzhou.com/posts/Go/06_slice/">李文周的博客</a></p><p>举个例子，现在有一个数组<code>a := [8]int&#123;0, 1, 2, 3, 4, 5, 6, 7&#125;</code>，切片<code>s1 := a[:5]</code>，示意图如下：</p><p><img src="https://www.liwenzhou.com/images/Go/slice/slice_01.png" alt=""></p><p>切片<code>s2 := a[3:6]</code>，示意图如下：</p><p><img src="https://www.liwenzhou.com/images/Go/slice/slice_02.png" alt=""></p><p><strong>注意</strong>：现在两个切片共享同一个底层数组，因为切片的本质就是对底层数组的封装，所以如果一个切片修改了该底层数组的共享部分，另一个切片也能感知到</p><h1 id="切片判断是否为空">切片判断是否为空</h1><p>切片之间是不能比较的，不能使用<code>==</code>操作符来判断两个切片是否含有全部相等元素。 切片唯一合法的比较操作是和 <code>nil</code> 比较。 一个 <code>nil</code> 值的切片并没有底层数组，一个 <code>nil</code> 值的切片的长度和容量都是0。但是不能说一个长度和容量都是0的切片一定是 <code>nil</code> ，例如下面的示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compareSlice</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> q1 []<span class="keyword">int</span> <span class="comment">// len(q1)=0;cap(q1)=0;q1==nil; 没有被初始化所以q1==nil is true</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;len(q1):%d cap(q1):%d q1==nil:%t \n&quot;</span>, <span class="built_in">len</span>(q1), <span class="built_in">cap</span>(q1), q1 == <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">q2 := []<span class="keyword">int</span>&#123;&#125; <span class="comment">// len(q2)=0;cap(q2)=0;q2!=nil; 这里是定义了元素为空的数组,所以q2==nil is false</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;len(q2):%d cap(q2):%d q2==nil:%t \n&quot;</span>, <span class="built_in">len</span>(q2), <span class="built_in">cap</span>(q2), q2 == <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">q3 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>) <span class="comment">// len(q3)=0;cap(q3)=0; q3!=nil; 这里使用了make所以十分分配内存的只不过cap和len都为0而已,所以q3==nil is false</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;len(q3):%d cap(q3):%d q3==nil:%t \n&quot;</span>, <span class="built_in">len</span>(q3), <span class="built_in">cap</span>(q3), q3 == <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以要判断一个切片是否是空的，要是用<code>len(s) == 0</code>来判断，不应该使用<code>s == nil</code>来判断。</p><h1 id="切片的赋值拷贝">切片的赋值拷贝</h1><p>下面代码演示了拷贝前后两个变量共享底层数组，之前也说过：对一个切片的修改会影响另一个切片的内容，这点需要特别注意。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shareArraySlice</span><span class="params">()</span></span> &#123;</span><br><span class="line">w1 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>) <span class="comment">// [0 0 0]</span></span><br><span class="line">w2 := w1             <span class="comment">// 将w1直接赋值给w2，w1和w2共用一个底层数组</span></span><br><span class="line">w2[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">fmt.Println(w1) <span class="comment">// [100 0 0]</span></span><br><span class="line">fmt.Println(w2) <span class="comment">// [100 0 0]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="切片遍历">切片遍历</h1><p>切片的遍历方式和数组是一致的，支持索引遍历和<code>for range</code>遍历。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">traversalSlice</span><span class="params">()</span></span> &#123;</span><br><span class="line">slice := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>) <span class="comment">// [0 0 0]</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(slice); i++ &#123;</span><br><span class="line">fmt.Println(i, slice[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> slice &#123;</span><br><span class="line">fmt.Println(index, value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="append">append</h1><p>Go语言的内建函数 <code>append()</code> 可以为切片动态添加元素。 可以一次添加一个元素，可以添加多个元素，也可以添加另一个切片中的元素（后面加<code>…</code>）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">appendSlice</span><span class="params">()</span></span> &#123;</span><br><span class="line">slice := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>)              <span class="comment">// 创建切片：[0 0 0]</span></span><br><span class="line">slice = <span class="built_in">append</span>(slice, <span class="number">1</span>)             <span class="comment">// 切片中添加第一个元素 1</span></span><br><span class="line">slice = <span class="built_in">append</span>(slice, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>) <span class="comment">// 继续添加元素 2,3,4,5,6</span></span><br><span class="line">slice2 := []<span class="keyword">int</span>&#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;             <span class="comment">// 创建新的切片</span></span><br><span class="line">slice = <span class="built_in">append</span>(slice, slice2...)     <span class="comment">// 将新的切片中的元素都放到w3中,这里...代表将slice2中的元素拆分</span></span><br><span class="line">fmt.Println(slice)                   <span class="comment">// 输出：[0 0 0 1 2 3 4 5 6 7 8 9]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**注意：**如果使用 <code>append()</code> 切片可以不被初始化,会自动扩容并添加元素。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="keyword">int</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>每个切片会指向一个底层数组，这个数组的容量够用就添加新增元素。当底层数组不能容纳新增的元素时，切片就会自动按照一定的策略进行“扩容”，此时该切片指向的底层数组就会更换。“扩容”操作往往发生在 <code>append()</code> 函数调用时，所以我们通常都需要用原变量接收append函数的返回值。</p><p>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">appendDilatationSlice</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> numSlice []<span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">numSlice = <span class="built_in">append</span>(numSlice, i)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v  len:%d  cap:%d  ptr:%p\n&quot;</span>, numSlice, <span class="built_in">len</span>(numSlice), <span class="built_in">cap</span>(numSlice), numSlice)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[0]  len:1  <span class="built_in">cap</span>:1  ptr:0xc000012088</span><br><span class="line">[0 1]  len:2  <span class="built_in">cap</span>:2  ptr:0xc0000120d0        </span><br><span class="line">[0 1 2]  len:3  <span class="built_in">cap</span>:4  ptr:0xc000010200      </span><br><span class="line">[0 1 2 3]  len:4  <span class="built_in">cap</span>:4  ptr:0xc000010200    </span><br><span class="line">[0 1 2 3 4]  len:5  <span class="built_in">cap</span>:8  ptr:0xc00000c340  </span><br><span class="line">[0 1 2 3 4 5]  len:6  <span class="built_in">cap</span>:8  ptr:0xc00000c340</span><br><span class="line">[0 1 2 3 4 5 6]  len:7  <span class="built_in">cap</span>:8  ptr:0xc00000c340</span><br><span class="line">[0 1 2 3 4 5 6 7]  len:8  <span class="built_in">cap</span>:8  ptr:0xc00000c340</span><br><span class="line">[0 1 2 3 4 5 6 7 8]  len:9  <span class="built_in">cap</span>:16  ptr:0xc00010e080</span><br><span class="line">[0 1 2 3 4 5 6 7 8 9]  len:10  <span class="built_in">cap</span>:16  ptr:0xc00010e080</span><br></pre></td></tr></table></figure><p>从上面的结果可以看出：</p><ol><li><code>append()</code>函数将元素追加到切片的最后并返回该切片</li><li>切片 <code>numSlice</code> 的容量按照1，2，4，8，16这样的规则自动进行扩容，每次扩容后都是扩容前的2倍</li></ol><h1 id="切片的扩容策略">切片的扩容策略</h1><p>可以通过查看 <code>$GOROOT/src/runtime/slice.go</code> 源码，其中扩容相关代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">newcap := old.<span class="built_in">cap</span></span><br><span class="line">doublecap := newcap + newcap</span><br><span class="line"><span class="comment">// 1.首先判断如果新申请容量(cap)大于2倍的旧容量(old.cap):那么最终容量等于新申请的容量(cap)</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">cap</span> &gt; doublecap &#123;</span><br><span class="line">newcap = <span class="built_in">cap</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 2.否则判断如果旧切片的长度小于1024，则最终容量等于旧容量(old.cap)x2</span></span><br><span class="line"><span class="keyword">if</span> old.<span class="built_in">len</span> &lt; <span class="number">1024</span> &#123;</span><br><span class="line">newcap = doublecap</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 3. 否则判断如果旧切片长度大于等于1024 ，则最终容量从旧容量（old.cap）开始循环增加原来的1/4，即 newcap=old.cap,for &#123;newcap += newcap/4&#125; 直到最终容量大于等于新申请的容量cap，即newcap &gt;= cap</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">// Check 0 &lt; newcap to detect overflow</span></span><br><span class="line"><span class="comment">// and prevent an infinite loop.</span></span><br><span class="line"><span class="keyword">for</span> <span class="number">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class="built_in">cap</span> &#123;</span><br><span class="line">newcap += newcap / <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Set newcap to the requested cap when</span></span><br><span class="line"><span class="comment">// the newcap calculation overflowed.</span></span><br><span class="line"><span class="keyword">if</span> newcap &lt;= <span class="number">0</span> &#123;</span><br><span class="line">newcap = <span class="built_in">cap</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以看出以下内容：</p><ol><li><p>首先判断如果新申请容量  <code>cap</code> 大于2倍的旧容量  <code>old.cap</code>，最终容量  <code>newcap</code> 等于新申请的容量  <code>cap</code></p></li><li><p>否则判断如果旧切片的长度小于 <code>1024</code> ，则最终容量 <code>newcap </code> 等于旧容量  <code>old.cap</code> 的两倍</p></li><li><p>否则判断如果旧切片长度大于等于 <code>1024</code> ，则最终容量 <code>newcap</code> 从旧容量 <code>old.cap</code> 开始循环增加原来的<code>1/4</code>，即 <code>newcap=old.cap,for &#123;newcap += newcap/4&#125; </code>直到最终容量 <code>newcap</code> 大于等于新申请的容量<code>cap</code>，即 <code>newcap &gt;= cap</code></p></li><li><p>如果最终容量  <code>cap</code> 计算值溢出，则最终容量 <code>cap</code>  就是新申请容量 <code>cap</code></p></li></ol><p>需要注意：切片扩容会根据切片中元素的类型不同而做不同的处理，比如 <code>int</code> 和 <code>string</code> 类型的处理方式就不一样。</p><h1 id="copy">copy</h1><p>首先来看一个问题：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">b := a</span><br><span class="line">fmt.Println(a) <span class="comment">// [1 2 3 4 5]</span></span><br><span class="line">fmt.Println(b) <span class="comment">// [1 2 3 4 5]</span></span><br><span class="line">b[<span class="number">0</span>] = <span class="number">1000</span></span><br><span class="line">fmt.Println(a) <span class="comment">// [1000 2 3 4 5]</span></span><br><span class="line">fmt.Println(b) <span class="comment">// [1000 2 3 4 5]</span></span><br></pre></td></tr></table></figure><p>由于切片是引用类型，所以 <code>a</code> 和 <code>b</code> 其实都指向了同一块内存地址。修改 <code>b</code> 的同时 <code>a</code> 的值也会发生变化。</p><p><code>copy()</code>函数可以迅速地将一个切片的数据复制到另外一个切片空间中，使用格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">copy</span>(destSlice, srcSlice []T)</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>srcSlice</code>: 数据来源切片</li><li><code>destSlice</code>: 目标切片</li></ul><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">c := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">d := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">copy</span>(d, c)     <span class="comment">// 使用copy()函数将切片c1中的元素复制到切片c2</span></span><br><span class="line">fmt.Println(c) <span class="comment">// [1 2 3 4 5]</span></span><br><span class="line">fmt.Println(d) <span class="comment">// [1 2 3 4 5]</span></span><br><span class="line">c[<span class="number">0</span>] = <span class="number">1000</span></span><br><span class="line">fmt.Println(c) <span class="comment">// [1000 2 3 4 5]</span></span><br><span class="line">fmt.Println(d) <span class="comment">// [1 2 3 4 5]</span></span><br></pre></td></tr></table></figure><h1 id="从切片中删除元素">从切片中删除元素</h1><p>Go语言中并没有删除切片元素的专用方法，我们可以使用切片本身的特性来删除元素。 代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从切片中删除元素</span></span><br><span class="line">c3 := []<span class="keyword">int</span>&#123;<span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>, <span class="number">36</span>, <span class="number">37</span>&#125;</span><br><span class="line"><span class="comment">// 要删除索引为2的元素32</span></span><br><span class="line">c3 = <span class="built_in">append</span>(c3[:<span class="number">2</span>], c3[<span class="number">3</span>:]...) <span class="comment">// 其实这就是利用append的特性修改了切片内容再返回</span></span><br><span class="line">fmt.Println(c3)                <span class="comment">// [30 31 33 34 35 36 37]</span></span><br></pre></td></tr></table></figure><p>总结：要从切片c3中删除索引为 <code>index</code> 的元素，操作方法是 <code>c3 = append(c3[:index], c3[index+1:]...)</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/go/05%E6%95%B0%E7%BB%84/"/>
      <url>/go/05%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>数组是由固定长度的特定类型元素组成的序列，数组可以由零个或多个元素组成（默认情况下，数组的每个元素都被初始化为元素类型对应的零值），数组的长度是固定的，因此在Go语言中很少直接使用数组。和数组对应的类型是 <code>Slice</code>（切片），它是可以增长和收缩的动态序列，<code>slice</code> 功能也更灵活，但是要理解 <code>slice</code> 工作原理的话需要先理解数组。</p><h2 id="创建数组">创建数组</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组创建,使用类型零值初始化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createArrayDeclar</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> arr [<span class="number">3</span>]<span class="keyword">int</span>               <span class="comment">// array of 3 integers</span></span><br><span class="line">fmt.Println(arr[<span class="number">0</span>])          <span class="comment">// print the first element</span></span><br><span class="line">fmt.Println(arr[<span class="built_in">len</span>(arr)<span class="number">-1</span>]) <span class="comment">// print the last element, a[2]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组字面值">数组字面值</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组创建,使用数字字面值语法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createArrayDeclar2</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> arr [<span class="number">3</span>]<span class="keyword">int</span> = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(arr[<span class="number">0</span>])</span><br><span class="line"><span class="comment">// fmt.Println(a[10]) invalid array index 10 (out of bounds for 3-element array),数组越界</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组字面值中，如果数组的长度位置出现的是<code>…</code>省略号，表示数组的长度根据初始化值的个数来计算。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createArrayDeclar3</span><span class="params">()</span></span> &#123;</span><br><span class="line">arr := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(arr[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指定数组第1个元素值为100,第9个元素值为200,数组长度就是10</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createArrayDeclar4</span><span class="params">()</span></span> &#123;</span><br><span class="line">arr := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>: <span class="number">100</span>, <span class="number">9</span>: <span class="number">200</span>&#125;</span><br><span class="line">fmt.Println(arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组比较">数组比较</h2><p>数组可以直接进行比较，当数组内的元素都一样的时候表示两个数组相等。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">q := [...]<span class="keyword">int</span>&#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>&#125;</span><br><span class="line">w := [...]<span class="keyword">int</span>&#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>&#125;</span><br><span class="line">fmt.Println(q == w)</span><br></pre></td></tr></table></figure><h2 id="数组遍历">数组遍历</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">traversalArray</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> arr [<span class="number">3</span>]<span class="keyword">int</span> = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(arr); i++ &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;index:%d, value:%d\n&quot;</span>, i, arr[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用range遍历数组</span></span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;index:%d, value:%d\n&quot;</span>, i, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用range遍历数组:如果需要值但希望忽略索引，可以通过使用_ blank标识符替换索引来实现</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;value:%d\n&quot;</span>, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多维数组">多维数组</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">multidimensionalArray</span><span class="params">()</span></span> &#123;</span><br><span class="line">array := [<span class="number">3</span>][<span class="number">4</span>]<span class="keyword">int</span>&#123;</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,   <span class="comment">/*  第一行索引为 0 */</span></span><br><span class="line">&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;,   <span class="comment">/*  第二行索引为 1 */</span></span><br><span class="line">&#123;<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125;, <span class="comment">/*  第三行索引为 2 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i, item := <span class="keyword">range</span> array &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%d the element of is %v \n&quot;</span>, i, item)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 the element of is [0 1 2 3]</span><br><span class="line">1 the element of is [4 5 6 7]</span><br><span class="line">2 the element of is [8 9 10 11]</span><br></pre></td></tr></table></figure><h2 id="数组作为参数传递">数组作为参数传递</h2><p>数组可以作为函数的参数传入，数组作为函数参数传入用的是值传递的方式(<strong>拷贝</strong>)。在函数内改变数组元素并不影响外层数组。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">passByValue</span><span class="params">(arr [3]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组是值类型：意味着当它被分配给一个新变量时，将把原始数组的副本分配给新变量。如果对新变量进行了更改不会在原始数组中反映</span></span><br><span class="line">e := [...]<span class="keyword">int</span>&#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>&#125;</span><br><span class="line">fmt.Println(e[<span class="number">0</span>])</span><br><span class="line">passByValue(e)</span><br><span class="line">fmt.Println(e[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">11</span><br><span class="line">11</span><br></pre></td></tr></table></figure><p>如果想要改变就只能使用指针，在函数内部改变的数组的值，也会改变外面的数组的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">passByReference</span><span class="params">(arr *[3]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用指针后函数内部对数组的更改将反应到原数组上</span></span><br><span class="line">r := [...]<span class="keyword">int</span>&#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>&#125;</span><br><span class="line">fmt.Println(r[<span class="number">0</span>])</span><br><span class="line">passByReference(&amp;r)</span><br><span class="line">fmt.Println(r[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">11</span><br><span class="line">100</span><br></pre></td></tr></table></figure><p>这里只是玩一下，正常这种情况下都是用切片来解决，而不是用数组。</p><p>这里的 <code>*</code> 和 <code>&amp;</code> 的区别：</p><ul><li><code>&amp;</code> 是取地址符号 , 即取得某个变量的地址 , 如 ; <code>&amp;a</code></li><li><code>*</code> 是指针运算符 , 可以表示一个变量是指针类型 , 也可以表示一个指针变量所指向的存储单元 , 也就是这个地址所存储的值</li></ul><p><code>Slice</code> （切片）代表变长的序列，序列中每个元素都有相同的类型。一个 <code>slice</code> 类型一般写作 <code>[]T</code> ，其中 <code>T</code> 代表 <code>slice</code> 中元素的类型；<code>slice</code> 的语法和数组很像，只是没有固定长度而已。</p><p><code>slice</code> 的底层引用一个数组对象。一个 <code>slice</code> 由三个部分构成：指针、长度和容量。指针指向第一个 <code>slice</code> 元素对应的底层数组元素的地址，要注意的是 <code>slice</code> 的第一个元素并不一定就是数组的第一个元素。长度对应<code>slice</code> 中元素的数目；长度不能超过容量，容量一般是从 <code>slice</code> 的开始位置到底层数据的结尾位置。内置的 <code>len</code> 和 <code>cap</code> 函数分别返回 <code>slice</code>的长度和容量。多个 <code>slice</code> 之间可以共享底层的数据，并且引用的数组部分区间可能重叠。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/go/07map/"/>
      <url>/go/07map/</url>
      
        <content type="html"><![CDATA[<p>Go语言中提供映射关系的容器为 <code>map</code>，内部使用<code>散列表（hash）</code>实现。是一种无序的基于<code>key-value</code>的数据结构，<code>map</code> 是引用类型，必须初始化才能使用。</p><h1 id="map-定义">map 定义</h1><p><code>map</code> 定义语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">map</span>[KeyType]ValueType</span><br></pre></td></tr></table></figure><ul><li><code>KeyType</code>：表示键的类型</li><li><code>ValueType</code>：表示键对应的值的类型</li></ul><p><code>map</code> 类型的变量默认初始值为 <code>nil</code>，需要使用 <code>make()</code>函数来分配内存。语法为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>(<span class="keyword">map</span>[KeyType]ValueType, [<span class="built_in">cap</span>])</span><br></pre></td></tr></table></figure><p>其中 <code>cap</code> 表示 <code>map</code> 的容量，该参数虽然不是必须的，但是应该在初始化时就为其指定一个合适的容量。</p><h1 id="map-基本使用">map 基本使用</h1><p>内置的 <code>make</code> 函数可以创建一个 <code>map</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createMap</span><span class="params">()</span></span> &#123;</span><br><span class="line">users := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, <span class="number">8</span>)</span><br><span class="line">users[<span class="string">&quot;小王&quot;</span>] = <span class="number">18</span></span><br><span class="line">users[<span class="string">&quot;小李&quot;</span>] = <span class="number">2</span></span><br><span class="line">fmt.Println(users)</span><br><span class="line">fmt.Println(users[<span class="string">&quot;小王&quot;</span>])</span><br><span class="line">fmt.Printf(<span class="string">&quot;type of a:%T\n&quot;</span>, users)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以使用 <code>map</code> 字面值语法创建，支持在声明的时候填充元素，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createMap2</span><span class="params">()</span></span> &#123;</span><br><span class="line">users := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;</span><br><span class="line"><span class="string">&quot;小周&quot;</span>: <span class="number">22</span>,</span><br><span class="line"><span class="string">&quot;小张&quot;</span>: <span class="number">23</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(users)</span><br><span class="line">fmt.Println(users[<span class="string">&quot;小王&quot;</span>])</span><br><span class="line">fmt.Printf(<span class="string">&quot;type of a:%T\n&quot;</span>, users)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建空的 <code>map</code> 的表达式是</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;&#125;</span><br></pre></td></tr></table></figure><h1 id="判断某个键是否存在">判断某个键是否存在</h1><p>格式如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value,ok := <span class="keyword">map</span>[key]</span><br></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">existMap</span><span class="params">()</span></span> &#123;</span><br><span class="line">users := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;</span><br><span class="line"><span class="string">&quot;小周&quot;</span>: <span class="number">22</span>,</span><br><span class="line"><span class="string">&quot;小张&quot;</span>: <span class="number">23</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果返回值是bool值通常使用ok接收，约定俗称</span></span><br><span class="line">v, ok := users[<span class="string">&quot;小张&quot;</span>]</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;不存在&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="map-遍历">map 遍历</h1><p>Go语言中使用 <code>for range</code> 遍历 <code>map</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">users := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;</span><br><span class="line"><span class="string">&quot;小周&quot;</span>: <span class="number">22</span>,</span><br><span class="line"><span class="string">&quot;小张&quot;</span>: <span class="number">23</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> users &#123;</span><br><span class="line">fmt.Println(k, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只想遍历 <code>key</code> 时可以这么写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k := <span class="keyword">range</span> users &#123;</span><br><span class="line">fmt.Println(k)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 遍历 <code>map</code> 时的元素顺序与添加键值对的顺序无关。</p><h1 id="删除键值对">删除键值对</h1><p>使用 <code>delete()</code> 内建函数从 <code>map</code> 中删除一组键值对，函数格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delete</span>(<span class="keyword">map</span>, key)</span><br></pre></td></tr></table></figure><ul><li><code>map</code> ：表示要删除键值对的<code>map</code></li><li><code>key</code> ：表示要删除的键值对的键</li></ul><p>示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">delMap</span><span class="params">()</span></span> &#123;</span><br><span class="line">users := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;</span><br><span class="line"><span class="string">&quot;小周&quot;</span>: <span class="number">21</span>,</span><br><span class="line"><span class="string">&quot;小张&quot;</span>: <span class="number">22</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> users &#123;</span><br><span class="line">fmt.Println(k, v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">delete</span>(users, <span class="string">&quot;小周&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> users &#123;</span><br><span class="line">fmt.Println(k, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：这些操作是安全的，即使元素不在map中也没有关系；如果找失败将返回 <code>value</code> 类型对应的零值。</p><h1 id="按照指定顺序遍历">按照指定顺序遍历</h1><p><code>map</code> 的迭代顺序是不确定的，并且不同的哈希函数实现可能导致不同的遍历顺序。实践中遍历的顺序是随机的，每一次遍历的顺序都不相同。这是故意的，每次都使用随机的遍历顺序可以强制要求程序不会依赖具体的哈希函数实现。如果需要按顺序遍历 <code>key/value</code> 对，必须显式地对 <code>key</code> 进行排序</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">orderTraversalMap</span><span class="params">()</span></span> &#123;</span><br><span class="line">users := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;</span><br><span class="line"><span class="string">&quot;1&quot;</span>: <span class="number">22</span>,</span><br><span class="line"><span class="string">&quot;2&quot;</span>: <span class="number">23</span>,</span><br><span class="line"><span class="string">&quot;3&quot;</span>: <span class="number">23</span>,</span><br><span class="line"><span class="string">&quot;4&quot;</span>: <span class="number">23</span>,</span><br><span class="line"><span class="string">&quot;5&quot;</span>: <span class="number">23</span>,</span><br><span class="line"><span class="string">&quot;6&quot;</span>: <span class="number">23</span>,</span><br><span class="line"><span class="string">&quot;7&quot;</span>: <span class="number">23</span>,</span><br><span class="line"><span class="string">&quot;8&quot;</span>: <span class="number">23</span>,</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 这里看到map的迭代顺序是不确定随机的，并且不同的哈希函数实现可能导致不同的遍历顺序</span></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> users &#123;</span><br><span class="line">fmt.Println(k, v)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;************排序后：***********************&quot;</span>)</span><br><span class="line"><span class="comment">// 如果需要按顺序遍历 key/value，必须显式地对key进行排序</span></span><br><span class="line"><span class="comment">// 1.取出map中的所有key存入切片keys</span></span><br><span class="line"><span class="keyword">var</span> keys = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>, <span class="number">200</span>)</span><br><span class="line"><span class="keyword">for</span> key := <span class="keyword">range</span> users &#123;</span><br><span class="line">keys = <span class="built_in">append</span>(keys, key)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2.对切片进行排序</span></span><br><span class="line">sort.Strings(keys)</span><br><span class="line"><span class="comment">// 3.按照排序后的key遍历map</span></span><br><span class="line"><span class="keyword">for</span> _, key := <span class="keyword">range</span> keys &#123;</span><br><span class="line">fmt.Println(key, users[key])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="元素为-map-类型的切片">元素为 map 类型的切片</h1><p>下面的代码演示了切片中的元素为map类型时的操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sliceValueMap</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> mapSlice = <span class="built_in">make</span>([]<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> mapSlice &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;index:%d value:%v\n&quot;</span>, index, value)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;after init&quot;</span>)</span><br><span class="line"><span class="comment">// 对切片中的map元素进行初始化</span></span><br><span class="line">mapSlice[<span class="number">0</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, <span class="number">10</span>)</span><br><span class="line">mapSlice[<span class="number">0</span>][<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;wangpengliang&quot;</span></span><br><span class="line">mapSlice[<span class="number">0</span>][<span class="string">&quot;password&quot;</span>] = <span class="string">&quot;123456&quot;</span></span><br><span class="line">mapSlice[<span class="number">0</span>][<span class="string">&quot;address&quot;</span>] = <span class="string">&quot;北京&quot;</span></span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> mapSlice &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;index:%d value:%v\n&quot;</span>, index, value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="值为切片类型的-map">值为切片类型的 map</h1><p>下面的代码演示了map中值为切片类型的操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapValueslice</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> sliceMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span>, <span class="number">3</span>)</span><br><span class="line">fmt.Println(sliceMap)</span><br><span class="line">fmt.Println(<span class="string">&quot;after init&quot;</span>)</span><br><span class="line">key := <span class="string">&quot;中国&quot;</span></span><br><span class="line">value, ok := sliceMap[key]</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">value = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">value = <span class="built_in">append</span>(value, <span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>)</span><br><span class="line">sliceMap[key] = value</span><br><span class="line">fmt.Println(sliceMap)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/go/08%E5%87%BD%E6%95%B0/"/>
      <url>/go/08%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>函数指：可重复使用的、用于执行指定任务的代码块。Go语言中支持函数、匿名函数和闭包，函数在Go语言中属于“一等公民”。</p><h1 id="函数定义">函数定义</h1><p>函数定义格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> 函数名<span class="params">(参数)</span><span class="params">(返回值)</span></span>&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>函数名：由字母、数字、下划线组成。但函数名的第一个字母不能是数字。同一个包内函数名也称不能重名</li><li>参数：参数由参数变量和参数变量的类型组成，多个参数之间使用 <code>,</code> 分隔</li><li>返回值：返回值由返回值变量和其变量类型组成，也可以只写返回值的类型，多个返回值必须用 <code>()</code> 包裹，并用 <code>,</code> 分隔</li><li>函数体：实现指定功能的代码块</li></ul><p>比如：定义求两数之和的函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">func1</span><span class="params">(x <span class="keyword">int</span>, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的参数和返回值都是可选的，比如：可以定义无参数无返回值的函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">func2</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="函数调用">函数调用</h1><p>通过 <code>函数名()</code> 的方式调用函数，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">sum := func1(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    func2()</span><br><span class="line">fmt.Println(sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参数">参数</h1><h2 id="类型简写">类型简写</h2><p>函数的参数中如果相邻变量的类型相同，则可以省略类型，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">func4</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可变参数">可变参数</h2><p>可变参数是指函数的参数数量不固定。可变参数通过在参数名后加<code>...</code>标识。比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">func5</span><span class="params">(x ...<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> x &#123;</span><br><span class="line">sum += v</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a := func5(<span class="number">1</span>)</span><br><span class="line">b := func5(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">c := func5(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">fmt.Println(a, b, c) <span class="comment">// 1 5 9</span></span><br></pre></td></tr></table></figure><p>固定参数搭配可变参数使用时，可变参数要放在固定参数的后面，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">func6</span><span class="params">(x <span class="keyword">int</span>, y ...<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> y &#123;</span><br><span class="line">x += v</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本质上，函数的可变参数是通过切片实现的。</p><h1 id="返回值">返回值</h1><p>Go语言中通过  <code>return</code>  关键字向外输出返回值。</p><h2 id="多返回值">多返回值</h2><p>Go语言中函数支持多返回值，函数如果有多个返回值时必须用  <code>()</code>  将所有返回值包裹起来。比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">func7</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">sum := x + y</span><br><span class="line">sub := x - y</span><br><span class="line"><span class="keyword">return</span> sum, sub</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="返回值命名">返回值命名</h2><p>函数定义时可以给返回值命名，并在函数体中直接使用这些变量，最后通过 <code>return</code> 关键字返回。比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">func8</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="params">(sum, sub <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">sum = x + y</span><br><span class="line">sub = x - y</span><br><span class="line"><span class="comment">// 这里可以直接return,不需要指定sum和sub</span></span><br><span class="line"><span class="keyword">return</span> sum, sub</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="返回值补充">返回值补充</h2><p>当函数返回值类型为 <code>slice</code> 时，<code>nil</code> 可以看做是一个有效的 <code>slice</code> ，没必要显式返回一个长度为0的切片。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">func9</span><span class="params">(x <span class="keyword">string</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> x == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span> <span class="comment">// 没必要返回[]int&#123;&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> []<span class="keyword">int</span>&#123;<span class="number">0</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="变量作用域">变量作用域</h1><h2 id="全局变量-v2">全局变量</h2><p>全局变量是定义在函数外部的变量，在程序整个运行周期内都有效。 在函数中可以访问到全局变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义全局变量value</span></span><br><span class="line"><span class="keyword">var</span> value <span class="keyword">int64</span> = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;value=%d\n&quot;</span>, value) <span class="comment">// 函数中可以访问全局变量value</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">test() <span class="comment">// value=10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="局部变量">局部变量</h2><p>局部变量分为两种：</p><ul><li>函数内定义的变量无法在该函数外使用</li><li>如果局部变量和全局变量重名，优先访问局部变量</li><li>语句块定义的变量，只在 <code>if</code>、<code>for</code>、<code>switch</code> 语句内有效</li></ul><h1 id="函数类型与变量">函数类型与变量</h1><h2 id="定义函数类型">定义函数类型</h2><p>可以使用 <code>type</code> 关键字来定义一个函数类型，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> calculation <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure><p>上面定义了一个 <code>calculation</code> 类型，它是一种函数类型，接收两个 <code>int</code> 类型的参数并且返回一个 <code>int</code> 类型的返回值。凡是满足这个条件的函数都是 <code>calculation</code> 类型的函数，例如下面的 <code>sum</code> 和  <code>sub</code> 都是 <code>calculation</code> 类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// calculation类型的函数sum</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// calculation类型的函数sub</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sub</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> x - y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sum</code> 和 <code>sub</code> 都能赋值给 <code>calculation</code> 类型的变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> calc1 calculation = sum</span><br><span class="line"><span class="keyword">var</span> calc2 calculation = sub</span><br></pre></td></tr></table></figure><h2 id="函数类型变量">函数类型变量</h2><p>可以声明函数类型的变量并且为该变量赋值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a calculation = sum</span><br><span class="line">fmt.Printf(<span class="string">&quot;type of a:%T\n&quot;</span>, a) <span class="comment">// type of c:main.calculation</span></span><br><span class="line">fmt.Println(a(<span class="number">1</span>, <span class="number">2</span>))            <span class="comment">// 像调用sum一样调用a</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b calculation = sub</span><br><span class="line">fmt.Printf(<span class="string">&quot;type of b:%T\n&quot;</span>, b) <span class="comment">// type of c:main.calculation</span></span><br><span class="line">fmt.Println(b(<span class="number">1</span>, <span class="number">2</span>))            <span class="comment">// 像调用sub一样调用b</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> of a:main.calculation</span><br><span class="line">3</span><br><span class="line"><span class="built_in">type</span> of b:main.calculation</span><br><span class="line">-1</span><br></pre></td></tr></table></figure><h1 id="高阶函数">高阶函数</h1><h2 id="函数作为参数">函数作为参数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将函数作为参数传递，该函数接收两个int类型变量x/y,一个函数参数sum。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">functionAsArgument</span><span class="params">(x, y <span class="keyword">int</span>, sum <span class="keyword">func</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> <span class="title">int</span>) <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> sum(x, y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">func1</span><span class="params">(x <span class="keyword">int</span>, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">functionAsArgumentTest</span><span class="params">()</span></span> &#123;</span><br><span class="line">ret2 := functionAsArgument(<span class="number">10</span>, <span class="number">20</span>, func1)</span><br><span class="line">fmt.Println(ret2) <span class="comment">//30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数作为返回值">函数作为返回值</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收一个切片参数patients,返回一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">functionAsTheReturnValue</span><span class="params">(patients []<span class="keyword">string</span>)</span> <span class="title">func</span><span class="params">(<span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="comment">// 定义匿名函数并返回</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, soul := <span class="keyword">range</span> patients &#123;</span><br><span class="line"><span class="keyword">if</span> soul == name &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">functionAsTheReturnValueTest</span><span class="params">()</span></span> &#123;</span><br><span class="line">testValue := []<span class="keyword">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;f&quot;</span>&#125;</span><br><span class="line">result := functionAsTheReturnValue(testValue)</span><br><span class="line"><span class="comment">// 调用筛选器函数获取字母是否已存在</span></span><br><span class="line">fmt.Println(result(<span class="string">&quot;a&quot;</span>))  <span class="comment">// true</span></span><br><span class="line">fmt.Println(result(<span class="string">&quot;ff&quot;</span>)) <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="匿名函数">匿名函数</h1><p>已经知道函数可以作为返回值，但是在Go语言函数内部不能再像之前那样定义函数了，只能定义匿名函数。匿名函数就是没有函数名的函数，匿名函数的定义格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(参数)</span><span class="params">(返回值)</span></span>&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名函数因为没有函数名，所以没办法像普通函数那样调用，所以匿名函数需要保存到某个变量或者作为立即执行函数:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">anonymousFunc</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 将匿名函数保存到变量</span></span><br><span class="line">add := <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(x + y)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过变量调用匿名函数</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名函数作为立即执行函数,一般用于匿名函数只用于一次的情况下就不需要再指定变量存储</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(x - y)</span><br><span class="line">&#125;(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名函数多用于实现回调函数和闭包。</p><h1 id="闭包">闭包</h1><p>闭包是函数式编程语言中的概念。指内层函数引用了外层函数中的变量或称为引用了自由变量（全局变量）的函数，其返回值也是一个函数。在Go语言中可以理解为<strong>匿名函数与其所引用环境的组合</strong>。</p><p>闭包只是在形式和表现上像函数，但实际上不是函数。函数是一些可执行的代码，这些代码在函数被定义后就确定了，不会在执行时发生变化，所以一个函数只有一个实例。闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。所谓引用环境是指在程序执行中的某个点所有处于活跃状态的约束所组成的集合。其中的约束是指一个变量的名字和其所代表的对象之间的联系。那么为什么要把引用环境与函数组合起来呢？这主要是因为在支持嵌套作用域的语言中，有时不能简单直接地确定函数的引用环境。这样的语言一般具有这样的特性</p><blockquote><p>函数是一等公民（First-class value），即函数可以作为另一个函数的返回值或参数，还可以作为一个变量的值。 函数可以嵌套定义，即在一个函数内部可以定义另一个函数。</p></blockquote><p>比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">()</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> x <span class="keyword">int</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">x += y</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTest</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> f = add()</span><br><span class="line">fmt.Println(f(<span class="number">10</span>)) <span class="comment">//10</span></span><br><span class="line">fmt.Println(f(<span class="number">20</span>)) <span class="comment">//30</span></span><br><span class="line">fmt.Println(f(<span class="number">30</span>)) <span class="comment">//60</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">int</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">x += y</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时 <code>f</code>  就是一个闭包，<code>f</code> 不仅仅是存储了一个函数的返回值，同时存储了一个闭包的状态。该状态会一直存在外部被赋值的变量 <code>f</code> 中，直到 <code>f</code> 被销毁，整个闭包才被销毁。</p><p>再看一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add2</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">x += y</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add2Test</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> f = add2(<span class="number">10</span>)</span><br><span class="line">fmt.Println(f(<span class="number">10</span>)) <span class="comment">//20</span></span><br><span class="line">fmt.Println(f(<span class="number">20</span>)) <span class="comment">//40</span></span><br><span class="line">fmt.Println(f(<span class="number">30</span>)) <span class="comment">//70</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数 <code>add2</code> 返回了一个函数，返回的这个函数就是一个闭包。这个函数本身中没有定义变量 <code>x</code> 的，而是引用了它所在的环境（函数 <code>add2</code>）中的变量 <code>x</code>。</p><p>每调用一次函数 <code>add2</code>，就形成了一个新的环境，对应的闭包中，函数都是同一个函数，环境却是引用不同的环境。变量 <code>x</code> 是函数 <code>add2 </code>中的局部变量，这个变量不会在函数 <code>add2 </code> 的栈中分配，因为函数 <code>add2</code> 返回后，对应的栈就失效了，<code>add2</code> 返回的那个函数中变量 <code>x</code> 就引用了一个失效的位置。所以闭包的环境中引用的变量不能够在栈上分配。</p><h1 id="闭包的陷阱">闭包的陷阱</h1><p>TODO</p><h1 id="defer-语句">defer 语句</h1><p>Go语言中 <code>defer</code> 语句会将其后面跟随的语句进行延迟处理。在 <code>defer</code> 归属的函数即将返回时，将延迟处理的语句按 <code>defer</code> 定义的逆序执行。先被 <code>defer</code> 的语句最后被执行，最后被 <code>defer</code> 的语句，最先被执行。比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// defer将后面的语句延迟到函数即将退出时逆序执行,一般常用于资源释放</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deferTest</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;start&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;...&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">start</span><br><span class="line">end</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>函数中存在多个 <code>defer</code> 时,逆序执行后进先出，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deferTest2</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;start&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;1111&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;2222&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;3333&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">start</span><br><span class="line">end  </span><br><span class="line">3333</span><br><span class="line">2222</span><br><span class="line">1111</span><br></pre></td></tr></table></figure><p>由于 <code>defer </code> 语句延迟调用的特性，所以 <code>defer</code> 语句一般用于处理资源释放问题。比如：资源清理、文件关闭、解锁及记录时间等。</p><h1 id="defer-执行时机">defer 执行时机</h1><p>Go语言的函数中 <code>return</code> 语句在底层并不是原子操作，它分为两步：</p><ol><li>给返回值赋值</li><li>执行 <code>RET</code> 指令</li></ol><p><code>defer</code> 语句执行的时机是在返回值赋值操作后，执行 <code>RET</code> 指令前。如下图所示：</p><p><img src="https://www.liwenzhou.com/images/Go/func/defer.png" alt="defer执行时机"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/go/10%E5%8F%8D%E5%B0%84/"/>
      <url>/go/10%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<p>Go语言中变量分为两部分：</p><ul><li>类型信息：预先定义好的元信息</li><li>值信息：程序运行过程中可动态变化的</li></ul><h1 id="反射介绍">反射介绍</h1><p>反射是指在程序运行期对程序本身进行访问和修改的能力。<strong>程序编译时，变量将被转换为内存地址，变量名不会被编译器写入到可执行部分</strong>。这就是说程序运行时无法获取自身的信息。而支持反射的语言可以在程序编译期将变量的反射信息，如字段名称、类型信息、结构体信息等整合到可执行文件中，并给程序提供接口访问反射信息，这样就可以在程序运行期获取类型的反射信息，并且有能力修改它们。</p><p>Go语言运行期使用 <code>reflect</code> 包访问程序的反射信息。<code>reflect</code> 包实现了运行时反射，允许程序操作任意类型的对象。典型用法是用 <code>interface&#123;&#125;</code> 保存一个值，通过调用 <code>TypeOf</code> 获取其动态类型信息，返回一个<code>Type</code> 类型值。调用 <code>ValueOf</code> 函数返回一个Value类型值，该值代表运行时的数据。</p><p>Go的反射系统无法获取到一个可执行文件空间中或者是一个包中的所有类型信息，需要配合使用标准库中对应的词法、语法解析器和抽象语法树（AST）对源码进行扫描后才能获得。</p><h1 id="reflect包">reflect包</h1><p>Go语言的反射机制中，任何接口值都由是 <code>一个具体类型</code> 和 <code>具体类型的值</code> 两部分组成的。 Go语言中反射的相关功能由内置的 <code>reflect</code> 包提供，任意接口值在反射中都可以理解为由 <code>reflect.Type</code> 和 <code>reflect.Value</code> 两部分组成，并且 <code>reflect</code> 包提供了 <code>reflect.TypeOf</code> 和 <code>reflect.ValueOf</code> 两个函数来获取任意对象的<code>Value</code> 和 <code>Type</code> 。</p><h2 id="type-name-type-kind">type name/type kind</h2><p>反射中关于类型划分为两种：<code>类型（Type）</code>和<code>种类（Kind）</code>。因为在Go语言中可以使用type关键字构造很多自定义类型，<code>种类（Kind）</code> 指的是对象归属的品种，<code>类型（Type)</code> 指的是系统原生数据类型。比如 <code>map[string]int64</code> 与 <code>map[string]interface&#123;&#125;</code> 它们的类型并不一样，但是都属于<code>map</code>这个种类。</p><p>举个例子，定义了两个指针类型和两个结构体类型，通过反射查看它们的类型和种类：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myInt <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectType</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">t := reflect.TypeOf(x)</span><br><span class="line">fmt.Printf(<span class="string">&quot;type:%v kind:%v\n&quot;</span>, t.Name(), t.Kind())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a *<span class="keyword">float32</span> <span class="comment">// 指针</span></span><br><span class="line"><span class="keyword">var</span> b myInt    <span class="comment">// 自定义类型</span></span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">rune</span>     <span class="comment">// 类型别名</span></span><br><span class="line">reflectType(a) <span class="comment">// type: kind:ptr</span></span><br><span class="line">reflectType(b) <span class="comment">// type:myInt kind:int64</span></span><br><span class="line">reflectType(c) <span class="comment">// type:int32 kind:int32</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> book <span class="keyword">struct</span>&#123; title <span class="keyword">string</span> &#125;</span><br><span class="line"><span class="keyword">var</span> d = person&#123;</span><br><span class="line">name: <span class="string">&quot;沙河小王子&quot;</span>,</span><br><span class="line">age:  <span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> e = book&#123;title: <span class="string">&quot;《跟小王子学Go语言》&quot;</span>&#125;</span><br><span class="line">reflectType(d) <span class="comment">// type:person kind:struct</span></span><br><span class="line">reflectType(e) <span class="comment">// type:book kind:struct</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：Go语言的反射中像数组、切片、Map、指针等类型的变量，它们的<code>.Name()</code>都是返回<code>空</code>。</p></blockquote><p><code>reflect</code> 包中定义的Kind类型如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Kind <span class="keyword">uint</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Invalid Kind = <span class="literal">iota</span>  <span class="comment">// 非法类型</span></span><br><span class="line">    Bool                 <span class="comment">// 布尔型</span></span><br><span class="line">    Int                  <span class="comment">// 有符号整型</span></span><br><span class="line">    Int8                 <span class="comment">// 有符号8位整型</span></span><br><span class="line">    Int16                <span class="comment">// 有符号16位整型</span></span><br><span class="line">    Int32                <span class="comment">// 有符号32位整型</span></span><br><span class="line">    Int64                <span class="comment">// 有符号64位整型</span></span><br><span class="line">    Uint                 <span class="comment">// 无符号整型</span></span><br><span class="line">    Uint8                <span class="comment">// 无符号8位整型</span></span><br><span class="line">    Uint16               <span class="comment">// 无符号16位整型</span></span><br><span class="line">    Uint32               <span class="comment">// 无符号32位整型</span></span><br><span class="line">    Uint64               <span class="comment">// 无符号64位整型</span></span><br><span class="line">    Uintptr              <span class="comment">// 指针</span></span><br><span class="line">    Float32              <span class="comment">// 单精度浮点数</span></span><br><span class="line">    Float64              <span class="comment">// 双精度浮点数</span></span><br><span class="line">    Complex64            <span class="comment">// 64位复数类型</span></span><br><span class="line">    Complex128           <span class="comment">// 128位复数类型</span></span><br><span class="line">    Array                <span class="comment">// 数组</span></span><br><span class="line">    Chan                 <span class="comment">// 通道</span></span><br><span class="line">    Func                 <span class="comment">// 函数</span></span><br><span class="line">    Interface            <span class="comment">// 接口</span></span><br><span class="line">    Map                  <span class="comment">// 映射</span></span><br><span class="line">    Ptr                  <span class="comment">// 指针</span></span><br><span class="line">    Slice                <span class="comment">// 切片</span></span><br><span class="line">    String               <span class="comment">// 字符串</span></span><br><span class="line">    Struct               <span class="comment">// 结构体</span></span><br><span class="line">    UnsafePointer        <span class="comment">// 底层指针</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="TypeOf">TypeOf</h2><p>Go语言中使用 <code>reflect.TypeOf()</code> 可以获得任意值的类型对象（<code>reflect.Type</code>），程序通过类型对象可以访问任意值的类型信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectType</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">v := reflect.TypeOf(x)</span><br><span class="line">fmt.Printf(<span class="string">&quot;type:%v\n&quot;</span>, v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">float32</span> = <span class="number">3.14</span></span><br><span class="line">reflectType(a) <span class="comment">// type:float32</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">int64</span> = <span class="number">100</span></span><br><span class="line">reflectType(b) <span class="comment">// type:int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ValueOf">ValueOf</h2><p>Go语言中使用 <code> reflect.ValueOf()</code>返回的是 <code>reflect.Value</code> 类型，其中包含了原始值的值信息。<code>reflect.Value</code>与原始值之间可以互相转换。</p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>Interface() interface &#123;&#125;</code></td><td style="text-align:left">将值以 interface{} 类型返回，可以通过类型断言转换为指定类型</td></tr><tr><td style="text-align:left"><code>Int() int64</code></td><td style="text-align:left">将值以 int 类型返回，所有有符号整型均可以此方式返回</td></tr><tr><td style="text-align:left"><code>Uint() uint64</code></td><td style="text-align:left">将值以 uint 类型返回，所有无符号整型均可以此方式返回</td></tr><tr><td style="text-align:left"><code>Float() float64</code></td><td style="text-align:left">将值以双精度（float64）类型返回，所有浮点数（float32、float64）均可以此方式返回</td></tr><tr><td style="text-align:left"><code>Bool() bool</code></td><td style="text-align:left">将值以 bool 类型返回</td></tr><tr><td style="text-align:left"><code>Bytes() []bytes</code></td><td style="text-align:left">将值以字节数组 []bytes 类型返回</td></tr><tr><td style="text-align:left"><code>String() string</code></td><td style="text-align:left">将值以字符串类型返回</td></tr></tbody></table><h3 id="通过反射获取值">通过反射获取值</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reflect.ValueOf()可以获取reflect.Value类型，其中包含了原始值的值信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectValue</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">k := v.Kind()</span><br><span class="line"><span class="keyword">switch</span> k &#123;</span><br><span class="line"><span class="keyword">case</span> reflect.Int64:</span><br><span class="line"><span class="comment">// v.Int()从反射中获取整型的原始值，然后通过int64()强制类型转换</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;type is int64, value is %d\n&quot;</span>, <span class="keyword">int64</span>(v.Int()))</span><br><span class="line"><span class="keyword">case</span> reflect.Float32:</span><br><span class="line"><span class="comment">// v.Float()从反射中获取浮点型的原始值，然后通过float32()强制类型转换</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;type is float32, value is %f\n&quot;</span>, <span class="keyword">float32</span>(v.Float()))</span><br><span class="line"><span class="keyword">case</span> reflect.Float64:</span><br><span class="line"><span class="comment">// v.Float()从反射中获取浮点型的原始值，然后通过float64()强制类型转换</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;type is float64, value is %f\n&quot;</span>, <span class="keyword">float64</span>(v.Float()))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过反射获取对象的值reflect.Value</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getValue</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">float32</span> = <span class="number">3.14</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">int64</span> = <span class="number">100</span></span><br><span class="line">reflectValue(a) <span class="comment">// type is float32, value is 3.140000</span></span><br><span class="line">reflectValue(b) <span class="comment">// type is int64, value is 100</span></span><br><span class="line"><span class="comment">// 将int类型的原始值转换为reflect.Value类型</span></span><br><span class="line">c := reflect.ValueOf(<span class="number">10</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;type c :%T\n&quot;</span>, c) <span class="comment">// type c :reflect.Value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过反射设置值">通过反射设置值</h3><p>如果想在函数中通过反射修改变量的值时需要注意：函数参数传递的是值拷贝，必须传递变量地址才能修改变量值。反射中使用专有的<code>Elem()</code>方法来获取指针对应的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过反射设置值时如果函数参数传递的是值拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectSetValue1</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">fmt.Printf(<span class="string">&quot;value:%v,kind:%v&quot;</span>, v, v.Kind())</span><br><span class="line"><span class="keyword">if</span> v.Kind() == reflect.Int64 &#123;</span><br><span class="line">v.SetInt(<span class="number">200</span>) <span class="comment">// 修改的是副本,reflect包会引发panic</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过反射设置值时必须传递变量地址才能修改变量值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectSetValue2</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line"><span class="comment">// 反射中使用 Elem()方法获取指针对应的值</span></span><br><span class="line"><span class="keyword">if</span> v.Elem().Kind() == reflect.Int64 &#123;</span><br><span class="line">v.Elem().SetInt(<span class="number">200</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setValue</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int64</span> = <span class="number">100</span></span><br><span class="line"><span class="comment">// reflectSetValue1(a) //panic: reflect: reflect.Value.SetInt using unaddressable value</span></span><br><span class="line">reflectSetValue2(&amp;a)</span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="isNil">isNil()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">IsNil</span><span class="params">()</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure><p><code>IsNil()</code> 判断 <code>v</code> 持有的值是否为 <code>nil</code> 。v持有的值的分类必须是通道、函数、接口、映射、指针、切片之一，否则会导致panic</p><h3 id="isValid">isValid()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">IsValid</span><span class="params">()</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure><p><code>IsValid()</code> 判断否持有一个值。如果 <code>v</code> 是 <code>Value</code> 零值会返回 <code>false</code> ，此时v除了IsValid、String、Kind之外的方法都会导致panic</p><h3 id="代码示例">代码示例</h3><p><code>IsNil()</code> 常被用于判断指针是否为空；<code>IsValid()</code> 常被用于判定返回值是否有效。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isNilAndisValid</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// *int类型空指针</span></span><br><span class="line"><span class="keyword">var</span> a *<span class="keyword">int</span></span><br><span class="line">fmt.Println(<span class="string">&quot;var a *int IsNil:&quot;</span>, reflect.ValueOf(a).IsNil())</span><br><span class="line"><span class="comment">// nil值</span></span><br><span class="line">fmt.Println(<span class="string">&quot;nil IsValid:&quot;</span>, reflect.ValueOf(<span class="literal">nil</span>).IsValid())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化一个匿名结构体</span></span><br><span class="line">b := <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line"><span class="comment">// 尝试从结构体中查找&quot;abc&quot;字段</span></span><br><span class="line">fmt.Println(<span class="string">&quot;不存在的结构体成员:&quot;</span>, reflect.ValueOf(b).FieldByName(<span class="string">&quot;abc&quot;</span>).IsValid())</span><br><span class="line"><span class="comment">// 尝试从结构体中查找&quot;abc&quot;方法</span></span><br><span class="line">fmt.Println(<span class="string">&quot;不存在的结构体方法:&quot;</span>, reflect.ValueOf(b).MethodByName(<span class="string">&quot;abc&quot;</span>).IsValid())</span><br><span class="line"></span><br><span class="line"><span class="comment">// map</span></span><br><span class="line">c := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="comment">// 尝试从map中查找一个不存在的键</span></span><br><span class="line">fmt.Println(<span class="string">&quot;map中不存在的键：&quot;</span>, reflect.ValueOf(c).MapIndex(reflect.ValueOf(<span class="string">&quot;wang&quot;</span>)).IsValid())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="结构体反射">结构体反射</h1><p>任意值通过 <code>reflect.TypeOf()</code> 获得反射对象信息后，如果它的类型是结构体，可以通过反射值对象（<code>reflect.Type</code>）的 <code>NumField()</code> 和 <code>Field()</code> 方法获得结构体成员的详细信息。<code>reflect.Type</code> 中与获取结构体成员相关的的方法如下：</p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>Field(i int) StructField</code></td><td style="text-align:left">返回索引对应的结构体字段信息</td></tr><tr><td style="text-align:left"><code>NumField() int</code></td><td style="text-align:left">返回结构体成员字段数量</td></tr><tr><td style="text-align:left"><code>FieldByName(name string) (StructField, bool)</code></td><td style="text-align:left">根据给定字符串返回字符串对应的结构体字段信息</td></tr><tr><td style="text-align:left"><code>FieldByIndex(index []int) StructField</code></td><td style="text-align:left">多层成员访问时，根据 []int 提供的每个结构体的字段索引，返回字段信息</td></tr><tr><td style="text-align:left"><code>FieldByNameFunc(match func(string) bool) (StructField,bool)</code></td><td style="text-align:left">根据传入的匹配函数匹配需要的字段</td></tr><tr><td style="text-align:left"><code>NumMethod() int</code></td><td style="text-align:left">返回该类型的方法集中方法的数目</td></tr><tr><td style="text-align:left"><code>Method(int) Method</code></td><td style="text-align:left">返回该类型方法集中的第i个方法</td></tr><tr><td style="text-align:left"><code>MethodByName(string)(Method, bool)</code></td><td style="text-align:left">根据方法名返回该类型方法集中的方法</td></tr></tbody></table><p><code>StructField</code> 类型用来描述结构体中的一个字段的信息。定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StructField <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Name是字段的名字。PkgPath是非导出字段的包路径，对导出字段该字段为&quot;&quot;。</span></span><br><span class="line">    <span class="comment">// 参见http://golang.org/ref/spec#Uniqueness_of_identifiers</span></span><br><span class="line">    Name    <span class="keyword">string</span></span><br><span class="line">    PkgPath <span class="keyword">string</span></span><br><span class="line">    Type      Type      <span class="comment">// 字段的类型</span></span><br><span class="line">    Tag       StructTag <span class="comment">// 字段的标签</span></span><br><span class="line">    Offset    <span class="keyword">uintptr</span>   <span class="comment">// 字段在结构体中的字节偏移量</span></span><br><span class="line">    Index     []<span class="keyword">int</span>     <span class="comment">// 用于Type.FieldByIndex时的索引切片</span></span><br><span class="line">    Anonymous <span class="keyword">bool</span>      <span class="comment">// 是否匿名字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码示例</strong>：当使用反射得到一个结构体数据之后可以通过索引依次获取其字段信息，也可以通过字段名去获取指定的字段信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">Name  <span class="keyword">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">Score <span class="keyword">int</span>    <span class="string">`json:&quot;score&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">stu1 := student&#123;</span><br><span class="line">Name:  <span class="string">&quot;小王子&quot;</span>,</span><br><span class="line">Score: <span class="number">90</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">t := reflect.TypeOf(stu1)</span><br><span class="line">fmt.Println(t.Name(), t.Kind()) <span class="comment">// student struct</span></span><br><span class="line"><span class="comment">// 通过for循环遍历结构体的所有字段信息</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumField(); i++ &#123;</span><br><span class="line">field := t.Field(i)</span><br><span class="line">fmt.Printf(<span class="string">&quot;name:%s index:%d type:%v json tag:%v\n&quot;</span>, field.Name, field.Index, field.Type, field.Tag.Get(<span class="string">&quot;json&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过字段名获取指定结构体字段信息</span></span><br><span class="line"><span class="keyword">if</span> scoreField, ok := t.FieldByName(<span class="string">&quot;Score&quot;</span>); ok &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;name:%s index:%d type:%v json tag:%v\n&quot;</span>, scoreField.Name, scoreField.Index, scoreField.Type, scoreField.Tag.Get(<span class="string">&quot;json&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写函数 <code>printMethod(s interface&#123;&#125;)</code> 遍历打印s包含的方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给student添加两个方法 Study和Sleep(注意首字母大写,小写表示不可导出反射无法读取到)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s student)</span> <span class="title">Study</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">msg := <span class="string">&quot;好好学习，天天向上。&quot;</span></span><br><span class="line">fmt.Println(msg)</span><br><span class="line"><span class="keyword">return</span> msg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s student)</span> <span class="title">Sleep</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">msg := <span class="string">&quot;好好睡觉，快快长大。&quot;</span></span><br><span class="line">fmt.Println(msg)</span><br><span class="line"><span class="keyword">return</span> msg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反射获取结构体方法并调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printMethod</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">rType := reflect.TypeOf(x)</span><br><span class="line"></span><br><span class="line">rValue := reflect.ValueOf(x)</span><br><span class="line"></span><br><span class="line">fmt.Println(rType.NumMethod())</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; rValue.NumMethod(); i++ &#123;</span><br><span class="line">methodType := rValue.Method(i).Type()</span><br><span class="line">fmt.Printf(<span class="string">&quot;method name:%s\n&quot;</span>, rType.Method(i).Name)</span><br><span class="line">fmt.Printf(<span class="string">&quot;method:%s\n&quot;</span>, methodType)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过反射调用方法传递的参数必须是 []reflect.Value 类型</span></span><br><span class="line"><span class="keyword">var</span> args = []reflect.Value&#123;&#125;</span><br><span class="line">rValue.Method(i).Call(args)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">method name:Sleep   </span><br><span class="line">method:func() string</span><br><span class="line">好好睡觉，快快长大。</span><br><span class="line">method name:Study   </span><br><span class="line">method:func() string</span><br><span class="line">好好学习，天天向上。</span><br></pre></td></tr></table></figure><h1 id="总结">总结</h1><p>使用反射可以写出更灵活的代码。但是反射不应该被滥用，原因有以下三个：</p><ol><li>基于反射的代码是极其脆弱的，反射中的类型错误会在真正运行的时候才会引发 <code>panic</code> 而不是在编译期</li><li>大量使用反射的代码通常难以理解</li><li>反射的性能低下，基于反射实现的代码通常比正常代码运行速度慢一到两个数量级</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/go/09%E6%8C%87%E9%92%88/"/>
      <url>/go/09%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h1 id="指针类型">指针类型</h1><p>任何程序数据载入内存后，在内存都有内存的地址这就是指针。而为了保存一个数据在内存中的地址，就需要指针变量。一个指针的值是一个变量的地址。一个指针对应变量在内存中的存储位置。</p><p>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x := <span class="number">1</span>          <span class="comment">// 声明int类型变量x</span></span><br><span class="line">p := &amp;x         <span class="comment">// &amp;x用于获取变量x的内存地址，返回一个指向x的指针p</span></span><br><span class="line">fmt.Println(*p) <span class="comment">// *p用户获取指针p指向变量的值</span></span><br><span class="line">*p = <span class="number">2</span>          <span class="comment">// 可以重新给*p指针赋值</span></span><br><span class="line">fmt.Println(x)  <span class="comment">// &quot;2&quot;</span></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1      </span><br><span class="line">2    </span><br></pre></td></tr></table></figure><p>用 <code>var x int</code> 声明语句声明一个变量，<code>&amp;x</code> 表达式（取x变量的内存地址）将产生一个指向该整数变量的指针，指针对应的数据类型是 <code>*int</code>，名字为 <code>p</code> ，可以理解为：“p指针指向变量x”或者“p指针保存了x变量的内存地址”。同时 <code>*p</code> 表达式对应p指针指向的变量的值。一般 <code>*p</code> 表达式读取指针指向的变量的值，这里为int类型的值，同时因为 <code>*p</code> 对应一个变量，所以该表达式也可以出现在赋值语句的左边，表示更新指针所指向的变量的值。</p><blockquote><p>注意：因为指针包含了一个变量的地址，因此如果将指针作为参数调用函数，那将可以在函数中通过该指针来更新变量的值</p></blockquote><ul><li><code>&amp;x</code>：获取变量x的内存地址，返回一个指向x的指针</li><li><code>*p</code>：获取指针p指向变量的值</li></ul><p>看一下 <code>b := &amp;a</code> 的图示：</p><p><img src="https://www.liwenzhou.com/images/Go/pointer/ptr.png" alt="取变量地址图示"></p><p><strong>总结：</strong> 取地址操作符 <code>&amp;</code> 和取值操作符 <code>*</code> 是一对互补操作符，<code>&amp; </code>取出地址，<code>* </code>根据地址取出地址指向的值。</p><p>变量、指针地址、指针变量、取地址、取值的相互关系和特性如下：</p><ul><li>对变量进行取地址 <code>&amp;</code> 操作，可以获得这个变量的指针变量</li><li>指针变量的值是指针地址</li><li>对指针变量进行取值 <code>*</code>操作，可以获得指针变量指向的原变量的值</li></ul><p>指针传值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify1</span><span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">x = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify2</span><span class="params">(x *<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">*x = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="number">10</span></span><br><span class="line">modify1(a)</span><br><span class="line">fmt.Println(a) <span class="comment">// 10</span></span><br><span class="line">modify2(&amp;a)</span><br><span class="line">fmt.Println(a) <span class="comment">// 100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="new和make">new和make</h1><p>先来看一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a *<span class="keyword">int</span></span><br><span class="line">*a = <span class="number">100</span></span><br><span class="line">fmt.Println(*a)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">b[<span class="string">&quot;wangpengliang&quot;</span>] = <span class="number">100</span></span><br><span class="line">fmt.Println(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上面的代码会引发 <code>panic</code>，为什么呢？ 在Go语言中<strong>对于引用类型的变量，在使用的时候不仅要声明，还要为它分配内存空间，否则值就没办法存储。而对于值类型的声明不需要分配内存空间，是因为它们在声明的时候已经默认分配好内存空间</strong>。Go语言中 <code>new</code> 和 <code>make</code> 是内建的两个函数，主要用来分配内存。</p><p>这里 <code>panic</code>原因在于：</p><p><code>var a *int</code>  只是声明了一个指针变量 <code>a</code> 但是没有初始化，指针作为引用类型需要初始化后才会拥有内存空间，才可以赋值。比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a *<span class="keyword">int</span></span><br><span class="line">a = <span class="built_in">new</span>(<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure><p><code>var b map[string]int</code> 只是声明变量 <code>b</code> 是一个 <code>map</code> 类型变量而未初始化。需要初始化后才可以赋值，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">b = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><h2 id="new">new</h2><p><code>new</code> 是一个内置的函数，函数签名如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">new</span><span class="params">(Type)</span> *<span class="title">Type</span></span></span><br></pre></td></tr></table></figure><p>其中，</p><ul><li><code>Type</code> 表示类型，<code>new</code> 函数只接受一个参数，这个参数是一个类型</li><li><code>*Type</code>表示类型指针，<code>new</code> 函数返回一个指向该类型内存地址的指针</li></ul><p>使用 <code>new</code> 函数得到的是一个类型的指针，并且该指针对应的值为该类型的零值。比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="built_in">new</span>(<span class="keyword">int</span>)</span><br><span class="line">b := <span class="built_in">new</span>(<span class="keyword">bool</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, a) <span class="comment">// *int</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, b) <span class="comment">// *bool</span></span><br><span class="line">fmt.Println(*a)       <span class="comment">// 0</span></span><br><span class="line">fmt.Println(*b)       <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="make">make</h2><p><code>make</code> 也是用于内存分配的，与 <code>new </code>区别在于它只用于 <code>slice</code>、<code>map</code>以及 <code>channel</code> 的内存创建，而且它返回的类型就是这三个类型本身，而不是他们的指针类型。</p><blockquote><p>因为这三种类型就是引用类型，所以就没有必要返回他们的指针了</p></blockquote><p>函数签名如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">make</span><span class="params">(t Type, size ...IntegerType)</span> <span class="title">Type</span></span></span><br></pre></td></tr></table></figure><h1 id="new与make的区别">new与make的区别</h1><ol><li>二者都是用来做内存分配的。</li><li><code>make</code> 只用于<code>slice</code>、<code>map</code> 、<code>channel</code> 的初始化，返回这三个引用类型本身</li><li><code>new</code> 用于类型的内存分配，并且内存对应的值为类型零值，返回的是指向类型的指针</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/go/12%E6%8E%A5%E5%8F%A3/"/>
      <url>/go/12%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<p>接口（interface）定义了一个对象的行为规范，只定义规范具体对象来实现规范的细节。Go语言中接口（interface）是一种抽象类型。与C#中接口的定义是一样的，相较于具体类型比如字符串、切片、结构体等（更注重“我是什么”），接口类型更注重“能做什么”。接口类型像是一种约定。Go语言中提倡使用面向接口的编程方式实现解耦。</p><h1 id="接口类型">接口类型</h1><p>接口是一种由程序员定义的类型，一个接口类型就是一组方法的集合，它规定了需要实现的所有方法。相较于使用结构体类型，当使用接口类型说明：<strong>相比于它是什么更关心它能做什么</strong>。</p><h1 id="接口定义">接口定义</h1><p>每个接口类型由任意个方法签名组成，定义格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 接口类型名 <span class="keyword">interface</span>&#123;</span><br><span class="line">    方法名<span class="number">1</span>( 参数列表<span class="number">1</span> ) 返回值列表<span class="number">1</span></span><br><span class="line">    方法名<span class="number">2</span>( 参数列表<span class="number">2</span> ) 返回值列表<span class="number">2</span></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>接口类型名：Go语言的接口在命名时，一般会在单词后面添加<code>er</code>，就像C#中接口定义通常以<code>I</code> 开头，接口名要能突出该接口的类型含义</li><li>方法名：当方法名首字母是大写且这个接口类型名首字母也是大写时，这个方法可以被接口所在的包（package）之外的代码访问</li><li>参数列表、返回值列表：参数列表和返回值列表中的参数变量名可以省略</li></ul><p>比如，定义一个包含<code>Write</code>方法的<code>Writer</code>接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span>&#123;</span><br><span class="line">    Write([]<span class="keyword">byte</span>) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当看到一个<code>Writer</code>接口类型的值时，不知道它是什么，唯一知道的就是可以通过调用它的<code>Write</code>方法来做一些事。</p><h1 id="实现接口的条件">实现接口的条件</h1><p>接口规定了一个<strong>需要实现的方法列表</strong>，<strong>Go 语言中一个类型只要实现了接口中规定的所有方法，就称它实现了这个接口</strong>。在C#或者Java语言中都需要显式声明类实现了哪些接口，Go语言中则使用隐式声明的方式实现接口。</p><h1 id="值接收者和指针接收者">值接收者和指针接收者</h1><p>之前介绍了在定义结构体方法时既可以使用值接收者也可以使用指针接收者。那么对于实现接口来说使用值接收者和使用指针接收者有什么区别呢？通过一个例子来看一下。</p><p>我们定义一个<code>Mover</code>接口，它包含一个<code>Move</code>方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Move <span class="keyword">interface</span> &#123;</span><br><span class="line">Move()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="值接收者实现接口">值接收者实现接口</h2><p>定义一个<code>Dog</code>结构体类型，并使用值接收者为其定义一个<code>Move</code>方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Move 使用值接收者定义Move方法实现Mover接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Dog)</span> <span class="title">Move</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;狗会动&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时实现<code>Mover</code>接口的是<code>Dog</code>类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x Mover    <span class="comment">// 声明一个Mover类型的变量x</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d1 = Dog&#123;&#125; <span class="comment">// d1是Dog类型</span></span><br><span class="line">x = d1         <span class="comment">// 可以将d1赋值给变量x</span></span><br><span class="line">x.Move()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d2 = &amp;Dog&#123;&#125; <span class="comment">// d2是Dog指针类型</span></span><br><span class="line">x = d2          <span class="comment">// 也可以将d2赋值给变量x</span></span><br><span class="line">x.Move()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">狗会动</span><br><span class="line">狗会动</span><br></pre></td></tr></table></figure><p>上面的代码中可以发现，使用值接收者实现接口之后，不管是结构体类型还是对应的结构体指针类型的变量都可以赋值给该接口变量。</p><h2 id="指针接收者实现接口">指针接收者实现接口</h2><p>再来测试一下使用指针接收者实现接口有什么区别。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Cat 猫结构体类型</span></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Move 使用指针接收者定义Move方法实现Mover接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cat)</span> <span class="title">Move</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;猫会动&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时实现<code>Mover</code>接口的是<code>*Cat</code>类型，可以将<code>*Cat</code>类型的变量直接赋值给<code>Mover</code>接口类型的变量<code>x</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c2 = &amp;Cat&#123;&#125; <span class="comment">// c2是*Cat类型</span></span><br><span class="line">x = c2          <span class="comment">// 可以将c2当成Mover类型</span></span><br><span class="line">x.Move()</span><br></pre></td></tr></table></figure><p>但是不能将<code>Cat</code>类型的变量赋值给<code>Mover</code>接口类型的变量<code>x</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面的代码无法通过编译</span></span><br><span class="line"><span class="keyword">var</span> c1 = Cat&#123;&#125; <span class="comment">// c1是Cat类型</span></span><br><span class="line">x = c1         <span class="comment">// 不能将c1当成Mover类型</span></span><br></pre></td></tr></table></figure><p>由于Go语言中有对指针求值的语法糖，对于值接收者实现的接口，无论使用值类型还是指针类型都没有问题。但是并不总是能对一个值求址，所以对于指针接收者实现的接口要额外注意。</p><h1 id="类型与接口">类型与接口</h1><h2 id="一个类型实现多个接口">一个类型实现多个接口</h2><p>一个类型可以同时实现多个接口，而接口间彼此独立，不知道对方的实现。例如狗不仅可以叫，还可以动。可以分别定义<code>Sayer</code>接口和<code>Mover</code>接口，代码示例如下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sayer 接口</span></span><br><span class="line"><span class="keyword">type</span> Sayer <span class="keyword">interface</span> &#123;</span><br><span class="line">Say()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mover 接口</span></span><br><span class="line"><span class="keyword">type</span> Mover <span class="keyword">interface</span> &#123;</span><br><span class="line">Move()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Dog</code>既可以实现<code>Sayer</code>接口，也可以实现<code>Mover</code>接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Move 使用值接收者定义Move方法实现Mover接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Dog)</span> <span class="title">Move</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;狗会动&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现Sayer接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Dog)</span> <span class="title">Say</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s会叫汪汪汪\n&quot;</span>, d.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同一个类型实现不同的接口互相不影响使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = Dog&#123;Name: <span class="string">&quot;旺财&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s Sayer = d</span><br><span class="line"><span class="keyword">var</span> m Mover = d</span><br><span class="line"></span><br><span class="line">s.Say()  <span class="comment">// 对Sayer类型调用Say方法</span></span><br><span class="line">m.Move() <span class="comment">// 对Mover类型调用Move方法</span></span><br></pre></td></tr></table></figure><h2 id="多种类型实现同一接口">多种类型实现同一接口</h2><p>Go语言中不同的类型还可以实现同一接口。例如不仅狗可以动，汽车也可以动。可以使用如下代码体现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现Mover接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Dog)</span> <span class="title">Move</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s会动\n&quot;</span>, d.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Car 汽车结构体类型</span></span><br><span class="line"><span class="keyword">type</span> Car <span class="keyword">struct</span> &#123;</span><br><span class="line">Brand <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Move Car类型实现Mover接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Car)</span> <span class="title">Move</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s速度70迈\n&quot;</span>, c.Brand)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在代码中就可以把狗和汽车当成一个会动的类型来处理，不必关注它们具体是什么，只需要调用<code>Move</code>方法即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x Mover</span><br><span class="line"></span><br><span class="line">x = Dog&#123;name: <span class="string">&quot;旺财&quot;</span>&#125;</span><br><span class="line">x.Move()</span><br><span class="line"></span><br><span class="line">x = Car&#123;brand: <span class="string">&quot;宝马&quot;</span>&#125;</span><br><span class="line">x.Move()</span><br></pre></td></tr></table></figure><p>一个接口的所有方法，不一定需要由一个类型完全实现，接口的方法可以通过在类型中嵌入其他类型或者结构体来实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  洗衣机</span></span><br><span class="line"><span class="keyword">type</span> WashingMachine <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 清洗</span></span><br><span class="line">wash()</span><br><span class="line">    <span class="comment">// 烘干</span></span><br><span class="line">dry()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 海尔洗衣机</span></span><br><span class="line"><span class="keyword">type</span> haier <span class="keyword">struct</span> &#123;</span><br><span class="line">dryer <span class="comment">// 嵌入甩干器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现WashingMachine接口的wash()方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h haier)</span> <span class="title">wash</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;洗刷刷&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 甩干机</span></span><br><span class="line"><span class="keyword">type</span> dryer <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dryer)</span> <span class="title">dry</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;甩一甩&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="接口组合">接口组合</h1><p>接口与接口之间可以通过互相嵌套形成新的接口类型，例如Go标准库<code>io</code>源码中就有很多接口之间互相组合的示例。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/io/io.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">Read(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Closer <span class="keyword">interface</span> &#123;</span><br><span class="line">Close() error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReadWriter 是组合Reader接口和Writer接口形成的新接口类型</span></span><br><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">Reader</span><br><span class="line">Writer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReadCloser 是组合Reader接口和Closer接口形成的新接口类型</span></span><br><span class="line"><span class="keyword">type</span> ReadCloser <span class="keyword">interface</span> &#123;</span><br><span class="line">Reader</span><br><span class="line">Closer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WriteCloser 是组合Writer接口和Closer接口形成的新接口类型</span></span><br><span class="line"><span class="keyword">type</span> WriteCloser <span class="keyword">interface</span> &#123;</span><br><span class="line">Writer</span><br><span class="line">Closer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于这种由多个接口类型组合形成的新接口类型，同样只需要实现新接口类型中规定的所有方法就算实现了该接口类型。</p><p>接口也可以作为结构体的一个字段，看一段Go标准库<code>sort</code>源码中的示例。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/sort/sort.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Interface 定义通过索引对元素排序的接口类型</span></span><br><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    Len() <span class="keyword">int</span></span><br><span class="line">    Less(i, j <span class="keyword">int</span>) <span class="keyword">bool</span></span><br><span class="line">    Swap(i, j <span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// reverse 结构体中嵌入了Interface接口</span></span><br><span class="line"><span class="keyword">type</span> reverse <span class="keyword">struct</span> &#123;</span><br><span class="line">    Interface</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过在结构体中嵌入一个接口类型，从而让该结构体类型实现了该接口类型，并且还可以改写该接口的方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Less 为reverse类型添加Less方法，重写原Interface接口类型的Less方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r reverse)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> r.Interface.Less(j, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Interface</code>类型原本的<code>Less</code>方法签名为<code>Less(i, j int) bool</code>，此处重写为<code>r.Interface.Less(j, i)</code>，即通过将索引参数交换位置实现反转。</p><p>在这个示例中还有一个需要注意的地方是<code>reverse</code>结构体本身是不可导出的（结构体类型名称首字母小写），<code>sort.go</code>中通过定义一个可导出的<code>Reverse</code>函数来让使用者创建<code>reverse</code>结构体实例。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Reverse</span><span class="params">(data Interface)</span> <span class="title">Interface</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;reverse&#123;data&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做的目的是保证得到的<code>reverse</code>结构体中的<code>Interface</code>属性一定不为<code>nil</code>，否者<code>r.Interface.Less(j, i)</code>就会出现空指针panic。</p><p>此外在Go内置标准库<code>database/sql</code>中也有很多类似的结构体内嵌接口类型的使用示例。</p><h1 id="空接口">空接口</h1><p>空接口是指没有定义任何方法的接口类型。因此任何类型都可以视为实现了空接口。也正是因为这个特性，空接口类型的变量可以存储任意类型的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Any 不包含任何方法的空接口类型</span></span><br><span class="line"><span class="keyword">type</span> Any <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空接口类型的变量可以存储任意类型的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">emptyInterfaceTest</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 声明空接口类型变量</span></span><br><span class="line"><span class="keyword">var</span> x Any</span><br><span class="line"></span><br><span class="line">x = <span class="string">&quot;你好&quot;</span> <span class="comment">// 字符串型</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;type:%T value:%v\n&quot;</span>, x, x)</span><br><span class="line">x = <span class="number">100</span> <span class="comment">// int型</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;type:%T value:%v\n&quot;</span>, x, x)</span><br><span class="line">x = <span class="literal">true</span> <span class="comment">// 布尔型</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;type:%T value:%v\n&quot;</span>, x, x)</span><br><span class="line">x = Person&#123;&#125; <span class="comment">// 结构体类型</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;type:%T value:%v\n&quot;</span>, x, x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常在使用空接口类型时不必使用<code>type</code>关键字声明，可以像下面的代码一样直接使用<code>interface&#123;&#125;</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125;  <span class="comment">// 声明一个空接口类型变量x</span></span><br></pre></td></tr></table></figure><h2 id="空接口作为函数参数">空接口作为函数参数</h2><p>使用空接口实现可以接收任意类型的函数参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空接口作为函数参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">print</span><span class="params">(a <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;type:%T value:%v\n&quot;</span>, a, a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="空接口作为map的值">空接口作为map的值</h2><p>使用空接口实现可以保存任意值的字典。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">emptyInterfaceTest4</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> person = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">person[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;wangpengliang&quot;</span></span><br><span class="line">person[<span class="string">&quot;age&quot;</span>] = <span class="number">18</span></span><br><span class="line">person[<span class="string">&quot;married&quot;</span>] = <span class="literal">false</span></span><br><span class="line">fmt.Println(person)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="接口值">接口值</h1><p>由于接口类型的值可以是任意一个实现了该接口的类型值，所以接口值除了需要记录具体<strong>值</strong>之外，还需要记录这个值属于的<strong>类型</strong>。也就是说接口值由“类型”和“值”组成，鉴于这两部分会根据存入值的不同而发生变化，称之为接口的<code>动态类型</code>和<code>动态值</code>。</p><p><img src="/images/2022-03-30-16-00-55.png" alt=""></p><p>通过一个示例来加深对接口值的理解，示例代码中，定义了一个<code>Mover</code>接口类型和两个实现了该接口的<code>Dog</code>和<code>Car</code>结构体类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mover <span class="keyword">interface</span> &#123;</span><br><span class="line">Move()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dog)</span> <span class="title">Move</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;狗在跑~&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Car <span class="keyword">struct</span> &#123;</span><br><span class="line">Brand <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Car)</span> <span class="title">Move</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;汽车在跑~&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先创建一个<code>Mover</code>接口类型的变量<code>m</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m Mover</span><br></pre></td></tr></table></figure><p>此时，接口变量<code>m</code>是接口类型的零值，也就是它的类型和值部分都是<code>nil</code>，就如下图所示。<br><img src="/images/2022-03-30-11-03-47.png" alt=""></p><p>可以使用<code>m == nil</code>来判断此时的接口值是否为空。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(m == <span class="literal">nil</span>)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：不能对一个空接口值调用任何方法，否则会产生panic。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m.Move() <span class="comment">// panic: runtime error: invalid memory address or nil pointer dereference</span></span><br></pre></td></tr></table></figure><p>接下来将一个<code>*Dog</code>结构体指针赋值给变量<code>m</code>，此时<code>m</code>的动态类型会被设置为<code>*Dog</code>，动态值为结构体变量的拷贝。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m = &amp;Dog&#123;Name: <span class="string">&quot;旺财&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/2022-03-30-15-54-50.png" alt=""></p><p>然后给接口变量<code>m</code>赋值为一个<code>*Car</code>类型的值。此时接口值的动态类型为<code>*Car</code>，动态值为<code>nil</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m = <span class="built_in">new</span>(Car)</span><br></pre></td></tr></table></figure><p><img src="/images/2022-03-30-15-55-29.png" alt=""></p><p><strong>注意</strong>：此时接口变量<code>m</code>与<code>nil</code>并不相等，因为它只是动态值的部分为<code>nil</code>，而动态类型部分保存着对应值的类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(m == <span class="literal">nil</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>接口值是支持相互比较的，当且仅当接口值的动态类型和动态值都相等时才相等。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">x Mover2 = <span class="built_in">new</span>(Dog2)</span><br><span class="line">y Mover2 = <span class="built_in">new</span>(Car2)</span><br><span class="line">)</span><br><span class="line">fmt.Println(x == y) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>有一种特殊情况需要特别注意，如果接口值的保存的动态类型相同，但是这个动态类型不支持互相比较（比如切片），那么对它们相互比较时就会引发 <code>panic</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> z <span class="keyword">interface</span>&#123;&#125; = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(z == z) <span class="comment">// panic: runtime error: comparing uncomparable type []int</span></span><br></pre></td></tr></table></figure><h1 id="类型断言">类型断言</h1><p>接口值可能赋值为任意类型的值，如何从接口值获取其存储的具体数据呢？可以借助标准库 <code>fmt</code> 包的格式化打印获取到接口值的动态类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m Mover</span><br><span class="line"></span><br><span class="line">m = &amp;Dog&#123;Name: <span class="string">&quot;旺财&quot;</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, m) <span class="comment">// *main.Dog</span></span><br><span class="line"></span><br><span class="line">m = <span class="built_in">new</span>(Car)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, m) <span class="comment">// *main.Car</span></span><br></pre></td></tr></table></figure><p>而<code>fmt</code>包内部其实是使用反射的机制在程序运行时获取到动态类型的名称。而想要从接口值中获取到对应的实际值需要使用类型断言，其语法格式如下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.(T)</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>x：表示接口类型的变量</li><li>T：表示断言<code>x</code>可能是的类型。</li></ul><p>该语法返回两个参数，第一个参数是<code>x</code>转化为<code>T</code>类型后的变量，第二个值是一个布尔值，若为<code>true</code>则表示断言成功，为<code>false</code>则表示断言失败。</p><p>比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n Mover = &amp;Dog&#123;Name: <span class="string">&quot;旺财&quot;</span>&#125;</span><br><span class="line">v, ok := n.(*Dog)</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;类型断言成功&quot;</span>)</span><br><span class="line">v.Name = <span class="string">&quot;富贵&quot;</span> <span class="comment">// 变量v是*Dog类型</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;类型断言失败&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果对一个接口值有多个实际类型需要判断，推荐使用<code>switch</code>语句来实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// justifyType 对传入的空接口类型变量x进行类型断言</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">justifyType</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> v := x.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">fmt.Printf(<span class="string">&quot;x is a string，value is %v\n&quot;</span>, v)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">fmt.Printf(<span class="string">&quot;x is a int is %v\n&quot;</span>, v)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">bool</span>:</span><br><span class="line">fmt.Printf(<span class="string">&quot;x is a bool is %v\n&quot;</span>, v)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;unsupport type！&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于接口类型变量能够动态存储不同类型值的特点，所以很多人会滥用接口类型（特别是空接口）来实现编码过程中的便捷。只有当有两个或两个以上的具体类型必须以相同的方式进行处理时才需要定义接口。切记不要为了使用接口类型而增加不必要的抽象，导致不必要的运行时损耗。</p><p>在 Go 语言中接口是一个非常重要的概念和特性，使用接口类型能够实现代码的抽象和解耦，也可以隐藏某个功能的内部实现，但是缺点就是在查看源码的时候，不太方便查找到具体实现接口的类型。<strong>切记</strong>：接口是一种类型，一种抽象的类型。它是一个只要求实现特定方法的抽象类型。</p><p><strong>小技巧：</strong> 下面的代码可以在程序编译阶段验证某一结构体是否满足特定的接口类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 摘自gin框架routergroup.go</span></span><br><span class="line"><span class="keyword">type</span> IRouter <span class="keyword">interface</span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RouterGroup <span class="keyword">struct</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ IRouter = &amp;RouterGroup&#123;&#125;  <span class="comment">// 确保RouterGroup实现了接口IRouter</span></span><br></pre></td></tr></table></figure><p>上面的代码中也可以使用 <code>var _ IRouter = (*RouterGroup)(nil)</code> 进行验证。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/go/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/CSP%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B/"/>
      <url>/go/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/CSP%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="并发模型">并发模型</h1><p>业界将如何实现并发编程总结归纳为各式各样的并发模型，常见的并发模型有以下几种：</p><ul><li>线程&amp;锁模型</li><li>Actor模型</li><li>CSP模型</li><li>Fork&amp;Join模型</li></ul><p>Go语言中的并发程序主要是通过基于 <code>CSP（communicating sequential processes）</code> 的 <code>goroutine</code> 和 <code>channel</code>来实现，当然也支持使用传统的多线程共享内存的并发方式。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/go/11%E7%BB%93%E6%9E%84%E4%BD%93/"/>
      <url>/go/11%E7%BB%93%E6%9E%84%E4%BD%93/</url>
      
        <content type="html"><![CDATA[<h1 id="自定义类型">自定义类型</h1><p>Go语言中有一些基本的数据类型，如<code>string</code>、<code>整型</code>、<code>浮点型</code>、<code>布尔</code>等数据类型， 使用<code>type</code>关键字来定义自定义类型。</p><p>自定义类型是定义了一个全新的类型。可以基于内置的基本类型定义，也可以通过 <code>struct</code> 定义。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将MyInt定义为int类型</span></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span></span><br></pre></td></tr></table></figure><p>通过 <code>type</code> 关键字的定义，<code>MyInt</code> 就是一种新的类型，具有 <code>int</code> 的特性。</p><h1 id="类型别名">类型别名</h1><p>类型别名是<code>Go1.9</code>版本添加的新功能。类型别名规定：<code>TypeAlias</code> 只是Type的别名，本质上TypeAlias与Type是同一个类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TypeAlias = Type</span><br></pre></td></tr></table></figure><p>之前见过的<code>rune</code>和<code>byte</code>就是类型别名，定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="keyword">byte</span> = <span class="keyword">uint8</span></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">rune</span> = <span class="keyword">int32</span></span><br></pre></td></tr></table></figure><h1 id="自定义类型-类型别名区别">自定义类型/类型别名区别</h1><p>类型别名与类型定义表面上看只有一个等号的差异，通过下面的这段代码来理解它们之间的区别：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型定义</span></span><br><span class="line"><span class="keyword">type</span> NewInt <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型别名</span></span><br><span class="line"><span class="keyword">type</span> MyInt = <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a NewInt</span><br><span class="line"><span class="keyword">var</span> b MyInt</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;type of a:%T\n&quot;</span>, a) <span class="comment">// type of a:main.NewInt</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;type of b:%T\n&quot;</span>, b) <span class="comment">// type of b:int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果显示a的类型是 <code>main.NewInt</code>，表示main包下定义的<code>NewInt</code>类型。b的类型是<code>int</code>。<code>MyInt</code>类型只会在代码中存在，编译完成时并不会有<code>MyInt</code>类型。</p><h1 id="结构定义">结构定义</h1><p>Go语言的结构体（struct）和其他语言的类（class）有同等的地位，但Go语言放弃了大量面向对象特性，只保留了组合（composition）这个最基础的特性。Go语言中可以通过 <code>struct</code> 来实现面向对象。</p><p>使用 <code>type</code> 和 <code>struct</code> 关键字来定义结构体，具体代码格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 类型名 <span class="keyword">struct</span> &#123;</span><br><span class="line">    字段名 字段类型</span><br><span class="line">    字段名 字段类型</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>类型名：标识自定义结构体的名称。在同一个包内不能重复</li><li>字段名：表示结构体字段名。结构体中的字段名必须唯一</li><li>字段类型：表示结构体字段的具体类型</li></ul><p>比如：定义一个表示矩形的结构</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Rect <span class="keyword">struct</span> &#123;</span><br><span class="line">width  <span class="keyword">float64</span></span><br><span class="line">height <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样类型的字段也可以写在一行，看起来更简洁</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Rect <span class="keyword">struct</span> &#123;</span><br><span class="line">width, height <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>语言内置的基础数据类型是用来描述一个值的，而结构体是用来描述一组值的。本质上是一种聚合型的数据类型。</p><h1 id="结构实例化">结构实例化</h1><p><strong>最简单的实例化方式</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rect Rect</span><br><span class="line">fmt.Printf(<span class="string">&quot;%p %T \n&quot;</span>, &amp;rect, rect)</span><br><span class="line">rect.height = <span class="number">13.4</span></span><br><span class="line">rect.width = <span class="number">21.</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%p %T \n&quot;</span>, &amp;rect, rect)</span><br><span class="line">fmt.Println(rect.height, rect.width)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0xc0000120a0 main.Rect </span><br><span class="line">0xc0000120a0 main.Rect </span><br><span class="line">13.4 21</span><br></pre></td></tr></table></figure><p>因为结构是值类型，所以定义结构体类型变量就会分配内存，如果不给结构体中的字段赋值，默认就会是该类型的零值。而后可以通过<code>.</code>来访问结构体的字段</p><p><strong>创建指针类型结构</strong>：</p><p>通过使用 <code>new</code> 关键字对结构体进行实例化，得到的是结构体的内存地址。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rect = <span class="built_in">new</span>(Rect)</span><br><span class="line">   <span class="comment">// Go语言中支持对结构体指针直接使用.来访问结构体的成员</span></span><br><span class="line">rect.height = <span class="number">13.4</span></span><br><span class="line">rect.width = <span class="number">21.4</span></span><br><span class="line">   <span class="comment">// 这里因为使用new()返回的已经是指针类型,所以打印输出时不需要加&amp;取址</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T %p\n&quot;</span>, rect, rect)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*main.Rect 0xc0000aa070</span><br></pre></td></tr></table></figure><p><strong>使用结构体的地址实例化</strong>：</p><p>使用<code>&amp;</code>对结构体进行取地址操作相当于对该结构体类型进行了一次<code>new</code>实例化操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rect = &amp;Rect&#123;&#125;</span><br><span class="line">rect.height = <span class="number">13.4</span></span><br><span class="line">rect.width = <span class="number">21.4</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T %p\n&quot;</span>, rect, rect)</span><br></pre></td></tr></table></figure><h1 id="结构初始化">结构初始化</h1><p><strong>默认</strong>：没有初始化的结构体，其成员变量都是对应其类型的零值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rect Rect</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v \n&quot;</span>, rect)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main.Rect&#123;width:0, height:0&#125;</span><br></pre></td></tr></table></figure><p><strong>使用键值对初始化</strong>：</p><p>使用键值对初始化时，键对应结构体的字段，值对应该字段的初始值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rect := Rect&#123;width: <span class="number">10.5</span>, height: <span class="number">3.5</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v \n&quot;</span>, rect)</span><br></pre></td></tr></table></figure><p>也可以对结构体指针进行键值对初始化，比如：</p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">// 对结构体指针进行键值初始化</span></span><br><span class="line"><span class="xml">rect2 := &amp;Rect&#123;width: 10.5, height: 3.5&#125;</span></span><br><span class="line"><span class="xml">fmt.Printf(&quot;%#v \n&quot;, rect2)</span></span><br></pre></td></tr></table></figure><p>如果字段没有初始值,可以省略，那么被省略的值就是该字段的零值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果字段没有初始值,可以省略,那么被省略的值就是该字段的零值</span></span><br><span class="line">rect3 := Rect&#123;width: <span class="number">100.0</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v \n&quot;</span>, rect3)</span><br></pre></td></tr></table></figure><p><strong>使用值的列表初始化</strong>：</p><p>初始化结构体的时候可以简写，也就是初始化的时候不写键，直接写值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rect := Rect&#123;<span class="number">10.5</span>, <span class="number">3.5</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v \n&quot;</span>, rect)</span><br><span class="line"></span><br><span class="line">rect2 := &amp;Rect&#123;<span class="number">10.5</span>, <span class="number">3.5</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v \n&quot;</span>, rect2)</span><br></pre></td></tr></table></figure><p>使用这种格式初始化时，需要注意：</p><ol><li>必须初始化结构体的所有字段</li><li>初始值的填充顺序必须与字段在结构体中的声明顺序一致</li><li>该方式不能和键值初始化方式混用</li></ol><h1 id="匿名结构体">匿名结构体</h1><p>在定义一些临时数据结构等场景下可以使用匿名结构体。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匿名结构体</span></span><br><span class="line"><span class="keyword">var</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line">user.name = <span class="string">&quot;wangpengliang&quot;</span></span><br><span class="line">user.age = <span class="number">18</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%v \n&quot;</span>, user)</span><br></pre></td></tr></table></figure><h1 id="空结构体">空结构体</h1><p>空结构体不占用内存空间。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">fmt.Println(unsafe.Sizeof(a)) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><h1 id="结构体内存布局">结构体内存布局</h1><p>结构体占用一块连续的内存。</p><p>TODO：<a href="https://segmentfault.com/a/1190000017527311?utm_campaign=studygolang.com&amp;utm_medium=studygolang.com&amp;utm_source=studygolang.com">在 Go 中恰到好处的内存对齐</a></p><h1 id="构造函数-v2">构造函数</h1><p>Go语言的结构体没有构造函数，可以自己实现。 因为<code>struct</code>是值类型，如果结构体比较复杂的话，值拷贝性能开销会比较大，所以构造函数返回的是结构体指针类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果不初始化,字段值为类型零值</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">name    <span class="keyword">string</span></span><br><span class="line">age     <span class="keyword">int</span></span><br><span class="line">address <span class="keyword">string</span></span><br><span class="line">hobby   []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种方式,使用指定值初始化结构体,返回指针类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPerson</span><span class="params">(name, address <span class="keyword">string</span>, age <span class="keyword">int</span>, hobby []<span class="keyword">string</span>)</span> *<span class="title">Person</span></span> &#123;</span><br><span class="line">instance := <span class="built_in">new</span>(Person)</span><br><span class="line">instance.name = name</span><br><span class="line">instance.address = address</span><br><span class="line">instance.age = age</span><br><span class="line">instance.hobby = hobby</span><br><span class="line"><span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种方式,使用&amp;初始化结构体,返回指针类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPerson2</span><span class="params">(name, address <span class="keyword">string</span>, age <span class="keyword">int</span>)</span> *<span class="title">Person</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Person&#123;</span><br><span class="line">name:    name,</span><br><span class="line">address: address,</span><br><span class="line">age:     age,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go中不支持函数重载，但是可以通过两个名称不同的构造函数来模拟实现构造函数重载。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a := NewPerson(<span class="string">&quot;wangpengliang&quot;</span>, <span class="string">&quot;beijing&quot;</span>, <span class="number">18</span>, []<span class="keyword">string</span>&#123;<span class="string">&quot;java&quot;</span>, <span class="string">&quot;go&quot;</span>&#125;)</span><br><span class="line">fmt.Println(a)</span><br><span class="line">b := NewPerson2(<span class="string">&quot;wangpengliang&quot;</span>, <span class="string">&quot;beijing&quot;</span>, <span class="number">18</span>)</span><br><span class="line">fmt.Println(b)</span><br></pre></td></tr></table></figure><h1 id="方法和接收者">方法和接收者</h1><p>Go语言中的<code>方法（Method）</code>是一种作用于特定类型变量的函数。这种特定类型变量叫做<code>接收者（Receiver）</code>方法的定义格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(接收者变量 接收者类型)</span> 方法名<span class="params">(参数列表)</span> <span class="params">(返回参数)</span></span> &#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>接收者变量：接收者中的参数变量名在命名时，官方建议使用接收者类型名称首字母的小写，而不是<code>self</code>、<code>this</code>之类的命名。例如，<code>Person</code>类型的接收者变量应该命名为 <code>p</code>，<code>Connector</code>类型的接收者变量应该命名为<code>c</code>等</li><li>接收者类型：接收者类型和参数类似，可以是指针类型和非指针类型</li><li>方法名、参数列表、返回参数：具体格式与函数定义相同</li></ul><p>简单理解：因为Go语言中没有Class的概念，所以不存在实例化一个类调用其中某个方法这种做法，Go语言中的方法其实就是给指定结构添加方法。比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给结构体Person定义方法,所谓方法在go中就是定义了接受者的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">say1</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;name: %s,age：%d  \n&quot;</span>, p.name, p.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">addAge1</span><span class="params">()</span></span> &#123;</span><br><span class="line">p.age = p.age + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法与函数的区别在于：<strong>函数不属于任何类型，方法属于特定的类型</strong>。</p><h2 id="值类型的接收者">值类型的接收者</h2><p>当方法作用于值类型接收者时，Go语言会在代码运行时将接收者的值复制一份。在值类型接收者的方法中可以获取接收者的成员值，但修改操作只是针对副本，无法修改接收者变量本身。比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给结构体Person定义方法,所谓方法在go中就是定义了接受者的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">say1</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;name: %s,age：%d  \n&quot;</span>, p.name, p.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">addAge1</span><span class="params">()</span></span> &#123;</span><br><span class="line">p.age = p.age + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 Person = Person&#123;<span class="string">&quot;zhansan&quot;</span>, <span class="number">16</span>, <span class="string">&quot;beijing&quot;</span>, []<span class="keyword">string</span>&#123;&#125;&#125;</span><br><span class="line">p1.addAge1()</span><br><span class="line">p1.say1()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 *Person = &amp;Person&#123;<span class="string">&quot;lisi&quot;</span>, <span class="number">16</span>, <span class="string">&quot;shanghai&quot;</span>, []<span class="keyword">string</span>&#123;&#125;&#125;</span><br><span class="line">p2.addAge1()</span><br><span class="line">p2.say1()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name: zhansan,age：16  </span><br><span class="line">name: lisi,age：16   </span><br></pre></td></tr></table></figure><h2 id="指针类型的接收者">指针类型的接收者</h2><p>指针类型的接收者由一个结构体的指针组成，由于指针的特性，调用方法时修改接收者指针的任意成员变量，在方法结束后，修改都是有效的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span> <span class="title">say2</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;name: %s,age：%d  \n&quot;</span>, p.name, p.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span> <span class="title">addAge2</span><span class="params">()</span></span> &#123;</span><br><span class="line">p.age = p.age + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p3 Person = Person&#123;<span class="string">&quot;zhansan&quot;</span>, <span class="number">16</span>, <span class="string">&quot;beijing&quot;</span>, []<span class="keyword">string</span>&#123;&#125;&#125;</span><br><span class="line">p3.addAge2()</span><br><span class="line">p3.say2()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p4 *Person = &amp;Person&#123;<span class="string">&quot;lisi&quot;</span>, <span class="number">16</span>, <span class="string">&quot;beijing&quot;</span>, []<span class="keyword">string</span>&#123;&#125;&#125;</span><br><span class="line">p4.addAge2()</span><br><span class="line">p4.say2()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name: zhansan,age：17  </span><br><span class="line">name: lisi,age：17  </span><br></pre></td></tr></table></figure><p><strong>什么时候使用指针类型接收?</strong></p><ol><li>需要修改接收者中的值</li><li>接收者是拷贝代价比较大的大对象</li><li>保证一致性，如果有某个方法使用了指针接收者，那么其他的方法也应该使用指针接收者。</li></ol><h1 id="任意类型添加方法">任意类型添加方法</h1><p>Go语言中，接收者的类型可以是任何类型，不仅仅是结构体，任何类型都可以拥有方法。比如：基于内置的<code>int</code>类型使用 type 关键字可以定义新的自定义类型，然后为自定义类型添加方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyInt 将int定义为自定义MyInt类型</span></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// SayHello 为MyInt添加一个SayHello的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m MyInt)</span> <span class="title">SayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Hello, 我是一个int。&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> m1 MyInt</span><br><span class="line">m1.SayHello() <span class="comment">//Hello, 我是一个int。</span></span><br><span class="line">m1 = <span class="number">100</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v  %T\n&quot;</span>, m1, m1) <span class="comment">//100  main.MyInt</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意事项：</strong> 非本地类型不能定义方法，不能给别的包的类型定义方法。</p><h1 id="结构体的匿名字段">结构体的匿名字段</h1><p>结构体允许其成员字段在声明时没有字段名而只有类型，这种没有名字的字段就称为匿名字段。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匿名字段的说法并不代表没有字段名，而是默认会采用类型名作为字段名，结构体要求字段名称必须唯一，因此一个结构体中同种类型的匿名字段只能有一个</span></span><br><span class="line"><span class="keyword">type</span> Book <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="keyword">string</span></span><br><span class="line"><span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">book := Book&#123;</span><br><span class="line"><span class="string">&quot;go语言编程&quot;</span>,</span><br><span class="line"><span class="number">100.00</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, book)              <span class="comment">// main.Book&#123;string:&quot;go语言编程&quot;, float64:100&#125;</span></span><br><span class="line">fmt.Println(book.<span class="keyword">string</span>, book.<span class="keyword">float64</span>) <span class="comment">//北京 go语言编程 100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：这里匿名字段的说法并不代表没有字段名，而是默认会采用类型名作为字段名，结构体要求字段名称必须唯一，因此一个结构体中同种类型的匿名字段只能有一个。</p><h1 id="嵌套结构体">嵌套结构体</h1><p>一个结构体中可以嵌套包含另一个结构体或结构体指针，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 地址结构体</span></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">Province <span class="keyword">string</span></span><br><span class="line">City     <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户结构体</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Name    <span class="keyword">string</span></span><br><span class="line">Gender  <span class="keyword">string</span></span><br><span class="line">Address Address</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">user := User&#123;</span><br><span class="line">Name:   <span class="string">&quot;wangpengliang&quot;</span>,</span><br><span class="line">Gender: <span class="string">&quot;男&quot;</span>,</span><br><span class="line">Address: Address&#123;</span><br><span class="line">Province: <span class="string">&quot;山西&quot;</span>,</span><br><span class="line">City:     <span class="string">&quot;长治&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;user=%#v\n&quot;</span>, user)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user=main.User&#123;Name:<span class="string">&quot;wangpengliang&quot;</span>, Gender:<span class="string">&quot;男&quot;</span>, Address:main.Address&#123;Province:<span class="string">&quot;山西&quot;</span>, City:<span class="string">&quot;长治&quot;</span>&#125;&#125;</span><br></pre></td></tr></table></figure><h1 id="嵌套匿名字段">嵌套匿名字段</h1><p>上面user结构体中嵌套的<code>Address</code>结构体也可以采用匿名字段的方式，匿名字段默认使用类型名作为字段名。比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 地址结构体</span></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">province <span class="keyword">string</span></span><br><span class="line">city     <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户结构体</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">name    <span class="keyword">string</span></span><br><span class="line">gender  <span class="keyword">string</span></span><br><span class="line">address Address <span class="comment">// 该字段为具名字段</span></span><br><span class="line">Address         <span class="comment">// 嵌套的Address结构体也可以采用匿名字段的方式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">user := User&#123;</span><br><span class="line">name:   <span class="string">&quot;wangpengliang&quot;</span>,</span><br><span class="line">gender: <span class="string">&quot;男&quot;</span>,</span><br><span class="line">address: Address&#123;</span><br><span class="line">province: <span class="string">&quot;山西&quot;</span>,</span><br><span class="line">city:     <span class="string">&quot;长治&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">Address: Address&#123;</span><br><span class="line">province: <span class="string">&quot;北京&quot;</span>,</span><br><span class="line">city:     <span class="string">&quot;北京&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;user=%#v\n&quot;</span>, user)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user=main.User&#123;name:<span class="string">&quot;wangpengliang&quot;</span>, gender:<span class="string">&quot;男&quot;</span>, address:main.Address&#123;province:<span class="string">&quot;山西&quot;</span>, city:<span class="string">&quot;长治&quot;</span>&#125;, Address:main.Address&#123;province:<span class="string">&quot;北京&quot;</span>, city:<span class="string">&quot;北京&quot;</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>当访问结构体成员时会先在结构体中查找该字段，找不到再去嵌套的匿名字段中查找。</p><h1 id="嵌套结构体字段名冲突">嵌套结构体字段名冲突</h1><p>嵌套结构体内部可能存在相同的字段名。这种情况下为了避免歧义需要通过指定具体的内嵌结构体字段名。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 地址结构体</span></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">province   <span class="keyword">string</span></span><br><span class="line">city       <span class="keyword">string</span></span><br><span class="line">createTime <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 邮箱结构体</span></span><br><span class="line"><span class="keyword">type</span> Email <span class="keyword">struct</span> &#123;</span><br><span class="line">account    <span class="keyword">string</span></span><br><span class="line">createTime <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户结构体</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">name    <span class="keyword">string</span></span><br><span class="line">gender  <span class="keyword">string</span></span><br><span class="line">address Address <span class="comment">// 该字段为具名字段</span></span><br><span class="line">Address         <span class="comment">// 嵌套的Address结构体也可以采用匿名字段的方式</span></span><br><span class="line">Email</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 具名字段赋值</span></span><br><span class="line">user := User&#123;</span><br><span class="line">name:   <span class="string">&quot;wangpengliang&quot;</span>,</span><br><span class="line">gender: <span class="string">&quot;男&quot;</span>,</span><br><span class="line">address: Address&#123;</span><br><span class="line">province: <span class="string">&quot;山西&quot;</span>,</span><br><span class="line">city:     <span class="string">&quot;长治&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;user=%#v\n&quot;</span>, user)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名字段</span></span><br><span class="line">user1 := User&#123;</span><br><span class="line">name:   <span class="string">&quot;wangpengliang&quot;</span>,</span><br><span class="line">gender: <span class="string">&quot;男&quot;</span>,</span><br><span class="line">Address: Address&#123;</span><br><span class="line">province: <span class="string">&quot;山西&quot;</span>,</span><br><span class="line">city:     <span class="string">&quot;长治&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;user1=%#v\n&quot;</span>, user1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> user2 User</span><br><span class="line">user2.name = <span class="string">&quot;wangpengliang&quot;</span></span><br><span class="line">user2.gender = <span class="string">&quot;男&quot;</span></span><br><span class="line"><span class="comment">// user2.createTime = &quot;2019&quot; //ambiguous selector user2.createTime</span></span><br><span class="line">user2.Address.createTime = <span class="string">&quot;2000&quot;</span> <span class="comment">//指定Address结构体中的createTime</span></span><br><span class="line">user2.Email.createTime = <span class="string">&quot;2000&quot;</span>   <span class="comment">//指定Email结构体中的createTime</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user=main.User&#123;name:<span class="string">&quot;wangpengliang&quot;</span>, gender:<span class="string">&quot;男&quot;</span>, address:main.Address&#123;province:<span class="string">&quot;山西&quot;</span>, city:<span class="string">&quot;长治&quot;</span>, createTime:<span class="string">&quot;&quot;</span>&#125;, Address:main.Address&#123;province:<span class="string">&quot;&quot;</span>, city:<span class="string">&quot;&quot;</span>, createTime:<span class="string">&quot;&quot;</span>&#125;, Email:main.Email&#123;account:<span class="string">&quot;&quot;</span>, createTime:<span class="string">&quot;&quot;</span>&#125;&#125;</span><br><span class="line">user=main.User&#123;name:<span class="string">&quot;wangpengliang&quot;</span>, gender:<span class="string">&quot;男&quot;</span>, address:main.Address&#123;province:<span class="string">&quot;&quot;</span>, city:<span class="string">&quot;&quot;</span>, createTime:<span class="string">&quot;&quot;</span>&#125;, Address:main.Address&#123;province:<span class="string">&quot;山西&quot;</span>, city:<span class="string">&quot;长治&quot;</span>, createTime:<span class="string">&quot;&quot;</span>&#125;, Email:main.Email&#123;account:<span class="string">&quot;&quot;</span>, createTime:<span class="string">&quot;&quot;</span>&#125;&#125;</span><br></pre></td></tr></table></figure><h1 id="结构体字段可见性">结构体字段可见性</h1><p>结构体中字段大写开头表示可公开访问，小写表示私有（仅在定义当前结构体的包中可访问）。</p><h1 id="结构体与JSON序列化">结构体与JSON序列化</h1><p><code>JSON(JavaScript Object Notation)</code>  是一种轻量级的数据交换格式。易于阅读和编写。同时也易于机器解析和生成。JSON键值对是用来保存JS对象的一种方式，键/值对组合中的键名写在前面并用双引号<code>&quot;&quot;</code>包裹，使用冒号<code>:</code>分隔，然后紧接着值；多个键值之间使用英文<code>,</code>分隔。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Student</span></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">ID     <span class="keyword">int</span></span><br><span class="line">Gender <span class="keyword">string</span></span><br><span class="line">Name   <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Class</span></span><br><span class="line"><span class="keyword">type</span> Class <span class="keyword">struct</span> &#123;</span><br><span class="line">Title    <span class="keyword">string</span></span><br><span class="line">Students []*Student</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">jsonSerializeTest</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := &amp;Class&#123;</span><br><span class="line">Title:    <span class="string">&quot;101&quot;</span>,</span><br><span class="line">Students: <span class="built_in">make</span>([]*Student, <span class="number">0</span>, <span class="number">200</span>),</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">stu := &amp;Student&#123;</span><br><span class="line">Name:   fmt.Sprintf(<span class="string">&quot;stu%02d&quot;</span>, i),</span><br><span class="line">Gender: <span class="string">&quot;男&quot;</span>,</span><br><span class="line">ID:     i,</span><br><span class="line">&#125;</span><br><span class="line">c.Students = <span class="built_in">append</span>(c.Students, stu)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JSON序列化：结构体--&gt;JSON格式的字符串</span></span><br><span class="line">data, err := json.Marshal(c)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;json marshal failed&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;json:%s\n&quot;</span>, data)</span><br><span class="line"><span class="comment">//JSON反序列化：JSON格式的字符串--&gt;结构体</span></span><br><span class="line">str := <span class="string">`&#123;&quot;Title&quot;:&quot;101&quot;,&quot;Students&quot;:[&#123;&quot;ID&quot;:0,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu00&quot;&#125;,&#123;&quot;ID&quot;:1,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu01&quot;&#125;,&#123;&quot;ID&quot;:2,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu02&quot;&#125;,&#123;&quot;ID&quot;:3,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu03&quot;&#125;,&#123;&quot;ID&quot;:4,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu04&quot;&#125;,&#123;&quot;ID&quot;:5,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu05&quot;&#125;,&#123;&quot;ID&quot;:6,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu06&quot;&#125;,&#123;&quot;ID&quot;:7,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu07&quot;&#125;,&#123;&quot;ID&quot;:8,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu08&quot;&#125;,&#123;&quot;ID&quot;:9,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu09&quot;&#125;]&#125;`</span></span><br><span class="line">c1 := &amp;Class&#123;&#125;</span><br><span class="line">err = json.Unmarshal([]<span class="keyword">byte</span>(str), c1)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;json unmarshal failed!&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, c1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="结构体标签（Tag）">结构体标签（Tag）</h1><p><code>Tag</code>是结构体的元信息，可以在运行时通过反射读取出来。 <code>Tag</code>在结构体字段的后方定义，由一对<strong>反引号</strong>包裹起来，格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`key1:<span class="string">&quot;value1&quot;</span> key2:<span class="string">&quot;value2&quot;</span>`</span><br></pre></td></tr></table></figure><p>结构体tag由一个或多个键值对组成。键与值使用冒号分隔，值用双引号括起来。同一个结构体字段可以设置多个键值对tag，不同的键值对之间使用空格分隔。</p><p><strong>注意事项：</strong> 为结构体编写<code>Tag</code>时，必须严格遵守键值对的规则。结构体标签的解析代码的容错能力很差，一旦格式写错，编译和运行时都不会提示任何错误，通过反射也无法正确取值。例如不要在key和value之间添加空格。</p><p>Go 中标签最常见的用途比如 <strong><a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Marshalling_(computer_science)">marshalling</a></strong>。看一下来自 JSON 包的函数 <strong><a href="https://link.zhihu.com/?target=https%3A//golang.org/pkg/encoding/json/%23Marshal">Marshal</a></strong> 如何使用它（<strong><a href="https://link.zhihu.com/?target=https%3A//play.golang.org/p/C1hAMXTKPM_S">源代码</a></strong>）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">    &quot;encoding/json&quot;</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line">func main() &#123;</span><br><span class="line">    type T struct &#123;</span><br><span class="line">       F1 int `json:&quot;f_1&quot;`</span><br><span class="line">       F2 int `json:&quot;f_2,omitempty&quot;`</span><br><span class="line">       F3 int `json:&quot;f_3,omitempty&quot;`</span><br><span class="line">       F4 int `json:&quot;-&quot;`</span><br><span class="line">    &#125;</span><br><span class="line">    t := T&#123;1, 0, 2, 3&#125;</span><br><span class="line">    b, err := JSON.Marshal(t)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        panic(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(&quot;%s\n&quot;, b) // &#123;&quot;f_1&quot;:1,&quot;f_3&quot;:2&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>xml 包也利用了标签 - <a href="https://link.zhihu.com/?target=https%3A//golang.org/pkg/encoding/xml/%23MarshalIndent">https://golang.org/pkg/encoding/xml/#MarshalIndent</a>.</p><p><strong>ORM</strong></p><p>像 GORM 这样的对象关系映射工具，也广泛使用标签 - <strong><a href="https://link.zhihu.com/?target=https%3A//github.com/jinzhu/gorm/blob/58e34726dfc069b558038efbaa25555f182d1f7a/multi_primary_keys_test.go%23L10">例子</a></strong>.</p><p><strong>摘要数据（Digesting forms data）</strong></p><p><a href="https://link.zhihu.com/?target=https%3A//godoc.org/github.com/gorilla/schema">https://godoc.org/github.com/gorilla/schema</a></p><p><strong>其他（Other）</strong></p><p>标签的更多潜在用例，如配置管理，结构的默认值，验证，命令行参数描述等（<strong><a href="https://link.zhihu.com/?target=https%3A//github.com/golang/go/wiki/Well-known-struct-tags">众所周知的结构标记列表</a></strong>）。</p><h1 id="练习题一">练习题一</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exercises01Test</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">make</span> := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]*<span class="keyword">int</span>)</span><br><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> slice &#123;</span><br><span class="line"><span class="built_in">make</span>[index] = &amp;value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> <span class="built_in">make</span> &#123;</span><br><span class="line">fmt.Println(k, <span class="string">&quot;=&gt;&quot;</span>, *v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 =&gt; 3</span><br><span class="line">1 =&gt; 3</span><br><span class="line">2 =&gt; 3</span><br><span class="line">3 =&gt; 3</span><br></pre></td></tr></table></figure><p>思考：这里输出map的value为什么都是3?</p><p>调整代码：输出指针地址</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> slice &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%p \n&quot;</span>, &amp;value)</span><br><span class="line"><span class="built_in">make</span>[index] = &amp;value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0xc000012088 </span><br><span class="line">0xc000012088 </span><br><span class="line">0xc000012088 </span><br><span class="line">0xc000012088 </span><br></pre></td></tr></table></figure><p>这里其实就可以看出来了，<code>&amp;stu</code> 指向了同一个内存地址，当遍历到最后一个元素时，将3写入了该地址。导致映射所有值都相同。<code>for range</code> 创建了每个元素的副本，而不是直接返回每个元素的引用，如果使用该值变量的地址作为指向每个元素的指针，就会导致错误，迭代时返回的变量是一个迭代过程中根据切片依次赋值的新变量，所以值的地址总是相同的，导致结果不如预期。</p><p>修改代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exercises02Test</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">make</span> := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]*<span class="keyword">int</span>)</span><br><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> slice &#123;</span><br><span class="line"><span class="comment">// 循环中使用新的变量接收</span></span><br><span class="line">item := value</span><br><span class="line">fmt.Printf(<span class="string">&quot;%p \n&quot;</span>, &amp;item)</span><br><span class="line"><span class="built_in">make</span>[index] = &amp;item</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> <span class="built_in">make</span> &#123;</span><br><span class="line">fmt.Println(k, <span class="string">&quot;=&gt;&quot;</span>, *v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0xc000012088 </span><br><span class="line">0xc0000120c0 </span><br><span class="line">0xc0000120c8</span><br><span class="line">0xc0000120d0</span><br><span class="line">3 =&gt; 3</span><br><span class="line">0 =&gt; 0</span><br><span class="line">1 =&gt; 1</span><br><span class="line">2 =&gt; 2</span><br></pre></td></tr></table></figure><p>这个问题很像C#学习委托时遇到的闭包问题。上面问题还可以使用传统的 <code>for</code> 循环处理：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exercises03Test</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">make</span> := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]*<span class="keyword">int</span>)</span><br><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(slice); i++ &#123;</span><br><span class="line"><span class="built_in">make</span>[i] = &amp;slice[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> <span class="built_in">make</span> &#123;</span><br><span class="line">fmt.Println(k, <span class="string">&quot;=&gt;&quot;</span>, *v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0xc0000101e0 </span><br><span class="line">0xc0000101e8 </span><br><span class="line">0xc0000101f0 </span><br><span class="line">0xc0000101f8 </span><br><span class="line">0 =&gt; 0       </span><br><span class="line">1 =&gt; 1       </span><br><span class="line">2 =&gt; 2       </span><br><span class="line">3 =&gt; 3  </span><br></pre></td></tr></table></figure><h1 id="练习题二">练习题二</h1><p>因为 <code>slice</code> 和 <code>map</code> 这两种数据类型都包含了指向底层数据的指针，因此在需要复制它们时要特别注意。来看下面的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Test <span class="keyword">struct</span> &#123;</span><br><span class="line">name   <span class="keyword">string</span></span><br><span class="line">age    <span class="keyword">int8</span></span><br><span class="line">dreams []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Test)</span> <span class="title">setDreams</span><span class="params">(dreams []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">t.dreams = dreams</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exercises02Test</span><span class="params">()</span></span> &#123;</span><br><span class="line">t := Test&#123;name: <span class="string">&quot;wangpengliang&quot;</span>, age: <span class="number">18</span>&#125;</span><br><span class="line">data := []<span class="keyword">string</span>&#123;<span class="string">&quot;吃饭&quot;</span>, <span class="string">&quot;睡觉&quot;</span>, <span class="string">&quot;搞钱&quot;</span>&#125;</span><br><span class="line">t.setDreams(data)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 真的想修改t.dreams吗？</span></span><br><span class="line">data[<span class="number">1</span>] = <span class="string">&quot;不睡觉&quot;</span></span><br><span class="line">fmt.Println(t.dreams) <span class="comment">// </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[吃饭 不睡觉 搞钱]</span><br></pre></td></tr></table></figure><p>这里因为 <code>slice</code> 和 <code>map</code> 这两种数据类型都包含了指向底层数据的指针所以修改了 <code>slice</code> 导致结构体内容也被修改，正确做法应该是：方法中使用传入的slice的拷贝进行结构体赋值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Test)</span> <span class="title">setDreams</span><span class="params">(dreams []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">t.dreams = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="built_in">len</span>(dreams))</span><br><span class="line"><span class="built_in">copy</span>(t.dreams, dreams)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">t := Test&#123;name: <span class="string">&quot;wangpengliang&quot;</span>, age: <span class="number">18</span>&#125;</span><br><span class="line">data := []<span class="keyword">string</span>&#123;<span class="string">&quot;吃饭&quot;</span>, <span class="string">&quot;睡觉&quot;</span>, <span class="string">&quot;搞钱&quot;</span>&#125;</span><br><span class="line">t.setDreams(data)</span><br><span class="line"></span><br><span class="line">data[<span class="number">1</span>] = <span class="string">&quot;不睡觉&quot;</span></span><br><span class="line">fmt.Println(t.dreams) </span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[吃饭 睡觉 搞钱]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/elk/1.1ElastaticSearch%E5%85%A5%E9%97%A8/"/>
      <url>/elk/1.1ElastaticSearch%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>Elasticsearch 简称 ES，是一个<strong>开源</strong>、<strong>高扩展</strong>的<strong>分布式全文检索引擎</strong>，可以实现近乎实时的存储、检索数据且扩展性很好，可以扩展到上百台服务器，处理PB级别的数据。ES 底层是开源库 Lucene，ES 实现了对 Lucene 的封装，并提供  <code>REST</code> 风格的操作接口开箱即用。通过简单的 RESTful API 来隐藏Lucene的复杂性，从而让全文搜索变得简单。</p><span id="more"></span><h1 id="ElasticSearch-对比-Solr">ElasticSearch 对比 Solr</h1><ul><li>Solr 利用 <code>Zookeeper</code> 进行分布式管理， Elasticsearch 自身带有分布式协调管理功能</li><li>Solr 支持更多格式的数据，而 Elasticsearch 仅支持json文件格式</li><li>Solr 官方提供的功能更多，而 Elasticsearch 本身更注重于核心功能，高级功能由第三方插件提供</li><li>Solr 在传统的搜索应用中表现好于 Elasticsearch，但在处理实时搜索应用时效率明显低于 Elasticsearch</li></ul><h1 id="ElasticSearch-安装">ElasticSearch 安装</h1><blockquote><p>注意：ES 使用 Java 开发，使用 Lucene 作为核心，所以需要配置好java环境（<code>jdk1.8</code> 以上）</p></blockquote><p>下载地址：<a href="https://www.elastic.co/products/elasticsearch">ElasticSearch 官网</a>，如果下载比较慢可以试试：<a href="https://www.newbe.pro/Mirrors/Mirrors-Elasticsearch">newbe.pro</a></p><p>Windows 平台下载完成直接解压即可，目录结构如下：</p><p><img src="/images/2022-03-06-00-17-58.png" alt=""></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bin     // 可执行二进制文件</span><br><span class="line">config  // 配置信息目录</span><br><span class="line">lib     // jar包存放目录,比如lucene相关的jar包</span><br><span class="line">logs    // 日志</span><br><span class="line">modulES // 模块</span><br><span class="line">plugins // 插件</span><br></pre></td></tr></table></figure><h1 id="ElasticSearch-配置">ElasticSearch 配置</h1><h2 id="调整内存">调整内存</h2><p>修改 <code>conf\jvm.option</code> 文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-Xms1g</span><br><span class="line">-Xmx1g</span><br><span class="line">修改为自己定义的值，比如</span><br><span class="line">-xms256m</span><br><span class="line">-xmx256m</span><br><span class="line">防止因为内存不足无法启动</span><br></pre></td></tr></table></figure><h2 id="开启跨域">开启跨域</h2><p>修改 <code>conf\elasticsearch.yml</code> 文件，在末尾加入如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http.cors.enabled: <span class="keyword">true</span></span><br><span class="line">http.cors.allow-origin: <span class="string">&quot;*&quot;</span></span><br><span class="line">network.host: <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br></pre></td></tr></table></figure><h1 id="ElasticSearch-启动">ElasticSearch 启动</h1><p>双击 <code>bin</code> 目录下的 <code>elasticsearch.bat</code> 启动：</p><p><img src="/images/2022-03-06-00-29-21.png" alt=""></p><blockquote><p>⚠️ ES集群之间使用tcp进行通信，<code>9300</code> 是tcp通信端口，<code>9200</code> 是http协议端口</p></blockquote><p>浏览器测试访问：</p><p><img src="/images/2022-03-06-00-31-42.png" alt=""></p><h1 id="Elasticsearch-head">Elasticsearch-head</h1><p>通过安装 <code>ElasticSearch</code> 的 <code>head</code> 插件，可以实现图形化查看索引数据。<a href="https://github.com/mobz/elasticsearch-head">下载地址</a></p><p>下载完成后解压即可，目录结构如下：</p><p><img src="/images/2022-03-06-00-34-01.png" alt=""></p><p><code>Elasticsearch-head</code> 依赖于 <code>node.js</code> 所以需要先保证本地有 <code>node.js</code> 的环境：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator&gt;node -v</span><br><span class="line">v14.17.3</span><br></pre></td></tr></table></figure><p>使用 <code>npm</code> 还原依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\Elasticsearch\elasticsearch-head-master&gt;npm install</span><br></pre></td></tr></table></figure><blockquote><p>注意：如果下载速度较慢，可以切换淘宝镜像使用 cnpm</p></blockquote><p>启动 <code>Elasticsearch-head</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">D:\Elasticsearch\elasticsearch-head-master&gt;npm run start</span><br><span class="line"></span><br><span class="line">&gt; elasticsearch-head@0.0.0 start D:\Elasticsearch\elasticsearch-head-master</span><br><span class="line">&gt; grunt server</span><br><span class="line"></span><br><span class="line">Running <span class="string">&quot;connect:server&quot;</span> (connect) task</span><br><span class="line">Waiting forever...</span><br><span class="line">Fatal error: Port 9100 is already <span class="keyword">in</span> use by another procESs.</span><br><span class="line">npm ERR! code ELIFECYCLE</span><br><span class="line">npm ERR! errno 1</span><br><span class="line">npm ERR! elasticsearch-head@0.0.0 start: `grunt server`</span><br><span class="line">npm ERR! Exit status 1</span><br><span class="line">npm ERR!</span><br><span class="line">npm ERR! Failed at the elasticsearch-head@0.0.0 start script.</span><br><span class="line">npm ERR! This is probably not a problem with npm. There is likely additional logging output above.</span><br><span class="line"></span><br><span class="line">npm ERR! A complete <span class="built_in">log</span> of this run can be found <span class="keyword">in</span>:</span><br><span class="line">npm ERR!     C:\Users\Administrator\AppData\Roaming\npm-cache\_logs\2022-03-05T16_39_04_056Z-debug.log</span><br></pre></td></tr></table></figure><p>这里报错：<code>Port 9100 is already in use by another procESs.</code> ，原因是 <code>9100</code> 端口被占用，查看哪个进程占用的端口号并结束该进程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">D:\Elasticsearch\elasticsearch-head-master&gt;netstat -ano | findstr &quot;9100&quot;</span><br><span class="line">  TCP    0.0.0.0:9100           0.0.0.0:0              LISTENING       12276</span><br><span class="line">  TCP    127.0.0.1:53459        127.0.0.1:9100         TIME_WAIT       0</span><br><span class="line"></span><br><span class="line">D:\Elasticsearch\elasticsearch-head-master&gt;taskkill -pid 12276 -F</span><br><span class="line">成功: 已终止 PID 为 12276 的进程。</span><br></pre></td></tr></table></figure><p>重新启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">D:\Elasticsearch\elasticsearch-head-master&gt;npm run start</span><br><span class="line"></span><br><span class="line">&gt; elasticsearch-head@0.0.0 start D:\Elasticsearch\elasticsearch-head-master</span><br><span class="line">&gt; grunt server</span><br><span class="line"></span><br><span class="line">Running <span class="string">&quot;connect:server&quot;</span> (connect) task</span><br><span class="line">Waiting forever...</span><br><span class="line">Started connect web server on http://localhost:9100</span><br></pre></td></tr></table></figure><p>浏览器访问：</p><p><img src="/images/2022-03-06-00-44-44.png" alt=""></p><p>ok，至此完成 <code>Elasticsearch-head</code> 的安装启动。</p><h1 id="Elasticsearch-核心概念">Elasticsearch 核心概念</h1><p>Elasticsearch 是面向文档（<code>document oriented</code> ）的，这意味着它可以存储整个对象或文档（<code>document</code> ）。然而它不仅会存储，还会索引( <code>index</code> )每个文档的内容使之可以被搜索。在Elasticsearch中，可以对文档（而非成行或列的数据）进行索引、搜索、排序、过滤。Elasticsearch 对比传统关系型数据库如下：</p><blockquote><p>RDBMS ‐&gt; DatabasES ‐&gt; TablES ‐&gt; Rows ‐&gt; Columns<br>Elasticsearch ‐&gt; IndicES ‐&gt; TypES ‐&gt; Documents ‐&gt; Fields</p></blockquote><h2 id="index-索引">index 索引</h2><blockquote><p>一个索引就是一个拥有几分相似特征的文档的集合。比如客户数据索引、产品目录索引、订单数据索引。索引由一个名字来标识（名称必须全部小写），当要对这个索引中的文档进行索引、搜索、更新和删除时都要使用到这个名字。一个集群中可以定义任意多的索引。可类比SqlServer中的数据库</p></blockquote><h2 id="type-类型"><s>type 类型</s></h2><blockquote><p>一个索引中可以定义一种或多种类型。一个类型是索引的一个逻辑上的分类/分区，其语义完全自己定义。通常会为具有一组共同字段的文档定义一个类型。假设运营一个博客平台并且将所有的数据存储到一个索引中。在这个索引中，可以为用户数据定义一个类型，为博客数据定义另一个类型。可类比SqlServer中的表</p><p><strong>🚨 注意</strong>：ES 7.0 以及之后的版本中 Type 被废弃。一个 index 中只有一个默认的 type，即 <code>_doc</code></p></blockquote><h2 id="Filed字段">Filed字段</h2><blockquote><p>相当于数据表的字段，对文档数据根据不同属性进行的分类标识 。</p></blockquote><h2 id="mapping-映射">mapping 映射</h2><blockquote><p>mapping 在处理数据的方式和规则方面做一些限制，如某个字段的数据类型、默认值、分析器、是否被索引等等，这些都可以在映射里设置，其它就是处理ES里面数据的一些使用规则设置也叫做映射，按最优规则处理数据对性能提高很大，因此才需要建立映射，并且需要思考如何建立映射才能对性能更好。相当于SqlServer中的创建表的过程，设置主键外键等等</p></blockquote><h2 id="document-文档">document 文档</h2><blockquote><p>一个文档是一个可被索引的基础信息单元。比如：客户文档、产品文档。文档以JSON（ <code>Javascript Object Notation</code> ）格式表示。一个 <code>index/type</code> 里可以存储任意多的文档。注意：尽管一个文档物理上存在于一个索引之中，但文档必须被索引赋予一个索引的 <code>type</code> 。 插入索引库以文档为单位，类比与数据库中的一行数据</p></blockquote><h2 id="cluster-集群">cluster 集群</h2><blockquote><p>一个集群就是由一个或多个节点组织在一起，它们共同持有整个的数据，并一起提供索引和搜索功能。一个集群由一个唯一的名字标识，这个名字默认是“elasticsearch”。一个节点只能通过指定某个集群的名字，来加入这个集群。</p></blockquote><h2 id="node-节点">node 节点</h2><blockquote><p>一个节点是集群中的一个服务器，作为集群的一部分，它存储数据，参与集群的索引和搜索功能。一 个节点由一个名字来标识，默认情况下，这个名字是一个随机的漫威漫画角色的名字，这个名字会在启动时候赋予节点。</p></blockquote><blockquote><p>一个节点可以通过配置集群名称的方式来加入一个指定的集群。默认情况下，每个节点都会被安排加入到一个叫做 <code>elasticsearch</code> 的集群中，这意味着，如果网络中启动了若干个节点，并假定它们能够相互发现彼此， 它们将会自动地形成并加入到一个叫 <code>elasticsearch</code> 的集群中。</p></blockquote><blockquote><p>一个集群里可以拥有任意多个节点。而且如果当前网络中没有运行任何 Elasticsearch 节点， 这时启动一个节点，会默认创建并加入一个叫做 <code>elasticsearch</code> 的集群。</p></blockquote><h2 id="shards-分片">shards 分片</h2><blockquote><p>一个索引可以存储超出单个节点硬件限制的大量数据。比如，一个具有10亿文档的索引占据1TB的磁盘空间，而任一节点都没有这样大的磁盘空间；或者单个节点处理搜索请求，响应太慢。为了解决这个问题，Elasticsearch 提供了将索引划分成多份的能力，这些份就叫做分片。当创建一个索引时，可以指定想要的分片的数量。每个分片本身也是一个功能完善并且独立的“索引”，这个“索引”可以被放置到集群中的任何节点上。分片很重要，主要有两方面的原因：</p><ul><li>允许水平分割/扩展内容容量</li><li>允许在分片（潜在地，位于多个节点上）之上进行分布式的、并行的操作，进而提高性能/吞吐量</li></ul><p>至于一个分片怎样分布，它的文档怎样聚合返回给搜索请求，是完全由Elasticsearch管理的，对于用户来说这些都是透明的。</p></blockquote><h2 id="replicas-复制">replicas 复制</h2><blockquote><p>在一个网络/云的环境里，失败随时都可能发生，在某个分片/节点不知怎么的就处于离线状态，或者由于任何原因消失了，这种情况下，有一个故障转移机制是非常有用并且是强烈推荐的。为此目的，Elasticsearch允许创建分片的一份或多份拷贝，这些拷贝叫做复制分片，或者直接叫复制。</p></blockquote><blockquote><p>复制之所以重要，有两个主要原因</p><ul><li>在分片/节点失败的情况下，提供了高可用性。因为这个原因，注意到复制分片从不与原/主要（original/primary）分片置于同一节点上是非常重要的。</li><li>扩展搜索量/吞吐量，因为搜索可以在所有的复制上并行运行。总之，每个索引可以被分成多个分片。一个索引也可以被复制0次（意思是没有复制）或多次。一旦复制了，每个索引就有了主分片（作为复制源的原来的分片）和复制分片（主分片的拷贝）之别。分片和复制的数量可以在索引创建的时候指定。在索引创建之后，可以在任何时候动态地改变复制的数量，但是事后不能改变分片的数量。</li></ul></blockquote><blockquote><p>默认情况下，Elasticsearch 中的每个索引被分片5个主分片和1个复制，这意味着如果集群中有两个节点，索引将会有5个主分片和另外5个复制分片（1个完全拷贝），这样的话每个索引总共就有10个分片。</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/elk/1.2ElastaticSearch%E9%85%8D%E7%BD%AE/"/>
      <url>/elk/1.2ElastaticSearch%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>配置文件所在目录路径：<code>安装目录/config/elasticsearch.yml</code></p><span id="more"></span><p><code>cluster.name: elasticsearch</code></p><blockquote><p>配置集群名称。默认为 elasticsearch，如果在同一网段下有多个集群，可以用这个属性来区分不同的集群</p></blockquote><p><code>node.name: “Franz Kafka”</code></p><blockquote><p>节点名称。默认为随机指定一个name列表中名字，该列表在ES的jar包中config文件夹里name.txt文件中，其中有很多作者添加的有趣名字，大部分是漫威动漫里的人物名称</p></blockquote><p><code>node.master: true</code></p><blockquote><p>指定该节点是否有资格被选举成为 <code>node</code> ，默认为 <code>true</code>。ES 默认集群中的第一台启动的机器为 <code>master</code> ，如果这台挂了就会重新选举 <code>master</code></p></blockquote><p><code>node.data: true</code></p><blockquote><p>指定该节点是否存储索引数据，默认为 <code>true</code>。如果节点配置 <code>node.master:false</code> 并且 <code>node.data: false</code> ，则该节点将只起到负载均衡作用</p></blockquote><p><code>index.number_of_shards: 5</code></p><blockquote><p>设置默认索引分片个数，默认为5片。索引分片对ES的查询性能有很大的影响，在生产环境应该选择适合的分片大小</p></blockquote><p><code>index.number_of_replicas: 1</code></p><blockquote><p>设置默认索引副本个数，默认为1个副本。此处1个副本是指 <code>index.number_of_shards</code> 的一个完全拷贝；默认5个分片1个拷贝。即总分片数为10</p></blockquote><p><code>path.conf: /path/to/conf</code></p><blockquote><p>设置配置文件存储路径。默认是ES根目录下的 <code>config</code> 文件夹</p></blockquote><p><code>path.data:/path/to/data1,/path/to/data2</code></p><blockquote><p>设置索引数据存储路径。默认是ES根目录下的 <code>data</code> 文件夹，可以设置多个存储路径，用逗号分割</p></blockquote><p><code>path.work:/path/to/work</code></p><blockquote><p>设置临时文件存储路径。默认是ES根目录下的 <code>work</code> 文件夹</p></blockquote><p><code>path.logs: /path/to/logs</code></p><blockquote><p>设置日志文件存储路径。默认是ES根目录下的 <code>logs</code> 文件夹</p></blockquote><p><code>path.plugins: /path/to/plugins</code></p><blockquote><p>设置插件的存放路径。默认是ES根目录下的 <code>plugins</code> 文件夹</p></blockquote><p><code>bootstrap.mlockall: true</code></p><blockquote><p>设置为 <code>true</code> 来锁住内存。因为当jvm开始 <code>swapping</code> 时es的效率会降低，所以要保证它不swap，可以把<code>ES_MIN_MEM</code> 和 <code>ES_MAX_MEM</code> 两个环境变量设置成同一个值，并且保证机器有足够的内存分配给es。同时也要允许elasticsearch的进程可以锁住内存，linux下可以通过<code>ulimit -l unlimited</code>命令</p></blockquote><p><code>network.bind_host: 192.168.0.1</code></p><blockquote><p>设置绑定的ip地址，可以是ipv4或ipv6的，默认为 <code>0.0.0.0</code></p></blockquote><p><code>network.publish_host: 192.168.0.1</code></p><blockquote><p>设置其它节点和该节点交互的ip地址，如果不设置它会自动判断，必须是个真实的ip地址</p></blockquote><p><code>network.host: 192.168.0.1</code></p><blockquote><p>同时设置 <code>bind_host</code> 和 <code>publish_host</code> (上面两个参数)</p></blockquote><p><code>transport.tcp.port: 9300</code></p><blockquote><p>设置节点间交互的tcp端口，默认是 <code>9300</code></p></blockquote><p><code>transport.tcp.compress: true</code></p><blockquote><p>设置是否压缩tcp传输时的数据，默认为 <code>false</code> 不压缩</p></blockquote><p><code>http.port: 9200</code></p><blockquote><p>设置对外服务的http端口，默认为 <code>9200</code></p></blockquote><p><code>http.max_content_length: 100mb</code></p><blockquote><p>设置内容的最大容量，默认 <code>100mb</code></p></blockquote><p><code>http.enabled: false</code></p><blockquote><p>是否使用http协议对外提供服务，默认为 <code>true</code> 开启</p></blockquote><p><code>gateway.type: local</code></p><blockquote><p>gateway的类型，默认为local即为本地文件系统，可以设置为本地文件系统，分布式文件系统，hadoop的HDFS，和amazon的s3服务器，其它文件系统的设置</p></blockquote><p><code>gateway.recover_after_nodes: 1</code></p><blockquote><p>设置集群中N个节点启动时进行数据恢复，默认为1</p></blockquote><p><code>gateway.recover_after_time: 5m</code></p><blockquote><p>设置初始化数据恢复进程的超时时间，默认是5分钟</p></blockquote><p><code>gateway.expected_nodes: 2</code></p><blockquote><p>设置集群中节点的数量，默认为2，一旦这N个节点启动，就会立即进行数据恢复</p></blockquote><p><code>cluster.routing.allocation.node_initial_primaries_recoveries: 4</code></p><blockquote><p>初始化数据恢复时，并发恢复线程的个数，默认为4</p></blockquote><p><code>cluster.routing.allocation.node_concurrent_recoveries: 2</code></p><blockquote><p>添加删除节点或负载均衡时并发恢复线程的个数，默认为4</p></blockquote><p><code>indices.recovery.max_size_per_sec: 0</code></p><blockquote><p>设置数据恢复时限制的带宽，如入 <code>100mb</code> ，默认为0，即无限制。</p></blockquote><p><code>indices.recovery.concurrent_streams: 5</code></p><blockquote><p>设置这个参数来限制从其它分片恢复数据时最大同时打开并发流的个数，默认为5</p></blockquote><p><code>discovery.zen.minimum_master_nodes: 1</code></p><blockquote><p>设置这个参数来保证集群中的节点可以知道其它N个有master资格的节点。默认为1，对于大的集群来说，可以设置大一点的值（2-4）</p></blockquote><p><code>discovery.zen.ping.timeout: 3s</code></p><blockquote><p>设置集群中自动发现其它节点时 <code>ping</code> 连接超时时间，默认为3秒，对于比较差的网络环境可以高点的值来防止自动发现时出错</p></blockquote><p><code>discovery.zen.ping.multicast.enabled: false</code></p><blockquote><p>设置是否打开多播发现节点，默认是true</p></blockquote><p><code>discovery.zen.ping.unicast.hosts: [“host1”, “host2:port”, “host3 [portX-portY] “]</code></p><blockquote><p>设置集群中master节点的初始列表，可以通过这些节点来自动发现新加入集群的节点</p></blockquote><p>上面是在安装时配置文件中就自带的配置项外，在实际使用过程还可能使用到下面的配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">threadpool:</span></span><br><span class="line">    <span class="attr">search:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">fixed</span></span><br><span class="line">        <span class="attr">min:</span> <span class="number">60</span></span><br><span class="line">        <span class="attr">max:</span> <span class="number">80</span></span><br><span class="line">        <span class="attr">queue_size:</span> <span class="number">1000</span></span><br><span class="line"><span class="string">//</span> <span class="string">配置es服务器的执行查询操作时所用线程池，fix固定线程数的线程池。</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">index :</span></span><br><span class="line">    <span class="attr">store:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">memory</span></span><br><span class="line"><span class="string">//</span> <span class="string">表示索引存储在内存中，当然es不太建议这么做。经本人测试，做查询时，使用内存索引并不会比正常的索引快。</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">index.mapper.dynamic:</span> <span class="literal">false</span></span><br><span class="line"><span class="string">//</span> <span class="string">禁止自动创建mapping。默认情况下，es可以根据数据类型自动创建mapping</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">index.query.parse.allow_unmapped_fields:</span> <span class="literal">false</span> </span><br><span class="line"><span class="string">//</span> <span class="string">不能查找没有在mapping中定义的属性</span></span><br></pre></td></tr></table></figure><p>安装时自带的配置文件只包含一部分比较核心的配置项，更多的配置内容需要自己边搞边查了。<a href="https://www.elastic.co/guide/en/elasticsearch/reference/index.html">更多配置参考</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/elk/1.3%E4%BD%BF%E7%94%A8Kibana%E6%93%8D%E4%BD%9CES/"/>
      <url>/elk/1.3%E4%BD%BF%E7%94%A8Kibana%E6%93%8D%E4%BD%9CES/</url>
      
        <content type="html"><![CDATA[<p>之前说到 ES 提供了 <code>RESTful</code> 风格的接口以便于我们操作，需要借助能够发送HTTP请求的工具调用这些API，工具是可以任意的，包括网页浏览器，当然也可以使用比如 <code>Postman</code> / <code>Talend API tester</code>等工具。这里为了学习 <code>ElK</code> 所以选择使用  <code>Kibana</code>，关于 <code>Kibana</code> 如何安装参考其他文章。</p><span id="more"></span><h1 id="集群相关">集群相关</h1><h2 id="查看集群健康信息">查看集群健康信息</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET _cat/health?v</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">epoch      timestamp cluster       status node.total node.data shards pri relo init unassign pending_tasks max_task_wait_time active_shards_percent</span><br><span class="line">1646502528 17:48:48  elasticsearch green           1         1      3   3    0    0        0             0                  -                100.0%</span><br></pre></td></tr></table></figure><p>主要字段描述：</p><ul><li><code>cluster</code>：集群名称</li><li><code>status</code>：集群状态</li><li><code>node.total</code>：集群中的节点数</li><li><code>node.data</code>：集群中的数据节点数</li><li><code>shards</code>：集群中总的分片数量</li><li><code>pri</code>：主分片数量，英文全称为 <code>private</code></li><li><code>relo</code>：复制分片总数</li><li><code>unassign</code>：未指定的分片数量，是应有分片数和现有的分片数的差值（包括主分片和复制分片）</li></ul><p>集群共有 <code>green</code> 、<code>yellow</code> 、 <code>red</code> 三种状态：</p><ul><li><code>green</code> 代表一切正常，集群功能齐全</li><li><code>yellow</code> 代表所有数据都是可用的，但是某些复制没有被分配（集群功能齐全）</li><li><code>red</code> 代表因为某些原因，某些数据不可用。如果是red状态，数据很有可能已经丢失</li></ul><p>可以在请求中添加 <code>help</code> 参数来查看每个操作返回结果字段的描述</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET _cat/health?<span class="built_in">help</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">epoch                 | t,time                                   | seconds since 1970-01-01 00:00:00  </span><br><span class="line">timestamp             | ts,hms,hhmmss                            | time <span class="keyword">in</span> HH:MM:SS                   </span><br><span class="line">cluster               | cl                                       | cluster name                       </span><br><span class="line">status                | st                                       | health status                      </span><br><span class="line">node.total            | nt,nodeTotal                             | total number of nodes              </span><br><span class="line">node.data             | nd,nodeData                              | number of nodes that can store data</span><br><span class="line">shards                | t,sh,shards.total,shardsTotal            | total number of shards             </span><br><span class="line">pri                   | p,shards.primary,shardsPrimary           | number of primary shards           </span><br><span class="line">relo                  | r,shards.relocating,shardsRelocating     | number of relocating nodes         </span><br><span class="line">init                  | i,shards.initializing,shardsInitializing | number of initializing nodes       </span><br><span class="line">unassign              | u,shards.unassigned,shardsUnassigned     | number of unassigned shards        </span><br><span class="line">pending_tasks         | pt,pendingTasks                          | number of pending tasks            </span><br><span class="line">max_task_wait_time    | mtwt,maxTaskWaitTime                     | <span class="built_in">wait</span> time of longest task pending  </span><br><span class="line">active_shards_percent | asp,activeShardsPercent                  | active number of shards <span class="keyword">in</span> percent </span><br></pre></td></tr></table></figure><p>ES中许多API都可以添加 <code>help</code> 参数来显示字段含义，如果觉得返回的东西太多看着烦，也可以人为指定返回的字段，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET _cat/health?h=cluster,status&amp;v</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cluster       status</span><br><span class="line">elasticsearch green</span><br></pre></td></tr></table></figure><h2 id="查看集群中节点信息">查看集群中节点信息</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET _cat/nodes?v</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip        heap.percent ram.percent cpu load_1m load_5m load_15m node.role master name</span><br><span class="line">127.0.0.1           28          59  11                          dilm      *      WANGPENGLIANG</span><br></pre></td></tr></table></figure><h2 id="查看集群中索引信息">查看集群中索引信息</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET _cat/indices?v</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">health status index                    uuid                   pri rep docs.count docs.deleted store.size pri.store.size</span><br><span class="line">green  open   .kibana_task_manager_1   BT3RImw0S9mVrEwQaKIc1Q   1   0          2            0     41.3kb         41.3kb</span><br><span class="line">green  open   .apm-agent-configuration 82PMto3PSt2UsRf7qYmfJg   1   0          0            0       283b           283b</span><br><span class="line">green  open   .kibana_1                xSc4xPL6TXica1mIT8005A   1   0         12            6     60.4kb         60.4kb</span><br></pre></td></tr></table></figure><p>更多的查看和监视 <code>ElastaticSearch</code> 的API查看：<a href="http://www.elastic.co/guide/en/elasticsearch/reference/current/cat.html">官网文档</a></p><h1 id="索引相关（Index）">索引相关（Index）</h1><h2 id="创建索引">创建索引</h2><p>创建名为 <code>movies</code> 的 <code>index</code> ，两种写法等同，名字不能包含特殊字符，只能小写，不能以<code>-</code> , <code>_</code> , <code>+</code> 开头，不能超过255字节。</p><p>第一种方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUT movies</span><br></pre></td></tr></table></figure><p>第二种方式：本质是 <code>PUT http://ip:9200/test</code>，kibana 做了优化因此写不写之前的 <code>/</code> 都可以</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUT /movies</span><br></pre></td></tr></table></figure><p>第三种方式：当向一个不存在的索引写入文档时，索引会自动被创建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PUT movies/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;:&quot;大话西游&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查看索引">查看索引</h2><p>如果试图访问一个不存在的索引会报错。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET movies</span><br></pre></td></tr></table></figure><h2 id="删除索引">删除索引</h2><p>如果试图删除一个不存在的索引会报错。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE movies</span><br></pre></td></tr></table></figure><h2 id="查看某字母开头的索引">查看某字母开头的索引</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET _cat/indices/m*?v</span><br></pre></td></tr></table></figure><h2 id="查询所有索引">查询所有索引</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET _cat/indices</span><br></pre></td></tr></table></figure><h2 id="mappings-settings">mappings / settings</h2><h3 id="创建索引时指定-map">创建索引时指定 map</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PUT movies</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot; : &#123;</span><br><span class="line">    &quot;properties&quot; : &#123;</span><br><span class="line">      &quot;name&quot; : &#123;</span><br><span class="line">        &quot;type&quot; : &quot;keyword&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建索引后指定-map">创建索引后指定 map</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUT movies</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PUT movies/_mapping</span><br><span class="line">&#123;</span><br><span class="line">    &quot;properties&quot; : &#123;</span><br><span class="line">      &quot;name&quot; : &#123;</span><br><span class="line">        &quot;type&quot; : &quot;keyword&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建索引时同时指定">创建索引时同时指定</h3><p>创建索引时指定分片数和副本数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">PUT movies</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot; : &#123;</span><br><span class="line">    &quot;properties&quot; : &#123;</span><br><span class="line">      &quot;name&quot; : &#123;</span><br><span class="line">        &quot;type&quot; : &quot;keyword&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;settings&quot; : &#123;</span><br><span class="line">    &quot;index&quot; : &#123;</span><br><span class="line">      &quot;number_of_shards&quot; : 1,</span><br><span class="line">      &quot;number_of_replicas&quot; : 2</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改副本数量">修改副本数量</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT movie/_settings</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;index&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;number_of_replicas&quot;</span> : <span class="number">3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改分片数量">修改分片数量</h3><p>分片数量必须在索引创建时指定，创建后无法修改。尝试修改时会报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 请求</span><br><span class="line">PUT movie/_settings</span><br><span class="line">&#123;</span><br><span class="line">  &quot;index&quot; : &#123;</span><br><span class="line">    &quot;number_of_shards&quot; : 3</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 响应</span><br><span class="line">&#123;</span><br><span class="line">  &quot;error&quot;: &#123;</span><br><span class="line">    &quot;root_cause&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;type&quot;: &quot;illegal_argument_exception&quot;,</span><br><span class="line">        &quot;reason&quot;: &quot;Can&#x27;t update non dynamic settings [[index.number_of_shards]] for open indices [[movie/BPnIxSCwTvWNtze-4gDJaw]]&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;type&quot;: &quot;illegal_argument_exception&quot;,</span><br><span class="line">    &quot;reason&quot;: &quot;Can&#x27;t update non dynamic settings [[index.number_of_shards]] for open indices [[movie/BPnIxSCwTvWNtze-4gDJaw]]&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;status&quot;: 400</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数据相关">数据相关</h1><h2 id="语法">语法</h2><p>添加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">*****************添加*************************</span><br><span class="line">// 如果不传id, 则系统自动生成一个UUID</span><br><span class="line">POST /index/<span class="built_in">type</span>/</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;属性名&quot;</span>:修改值</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">POST /index/<span class="built_in">type</span>/id</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;属性名&quot;</span>:修改值</span><br><span class="line">&#125;</span><br><span class="line">*****************修改*************************</span><br><span class="line"><span class="comment"># 没有带上的属性会被清除</span></span><br><span class="line">POST /index/<span class="built_in">type</span>/id</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;属性名&quot;</span>:修改值</span><br><span class="line">&#125;</span><br><span class="line">*****************查询*************************</span><br><span class="line">GET /index/<span class="built_in">type</span>/id  </span><br><span class="line">*****************删除*************************</span><br><span class="line"><span class="comment"># 只是逻辑删除, 将其标记为 `delete` ，数据越来越多时, ES会自动物理删除</span></span><br><span class="line">DELETE /index/<span class="built_in">type</span>/id</span><br></pre></td></tr></table></figure><h2 id="实例">实例</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/go/01%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/go/01%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>🚩    人生苦短，Let’s  go ，本系列所有测试代码均托管在：<a href="https://gitee.com/wangpengliang815/go_study">代码地址</a></p><p><strong>参考</strong>：</p><ul><li><p><a href="https://liwenzhou.com/">李文周的博客</a></p></li><li><p><a href="https://eddycjy.com/go-categories/">跟煎鱼学 Go</a></p></li><li><p><a href="">《Go语言编程》</a></p></li><li><p><a href="https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/directory.md">《Go入门指南》</a></p></li><li><p><a href="https://books.studygolang.com/gopl-zh/">《Go语言圣经》</a></p></li></ul><h1 id="Go-语言环境安装">Go 语言环境安装</h1><p>学习之前需要先安装GO语言的环境</p><ul><li>官网下载地址：<a href="https://golang.org/dl/">https://golang.org/dl/</a></li><li>官方镜像：<a href="https://golang.google.cn/dl/">https://golang.google.cn/dl/</a></li></ul><p><code>Windows</code> 平台和 <code>Mac</code> 平台推荐下载可执行文件版，<code>Linux</code> 平台下载压缩文件版。本机操作系统是 <code>Windows</code>，在下载地址中找到 <code>.msi</code> 后缀的安装包：</p><p><img src="/images/2022-01-04-11-23-11.png" alt=""></p><p>下载到本地并安装，建议安装到指定目录下：</p><p><img src="/images/2022-01-04-11-26-44.png" alt=""></p><p><img src="/images/2022-01-04-11-27-56.png" alt=""></p><p>通过 <code>go version</code> 测试是否安装成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator&gt;go version</span><br><span class="line">go version go1.17.5 windows/amd64</span><br></pre></td></tr></table></figure><p>Go 支持以下操作系统：</p><ul><li><code>Linux</code></li><li><code>FreeBSD</code></li><li><code>MacOS</code></li><li><code>Windows</code></li></ul><p>针对其它平台的安装需要的话自行查找相关资料。</p><h1 id="GOPATH">GOPATH</h1><p><code>GOPATH </code> 是一个环境变量，用来指定工作目录。所有的 <code>go</code> 文件，都需要放在 <code>GoPath</code> 下的 <code>src</code> 目录下才能够编译运行。但是这么做存在几个问题：</p><p>在项目中使用第三方类库时 通过 <code>go get</code> 命令拉取下来的包会直接下载到 <code>GoPath</code> 目录下的 <code>src</code> 包下，这就导致自己写的代码和第三方的文件混在一起，对于管理 Golang 项目的包是非常麻烦的。而且每个如果项目都需要同样的依赖，那么就会在不同的 <code>GoPath</code> 的 <code>src</code> 中下载大量重复的第三方依赖包，同样会占用大量的磁盘空间。</p><p><strong>能否通过给不同的项目设置不同的 <code>GoPath</code> 来解决依赖项目结构混乱问题？</strong></p><p>这么做便于管理项目，每个项目都是不同的 <code>GoPath</code> ，对于管理多个项目而言，能够非常清晰的处理项目结构。否则如果把所有项目都放在同一个 <code>GoPath</code> 的 <code>src</code> 包下，项目的结构就会变得非常混乱，难以管理。</p><p><strong>但是当需要依赖第三方的包的时候，上面的方式解决不了依赖重复的问题</strong></p><p>第三方依赖的包和自己的包混在一起，会给项目文件管理带来一定的麻烦。不同的 <code>GoPath</code> 都需要下载依赖，那么磁盘中重复的依赖就会非常多，会占用大量的磁盘空间。</p><p>所以，究竟是设置一个GoPath目录，解决依赖重复的问题；还是设置不同的GoPath目录，解决Golang项目结构混乱的问题，这是一个有争议性的问题。为了解决这所有的问题，Golang 最终引入了 <code>GoModule</code> 的概念。</p><h1 id="Go-Module">Go Module</h1><p>在 <code>go version&lt;1.11</code>前，使用 <code>GOPATH</code> 来构建应用，但在Go1.11版本之后不再推荐。<code>go module</code> 是Go语言从 1.11 版本之后官方推出的版本管理工具。</p><p>Modules 官方定义为：</p><blockquote><p>Modules 是相关 Go 包的集合，是源代码交换和版本控制的单元。Go语言命令直接支持使用 Modules，包括记录和解析对其他模块的依赖性，Modules 替换旧的基于 GOPATH 的方法，来指定使用哪些源文件</p></blockquote><p><strong>注意</strong>：<code>Golang1.11和1.12</code> 版本虽然已经引入了 <code>GoModule</code> 的概念，但是默认是不开启的，如果需要开启，需要配置环境变量：<code>GO111MODULE=on</code>，默认是 <code>off</code>。而在 <code>Golang1.13</code> 及以上的版本中，<code>GoModule</code> 的默认配置为 <code>auto</code> ，即 <code>GoModule</code> 会通过目录下是否有 <code>go.mod</code> 文件来判断是否开启 <code>GoModule</code> 。所以<code>Golang1.13+</code> 的版本中就不再需要额外配置 <code>GO111MODULE</code> 属性。</p><ul><li><code>GO111MODULE=off </code>：禁用 go module，编译时会从 <code>GOPATH</code> 和 <code>vendor</code> 文件夹中查找包</li><li><code>GO111MODULE=on</code>： 启用 go module，编译时会忽略 <code>GOPATH</code> 和 <code>vendor</code> 文件夹只根据 <code>go.mod</code> 下载依赖</li><li><code>GO111MODULE=auto</code>：默认值，当项目在 <code>GOPATH/src</code> 目录之外，并且项目根目录有 <code>go.mod</code> 文件时，开启  <code>go module</code></li></ul><p>Windows 下手动开启 <code>GO111MODULE</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> GO111MODULE=on 或者 <span class="built_in">set</span> GO111MODULE=auto</span><br></pre></td></tr></table></figure><p>MacOS 或者 Linux 下手动开启 <code>GO111MODULE</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> GO111MODULE=on 或者 <span class="built_in">export</span> GO111MODULE=auto</span><br></pre></td></tr></table></figure><p><strong>有了 <code>GoModule</code> 之后，<code>GoPath</code> 是不是就可以被舍弃了？</strong></p><p>不是的！之前说过 <code>GoPath</code> 所引出的问题，就是因为第三方类库的包所导致的，所以在有了 <code>GoModule</code> 之后，<code>GoPath</code> 和 <code>GoModule</code> 就分别负责不同的职责，共同为项目服务。</p><ul><li><code>GoPath</code> 用来存放从网上拉取的第三方依赖包</li><li><code>GoModule</code> 用来存放自己的Golang项目文件，当项目需要依赖第三方的包时通过 <code>GoModule</code> 目录下的 <code>go.mod</code> 文件来引用 <code>GoPath</code> 目录 <code>src</code> 包下的第三方依赖即可</li></ul><p>这样既解决了原来只能局限在  <code>GoPath/src</code> 包下编程的问题，也解决了第三方依赖包难以管理和重复依赖占用磁盘空间的问题。在引入 <code>GoModule</code> 之后，不会直接在 <code>GoPath</code> 目录进行编程，而是把 <code>GoPath</code> 作为一个第三方依赖包的仓库，真正的工作空间在 <code>GoModule</code> 目录下。</p><h1 id="Go-Module设置">Go Module设置</h1><p>使用 <code>go mod init 模块名称</code> 命令对目录进行初始化操作，即可将这个目录设置为 <code>GoModule</code> 目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\GoProject&gt;go mod init goProject</span><br></pre></td></tr></table></figure><p>初始化命令执行完毕之后，会在 <code>D:\GoProject&gt;</code> 目录下生成一个 <code>go.mod</code> 文件，该文件就是用来引入 <code>GoPath</code> 目录下的第三方依赖的文件。</p><p>初始化之后的 <code>go.mod</code> 文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module goProject</span><br><span class="line"></span><br><span class="line">go 1.17</span><br></pre></td></tr></table></figure><p>当需要引入 <code>GoPath</code> 目录下的第三方依赖包的时候，只需要在 <code>go.mod</code> 目录下添加依赖名称，<code>GoModule</code> 就会自动把第三方依赖包下载到 <code>GoPath</code> 目录下。例如下面的 <code>go.mod</code> 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">module go_module_demo</span><br><span class="line"></span><br><span class="line">go 1.17</span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">github.com/astaxie/beego v1.12.1</span><br><span class="line">github.com/go-sql-driver/mysql v1.5.0</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>在这个 <code>go.mod</code> 文件中引入了两个依赖，分别是：<code>beego框架 v1.12.1版本</code> 和 <code>mysql驱动 v1.5.0版本</code> 。</p><p><strong>常用命令如下</strong>：</p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td><code>go mod download</code></td><td>下载依赖包到本地（默认为 GOPATH/pkg/mod 目录）</td></tr><tr><td><code>go mod edit</code></td><td>编辑 go.mod 文件</td></tr><tr><td><code>go mod graph</code></td><td>打印模块依赖图</td></tr><tr><td><code>go mod init</code></td><td>初始化当前文件夹，创建 go.mod 文件</td></tr><tr><td><code>go mod tidy</code></td><td>增加缺少的包，删除无用的包</td></tr><tr><td><code>go mod vendor</code></td><td>将依赖复制到 vendor 目录下</td></tr><tr><td><code>go mod verify</code></td><td>校验依赖</td></tr><tr><td><code>go mod why</code></td><td>解释为什么需要依赖</td></tr></tbody></table><h1 id="GO-PROXY">GO PROXY</h1><p>国内的网络因为防火墙的存在导致有些Go语言的第三方包无法直接通过 <code>go get</code> 命令获取。<code>GOPROXY </code>是Go官方提供的一种通过中间代理商来为用户提供包下载服务的方式。要使用  <code>GOPROXY</code>  只需要设置环境变量  <code>GOPROXY</code> 即可。</p><p>目前公开的代理服务器的地址有：</p><ul><li><a href="http://goproxy.io">goproxy.io</a></li><li><a href="http://goproxy.cn">goproxy.cn</a>：（推荐）由国内的七牛云提供</li></ul><p>Windows 下设置 <code>GOPROXY</code> ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go env -w GOPROXY=https://goproxy.cn,direct</span><br></pre></td></tr></table></figure><p>MacOS 或 Linux 下设置 <code>GOPROXY</code> ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export GOPROXY=https://goproxy.cn</span><br></pre></td></tr></table></figure><blockquote><p>Go 在 1.13 版本之后 GOPROXY 默认值为 <a href="https://proxy.golang.org">https://proxy.golang.org</a>，在国内可能会存在下载慢或者无法访问的情况，所以建议将 GOPROXY 设置为国内的 <a href="http://goproxy.cn">goproxy.cn</a></p></blockquote><p><strong>下载指定版本</strong>：</p><p>执行 <code>go get </code>命令，在下载依赖包的同时还可以指定依赖包的版本。</p><ul><li>运行 <code>go get -u</code> 命令会将项目中的包升级到最新的次要版本或者修订版本</li><li>运行 <code>go get -u=patch</code> 命令会将项目中的包升级到最新的修订版本</li><li>运行 <code>go get [包名]@[版本号] </code>命令会下载对应包的指定版本或者将对应包升级到指定的版本</li></ul><blockquote><p>注意：<code>go get [包名]@[版本号]</code>命令中版本号可以是 x.y.z 的形式，例如 go get foo@v1.2.3，也可以是 git 上的分支或 tag，例如 go get foo@master，还可以是 git 提交时的哈希值，例如 go get foo@e3702bed2</p></blockquote><h1 id="Hello-World">Hello, World</h1><p>老规矩先搞一个 <code>hello world</code> 看看，创建 <code>GoProject</code> 目录，目录格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">D:\GoProject&gt;tree</span><br><span class="line">卷 Data 的文件夹 PATH 列表</span><br><span class="line">卷序列号为 189B-A748</span><br><span class="line">D:.</span><br><span class="line">└─src</span><br></pre></td></tr></table></figure><h2 id="go-mod-init">go mod init</h2><p>使用 <code>go module</code> 模式新建项目时，需要通过 <code>go mod init 项目名</code> 命令对项目进行初始化，该命令会在项目根目录下生成 <code>go.mod</code> 文件。比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\GoProject\src&gt;go mod init goProject</span><br></pre></td></tr></table></figure><h2 id="编写代码">编写代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">/* go 语言的hello world */</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一行：<code>package main</code>，定义包名，必须在源文件中非注释的第一行指明这个文件属于哪个包，比如：<code>package main </code>表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 main 的包。类似于 C# 中的 <code>namespace</code>，表示处于哪个命名空间下。</p><p>第二行：<code>import &quot;fmt&quot;</code>，告诉 Go 编译器这个程序需要使用 fmt 包的函数或其他元素，fmt 包实现了格式化 IO（输入/输出）的函数。类似于在 C# 中需要引用其他 <code>namespace</code> 中的函数时需要使用 <code>using</code>。</p><p>第三行：<code>func main()</code>，表示程序开始执行的函数。main 函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数（如果有 <code>init()</code> 函数则会先执行该函数）。类似于C#中作为入口方法的Main()方法。</p><p>第四行：<code>/*...*/</code>： 注释，单行使用<code>//</code>，多行使用<code>/**/</code> 这没什么好说的。</p><p>第五行：<code>fmt.Println(...)</code>: 用于将字符串输出到控制台，并在最后自动增加换行字符<code> \n</code>。类似于 C# 中的 <code>Console.WriteLine()</code> /<code>Console.Write()</code>。</p><h2 id="go-build">go build</h2><p><code>go build</code> 命令表示将源代码编译成可执行文件。在 <code>D:\GoProject\src&gt;</code> 目录下执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">D:\GoProject\src&gt;go build test.go</span><br><span class="line">D:\GoProject\src&gt;dir</span><br><span class="line"> 驱动器 D 中的卷是 Data</span><br><span class="line"> 卷的序列号是 189B-A748</span><br><span class="line"></span><br><span class="line"> D:\GoProject\src 的目录</span><br><span class="line"></span><br><span class="line">2022/01/04 周二  16:12         1,924,096 test.exe</span><br><span class="line">2022/01/04 周二  15:57               111 test.go</span><br></pre></td></tr></table></figure><p>编译得到的可执行文件会保存在执行编译命令的当前目录下，如果是windows平台会在当前目录下找到  <code>test.exe</code> 可执行文件。</p><p>可在终端直接执行该 <code>test.exe</code> 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D:\GoProject\src&gt;test.exe</span><br><span class="line">Hello, World!</span><br></pre></td></tr></table></figure><h2 id="go-run">go run</h2><p><img src="/images/2021-12-16-22-55-19.png" alt=""></p><p>Go 是一门编译型语言，Go 语言的工具链将源代码及其依赖转换成计算机的机器指令（静态编译）。Go语言提供的工具都通过一个单独的命令 <code>go</code> 调用，<code>go</code> 命令有一系列子命令。最简单的一个子命令就是 <code>run</code>。这个命令编译一个或多个以 <code>.go</code> 结尾的源文件，链接库文件，并运行最终生成的可执行文件。</p><h2 id="跨平台编译">跨平台编译</h2><p>默认 <code>go build</code> 的可执行文件都是当前操作系统可执行的文件，如果想在 <code>windows</code> 下编译一个 <code>linux</code> 下可执行文件，可以这么做：</p><p>指定目标操作系统的平台和处理器架构：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET CGO_ENABLED=0  // 禁用CGO</span><br><span class="line">SET GOOS=linux  // 目标平台是linux</span><br><span class="line">SET GOARCH=amd64  // 目标处理器架构是amd64</span><br></pre></td></tr></table></figure><p><em>使用了cgo的代码是不支持跨平台编译的</em></p><p>然后再执行 <code>go build</code> 命令，得到的就是能够在 <code>linux</code> 平台运行的可执行文件了。</p><p>Mac 下编译 Linux 和 Windows平台 64位 可执行程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build</span><br><span class="line">CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build</span><br></pre></td></tr></table></figure><p>Linux 下编译 Mac 和 Windows 平台64位可执行程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build</span><br><span class="line">CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build</span><br></pre></td></tr></table></figure><p>Windows下编译Mac平台64位可执行程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SET CGO_ENABLED=0</span><br><span class="line">SET GOOS=darwin</span><br><span class="line">SET GOARCH=amd64</span><br><span class="line">go build</span><br></pre></td></tr></table></figure><p>现在，开启 <code>Go</code> 语言学习之旅。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/go/02%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/"/>
      <url>/go/02%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<p>变量和常量是编程中必不可少的部分，也是比较好理解的一部分。</p><h1 id="标识符">标识符</h1><p>编程语言中标识符指：由程序员定义的具有特殊意义的词，比如变量名、常量名、函数名等。 Go语言中标识符由字母数字和<code>_</code>(下划线）组成，并且只能以字母和<code>_</code>开头且区分大小写。 比如：<code>abc</code>, <code>_123</code>, <code>a123</code>。</p><h1 id="关键字">关键字</h1><p>关键字指：编程语言中预先定义好的具有特殊含义的标识符。 关键字和保留字都不建议用作变量名。Go 语言中类似 C# 的关键字有25个，只能在特定语法结构中使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">break      default        func     interface    select</span><br><span class="line">case       defer          go       map          struct</span><br><span class="line">chan       else           goto     package      switch</span><br><span class="line">const      fallthrough    if       range        type</span><br><span class="line">continue   for            import   return       var</span><br></pre></td></tr></table></figure><p>除此之外Go语言中还有30多个预定义的名字，比如 int 和 ture 等，主要对应内建的常量、类型和函数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">内建常量: true false iota nil</span><br><span class="line">内建类型: int   int8   int16   int32  int64   uint   uint8  uint16   uint32   uint64   uintptr  </span><br><span class="line">         float32   float64   complex128   complex64   bool   byte    rune   string  error</span><br><span class="line">内建函数: make  len  cap   new   append   copy   close   delete   complex   real    imag    panic  recover</span><br></pre></td></tr></table></figure><p>通常在 Go 语言编程中推荐的命名方式是驼峰命名。如：ReadAll，不推荐下划线命名。</p><h1 id="变量">变量</h1><h2 id="变量声明">变量声明</h2><p>变量声明语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名字 类型 = 表达式</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定变量类型但不赋值，使用默认值</span></span><br><span class="line"><span class="keyword">var</span> v1 <span class="keyword">int</span>      <span class="comment">// 省略表达式，使用数值类型对应的零值初始化（0）</span></span><br><span class="line"><span class="keyword">var</span> v2 <span class="keyword">string</span>   <span class="comment">// 省略表达式，使用字符串对应的零值初始化（空字符串）</span></span><br><span class="line"><span class="keyword">var</span> v3 [<span class="number">10</span>]<span class="keyword">int</span>  <span class="comment">// 会创建长度为10的数据</span></span><br><span class="line"><span class="keyword">var</span> v4 []<span class="keyword">int</span>    <span class="comment">// 数组切片</span></span><br><span class="line"><span class="keyword">var</span> v5 <span class="keyword">struct</span> &#123; <span class="comment">// &#123;0&#125;</span></span><br><span class="line">f <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> v6 *<span class="keyword">int</span>            <span class="comment">// 指针,因未被初始化所以默认值为nil</span></span><br><span class="line"><span class="keyword">var</span> v7 <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>  <span class="comment">// map,key为string类型，value为int类型,默认值为map[]</span></span><br><span class="line"><span class="keyword">var</span> v8 <span class="function"><span class="keyword">func</span><span class="params">(a <span class="keyword">int</span>)</span> <span class="title">int</span> // 函数类型,因未被初始化所以默认值为<span class="title">nil</span>,直接调用会抛出空指针异常</span></span><br><span class="line">fmt.Println(v1, v2, v3, v4, v5, v6, v7, v8)</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><ol><li>Go 语言中变量声明采用<strong>类型后置</strong>方式，需要先声明变量名称再声明变量类型</li><li>语句最后不需要加<code>;</code>（如果需要一行写多条语句需要，但不推荐这么干）</li><li>如果定义的是局部变量，则必须使用，否则编译报错</li></ol><h2 id="批量声明">批量声明</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多变量声明使用此方式避免重复写var</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">v1 <span class="keyword">int</span></span><br><span class="line">v2 <span class="keyword">string</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>或者这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n1, n2, n3 <span class="keyword">string</span></span><br><span class="line">n1, n2, n3 = <span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span></span><br></pre></td></tr></table></figure><p>再或者这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n4, n5, n6 = <span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span></span><br></pre></td></tr></table></figure><h2 id="变量初始化">变量初始化</h2><p>通常情况下 <code>类型 </code>或 <code>= 表达式</code> 两个部分可以省略其中的一个。如果省略的是类型信息，将根据初始化表达式来推导变量的类型信息。如果初始化表达式被省略，那么将用零值初始化该变量。</p><ul><li>数值类型变量对应的零值是 <code>0</code></li><li>布尔类型变量对应的零值是 <code>false</code></li><li>字符串类型对应的零值是 <code>空字符串</code></li><li>接口或引用类型（包括slice、map、chan和函数）变量对应的零值是 <code>nil</code></li><li>数组或结构体等聚合类型对应的零值是每个元素或字段对应类型的零值</li></ul><p>零值初始化机制可以确保每个声明的变量总是有一个良好定义的值，以保证不存在未初始化的变量。</p><h3 id="1：指定类型但不赋值">1：指定类型但不赋值</h3><p>指定类型但不赋值，将使用类型的默认零值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span> <span class="comment">// 省略表达式，使用字符串对应的零值初始化（空字符串）</span></span><br><span class="line"><span class="keyword">var</span> age <span class="keyword">int</span>     <span class="comment">// 省略表达式，使用数值类型对应的零值初始化（0）</span></span><br><span class="line">fmt.Println(name, age)</span><br></pre></td></tr></table></figure><h3 id="2：使用类型推断">2：使用类型推断</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> address = <span class="string">&quot;beijing&quot;</span></span><br><span class="line">fmt.Println(address)</span><br></pre></td></tr></table></figure><h3 id="3：简短声明">3：简短声明</h3><p>简短声明，以<code>名字 := 表达式 </code>形式声明变量，变量的类型根据表达式来自动推导。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sex := <span class="string">&quot;男&quot;</span></span><br><span class="line">fmt.Println(sex)</span><br></pre></td></tr></table></figure><h3 id="4：使用-new-函数">4：使用 new 函数</h3><p>调用内建的 <code>new</code> 函数创建变量。表达式 <code>new(T)</code>将创建一个 <code>T</code> 类型的匿名变量，初始化为 <code>T</code> 类型的零值，然后返回变量地址，返回的指针类型为<code>*T</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p := <span class="built_in">new</span>(<span class="keyword">int</span>)   <span class="comment">// p, *int 类型, 指向匿名的 int 变量</span></span><br><span class="line">fmt.Println(*p) <span class="comment">// &quot;0&quot;</span></span><br><span class="line">*p = <span class="number">2</span>          <span class="comment">// 设置 int 匿名变量的值为 2</span></span><br><span class="line">fmt.Println(*p) <span class="comment">// &quot;2&quot;</span></span><br></pre></td></tr></table></figure><p><code>new</code> 函数创建变量和普通变量声明语句方式创建变量没有什么区别，除了不需要声明一个临时变量的名字外，还可以在表达式中使用 <code>new(T)</code>。其实这就是一种语法糖，而不是一个新的基础概念。<code>new</code> 函数使用通常相对比较少，因为对于结构体来说，直接用字面量语法创建新变量的方法会更灵活。由于 <code>new</code> 只是一个预定义的函数，它并不是一个关键字，因此可以将 <code>new</code> 名字重新定义为别的类型。例如下面的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">delta</span><span class="params">(old, <span class="built_in">new</span> <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> <span class="built_in">new</span> - old &#125;</span><br></pre></td></tr></table></figure><p>由于 <code>new </code>被定义为 <code>int</code> 类型的变量名，因此在 <code>delta</code> 函数内部无法使用内置的<code> new</code> 函数。</p><h2 id="全局变量">全局变量</h2><p>全局声明变量，如果没有使用不会编译报错。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">author  <span class="keyword">string</span></span><br><span class="line">address <span class="keyword">string</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匿名变量">匿名变量</h2><p>在使用多重赋值时，如果想要忽略某个值，可以使用 <code>匿名变量（anonymous variable）</code>。 匿名变量用一个下划线<code>_</code>表示，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该函数返回两个值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getName</span><span class="params">()</span> <span class="params">(firstName, lastName <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;wangpengliang&quot;</span>, <span class="string">&quot;lizimeng&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// _ 代表匿名变量,匿名变量将会被忽略</span></span><br><span class="line">result, _ := getName()</span><br><span class="line">fmt.Println(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名变量不占用命名空间，不会分配内存，所以匿名变量之间不存在重复声明。 (在<code>Lua</code>等编程语言里，匿名变量也被叫做哑元变量)</p><p><strong>注意：</strong></p><ol><li>函数外的每个语句都必须以关键字开始（var、const、func等）</li><li><code>:=</code> 不能使用在函数外</li><li><code>_ </code>多用于占位，表示忽略值</li></ol><h2 id="变量生命周期">变量生命周期</h2><p>变量的生命周期指的是在程序运行期间变量有效存在的时间段。</p><ul><li>对于在包一级声明的变量来说，它们生命周期和整个程序的运行周期一致</li><li>在局部变量的声明周期是动态的：从每次创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收</li><li>函数的参数变量和返回值变量都是局部变量。它们在函数每次被调用的时候创建</li></ul><p>这里需要注意一个问题，看以下代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> global *<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">int</span></span><br><span class="line">    x = <span class="number">1</span></span><br><span class="line">    global = &amp;x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">g</span><span class="params">()</span></span> &#123;</span><br><span class="line">    y := <span class="built_in">new</span>(<span class="keyword">int</span>)</span><br><span class="line">    *y = <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>f()</code> 里的 <code>x</code> 变量必须在堆上分配，因为它在函数退出后依然可以通过包一级的 <code>global</code> 变量找到，虽然它是在函数内部定义的。用Go语言的术语说，这个  <code>x </code> 局部变量从函数 <code>f</code> 中逃逸了。相反，当 <code>g</code> 函数返回时，变量  <code>*y</code> 将是不可达的，也就是说可以马上被回收的。因此：<code>*y</code> 并没有从函数 <code>g</code> 中逃逸，虽然这里用的是 <code>new</code> 方式。编译器会自动选择在栈上还是在堆上分配局部变量的存储空间 而不是用 <code>var</code> 还是 <code>new</code> 声明变量的方式区分。</p><h2 id="变量赋值">变量赋值</h2><p>使用赋值语句可以更新一个变量的值，最简单的赋值语句是将要被赋值的变量放在=的左边，新值的表达式放在=的右边。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1</span>                       <span class="comment">// 命名变量的赋值</span></span><br><span class="line">*p = <span class="literal">true</span>                   <span class="comment">// 通过指针间接赋值</span></span><br><span class="line">person.name = <span class="string">&quot;bob&quot;</span>         <span class="comment">// 结构体字段赋值</span></span><br><span class="line">count[x] = count[x] * scale <span class="comment">// 数组、slice或map的元素赋值</span></span><br></pre></td></tr></table></figure><p>特定的二元算术运算符和赋值语句的复合操作有一个简洁形式，例如上面最后的语句可以重写为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count[x] *= scale</span><br></pre></td></tr></table></figure><p>这样可以省去对变量表达式的重复计算。数值变量也可以支持 <code>++</code> 递增和 <code>--</code> 递减语句</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v := <span class="number">1</span></span><br><span class="line">v++    <span class="comment">// 等价方式 v = v + 1；v 变成 2</span></span><br><span class="line">v--    <span class="comment">// 等价方式 v = v - 1；v 变成 1</span></span><br></pre></td></tr></table></figure><p>除此之外Go语言还支持多重赋值，在不支持多重赋值的语言中，交换两个变量的内容需要引入一个中间变量，但是Go语言中不需要，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> j <span class="keyword">int</span> = <span class="number">20</span></span><br><span class="line">i, j = j, i</span><br></pre></td></tr></table></figure><h1 id="包和文件">包和文件</h1><p>Go 语言中的包与C#中的 <code>namespace</code> 的概念类似，目的都是为了支持模块化、封装、单独编译和代码重用。每个Go文件都只能属于一个包。一个包可以由许多以 <code>.go</code> 为扩展名的源文件组成，因此文件名和包名一般来说都是不相同的。</p><h2 id="包初始化顺序">包初始化顺序</h2><p>如果包中含有多个 <code>.go</code>  源文件，将按照发给编译器的顺序进行初始化，Go语言的构建工具首先会将 <code>.go</code> 文件根据文件名排序，然后依次调用编译器编译。</p><h2 id="包级别变量处理">包级别变量处理</h2><p>对于在包级别声明的变量，如果有初始化表达式则用表达式初始化，如果存在没有初始化表达式的，可以用一个特殊的 <code>init</code> 初始化函数来简化初始化工作。每个文件可以包含多个 <code>init</code> 初始化函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123; &#125;</span><br></pre></td></tr></table></figure><p><code>init</code> 初始化函数除了不能被调用或引用外，其他行为和普通函数类似。每个文件中的 <code>init</code> 初始化函数，在程序开始执行时按照声明的顺序被自动调用。 每个包在解决依赖的前提下，以导入声明的顺序初始化，每个包只会被初始化一次。因此，如果 <code>a</code> 包 导入了 <code>b</code> 包，那么在 <code>a</code> 包初始化的时候可以认为 <code>b</code> 包必然已经初始化过了。初始化工作是自下而上进行的， <code>main</code> 包最后被初始化。这种方式可以确保在 <code>main</code> 函数执行之前所有依赖的包都已经完成初始化。</p><h2 id="导出包">导出包</h2><p>Go 语言中根据首字母的大小写来确定可以访问的权限。如果首字母大写则可以被其他的包访问；如果首字母小写，则只能在本包中使用。该规则适用于全局变量、全局常量、类型、结构字段、函数、方法等。可以简单的理解成：<em>首字母大写是公有的，首字母小写是私有的</em>。只能访问包导出的名字，未导出的名字不能被包外的代码访问。</p><h2 id="导入包">导入包</h2><p>使用包成员需要使用 <code>import</code> 关键字导入，但不能形成导入循环。</p><p><strong>导入系统包：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span> </span><br></pre></td></tr></table></figure><p><strong>相对路径导入包：导入同一目录下 test 包</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;./test&quot;</span> </span><br></pre></td></tr></table></figure><p><strong>绝对路径导入包：导入 <code>gopath/src/oldboy/python</code> 包</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;oldboy/python&quot;</span></span><br></pre></td></tr></table></figure><p><strong>导入包并启用别名：导入<code>fmt</code>并启用别名 <code>f2</code></strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> f2 <span class="string">&quot;fmt&quot;</span></span><br></pre></td></tr></table></figure><p>将 <code>fmt</code> 启用别名<code>.</code>可以直接使用内容而不用再添加 <code>fmt</code> 。比如 <code>fmt.Println</code> 可以直接写成 <code>Println</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> . <span class="string">&quot;fmt&quot;</span> </span><br></pre></td></tr></table></figure><p><strong>import _</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>  _ <span class="string">&quot;fmt&quot;</span>  </span><br></pre></td></tr></table></figure><p>这表示只使用该包的 <code>init</code> 函数，并不使用该包的其他内容。这种形式的 <code>import</code> ，在 <code>import</code>时就执行了 <code>fmt</code> 包中的 <code>init</code> 函数。</p><p><strong>注意</strong>：未使用的导入包，会被编译器视为错误 (不包括 <code>&quot;import _&quot;</code>)。实例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./main.go:4:2: imported and not used: &quot;fmt&quot;</span><br></pre></td></tr></table></figure><h1 id="作用域">作用域</h1><p>一个声明语句将程序中的实体和一个名字关联，比如一个函数或一个变量。声明语句的作用域是指源代码中可以有效使用这个名字的范围。</p><p>作用域和生命周期不能混为一谈。声明语句的作用域对应的是一个源代码的文本区域；它是一个编译时的属性。一个变量的生命周期是指程序运行时变量存在的有效时间段，在此时间区域内它可以被程序的其他部分引用；是一个运行时的概念。</p><p>声明语句对应的词法域决定了作用域范围的大小。对于内置的类型、函数和常量，比如 <code>int</code>、<code>len</code>和 <code>true</code> 等是在全局作用域的，因此可以在整个程序中直接使用。任何在函数外部（也就是包级语法域）声明的名字可以在同一个包的任何源文件中访问的。对于导入的包，例如 <code>tempconv</code> 导入的 <code>fmt</code> 包，则是对应源文件级的作用域，因此只能在当前的文件中访问导入的 <code>fmt</code> 包，当前包的其它源文件无法访问在当前源文件导入的包。还有许多声明语句，比如 <code>tempconv.CToF</code> 函数中的变量 <code>c</code>，则是局部作用域的，它只能在函数内部（甚至只能是局部的某些部分）访问。</p><h1 id="常量">常量</h1><p>常量表达式的值在编译期计算，而不是在运行期。每种常量的潜在类型都是基础类型：<code>boolean</code>、<code>string</code>或数字。Go语言中常量指：编译期间就已知且不可改变的值。使用 <code>const</code> 关键字定义常量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PI <span class="keyword">float64</span> = <span class="number">3.14159265358979323846</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 显式类型定义,常量名称推荐全大写</span></span><br><span class="line"><span class="keyword">const</span> LENGTH <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐式类型定义,其实也是使用类型推导</span></span><br><span class="line"><span class="keyword">const</span> WIDTH = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多重定义</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">size <span class="keyword">int64</span> = <span class="number">1024</span></span><br><span class="line">eof        = <span class="number">-1</span> <span class="comment">// 无类型整型常量</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 或者这样</span></span><br><span class="line"><span class="keyword">const</span> a, b, c = <span class="number">1</span>, <span class="literal">false</span>, <span class="string">&quot;hello world&quot;</span> <span class="comment">// 常量的多重赋值</span></span><br></pre></td></tr></table></figure><h2 id="iota">iota</h2><p>常量声明可以使用 <code>iota</code> 常量生成器初始化，它用于生成一组以相似规则初始化的常量，但是不用每行都写一遍初始化表达式。在一个 <code>const</code> 声明语句中，在第一个声明的常量所在行的 <code>iota</code> 将会被置为 <code>0</code> ，然后在每一个有常量声明的行加 <code>1</code>。(Go语言没有枚举类型，可以使用 <code>const+iota</code> 模拟)</p><blockquote><p>关键字 <code>iota</code> 定义常量组中从0开始按行计数的自增枚举值。<code>iota</code> 在 <code>const</code> 关键字出现时将被重置为0 (const内部的第一行之前)，const中每新增一行常量声明将使 <code>iota</code> 计数一次。</p></blockquote><p>普通常量组：如果不指定类型和初始化值，则与上一行非空常量右值相同</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">   Windows = <span class="number">0</span></span><br><span class="line">   Linux</span><br><span class="line">   MaxOS</span><br><span class="line">)</span><br><span class="line">fmt.Println(Windows, Linux, MaxOS) <span class="comment">// output: 0 0 0</span></span><br></pre></td></tr></table></figure><p>结合 <code>iota</code> 实现枚举：第一个 <code>iota</code> 等于0，每当 <code>iota</code> 在新的一行被使用，它的值自增1</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">   Sunday    = <span class="literal">iota</span> <span class="comment">// 0</span></span><br><span class="line">   Monday           <span class="comment">// 1,通常省略后续行行表达式。</span></span><br><span class="line">   Tuesday          <span class="comment">// 2</span></span><br><span class="line">   Wednesday        <span class="comment">// 3</span></span><br><span class="line">   Thursday         <span class="comment">// 4</span></span><br><span class="line">   Friday           <span class="comment">// 5</span></span><br><span class="line">   Saturday         <span class="comment">// 6</span></span><br><span class="line">)</span><br><span class="line">fmt.Println(Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday)</span><br></pre></td></tr></table></figure><p><code>iota</code> 插队：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">   a1 = <span class="literal">iota</span>    <span class="comment">// 0</span></span><br><span class="line">   a2           <span class="comment">// 1</span></span><br><span class="line">   b1 = <span class="string">&quot;hello&quot;</span> <span class="comment">// 独立值hello,iota+=1</span></span><br><span class="line">   b2           <span class="comment">// 如不指定类型和初始化值，则与上一行非空常量右值相同,所以是hello;iota+=1</span></span><br><span class="line">   c1 = <span class="literal">iota</span>    <span class="comment">// 恢复自增,4</span></span><br><span class="line">   c2           <span class="comment">// 5</span></span><br><span class="line">)</span><br><span class="line">fmt.Println(a1, a2, b1, b2, c1, c2) <span class="comment">// output:0 1 hello hello 4 5</span></span><br></pre></td></tr></table></figure><p><code>iotl</code> 忽略：使用 <code>_</code> 忽略某些值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">d1 = <span class="literal">iota</span></span><br><span class="line">d2</span><br><span class="line">_</span><br><span class="line">d3</span><br><span class="line">)</span><br><span class="line">fmt.Println(d1, d2, d3) <span class="comment">// output:0 1 3</span></span><br></pre></td></tr></table></figure><p><code>iota</code> 定义数量级</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">_  = <span class="literal">iota</span>             <span class="comment">// _表示将0忽略</span></span><br><span class="line">KB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>) <span class="comment">// 表示1左移十位，转换为十进制就是1024</span></span><br><span class="line">MB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">GB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">TB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">PB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>同一常量组中，可以提供多个 <code>iota</code>，它们各自增⻓。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">a, b = <span class="literal">iota</span> + <span class="number">1</span>, <span class="literal">iota</span> + <span class="number">2</span> <span class="comment">// a=iota+1 b=iota+2 =&gt; 1,2</span></span><br><span class="line">c, d                      <span class="comment">// c=iota(1)+1 b=iota(2)+1 =&gt; 2,3</span></span><br><span class="line">)</span><br><span class="line">fmt.Println(a, b, c, d)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/go/04%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/go/04%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="流程控制">流程控制</h1><h2 id="If">If</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">score := <span class="number">60</span></span><br><span class="line"><span class="keyword">if</span> score &gt;= <span class="number">90</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> score &gt; <span class="number">70</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;C&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="If-特殊写法">If 特殊写法</h2><p>可以在 if 表达式之前添加一个执行语句，再根据变量值进行判断。这种写法可以将返回值与判断放在一行进行处理，而且返回值的作用范围被限制在 <code>if、else</code> 语句组合中。这么做的好处在于：在编程中，变量的作用范围越小，所造成的问题可能性越小，每一个变量代表一个状态，有状态的地方，状态就会被修改，函数的局部变量只会影响一个函数的执行，但全局变量可能会影响所有代码的执行状态，因此限制变量的作用范围对代码的稳定性有很大的帮助。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> score := <span class="number">60</span>; score &gt;= <span class="number">90</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> score &gt; <span class="number">75</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;C&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="for">for</h2><p>条件表达式返回 <code>true</code> 时循环体不停地进行循环，直到条件表达式返回 <code>false</code> 时自动退出循环，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">sum += i <span class="comment">// 1+2+3+4</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(sum)</span><br></pre></td></tr></table></figure><p><code>for</code> 循环的初始语句可以被忽略，但是初始语句后的分号必须要写，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> ; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>for</code> 循环的初始语句和结束语句都可以省略，类似于C#中的 <code>while</code>（满足条件表达式时持续循环，否则结束循环。），比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">j := <span class="number">0</span></span><br><span class="line"><span class="comment">// 循环的初始语句和结束语句都可以省略:</span></span><br><span class="line"><span class="keyword">for</span> j &lt; <span class="number">10</span> &#123;</span><br><span class="line">fmt.Println(j)</span><br><span class="line">j++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无限循环：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">fmt.Print(<span class="string">&quot;hello word&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>for</code> 循环可以通过<code>break</code>、<code>goto</code>、<code>return</code>、<code>panic </code>语句强制退出循环。</p><h2 id="for-range">for range</h2><p>Go 语言中可以使用 <code>for range</code> 遍历数组、切片、字符串、<code>map</code>  及通道（channel）。 通过 <code>for range</code> 遍历的返回值有以下规律：</p><ol><li>数组、切片、字符串返回索引和值</li><li><code>map</code> 返回键和值</li><li><code>channel</code> 只返回通道内的值</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> c &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;value:%d\n&quot;</span>, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="switch-case">switch case</h2><p>使用 <code>switch</code> 语句可方便地对大量的值进行条件判断。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sex := <span class="string">&quot;男&quot;</span></span><br><span class="line"><span class="keyword">switch</span> sex &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;男&quot;</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;男性&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;女&quot;</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;女性&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;无效的输入！&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go语言规定每个<code>switch</code>只能有一个<code>default</code>分支。</p><p>一个分支可以有多个值，多个case值中间使用英文逗号分隔。比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> n := <span class="number">7</span>; n &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;奇数&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;偶数&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分支还可以使用表达式，这时候switch语句后面不需要再跟判断变量。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">age := <span class="number">30</span></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> age &lt; <span class="number">25</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;好好学习吧&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> age &gt; <span class="number">25</span> &amp;&amp; age &lt; <span class="number">35</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;好好工作吧&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> age &gt; <span class="number">60</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;好好享受吧&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;活着真好&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>fallthrough</code>语法可以执行满足条件的case的下一个case，是为了兼容C语言中的case设计的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> s == <span class="string">&quot;a&quot;</span>:</span><br><span class="line"><span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> s == <span class="string">&quot;b&quot;</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;b&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> s == <span class="string">&quot;c&quot;</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;c&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;...&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b</span><br></pre></td></tr></table></figure><h2 id="goto">goto</h2><p><code>goto</code>  语句通过标签进行代码间的无条件跳转。C#中也有只是不推荐使用，只在特定场景下才考虑使用。因为goto可以无条件地转移到过程中指定的行会造成程序流程的混乱，使理解和调试程序都产生困难。Go语言中使用  <code>goto</code> 语句能简化一些代码的实现过程。 例如双层嵌套的for循环要退出时：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例一：内层循环打印到2时结束，外层循环也随即结束</span></span><br><span class="line"><span class="keyword">var</span> breakFlag <span class="keyword">bool</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> j == <span class="number">2</span> &#123;</span><br><span class="line"><span class="comment">// 设置退出标签</span></span><br><span class="line">breakFlag = <span class="literal">true</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v-%v\n&quot;</span>, i, j)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 外层for循环判断</span></span><br><span class="line"><span class="keyword">if</span> breakFlag &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>goto</code> 简化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> j == <span class="number">2</span> &#123;</span><br><span class="line"><span class="comment">// 设置退出标签</span></span><br><span class="line"><span class="keyword">goto</span> breakTag</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v-%v\n&quot;</span>, i, j)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="comment">// 标签</span></span><br><span class="line">breakTag:</span><br><span class="line">fmt.Println(<span class="string">&quot;结束for循环&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="break">break</h2><p><code>break</code> 语句可以结束 <code>for</code> 、 <code>switch</code> 和 <code>select</code> 的代码块。<code>break</code>语句还可以在语句后面添加标签，如果加了标签就会跳出标签对应的for循环，标签要求必须定义在对应的 <code>for</code>、 <code>switch</code> 和  <code>select </code>的代码块上。 例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">breakTest</span><span class="params">()</span></span> &#123;</span><br><span class="line">BREAKDEMO1:</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> j == <span class="number">2</span> &#123;</span><br><span class="line"><span class="keyword">break</span> BREAKDEMO1 <span class="comment">// 如果加了标签就会跳出标签对应的for循环</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v-%v\n&quot;</span>, i, j)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="continue">continue</h2><p><code>continue </code>语句可以结束当前循环，开始下一次的循环迭代过程，仅限在<code>for</code>循环内使用。在 <code>continue</code>语句后添加标签时，表示开始标签对应的循环。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processControlContinue</span><span class="params">()</span></span> &#123;</span><br><span class="line">forloop1:</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line"><span class="comment">// forloop2:</span></span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">5</span>; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> i == <span class="number">2</span> &amp;&amp; j == <span class="number">2</span> &#123;</span><br><span class="line"><span class="keyword">continue</span> forloop1</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v-%v\n&quot;</span>, i, j)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> i == <span class="number">2</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="运算符">运算符</h1><p>运算符用于在程序运行时执行数学或逻辑运算，Go 语言内置的运算符有：</p><ul><li>算术运算符</li><li>关系运算符</li><li>逻辑运算符</li><li>位运算符</li><li>赋值运算符</li></ul><h2 id="算术运算符">算术运算符</h2><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">+</td><td style="text-align:center">相加</td></tr><tr><td style="text-align:center">-</td><td style="text-align:center">相减</td></tr><tr><td style="text-align:center">*</td><td style="text-align:center">相乘</td></tr><tr><td style="text-align:center">/</td><td style="text-align:center">相除</td></tr><tr><td style="text-align:center">%</td><td style="text-align:center">求余</td></tr></tbody></table><p><strong>注意：</strong> <code>++</code>（自增）和<code>--</code>（自减）在Go语言中是单独的语句，并不是运算符。</p><h2 id="关系运算符">关系运算符</h2><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">==</td><td style="text-align:center">检查两个值是否相等，如果相等返回 True 否则返回 False。</td></tr><tr><td style="text-align:center">!=</td><td style="text-align:center">检查两个值是否不相等，如果不相等返回 True 否则返回 False。</td></tr><tr><td style="text-align:center">&gt;</td><td style="text-align:center">检查左边值是否大于右边值，如果是返回 True 否则返回 False。</td></tr><tr><td style="text-align:center">&gt;=</td><td style="text-align:center">检查左边值是否大于等于右边值，如果是返回 True 否则返回 False。</td></tr><tr><td style="text-align:center">&lt;</td><td style="text-align:center">检查左边值是否小于右边值，如果是返回 True 否则返回 False。</td></tr><tr><td style="text-align:center">&lt;=</td><td style="text-align:center">检查左边值是否小于等于右边值，如果是返回 True 否则返回 False。</td></tr></tbody></table><h2 id="逻辑运算符">逻辑运算符</h2><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">&amp;&amp;</td><td style="text-align:center">逻辑 AND 运算符。 如果两边的操作数都是 True，则为 True，否则为 False。</td></tr><tr><td style="text-align:center">||</td><td style="text-align:center">逻辑 OR 运算符。 如果两边的操作数有一个 True，则为 True，否则为 False。</td></tr><tr><td style="text-align:center">!</td><td style="text-align:center">逻辑 NOT 运算符。 如果条件为 True，则为 False，否则为 True。</td></tr></tbody></table><h2 id="位运算符">位运算符</h2><p>位运算符对整数在内存中的二进制位进行操作。</p><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">&amp;</td><td style="text-align:center">参与运算的两数各对应的二进位相与。 （两位均为1才为1）</td></tr><tr><td style="text-align:center">|</td><td style="text-align:center">参与运算的两数各对应的二进位相或。 （两位有一个为1就为1）</td></tr><tr><td style="text-align:center">^</td><td style="text-align:center">参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。 （两位不一样则为1）</td></tr><tr><td style="text-align:center">&lt;&lt;</td><td style="text-align:center">左移n位就是乘以2的n次方。 “a&lt;&lt;b”是把a的各二进位全部左移b位，高位丢弃，低位补0。</td></tr><tr><td style="text-align:center">&gt;&gt;</td><td style="text-align:center">右移n位就是除以2的n次方。 “a&gt;&gt;b”是把a的各二进位全部右移b位。</td></tr></tbody></table><h2 id="赋值运算符">赋值运算符</h2><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">=</td><td style="text-align:center">简单的赋值运算符，将一个表达式的值赋给一个左值</td></tr><tr><td style="text-align:center">+=</td><td style="text-align:center">相加后再赋值</td></tr><tr><td style="text-align:center">-=</td><td style="text-align:center">相减后再赋值</td></tr><tr><td style="text-align:center">*=</td><td style="text-align:center">相乘后再赋值</td></tr><tr><td style="text-align:center">/=</td><td style="text-align:center">相除后再赋值</td></tr><tr><td style="text-align:center">%=</td><td style="text-align:center">求余后再赋值</td></tr><tr><td style="text-align:center">&lt;&lt;=</td><td style="text-align:center">左移后赋值</td></tr><tr><td style="text-align:center">&gt;&gt;=</td><td style="text-align:center">右移后赋值</td></tr><tr><td style="text-align:center">&amp;=</td><td style="text-align:center">按位与后赋值</td></tr><tr><td style="text-align:center">|=</td><td style="text-align:center">按位或后赋值</td></tr><tr><td style="text-align:center">^=</td><td style="text-align:center">按位异或后赋值</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/go/03%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/go/03%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="布尔类型">布尔类型</h1><p>Go语言中的布尔类型与其他语言基本一致，关键字也为 <code>bool</code> 。布尔型数据只有 <code>true</code> / <code>false</code> 两个值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a1 = <span class="literal">false</span></span><br><span class="line"><span class="keyword">var</span> a2 = <span class="literal">true</span></span><br><span class="line">fmt.Println(a1, a2)</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li>布尔类型变量的默认值为 <code>false</code></li><li>Go 语言中不允许将整型强制转换为布尔型</li><li>布尔型无法参与数值运算，也无法与其他类型进行转换</li></ol><h1 id="复数">复数</h1><p>复数有实部和虚部，<code>complex64</code> 的实部和虚部为32位，<code>complex128</code> 的实部和虚部为64位，用的比较少不做详细记录。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c1 <span class="keyword">complex64</span></span><br><span class="line">c1 = <span class="number">1</span> + <span class="number">2i</span></span><br><span class="line"><span class="keyword">var</span> c2 <span class="keyword">complex128</span></span><br><span class="line">c2 = <span class="number">2</span> + <span class="number">3i</span></span><br><span class="line">fmt.Println(c1)</span><br><span class="line">fmt.Println(c2)</span><br></pre></td></tr></table></figure><h1 id="整型-v2">整型</h1><p>整型分为以下两个大类：有符号整形按长度分为：<code>int8</code>、<code>int16</code>、<code>int32</code>、<code>int64</code>，对应的无符号整型：<code>uint8</code>、<code>uint16</code>、<code>uint32</code>、<code>uint64</code></p><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:left">范围</th><th style="text-align:center">占用空间(字节)</th></tr></thead><tbody><tr><td style="text-align:center"><code>int8</code></td><td style="text-align:left">(-128 到 127) <code>-2^7 到 2^7-1</code></td><td style="text-align:center">1 Byte</td></tr><tr><td style="text-align:center"><code>int16</code></td><td style="text-align:left">(-32768 到 32767) <code>-2^15 到 2^15-1</code></td><td style="text-align:center">2 Byte</td></tr><tr><td style="text-align:center"><code>int32</code></td><td style="text-align:left">(-2147483648 到 2147483647) <code>-2^31 到 2^31-1</code></td><td style="text-align:center">4 Byte</td></tr><tr><td style="text-align:center"><code>int64</code></td><td style="text-align:left">(-9223372036854775808 到 9223372036854775807) <code>-2^63 到 2^63-1</code></td><td style="text-align:center">8 Byte</td></tr><tr><td style="text-align:center"><code>uint8</code></td><td style="text-align:left">(0 到 255) <code>0 到 2^8-1</code></td><td style="text-align:center">1 Byte</td></tr><tr><td style="text-align:center"><code>uint16</code></td><td style="text-align:left">(0 到 65535)<code> 0 到 2^16-1</code></td><td style="text-align:center">2 Byte</td></tr><tr><td style="text-align:center"><code>uint32</code></td><td style="text-align:left">(0 到 4294967295) <code>0 到 2^32-1</code></td><td style="text-align:center">4 Byte</td></tr><tr><td style="text-align:center"><code>uint64</code></td><td style="text-align:left">(0 到 18446744073709551615) <code>0 到 2^64-1</code></td><td style="text-align:center">8 Byte</td></tr></tbody></table><h2 id="特殊整型">特殊整型</h2><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>uint</code></td><td style="text-align:left">32 位操作系统上就是 <code>uint32</code>，64 位操作系统上就是 <code>uint64</code></td></tr><tr><td style="text-align:center"><code>int</code></td><td style="text-align:left">32 位操作系统上就是 <code>int32</code>，64 位操作系统上就是 <code>int64</code></td></tr><tr><td style="text-align:center"><code>uintptr</code></td><td style="text-align:left">无符号整型，用于存放一个指针</td></tr></tbody></table><p><strong>注意</strong>： 在使用 <code>int</code> 和 <code>uint</code> 类型时，不能假定它是 32 位或 64 位的整型，而是考虑 <code>int</code> 和 <code>uint</code> 可能在不同平台上的差异</p><h2 id="字节-Byte">字节(Byte)</h2><p>字节也叫 <code>Byte</code>，是计算机数据的基本存储单位。1Byte(字节)=8bit(位) 1024Byte(字节)=1KB。中文字符在 <code>unicode</code> 下占2个字节，在 <code>utf-8</code> 编码下占3个字节，go 默认编码是 <code>utf-8</code>。</p><p><code>unsafe.Sizeof(n1)</code> 是 <code>unsafe</code>包的一个函数，可以返回变量占用的字节数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main </span><br><span class="line"><span class="keyword">import</span> ( </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span> </span><br><span class="line">    <span class="string">&quot;unsafe&quot;</span> </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; </span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">int8</span> = <span class="number">120</span> </span><br><span class="line">    fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, a) </span><br><span class="line">    fmt.Println(unsafe.Sizeof(a)) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PS D:\GoProject&gt; go run .\test.go</span><br><span class="line">int8</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="数字字面量语法">数字字面量语法</h2><p>Go1.13 版本之后引入了数字字面量语法，便于以二进制、八进制或十六进制浮点数的格式定义数字，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numberLiteralsSyntax</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 代表二进制的 101101，相当于十进制的 45</span></span><br><span class="line">v1 := <span class="number">0</span>b00101101</span><br><span class="line">fmt.Printf(<span class="string">&quot;value:%v type:%T \n&quot;</span>, v1, v1)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代表八进制的377，相当于十进制的 255</span></span><br><span class="line">v2 := <span class="number">0</span>o377</span><br><span class="line">fmt.Printf(<span class="string">&quot;value:%v type:%T \n&quot;</span>, v2, v2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代表十六进制的 1 除以 2²，也就是 0.25</span></span><br><span class="line">v3 := <span class="number">0x1</span>p<span class="number">-2</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;value:%v type:%T \n&quot;</span>, v3, v3)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用“_”分隔数字</span></span><br><span class="line">v4 := <span class="number">123</span>_456</span><br><span class="line">fmt.Printf(<span class="string">&quot;value:%v type:%T \n&quot;</span>, v4, v4)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>借助 <code>fmt</code> 函数以不同进制形式显示整数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convertOutput</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 十进制</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;十进制:%d 二进制:%b \n&quot;</span>, a, a) <span class="comment">// %d表示十进制,%b表示二进制</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 八进制以0开头</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">int</span> = <span class="number">077</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;八进制:%o 二进制:%d\n&quot;</span>, b, b) <span class="comment">// %o表示八进制,%d表示十进制</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 十六进制 以 0x 开头</span></span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">int</span> = <span class="number">0xff</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;十六进制:%x 十六进制大写:%X 十进制:%d 变量类型:%T \n&quot;</span>, c, c, c, c) <span class="comment">//%x 表示十六进制,%X 表示大写的十六进制,%d 表示十进制,%T 查看变量类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// int不同长度转换</span></span><br><span class="line"><span class="keyword">var</span> num1 <span class="keyword">int8</span> = <span class="number">127</span></span><br><span class="line">num2 := <span class="keyword">int32</span>(num1)</span><br><span class="line">fmt.Printf(<span class="string">&quot;value:%v type:%T \n&quot;</span>, num2, num2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不同长度转换">不同长度转换</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main </span><br><span class="line"><span class="keyword">import</span> ( </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span> </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; </span><br><span class="line">    <span class="keyword">var</span> num1 <span class="keyword">int8</span> </span><br><span class="line">    num1 = <span class="number">127</span> </span><br><span class="line">    num2 := <span class="keyword">int32</span>(num1) </span><br><span class="line">    fmt.Printf(<span class="string">&quot;值:%v 类型%T&quot;</span>, num2, num2) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="浮点型">浮点型</h1><p>Go 语言支持两种浮点型数：<code>float32</code> 和 <code>float64</code>。</p><p>这两种浮点型数据格式遵循 <code>IEEE 754</code> 标准</p><ul><li><code>float32</code> 最大范围约为 <code>3.4e38</code>，可以使用常量定义：<code>math.MaxFloat32</code></li><li><code>float64</code> 最大范围约为 <code>1.8e308</code>，可以使用常量定义：<code>math.MaxFloat64</code></li></ul><p>打印浮点数时可以使用 <code>fmt</code> 包配合动词 <code>%f</code>，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f <span class="keyword">float64</span> = <span class="number">3.1415926</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%f\n&quot;</span>, f)             <span class="comment">// 默认保留6位小数</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%.2f\n&quot;</span>, f)           <span class="comment">// 保留2位小数</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;值:%v,类型:%T \n&quot;</span>, f, f) <span class="comment">// 浮点数默认类型是float64</span></span><br><span class="line"></span><br><span class="line">fmt.Println(math.MaxFloat32) <span class="comment">// 输出float32最大值</span></span><br><span class="line">fmt.Println(math.MaxFloat64) <span class="comment">// 输出float64最大值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 科学计数法表示浮点类型</span></span><br><span class="line">n1 := <span class="number">5.1234e2</span></span><br><span class="line">n2 := <span class="number">5.1234e2</span></span><br><span class="line">n3 := <span class="number">5.1234e-2</span></span><br><span class="line">fmt.Println(<span class="string">&quot;n1=&quot;</span>, n1, <span class="string">&quot;n2=&quot;</span>, n2, <span class="string">&quot;n3=&quot;</span>, n3)</span><br></pre></td></tr></table></figure><h2 id="精度丢失问题">精度丢失问题</h2><p>精度丢失是几乎所有的编程语言都有的问题，是典型的二进制浮点数精度损失问题。在定长条件下，二进制小数和十进制小数互转可能有精度丢失，Go也不例外，观察以下代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">floatPrecisionLossTest</span><span class="params">()</span></span> &#123;</span><br><span class="line">d := <span class="number">1129.6</span></span><br><span class="line">fmt.Println(d * <span class="number">100</span>) <span class="comment">// 此处结果应该是：112960，实际打印的却是：112959.99999999999</span></span><br><span class="line"></span><br><span class="line">m1 := <span class="number">8.2</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;值:%v--类型:%T \n&quot;</span>, m1, m1)</span><br><span class="line">m2 := <span class="number">3.8</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;值:%v--类型:%T \n&quot;</span>, m2, m2)</span><br><span class="line">fmt.Println(m1 - m2) <span class="comment">// 此处结果应该是：4.4，实际打印：4.3999999999999995</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解决精度丢失问题">解决精度丢失问题</h2><p>使用第三方包需要使用 <code>go mod </code>，关于 <code>go mod</code> 参考之前的章节。引入第三方包解决经度丢失问题：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PS D:\GoProject\src&gt; go get github.com/shopspring/decimal</span><br><span class="line">go: downloading github.com/shopspring/decimal v1.3.1</span><br><span class="line">go get: added github.com/shopspring/decimal v1.3.1</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;github.com/shopspring/decimal&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用第三方包解决float精度丢失问题：go get github.com/shopspring/decimal</span></span><br><span class="line"><span class="comment">文档：https://pkg.go.dev/github.com/shopspring/decimal#section-readme</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">floatPrecisionLossSolveTest</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := decimal.NewFromFloat(<span class="number">1129.6</span>)</span><br><span class="line">b := decimal.NewFromInt(<span class="number">100</span>)</span><br><span class="line">fmt.Println(a.Mul(b)) <span class="comment">// output:112960</span></span><br><span class="line"></span><br><span class="line">c := decimal.NewFromFloat(<span class="number">8.2</span>)</span><br><span class="line">d := decimal.NewFromFloat(<span class="number">3.8</span>)</span><br><span class="line">fmt.Println(c.Sub(d)) <span class="comment">// output:4.4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个变量</span></span><br><span class="line">d0 := decimal.NewFromFloat(<span class="number">0</span>)</span><br><span class="line"><span class="comment">// 设置精度 为三位 四舍五入的精度</span></span><br><span class="line">decimal.DivisionPrecision = <span class="number">3</span></span><br><span class="line">fmt.Println(d0)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加法 Add</span></span><br><span class="line"><span class="keyword">var</span> f1 <span class="keyword">float64</span> = <span class="number">2.1</span></span><br><span class="line"><span class="keyword">var</span> i1 <span class="keyword">int</span> = <span class="number">3</span></span><br><span class="line">fmt.Println(decimal.NewFromFloat(f1).Add(decimal.NewFromFloat(<span class="keyword">float64</span>(i1)))) <span class="comment">// 2.1 + 3: float和int相加=&gt;output: &quot;5.1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f2 <span class="keyword">float64</span> = <span class="number">2.1</span></span><br><span class="line"><span class="keyword">var</span> f3 <span class="keyword">float64</span> = <span class="number">3.1</span></span><br><span class="line">fmt.Println(decimal.NewFromFloat(f2).Add(decimal.NewFromFloat(f3))) <span class="comment">// 2.1 + 3.1 (float和float相加)=&gt;output: &quot;5.2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f4 <span class="keyword">float64</span> = <span class="number">2</span></span><br><span class="line"><span class="keyword">var</span> f5 <span class="keyword">float64</span> = <span class="number">3</span></span><br><span class="line">fmt.Println(decimal.NewFromFloat(f4).Add(decimal.NewFromFloat(f5))) <span class="comment">// 2 + 3 (int和int相加 可以直接相加 d1 = num1+num2)=&gt; output: &quot;5&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 减法 Sub</span></span><br><span class="line"><span class="keyword">var</span> f7 <span class="keyword">float64</span> = <span class="number">3.1</span></span><br><span class="line"><span class="keyword">var</span> f8 <span class="keyword">int</span> = <span class="number">2</span></span><br><span class="line">d1 := decimal.NewFromFloat(f7).Sub(decimal.NewFromFloat(<span class="keyword">float64</span>(f8))) <span class="comment">// 3.1 - 2 float和int相减 =&gt; output: &quot;1.1&quot;</span></span><br><span class="line">fmt.Println(d1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> n1 <span class="keyword">float64</span> = <span class="number">2.1</span></span><br><span class="line"><span class="keyword">var</span> n2 <span class="keyword">float64</span> = <span class="number">3.1</span></span><br><span class="line">fmt.Println(decimal.NewFromFloat(n1).Sub(decimal.NewFromFloat(n2))) <span class="comment">// 2.1 - 3.1 (float和float相减)=&gt;output: &quot;-1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> n3 <span class="keyword">int</span> = <span class="number">2</span></span><br><span class="line"><span class="keyword">var</span> n4 <span class="keyword">int</span> = <span class="number">3</span></span><br><span class="line">fmt.Println(decimal.NewFromFloat(<span class="keyword">float64</span>(n3)).Sub(decimal.NewFromFloat(<span class="keyword">float64</span>(n4)))) <span class="comment">// 2 - 3 (int和int相减 d1 = num1 - num2) =&gt; output: &quot;-1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 乘法 Mul</span></span><br><span class="line"><span class="keyword">var</span> n5 <span class="keyword">float64</span> = <span class="number">3.1</span></span><br><span class="line"><span class="keyword">var</span> n6 <span class="keyword">int</span> = <span class="number">2</span></span><br><span class="line">fmt.Println(decimal.NewFromFloat(n5).Mul(decimal.NewFromFloat(<span class="keyword">float64</span>(n6)))) <span class="comment">// 3.1 * 2 float和int相乘 =&gt; output: &quot;6.2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> n7 <span class="keyword">float64</span> = <span class="number">2.1</span></span><br><span class="line"><span class="keyword">var</span> n8 <span class="keyword">float64</span> = <span class="number">3.1</span></span><br><span class="line">fmt.Println(decimal.NewFromFloat(n7).Mul(decimal.NewFromFloat(n8))) <span class="comment">// 2.1 * 3.1 (float和float相乘) =&gt; output: &quot;6.51&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> n9 <span class="keyword">int</span> = <span class="number">2</span></span><br><span class="line"><span class="keyword">var</span> n10 <span class="keyword">int</span> = <span class="number">3</span></span><br><span class="line">fmt.Println(decimal.NewFromFloat(<span class="keyword">float64</span>(n9)).Mul(decimal.NewFromFloat(<span class="keyword">float64</span>(n10)))) <span class="comment">// 2 * 3 int和int相乘(d1 = num1 * num2) =&gt;  output: &quot;6&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 除法 Div</span></span><br><span class="line"><span class="keyword">var</span> n11 <span class="keyword">int</span> = <span class="number">2</span></span><br><span class="line"><span class="keyword">var</span> n12 <span class="keyword">int</span> = <span class="number">3</span></span><br><span class="line">fmt.Println(decimal.NewFromFloat(<span class="keyword">float64</span>(n11)).Div(decimal.NewFromFloat(<span class="keyword">float64</span>(n12)))) <span class="comment">// 2 / 3 = 0.6666666666666667  =&gt;  output: &quot;0.6666666666666667&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// float64 和 int 相除</span></span><br><span class="line"><span class="keyword">var</span> num13 <span class="keyword">float64</span> = <span class="number">2.1</span></span><br><span class="line"><span class="keyword">var</span> num14 <span class="keyword">int</span> = <span class="number">3</span></span><br><span class="line">fmt.Println(decimal.NewFromFloat(num13).Div(decimal.NewFromFloat(<span class="keyword">float64</span>(num14)))) <span class="comment">// output: &quot;0.7&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// float64 和 float64 相除</span></span><br><span class="line"><span class="keyword">var</span> num15 <span class="keyword">float64</span> = <span class="number">2.1</span></span><br><span class="line"><span class="keyword">var</span> num16 <span class="keyword">float64</span> = <span class="number">0.3</span></span><br><span class="line">fmt.Println(decimal.NewFromFloat(num15).Div(decimal.NewFromFloat(num16))) <span class="comment">// output: &quot;7&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// int 和 int 相除 并保持3位精度</span></span><br><span class="line"><span class="keyword">var</span> num17 <span class="keyword">int</span> = <span class="number">2</span></span><br><span class="line"><span class="keyword">var</span> num18 <span class="keyword">int</span> = <span class="number">3</span></span><br><span class="line">decimal.DivisionPrecision = <span class="number">3</span></span><br><span class="line">result := decimal.NewFromFloat(<span class="keyword">float64</span>(num17)).Div(decimal.NewFromFloat(<span class="keyword">float64</span>(num18))) <span class="comment">// 2/3 = 0.667 =&gt;  output: &quot;0.667&quot;</span></span><br><span class="line">fmt.Println(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="科学计数法表示">科学计数法表示</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n1 := <span class="number">5.1234e2</span></span><br><span class="line">n2 := <span class="number">5.1234e2</span></span><br><span class="line">n3 := <span class="number">5.1234e-2</span></span><br><span class="line">fmt.Println(<span class="string">&quot;n1=&quot;</span>, n1, <span class="string">&quot;n2=&quot;</span>, n2, <span class="string">&quot;n3=&quot;</span>, n3)</span><br></pre></td></tr></table></figure><h1 id="字符串">字符串</h1><p>Go 语言中，一个字符串是一个不可改变的字节序列。字符串可以包含任意的数据，包括byte值0，但是通常用来保存人类可读的文本。</p><p>Go的字符串是由 <code>Utf-8</code> 编码之后的字节序列，所以不能修改。</p><ul><li>1个汉字占用3个字节</li><li>1个英文字母占用1个字节</li></ul><p>Go使用 <code>rune</code>（1个int32类型的数字） 表示中文字符，使用 <code>byte</code>（1个uint8类型的数字）表示英文。Go语言中组成字符串的最小单位是字符，存储的最小单位是字节，字符串本身不支持修改。字节是数据存储的最小单元，每个字节的数据都可以用整数表示，例如一个字节储存的字符 <code>a</code>，实际存储的是 <code>97</code> 而非字符的字形，将这个实际存储的内容用数字表示的类型，称之为 <code>byte</code>。</p><h2 id="len">len</h2><p>内置的 <code>len</code> 函数用于返回一个字符串中的字节数目（不是 <code>rune</code> 字符数目），索引操作 <code>s[i]</code> 返回第 <code>i</code> 个字节的字节值，<code>i</code> 必须满足 <code>0 ≤ i&lt; len(s)</code> 条件约束。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">&quot;hello, world&quot;</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s))     <span class="comment">// &quot;12&quot;</span></span><br><span class="line">fmt.Println(s[<span class="number">0</span>], s[<span class="number">7</span>]) <span class="comment">// &quot;104 119&quot; (&#x27;h&#x27; and &#x27;w&#x27;)</span></span><br></pre></td></tr></table></figure><p>如果试图访问超出字符串索引范围的字节将会导致 <code>panic</code> 异常：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c := s[<span class="built_in">len</span>(s)] <span class="comment">// panic: index out of range</span></span><br></pre></td></tr></table></figure><p>第 <code>i</code> 个字节并不一定是字符串的第 <code>i</code> 个字符，因为对于非 <code>ASCII</code> 字符的 <code>UTF8</code> 编码会要两个或多个字节。</p><p>比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">&quot;abc北京&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;字节长度：%d \n&quot;</span>, <span class="built_in">len</span>(s)) <span class="comment">//output:9</span></span><br><span class="line"><span class="comment">// 返回字符串每个字节的值</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">fmt.Println(s[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">字节长度：9 </span><br><span class="line">97        // a  </span><br><span class="line">98        // b</span><br><span class="line">99        // c  </span><br><span class="line">229       // 北  </span><br><span class="line">140       // 北  </span><br><span class="line">151       // 北</span><br><span class="line">228       // 京 </span><br><span class="line">186       // 京</span><br><span class="line">172       // 京</span><br></pre></td></tr></table></figure><p>英文字母占用一个字节：<code>97：a</code>/<code>98：b</code>/<code>99：c</code>，汉字占用三个字节：<code>229/140/151</code>组成<code>北</code>，<code>228/186/172</code>组成<code>京</code></p><p>如果要获取字符串中字符的个数，需要先把字符串转换成 <code>[]rune</code> 类型，然后用 <code>len()</code> 函数获取字符个数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r := []<span class="keyword">rune</span>(s)</span><br><span class="line">fmt.Print(<span class="built_in">len</span>(r)) <span class="comment">// output:5</span></span><br></pre></td></tr></table></figure><h2 id="字符串不可变性">字符串不可变性</h2><p>字符串的值是不可变的：一个字符串包含的字节序列永远不会被改变，当然也可以给一个字符串变量分配一个新字符串值。可以像下面这样将一个字符串追加到另一个字符串：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">&quot;left foot&quot;</span></span><br><span class="line">t := s</span><br><span class="line">s += <span class="string">&quot;, right foot&quot;</span></span><br></pre></td></tr></table></figure><p>这并不会导致原始的字符串值被改变，但是变量 <code>s</code> 将因为 <code>+=</code> 语句持有一个新的字符串值，但是 <code>t</code> 依然是包含原先的字符串值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(s) <span class="comment">// &quot;left foot, right foot&quot;</span></span><br><span class="line">fmt.Println(t) <span class="comment">// &quot;left foot&quot;</span></span><br></pre></td></tr></table></figure><p>因为字符串是不可修改的，因此尝试修改字符串内部数据的操作也是被禁止的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s[<span class="number">0</span>] = <span class="string">&#x27;L&#x27;</span> <span class="comment">// compile error: cannot assign to s[0]</span></span><br></pre></td></tr></table></figure><p>或者使用 <code>Sprintf</code> ：不会直接打印而是生成一个新的字符串</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = fmt.Sprintf(<span class="string">&quot;%s%s&quot;</span>, q1, q2)</span><br><span class="line">fmt.Println(result)</span><br></pre></td></tr></table></figure><h2 id="字符串字面量">字符串字面量</h2><p>Golang 支持两种类型的字符串字面量：</p><ul><li>非解释型表示法，需用用反引号&quot;`&quot;把字符序列包起来</li><li>解释型表示法，需要用双引号&quot;&quot;包裹字符序列</li></ul><p>区别在于：前者表示所见即所得的(除了回车符)。后者所表示的值中转义符会起作用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串字面量语法：可以定义一个多行字符串</span></span><br><span class="line"><span class="keyword">var</span> s1 <span class="keyword">string</span> = <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="keyword">var</span> s2 <span class="keyword">string</span> = <span class="string">`hello</span></span><br><span class="line"><span class="string">     world`</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><h2 id="字符串转义符">字符串转义符</h2><p>所谓的解释型字符串就是用双引号括起来的字符串(“”)，其中的转义字符会被替换掉，这些转义字符包括：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">\a    <span class="comment">// 响铃     </span></span><br><span class="line">\b    <span class="comment">// 退格</span></span><br><span class="line">\f    <span class="comment">// 换页</span></span><br><span class="line">\n    <span class="comment">// 换行</span></span><br><span class="line">\r    <span class="comment">// 回车</span></span><br><span class="line">\t    <span class="comment">// 制表符</span></span><br><span class="line">\u    <span class="comment">// Unicode 字符</span></span><br><span class="line">\v    <span class="comment">// 垂直制表符</span></span><br><span class="line">\<span class="string">&quot;    // 双引号</span></span><br><span class="line"><span class="string">\\    // 反斜杠</span></span><br></pre></td></tr></table></figure><h2 id="Go语言字符编码">Go语言字符编码</h2><p>Go 语言采用的字符编码方案从属于 <code>Unicode</code> 编码规范。Go 语言的代码正是由 <code>Unicode</code> 字符组成的，且源码文件必须使用 <code>UTF-8</code> 编码格式进行存储。如果源码文件中出现了非 <code>UTF-8</code> 编码的字符，那么在构建、安装以及运行的时候，go 命令会报错  <code>illegal UTF-8 encoding </code>。当一个 <code>string</code> 类型的值被转换为 <code>[]rune</code> 类型值的时候，其中的字符串会被拆分成一个个的 <code>Unicode</code> 字符。</p><h2 id="截取字符串">截取字符串</h2><p>可以通过下面的语法截取字符串中的内容：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">&quot;abcdefg&quot;</span></span><br><span class="line">t1 := str[<span class="number">1</span>:<span class="number">4</span>] <span class="comment">//startIndex=1,endIndex=4</span></span><br></pre></td></tr></table></figure><p>此时 t1 的内容为  <code>bcd</code>，该语法通过下标索引的方式截取字符串中的内容，特点是 “左含右不含”。也就是说新的子串包含源串索引为 1 的字符，而不包含源串索引为 4 的字符。</p><p>如果要从源串的开始处截取可以省略第一个索引：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t2 := str[:<span class="number">4</span>]  <span class="comment">//省略第一个索引从0开始，startIndex=0,endIndex=4</span></span><br></pre></td></tr></table></figure><blockquote><p>t2 的内容为 “abcd”。</p></blockquote><p>如果要从源串的某个位置开始一直截取到末尾，可以省略第二个索引：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t3 := str[<span class="number">1</span>:]  <span class="comment">//省略第二个索引，从1开始截取到末尾</span></span><br></pre></td></tr></table></figure><blockquote><p>t3 的内容为 “cdef”</p></blockquote><p>访问越界问题：如果试图访问超出字符串索引范围的字节将会在运行时导致 panic 异常：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t4 := str[:<span class="number">10</span>]</span><br></pre></td></tr></table></figure><blockquote><p>runtime error: slice bounds out of range [:10] with length 7 数组越界</p></blockquote><h2 id="遍历字符串">遍历字符串</h2><p>可以通过下标索引字符串中的字节，所以可以用这种方式遍历字符串：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p := <span class="string">&quot;abc你好&quot;</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(p); i++ &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%c&quot;</span>, p[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abcä% å¥%</span><br></pre></td></tr></table></figure><p>可见在字符串中含有非单字节的字符时这种方法是不正确的。<code>range</code> 函数解决这个问题：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%c&quot;</span>, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abc你好</span><br></pre></td></tr></table></figure><blockquote><p>带有 range 子句的 for 语句会先把被遍历的字符串值拆成一个字节序列，然后再试图找出这个字节序列中包含的每一个 UTF-8 编码值，或者说每一个 Unicode 字符。因此在 range for 语句中，赋给第二个变量的值是UTF-8 编码值代表的那个 Unicode 字符，类型是 rune</p></blockquote><h2 id="字符串分割">字符串分割</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">url := <span class="string">&quot;www.baidu.com&quot;</span></span><br><span class="line">strArray := strings.Split(url, <span class="string">&quot;.&quot;</span>)</span><br><span class="line">fmt.Println(strArray)</span><br></pre></td></tr></table></figure><h2 id="字符串-Join">字符串 Join</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(strings.Join(strArray, <span class="string">&quot;.&quot;</span>))</span><br></pre></td></tr></table></figure><h2 id="前缀判断">前缀判断</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(strings.HasPrefix(url, <span class="string">&quot;www&quot;</span>))</span><br></pre></td></tr></table></figure><h2 id="后缀判断">后缀判断</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(strings.HasSuffix(url, <span class="string">&quot;com&quot;</span>))</span><br></pre></td></tr></table></figure><h2 id="修改字符串">修改字符串</h2><p>Golang 中不能修改字符串的内容，就是说不能通过 <code>s[i]</code> 这种方式修改字符串中的字符。要修改字符串的内容，可以先将字符串的内容复制到一个可写的变量中，一般是 <code>[]byte</code> 或 <code>[]rune</code> 类型的变量，然后再进行修改。</p><p><strong>注意</strong>：如果要对字符串中的字节进行修改，就转换为 <code>[]byte</code> 类型，如果要对字符串中的字符修改，就转换为 <code>[]rune</code> 类型，转换类型的过程中会自动复制数据</p><p><strong>修改字符串中的字节(<code>[]byte</code>)</strong><br>对于单字节字符来说可以用这种方式进行修改：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ss := <span class="string">&quot;hello world&quot;</span></span><br><span class="line">value := []<span class="keyword">byte</span>(ss) <span class="comment">// 转换为[]byte</span></span><br><span class="line">value[<span class="number">5</span>] = <span class="string">&#x27;,&#x27;</span>      <span class="comment">// 将空格替换为“,”</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, ss)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, value)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello world</span><br><span class="line">hello,world</span><br></pre></td></tr></table></figure><p><strong>修改字符串中的字符(<code>[]rune</code>)</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sss := <span class="string">&quot;一梦三两年&quot;</span></span><br><span class="line">value2 := []<span class="keyword">rune</span>(sss) <span class="comment">// 转换为[]rune</span></span><br><span class="line">value2[<span class="number">2</span>] = <span class="string">&#x27;四&#x27;</span></span><br><span class="line">value2[<span class="number">3</span>] = <span class="string">&#x27;五&#x27;</span></span><br><span class="line">fmt.Println(sss)</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(value2))</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">一梦三两年</span><br><span class="line">一梦四五年</span><br></pre></td></tr></table></figure><blockquote><p>注意：string 类型的 0 值是长度为 0 的字符串，即空字符串 “”</p></blockquote><h2 id="strconv-包">strconv 包</h2><p>除了字符串、字符、字节之间的转换，字符串和数值之间的转换也比较常见。由 <code>strconv</code> 包提供这类转换功能。</p><p>将一个整数转为字符串，一种方法是用 <code>fmt.Sprintf</code> 返回一个格式化的字符串；另一个方法是用<code>strconv.Itoa()</code> ：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x := <span class="number">123</span></span><br><span class="line">y := fmt.Sprintf(<span class="string">&quot;%d&quot;</span>, x)</span><br><span class="line">fmt.Println(y, strconv.Itoa(x)) <span class="comment">// &quot;123 123&quot; “整数到ASCII”</span></span><br></pre></td></tr></table></figure><p><code>FormatInt</code> 和 <code>FormatUint</code> 函数可以用不同的进制来格式化数字：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(strconv.FormatInt(<span class="keyword">int64</span>(x), <span class="number">2</span>)) <span class="comment">// &quot;1111011&quot;</span></span><br></pre></td></tr></table></figure><p><code>fmt.Printf</code> 函数的 <code>%b</code> 、<code>%d</code>、<code>%o</code> 和<code>%x</code> 等参数提供功能往往比 <code>strconv</code> 包的 <code>Format</code> 函数方便很多，特别是在需要包含有附加额外信息的时候：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := fmt.Sprintf(<span class="string">&quot;x=%b&quot;</span>, x) <span class="comment">// &quot;x=1111011&quot;</span></span><br></pre></td></tr></table></figure><p>如果要将一个字符串解析为整数，可以使用 <code>strconv</code> 包的<code>Atoi</code>或<code>ParseInt</code>函数，还有用于解析无符号整数的<code>ParseUint</code> 函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x, err := strconv.Atoi(<span class="string">&quot;123&quot;</span>)             <span class="comment">// x is an int</span></span><br><span class="line">y, err := strconv.ParseInt(<span class="string">&quot;123&quot;</span>, <span class="number">10</span>, <span class="number">64</span>) <span class="comment">// base 10, up to 64 bits</span></span><br></pre></td></tr></table></figure><p><code>ParseInt</code> 函数的第三个参数是用于指定整型数的大小；例如16表示int16，0则表示int。在任何情况下，返回的结果y总是int64类型，可以通过强制类型转换将它转为更小的整数类型。</p><p>有时候也会使用 <code>fmt.Scanf</code> 来解析输入的字符串和数字，特别是当字符串和数字混合在一行的时候，它可以灵活处理不完整或不规则的输入。</p><h2 id="字符类型">字符类型</h2><p>在Go语言中支持两个字符类型，一个是byte（实际上是uint8的别名），代表UTF-8字符串的单个字节的值；另一个是rune，代表单个Unicode字符。</p><p>一个 <code>string</code> 类型的值既可以被拆分为<strong>一个包含多个字符的序列</strong>，也可以被拆分为<strong>一个包含多个字节的序列</strong>。</p><ul><li>前者由以 <code>rune</code> 为元素类型的切片表示</li><li>后者由以 <code>byte</code> 为元素类型的切片代表</li></ul><blockquote><p><code>rune</code> 是Go语言特有的一个基本数据类型，它的一个值就代表一个字符，即：一个Unicode 字符(就是一个中文字符，占3个字节)</p></blockquote><p>看以下代码:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">&quot;helloworld 世界你好&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;string:%q\n&quot;</span>, s)              <span class="comment">// 原文格式输出</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;rune(char):%q\n&quot;</span>, []<span class="keyword">rune</span>(s))  <span class="comment">// 输出[]rune切片</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;rune(hex):%x\n&quot;</span>, []<span class="keyword">rune</span>(s))   <span class="comment">// 采用16进制数表示</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;bytes(hex):% x\n&quot;</span>, []<span class="keyword">byte</span>(s)) <span class="comment">// 输出[]byte切片</span></span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string:&quot;helloworld 世界你好&quot;</span><br><span class="line">rune(char):[&#x27;h&#x27; &#x27;e&#x27; &#x27;l&#x27; &#x27;l&#x27; &#x27;o&#x27; &#x27;w&#x27; &#x27;o&#x27; &#x27;r&#x27; &#x27;l&#x27; &#x27;d&#x27; &#x27; &#x27; &#x27;世&#x27; &#x27;界&#x27; &#x27;你&#x27; &#x27;好&#x27;]</span><br><span class="line">rune(hex):[68 65 6c 6c 6f 77 6f 72 6c 64 20 4e16 754c 4f60 597d]</span><br><span class="line">bytes(hex):68 65 6c 6c 6f 77 6f 72 6c 64 20 e4 b8 96 e7 95 8c e4 bd a0 e5 a5 bd</span><br></pre></td></tr></table></figure><p>结果分析：</p><ol><li>第二行输出说明：字符串在被转换为 <code>[]rune</code> 类型的值时每个字符都会成为一个独立的 <code>rune</code> 类型的元素值。</li><li>由于每个 <code>rune</code> 底层的值都是采用 <code>UTF-8</code> 编码值来表达的，所以第三行采用 <code>16进制数</code> 来表示上述字符串，每一个16进制的字符分别表示一个字符，可以看到，当遇到中文字符时，由于底层存储需要更大的空间，所以使用的16进制数字也比较大，比如 <code>4e16</code> 和 <code>754c</code> 分别代表世和界。</li><li>如果将整个字符的 <code>UTF-8</code> 编码值都拆成字节序列时，就变成了第四行的输出，可以看到一个中文字符底层占用了三个byte，比如<code>e4 b8 96 </code>/ <code>e7 95 8c</code>分别对应UFT-8编码值的 <code>4e16</code> 和 <code>754c</code>，也就是中文字符中的世和界。</li></ol><p>总结： string 类型的值会由若干个 Unicode 字符组成，每个 Unicode 字符都可以由一个 rune 类型的值来承载。这些字符在底层都会被转换为 UTF-8 编码值，而这些 UTF-8 编码值又会以字节序列的形式表达和存储。所以：一个 string 类型的值在底层就是一个能够表达若干个 UTF-8 编码值的字节序列。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/dotnet/%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B/"/>
      <url>/dotnet/%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>并行开发要做的事情就是将任务分摊给硬件线程去并行执行来达到负载和加速，传统的代码都是串行的，就一个主线程，为了实现加速而开了很多工作线程，这些工作线程就是软件线程。</p><h1 id="Parallel">Parallel</h1><p><code>Parallel</code> 类是对线程的抽象，位于 <code>System.Threading.Tasks</code> 名称空间下,提供了 <code>任务和数据并行性</code> .在<code>Parallel</code> 下有三个常用的方法 <code>Invoke</code> 、 <code>For</code> 、<code>ForEach</code>，其中：</p><ul><li><code>Parallel</code>.<code>Invoke</code> 用于任务并行性</li><li><code>Parallel.ForEach</code>/<code>Parallel.For</code> 用于数据并行性</li></ul><h1 id="任务并行性">任务并行性</h1><h2 id="Parallel-Invoke">Parallel.Invoke</h2><p>如果多个任务应并行运行，就可以使用 <code>Parallel.Invoke()</code> 方法将串行的代码并行化。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Parallel_Example_01</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> watch = Stopwatch.StartNew();</span><br><span class="line">    watch.Start();</span><br><span class="line">    Run1();</span><br><span class="line">    Run2();</span><br><span class="line">    Run3();</span><br><span class="line">    watch.Stop();</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;串行开发,总耗时&#123;0&#125;&quot;</span>, watch.ElapsedMilliseconds);</span><br><span class="line"></span><br><span class="line">    watch.Restart();</span><br><span class="line"></span><br><span class="line">    Parallel.Invoke(Run1, Run2, Run3);</span><br><span class="line">    watch.Stop();</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;并行开发,总耗时&#123;0&#125;&quot;</span>, watch.ElapsedMilliseconds);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Run1</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Run1,我需要1s&quot;</span>);</span><br><span class="line">        Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Run2</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Run2,我需要2s&quot;</span>);</span><br><span class="line">        Thread.Sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Run3</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Run3,我需要3s&quot;</span>);</span><br><span class="line">        Thread.Sleep(<span class="number">3000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Assert.IsTrue(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/2021-09-02-22-45-44.png" alt=""><br>主程序启动时，先顺序调用<code>Run1()</code>,<code>Run()2</code>,<code>Run3()</code>方法，这是串行的。而后使用<code>Parallel.Invoke()</code>将三个方法并行调用。</p><h2 id="执行顺序">执行顺序</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Parallel_Example_02</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;主线程启动,线程ID:&#123;0&#125;&quot;</span>, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line"></span><br><span class="line">    Parallel.Invoke(</span><br><span class="line">        () =&gt; Run1(<span class="string">&quot;task1&quot;</span>),</span><br><span class="line">        () =&gt; Run2(<span class="string">&quot;task2&quot;</span>),</span><br><span class="line">        () =&gt; Run3(<span class="string">&quot;task3&quot;</span>));</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;主线程结束,线程ID:&#123;0&#125;&quot;</span>, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Run1</span>(<span class="params"><span class="built_in">string</span> taskName</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;任务名：&#123;0&#125;线程ID:&#123;1&#125;&quot;</span>, taskName, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Run2</span>(<span class="params"><span class="built_in">string</span> taskName</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;任务名：&#123;0&#125;线程ID:&#123;1&#125;&quot;</span>, taskName, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Run3</span>(<span class="params"><span class="built_in">string</span> taskName</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;任务名：&#123;0&#125;线程ID:&#123;1&#125;&quot;</span>, taskName, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Assert.IsTrue(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/2021-09-02-22-46-14.png" alt=""><br>结果可知：<br>没有固定顺序，每个<code>Task</code>可能是不同的线程去执行，也可能是相同的。主线程必须等<code>Invoke</code>中的所有方法执行完成后返回才继续向下执行。以后设计并行的时候，要考虑每个<code>Task</code>任务尽可能差不多，如果相差很大，比如一个时间非常长，其他都比较短，这样一个线程可能会影响整个任务的性能。这点非常重要(就是说<code>Invoke</code>会阻塞主线程)。</p><h1 id="数据并行性">数据并行性</h1><h2 id="Parallel-For">Parallel.For</h2><p><code>Parallel.For</code>是 <code>for</code> 的多线程实现，串行代码中也有一个<code>for</code>，但是那个<code>for</code>并没有用到多核。而<code>Paraller.For</code>它会在底层根据硬件线程的运行状况来充分的使用所有的可利用的硬件线程。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Parallel_Example_For</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ConcurrentBag&lt;<span class="built_in">int</span>&gt; bag = <span class="keyword">new</span> ConcurrentBag&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">        <span class="keyword">var</span> watch = Stopwatch.StartNew();</span><br><span class="line">        watch.Start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; <span class="number">20000000</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            bag.Add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        watch.Stop();</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;串行添加,总数20000000,耗时&#123;0&#125;&quot;</span>, watch.ElapsedMilliseconds);</span><br><span class="line">        watch.Restart();</span><br><span class="line">        Parallel.For(<span class="number">0</span>, <span class="number">20000000</span>, j =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            bag.Add(j);</span><br><span class="line">        &#125;);</span><br><span class="line">        watch.Stop();</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;并行添加,总数20000000,耗时&#123;0&#125;&quot;</span>, watch.ElapsedMilliseconds);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;***********************************&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Assert.IsTrue(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向一个线程安全的集合插入数据,使用串行的 for 耗时与使用并行的 Parallel.For 差异：<br><img src="/images/2021-09-02-22-46-43.png" alt=""></p><h2 id="Parallel-ForEach">Parallel.ForEach</h2><p><code>Parallel.ForEach</code> 是 <code>foreach</code> 的多线程实现，都能对<code>IEnumerable&lt;T&gt;</code> 类型对象进行遍历。<code>Parallel.ForEach</code>的特殊之处在于它使用多线程来执行循环体内的代码段。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Parallel_Example_ForEach</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ConcurrentBag&lt;<span class="built_in">int</span>&gt; bag = <span class="keyword">new</span> ConcurrentBag&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">    Parallel.For(<span class="number">0</span>, <span class="number">10</span>, j =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        bag.Add(j);</span><br><span class="line">    &#125;);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;集合总数:&#123;0&#125;&quot;</span>, bag.Count);</span><br><span class="line">    Parallel.ForEach(bag, item =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(item);</span><br><span class="line">    &#125;);</span><br><span class="line">    Assert.IsTrue(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="中断">中断</h1><ul><li><code>Parallel.For</code>：添加<code>ParallelLoopState</code>参数，该实例提供了<code>Break</code>和<code>Stop</code>方法来帮助实现中断</li><li><code>ParallelLoopState.Break()</code>：在完成当前的这轮工作之后，不再执行后继的工作，但在当前这轮工作开始之前“已经在执行”的工作，则必须完成。但并不能执行完所有的循环</li><li><code>ParallelLoopState.Stop()</code>：不但不会再创建新的线程执行并行循环，而且当前“已经在执行”的工作也应该被中止</li></ul><h2 id="ParallelLoopState-Break">ParallelLoopState.Break()</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Parallel_Example_For_Break</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> maxCount = <span class="number">1000</span>;</span><br><span class="line">    ConcurrentBag&lt;<span class="built_in">int</span>&gt; bag = <span class="keyword">new</span> ConcurrentBag&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">    <span class="keyword">var</span> watch = Stopwatch.StartNew();</span><br><span class="line">    watch.Start();</span><br><span class="line">    Parallel.For(<span class="number">0</span>, <span class="number">2000</span>, (j, state) =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (bag.Count == maxCount)</span><br><span class="line">        &#123;</span><br><span class="line">            state.Break();</span><br><span class="line">            <span class="comment">//return是必须的,否则依旧会继续执行</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        bag.Add(j);</span><br><span class="line">    &#125;);</span><br><span class="line">    watch.Stop();</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;集合元素个数&#123;0&#125;&quot;</span>, bag.Count);</span><br><span class="line">    Assert.AreEqual(maxCount, bag.Count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ParallelLoopState-Stop">ParallelLoopState.Stop()</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Parallel_Example_For_Stop</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> maxCount = <span class="number">1000</span>;</span><br><span class="line">    ConcurrentBag&lt;<span class="built_in">int</span>&gt; bag = <span class="keyword">new</span> ConcurrentBag&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        bag = <span class="keyword">new</span> ConcurrentBag&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">        Parallel.For(<span class="number">0</span>, <span class="number">2000</span>, (i, state) =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (bag.Count == maxCount)</span><br><span class="line">            &#123;</span><br><span class="line">                state.Stop();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            bag.Add(i);</span><br><span class="line">        &#125;);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;集合元素个数&#123;0&#125;&quot;</span>, bag.Count);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;*************************************************&quot;</span>);</span><br><span class="line">        Assert.AreEqual(maxCount, bag.Count);</span><br><span class="line">    &#125;           </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意">注意</h2><p><code>Stop</code>仅仅通知其他迭代尽快结束，而<code>Break</code>不仅通知其他迭代尽快结束，同时还要保证退出之前要完成<code>LowestBreakIteration</code>之前的迭代。 例如，对于从 0 到 1000 并行迭代的<code>for</code>循环，如果从第 100 此迭代开始调用<code>Break</code>，则低于 100 的所有迭代仍会运行，从 101 到 1000 的迭代则不必要。而调用<code>Stop</code>方法不保证低于 100 的所有迭代都会运行。</p><h1 id="异常处理">异常处理</h1><p>任务是并行计算的，处理过程中可能会产生n多的异常。</p><h2 id="Exception">Exception</h2><p><code>Exception</code>是可以捕获到两个异常的。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Parallel_Example_Exception</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;主线程启动,线程ID:&#123;0&#125;&quot;</span>, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        Parallel.Invoke(() =&gt; Run1(<span class="string">&quot;task1&quot;</span>), () =&gt; Run2(<span class="string">&quot;task2&quot;</span>), () =&gt; Run3(<span class="string">&quot;task3&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Exception ex)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(ex.Message);</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;主线程结束,线程ID:&#123;0&#125;&quot;</span>, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Run1</span>(<span class="params"><span class="built_in">string</span> taskName</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;任务名：&#123;0&#125;线程ID:&#123;1&#125;&quot;</span>,</span><br><span class="line">            taskName, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Run1出现异常&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Run2</span>(<span class="params"><span class="built_in">string</span> taskName</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;任务名：&#123;0&#125;线程ID:&#123;1&#125;&quot;</span>,</span><br><span class="line">            taskName, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Run3</span>(<span class="params"><span class="built_in">string</span> taskName</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;任务名：&#123;0&#125;线程ID:&#123;1&#125;&quot;</span>,</span><br><span class="line">            taskName, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Run3出现异常&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Assert.IsTrue(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/2021-09-02-22-47-13.png" alt=""></p><h2 id="AggregateException">AggregateException</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Parallel_Example_AggregateException</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;主线程启动,线程ID:&#123;0&#125;&quot;</span>, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        Parallel.Invoke(() =&gt; Run1(<span class="string">&quot;task1&quot;</span>), () =&gt; Run2(<span class="string">&quot;task2&quot;</span>), () =&gt; Run3(<span class="string">&quot;task3&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    catch (AggregateException ex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// AggregateException捕获并行产生的一组异常集合</span></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> ex.InnerExceptions)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Run1</span>(<span class="params"><span class="built_in">string</span> taskName</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;任务名：&#123;0&#125;线程ID:&#123;1&#125;&quot;</span>,</span><br><span class="line">            taskName, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Run1出现异常&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Run2</span>(<span class="params"><span class="built_in">string</span> taskName</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;任务名：&#123;0&#125;线程ID:&#123;1&#125;&quot;</span>,</span><br><span class="line">            taskName, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Run3</span>(<span class="params"><span class="built_in">string</span> taskName</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;任务名：&#123;0&#125;线程ID:&#123;1&#125;&quot;</span>,</span><br><span class="line">            taskName, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Run3出现异常&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;主线程结束,线程ID:&#123;0&#125;&quot;</span>, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">    Assert.IsTrue(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Invoke</code>方法中调用了一个产生异常的方法，但是结果显示异常并不会影响其它方法及主线程的执行。</p><h1 id="Parallel-For肯定快吗">Parallel.For肯定快吗?</h1><p>在实现多线程时，为了防止多个线程同时处理同一个变量而导致变量处于&quot;薛定谔状态&quot;，引入了&quot;锁&quot;的概念，即在每一时刻只有获得&quot;锁&quot;的线程才能操作目标变量。如果在<code>Parallel.For</code>中也需要操作一个全局变量，就意味着即使这是并行计算，大家也需要排队操作全局变量，此时<code>Parallel.For</code>可能远远不如传统的<code>for</code>循环来的快。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Parallel_Example_Performance</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Stopwatch stopWatch = <span class="keyword">new</span> Stopwatch();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line">    <span class="built_in">long</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    stopWatch.Start();</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; <span class="number">60000</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    stopWatch.Stop();</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;for run &quot;</span> + stopWatch.ElapsedMilliseconds + <span class="string">&quot; ms.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    stopWatch.Reset();</span><br><span class="line">    stopWatch.Start();</span><br><span class="line">    Parallel.For(<span class="number">0</span>, <span class="number">10000</span>, item =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; <span class="number">60000</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">lock</span> (obj)</span><br><span class="line">            &#123;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    stopWatch.Stop();</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;ParallelFor run &quot;</span> + stopWatch.ElapsedMilliseconds + <span class="string">&quot; ms.&quot;</span>);</span><br><span class="line">    Assert.IsTrue(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/2021-09-02-22-47-34.png" alt=""></p><h1 id="ParallelOptions类">ParallelOptions类</h1><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">CancellationToken</td><td style="text-align:left">获取或设置与此 ParallelOptions 实例关联的 CancellationToken</td></tr><tr><td style="text-align:left">MaxDegreeOfParallelism</td><td style="text-align:left">获取或设置此 ParallelOptions 实例所允许的并发任务的最大数目</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/dotnet/%E6%B3%9B%E5%9E%8B%E6%8A%80%E6%9C%AF/"/>
      <url>/dotnet/%E6%B3%9B%E5%9E%8B%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<p>.Net从2.0版 开始支持泛型。泛型允许在编译时实现类型安全。允许创建一个数据结构而不限于特定的数据类型。当使用该数据结构时，编译器保证它使用的类型与类型安全是相一致的。泛型提供了类型安全，但是没有造成任何性能损失和代码臃肿。泛型不仅限于类，还可用于接口、方法、委托…。</p><h1 id="为什么使用泛型">为什么使用泛型</h1><p>泛型主要具有以下优势：</p><ul><li>类型安全</li><li>避免装箱拆箱带来的性能损耗</li><li>二进制代码重用</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList arrs = <span class="keyword">new</span> ArrayList</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;wang&quot;</span>，</span><br><span class="line">    <span class="number">100</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>问题一：这里如果将 <code>item</code> 设置为 <code>int</code> 类型遍历集合，会抛出异常，因为集合项中存在<code>string</code> 类型</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> arrs)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题二：遍历时不可避免装箱/拆箱操作</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> arrs)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非泛型集合</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">arr1.Add(<span class="number">10</span>);<span class="comment">//Add方法参数值是object类型，这里将int-&gt;object</span></span><br><span class="line">arr1.Add(<span class="string">&quot;wang&quot;</span>);<span class="comment">//Add方法参数值是object类型，这里将int-&gt;object</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">int</span> item <span class="keyword">in</span> arr1)<span class="comment">//这里如果用int类型遍历集合，就挂掉了</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(item);<span class="comment">//读取时要进行拆箱</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型集合</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*泛型集合在使用时定义好类型，之后就不存在装箱拆箱;</span></span><br><span class="line"><span class="comment"> * 因为已经定义当前集合只能存入int类型，也就不能存入其他类型</span></span><br><span class="line"><span class="comment"> * 编译时就会报错，错误应及早发现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> arr2 = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">arr2.Add(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> arr2)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过参数化类型来实现在同一份代码上操作多种数据类型，利用“参数化类型”将类型抽象化，从而实现灵活的复用。每个集合的详细规范可以在 <code>System.Collection.Generic</code>  名称空间下找到。</p><h1 id="泛型工作机制">泛型工作机制</h1><p>泛型是延迟声明的：即定义的时候没有指定具体的参数类型，把参数类型的声明推迟到了调用的时候才指定参数类型。 延迟思想在程序架构设计的时候很受欢迎。例如：分布式缓存队列、EF的延迟加载等等。</p><p>控制台程序最终会编译成一个exe程序，exe被点击的时候，会经过JIT(即时编译器)的编译，最终生成二进制代码，才能被计算机执行。泛型加入到语法以后，VS自带的编译器又做了升级，升级之后编译时遇到泛型，会做特殊的处理：生成占位符。再次经过JIT编译的时候，会把上面编译生成的占位符替换成具体的数据类型。</p><h1 id="泛型方法">泛型方法</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Print</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintType</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span>) <span class="keyword">where</span> T : <span class="keyword">new</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        T t = <span class="keyword">new</span>();</span><br><span class="line">        Console.WriteLine(t.GetType());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">TestMethod</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GenericityMethod</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Print p = <span class="keyword">new</span>();</span><br><span class="line">    p.PrintType&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">    p.PrintType&lt;<span class="built_in">double</span>&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="泛型类">泛型类</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyArray</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> T t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">TestMethod</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GenericityClass</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    MyArray&lt;<span class="built_in">int</span>&gt; genericInt = <span class="keyword">new</span>();</span><br><span class="line">    genericInt.t = <span class="number">123</span>;</span><br><span class="line">    Console.WriteLine(genericInt.t);</span><br><span class="line"></span><br><span class="line">    MyArray&lt;<span class="built_in">string</span>&gt; genericStr = <span class="keyword">new</span>();</span><br><span class="line">    genericStr.t = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    Console.WriteLine(genericStr.t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="default">default</h1><p><code>default</code> 用于将泛型类型初始化为 <code>null</code> 或 <code>0</code> 。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T t = <span class="literal">default</span>(T);</span><br></pre></td></tr></table></figure><h1 id="泛型接口">泛型接口</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IDAL</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Add</span>(<span class="params">T t</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ClassADAL</span>&lt;<span class="title">T</span>&gt; : <span class="title">IDAL</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Add</span>(<span class="params">T t</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ClassBDAL</span>&lt;<span class="title">T</span>&gt; : <span class="title">IDAL</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Add</span>(<span class="params">T t</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="泛型委托">泛型委托</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">SayHi</span>&lt;<span class="title">T</span>&gt;(<span class="params">T t</span>)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">TestMethod</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GenericityDelegate</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    SayHi&lt;<span class="built_in">int</span>&gt; a = <span class="keyword">new</span>((p) =&gt; &#123; Console.WriteLine(p); &#125;);</span><br><span class="line">    a.Invoke(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">    SayHi&lt;<span class="built_in">string</span>&gt; b = <span class="keyword">new</span>((p) =&gt; &#123; Console.WriteLine(p); &#125;);</span><br><span class="line">    b.Invoke(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="注意事项">注意事项</h1><p>泛型在声明的时候可以不指定具体的类型，但是在使用的时候必须指定具体类型。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Print&lt;<span class="built_in">int</span>&gt; iPrint = <span class="keyword">new</span> Print&lt;<span class="built_in">int</span>&gt;();</span><br></pre></td></tr></table></figure><p>这里的类型是int，如果存在继承并且子类也是泛型的，那么继承的时候可以不指定具体类型</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Print</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> T t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里继承时没有指定泛型类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">ConsolePrint</span>&lt;<span class="title">T</span>&gt; : <span class="title">Print</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同上，类实现泛型接口也是如此。</p><h1 id="泛型约束">泛型约束</h1><p>所谓的泛型约束，就是约束类型 <code>T</code> ，使 <code>T</code> 必须遵循一定的规则。比如 <code>T</code> 必须继承自某个类，或者 <code>T</code> 必须实现某个接口等。</p><table><thead><tr><th><strong>类型</strong></th><th style="text-align:left"><strong>描述</strong></th></tr></thead><tbody><tr><td>T:calss</td><td style="text-align:left">类型参数必须是引用类型，包括任何类、接口、委托或数组类型</td></tr><tr><td>T:stauct</td><td style="text-align:left">类型参数必须是值类型。可以指定除 Nullable 以外的任何值类型</td></tr><tr><td>T:new()</td><td style="text-align:left">类型参数必须具有无参数的公共构造函数。当与其他约束一起使用时，new() 约束必须最后指定</td></tr><tr><td>T:&lt;基类名&gt;</td><td style="text-align:left">类型参数必须是指定的基类或派生自指定的基类</td></tr><tr><td>T:&lt;接口名称&gt;</td><td style="text-align:left">类型参数必须是指定的接口或实现指定的接口。可以指定多个接口约束。约束接口也可以是泛型的</td></tr><tr><td>T1:T2</td><td style="text-align:left">类型T1派生自泛型类型T2,该约束也被称为裸类型约束</td></tr></tbody></table><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PintSayHello</span>(<span class="params"></span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title">ISport</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Sport</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 约束T必须是Person类型或者是Person的子类并且实现了ISport接口且T类型中必须有无参构造函数</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;typeparam name=&quot;T&quot;&gt;</span><span class="doctag">&lt;/typeparam&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Show</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="title">Person</span>， <span class="title">ISport</span>， <span class="title">new</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 约束T必须是引用类型并且实现了ISport接口且T类型中必须有无参构造函数</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;typeparam name=&quot;T&quot;&gt;</span><span class="doctag">&lt;/typeparam&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Show2</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="keyword">class</span>， <span class="title">ISport</span>， <span class="title">new</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 约束T必须是值类型并且实现了ISport接口</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;typeparam name=&quot;T&quot;&gt;</span><span class="doctag">&lt;/typeparam&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Show3</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="title">struct</span>， <span class="title">ISport</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：泛型约束可以同时约束多个，有多个泛型约束时，<code>new()</code> 约束一定是在最后。</p></blockquote><h1 id="泛型协变与逆变">泛型协变与逆变</h1><p><a href="http://xn--ykr6la33ei5hvr2j.NET">协变和逆变在.NET</a> 4.0的时候出现，<strong>只能放在接口或者委托的泛型参数前</strong>。</p><ul><li><code>out</code> 协变，用来修饰返回值</li><li><code>in</code>：逆变，用来修饰传入参数</li></ul><p>在C#中声明泛型接口时，可以使用 <code>in</code> 和 <code>out</code> 参数来控制这个泛型是协变还是逆变的（逆变有时也被翻译成抗变）协变和逆变是用来描述<strong>如果泛型存在继承关系时，两个泛型类是否能够直接赋值的问题</strong>。比如派生泛型 <code>IInterface&lt;Child&gt;</code> 是否能被赋值给 <code>IInterface&lt;Parent&gt;</code>。</p><h2 id="协变：只能是方法参数"><strong>协变</strong>：只能是方法参数</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ICustomerListIn</span>&lt;<span class="keyword">in</span> <span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span>(<span class="params">T t</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 泛型协变(子类到父类的转换)</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;remarks&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> out：协变covariant，用来修饰返回值</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/remarks&gt;</span></span></span><br><span class="line">        [<span class="meta">TestMethod</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GenericityCovariant</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 直接声明Animal类</span></span><br><span class="line">            Animal animal = <span class="keyword">new</span> Animal();</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;animal.GetType()&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 直接声明Cat类</span></span><br><span class="line">            Cat cat = <span class="keyword">new</span> Cat();</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;cat.GetType()&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 声明子类对象指向父类</span></span><br><span class="line">            Animal animal2 = <span class="keyword">new</span> Cat();</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;animal2.GetType()&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 声明Animal类的集合</span></span><br><span class="line">            List&lt;Animal&gt; listAnimal = <span class="keyword">new</span> List&lt;Animal&gt;();</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> listAnimal)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;item.GetType()&#125;</span>&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 声明Cat类的集合</span></span><br><span class="line">            List&lt;Cat&gt; listCat = <span class="keyword">new</span> List&lt;Cat&gt;();</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> listCat)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;item.GetType()&#125;</span>&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> debug</span></span><br><span class="line">            <span class="comment">// 一只Cat属于Animal，一群Cat也应该属于Animal。但实际上这样声明是错误的：因为List&lt;Cat&gt;和List&lt;Animal&gt;之间没有父子关系</span></span><br><span class="line">            List&lt;Animal&gt; list = <span class="keyword">new</span> List&lt;Cat&gt;();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            <span class="comment">// 泛型协变，IEnumerable泛型参数类型使用了out修饰</span></span><br><span class="line">            ICustomerListOut&lt;Animal&gt; customerList1 = <span class="keyword">new</span> CustomerListOut&lt;Animal&gt;();</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;customerList1.GetType()&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">            ICustomerListOut&lt;Animal&gt; customerList2 = <span class="keyword">new</span> CustomerListOut&lt;Cat&gt;();</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;customerList2.GetType()&#125;</span>&quot;</span>);</span><br><span class="line">            Assert.IsTrue(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="逆变：只能是返回值"><strong>逆变</strong>：只能是返回值</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ICustomerListIn</span>&lt;<span class="keyword">in</span> <span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span>(<span class="params">T t</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 泛型逆变(父类到子类的转换)</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;remarks&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> int：协变contravariant，用来修饰返回值(子类到父类的转换)</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/remarks&gt;</span></span></span><br><span class="line">[<span class="meta">TestMethod</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GenericityContravariant</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 直接声明Animal类</span></span><br><span class="line">    Animal animal = <span class="keyword">new</span> Animal();</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;animal.GetType()&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接声明Cat类</span></span><br><span class="line">    Cat cat = <span class="keyword">new</span> Cat();</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;cat.GetType()&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明子类对象指向父类</span></span><br><span class="line">    Animal animal2 = <span class="keyword">new</span> Cat();</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;animal2.GetType()&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明Animal类的集合</span></span><br><span class="line">    List&lt;Animal&gt; listAnimal = <span class="keyword">new</span> List&lt;Animal&gt;();</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> listAnimal)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;item.GetType()&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明Cat类的集合</span></span><br><span class="line">    List&lt;Cat&gt; listCat = <span class="keyword">new</span> List&lt;Cat&gt;();</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> listCat)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;item.GetType()&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ICustomerListIn&lt;Cat&gt; customerListCat1 = <span class="keyword">new</span> CustomerListIn&lt;Cat&gt;();</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;customerListCat1.GetType()&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ICustomerListIn&lt;Cat&gt; customerListCat2 = <span class="keyword">new</span> CustomerListIn&lt;Animal&gt;();</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;customerListCat2.GetType()&#125;</span>&quot;</span>);</span><br><span class="line">    Assert.IsTrue(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="高性能泛型缓存">高性能泛型缓存</h1><p>静态字典缓存和常用的泛型缓存的性能相比，泛型缓存性能是非常优异的。泛型缓存是 <code>JIT</code> 产生全新的类，内存直接分配，由CPU查找内存地址。静态字典缓存需要根据地址去寻址查找。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 类中的静态类型无论实例化多少次，在内存中只会有一个</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 静态构造函数只会执行一次</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 在泛型类中，T类型不同</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 每个不同的T类型，都会产生一个不同的副本，所以会产生不同的静态属性、不同的静态构造函数</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;typeparam name=&quot;T&quot;&gt;</span><span class="doctag">&lt;/typeparam&gt;</span></span></span><br><span class="line">gma warning disable S1118 <span class="comment">// Utility classes should not have public constructors</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GenericCache</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line"><span class="title">gma</span> <span class="title">warning</span> <span class="title">restore</span> <span class="title">S1118</span> <span class="comment">// Utility classes should not have public constructors</span></span><br><span class="line">&#123;</span><br><span class="line">gma warning disable S3963 <span class="comment">// &quot;static&quot; fields should be initialized inline</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">GenericCache</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _CachedValue = <span class="built_in">string</span>.Format(<span class="string">&quot;&#123;0&#125;_&#123;1&#125;&quot;</span>，</span><br><span class="line">            <span class="keyword">typeof</span>(T).FullName， DateTime.Now.ToString(<span class="string">&quot;yyyyMMddHHmmss.fff&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">gma warning restore S3963 <span class="comment">// &quot;static&quot; fields should be initialized inline</span></span><br><span class="line"></span><br><span class="line">gma warning disable S2743 <span class="comment">// Static fields should not be used in generic types</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">string</span> _CachedValue = <span class="string">&quot;&quot;</span>;</span><br><span class="line">gma warning restore S2743 <span class="comment">// Static fields should not be used in generic types</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">GetCache</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> _CachedValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 泛型会为不同的类型都创建一个副本</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 所以静态构造函数会执行4次，而且每次静态属性的值都是一样的</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 利用泛型的这一特性，可以实现缓存</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 注意：只能为不同的类型缓存一次。泛型缓存比字典缓存效率高。泛型缓存不能主动释放</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">[<span class="meta">TestMethod</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GenericityCache</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(GenericCache&lt;<span class="built_in">int</span>&gt;.GetCache());</span><br><span class="line">        Console.WriteLine(GenericCache&lt;<span class="built_in">long</span>&gt;.GetCache());</span><br><span class="line">        Console.WriteLine(GenericCache&lt;DateTime&gt;.GetCache());</span><br><span class="line">        Console.WriteLine(GenericCache&lt;<span class="built_in">string</span>&gt;.GetCache());</span><br><span class="line">    &#125;</span><br><span class="line">    Assert.IsTrue(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/2021-09-02-21-55-49.png" alt=""></p><h1 id="参考">参考</h1><ul><li><a href="https://www.cnblogs.com/dotnet261010/p/9034594.html">https://www.cnblogs.com/dotnet261010/p/9034594.html</a></li><li><a href="https://www.cnblogs.com/yilezhu/p/10029782.html">https://www.cnblogs.com/yilezhu/p/10029782.html</a></li><li><a href="https://www.cnblogs.com/aehyok/p/3384637.html">https://www.cnblogs.com/aehyok/p/3384637.html</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/dotnet/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
      <url>/dotnet/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>对于多线程，经常使用的是 <code>Thread</code>。在了解 <code>Task</code> 之前，如果要使用多核的功能可能就会自己来开线程，然而这种线程模型在 <code>.net 4.0</code> 之后被一种称为 <code>基于“任务的编程模型”</code> 所冲击，这就是 <code>Task</code>。</p><p><code>Task </code>会比 <code>Thread</code> 具有更小的性能开销，<code>Task </code>是架构在 <code>Thread</code> 之上的就是说 <code>Task</code> 最终还是会抛给线程去做，并且任务跟线程不是一对一的关系，比如开 10 个任务并不是说会开 10 个线程，这一点任务有点类似线程池，但是任务相比线程池有很小的开销和精确的控制。<code>Task</code> 类的表示单个操作不返回一个值，通常以异步方式执行，<code>Task</code>  对象是 <code>&quot;基于任务的异步模式“</code> 首次引入 <code>.NET Framework 4</code>  中。</p><p>因为由执行工作  <code>Task</code> 对象通常以异步方式执行在线程池线程上而不是以同步方式在主应用程序线程，可以使用<code>Status </code>属性，以及 <code>IsCanceled</code>,<code>IsCompleted</code>, 和 <code>IsFaulted</code>属性，以确定任务的状态。</p><h1 id="相关概念理解">相关概念理解</h1><ul><li>同步（Synchronous）</li><li>异步 (Asynchronous)</li><li>阻塞 (Blocking)</li><li>非阻塞(Nonblocking)</li></ul><p>同步/异步指的是在客户端</p><blockquote><p>同步意味着：客户端提出了一个请求以后，在回应之前只能等待<br>异步意味着：客户端提出一个请求以后，还可以继续提其他请求</p></blockquote><p>阻塞/非阻塞指的是服务器端</p><blockquote><p>阻塞意味着：服务器接受一个请求后，在返回结果以前不能接受其他请求<br>非阻塞意味着：服务器接受一个请求后，尽管没有返回结果，还是可以继续接受其他请求</p></blockquote><h1 id="同步与异步">同步与异步</h1><p>同步和异步关注的是消息通信机制 (synchronous communication/ asynchronous communication)</p><p>所谓同步，就是在发出一个<strong>调用</strong>时，在没有得到结果之前，该<strong>调用</strong>就不返回。但是一旦调用返回，就得到返回值了。换句话说，就是由<strong>调用者</strong>主动等待这个<strong>调用</strong>的结果。</p><p>而异步则是相反，<strong>调用</strong>在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果,而是在<strong>调用</strong>发出后，<strong>被调用者</strong>通过状态、通知来通知调用者，或通过回调函数处理这个调用。(典型的异步编程模型比如Node.js)</p><p><strong>同步通信机制</strong></p><blockquote><p>你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，“我查一下”，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）</p></blockquote><p><strong>异步通信机制</strong></p><blockquote><p>书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过&quot;回电&quot;这种方式来回调</p></blockquote><h1 id="阻塞与非阻塞">阻塞与非阻塞</h1><p>阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态，阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程</p><p>Example</p><blockquote><p>你打电话问书店老板有没有《分布式系统》这本书，如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果，在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关</p></blockquote><h1 id="模型图例">模型图例</h1><h2 id="单线程同步模型">单线程同步模型</h2><p><img src="/images/2021-09-02-22-35-08.png" alt=""></p><h2 id="多线程模型">多线程模型</h2><p><img src="/images/2021-09-02-22-35-45.png" alt=""></p><h2 id="异步模型">异步模型</h2><p><img src="/images/2021-09-02-22-36-14.png" alt=""></p><h1 id="基础">基础</h1><h2 id="创建任务">创建任务</h2><h3 id="new-TaskFactory">new TaskFactory()</h3><p>使用实例化的TaskFactory类</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t1 = <span class="keyword">new</span> TaskFactory().StartNew(() =&gt; Console.WriteLine(<span class="string">&quot;new TaskFactory().StartNew&quot;</span>));</span><br></pre></td></tr></table></figure><h3 id="Task-Factory">Task.Factory</h3><p>使用Task静态属性Factory</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t2 = Task.Factory.StartNew(() =&gt; Console.WriteLine(<span class="string">&quot;Task.Factory&quot;</span>));</span><br></pre></td></tr></table></figure><h3 id="new-Task">new Task()</h3><p>使用<code>Task</code>的构造函数, 实例化<code>Task</code>对象时，任务不会立即执行，而是指定<code>Created</code>状态，通过<code>Task.Start()</code>方法启动</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t3 = <span class="keyword">new</span> Task(() =&gt; Console.WriteLine(<span class="string">&quot;Task Constructor&quot;</span>));</span><br><span class="line">t3.Start();</span><br></pre></td></tr></table></figure><h3 id="Task-Run">Task.Run</h3><p>.Net4.5 新增功能使用<code>Task</code>类的<code>Run</code>方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var t4 = Task.Run(() =&gt; Console.WriteLine(<span class="string">&quot;Task.Run&quot;</span>));</span><br></pre></td></tr></table></figure><p>注意：使用<code>Task.Run/Task.Factory.StartNew/new TaskFactory().StartNew()</code>方法运行的任务会立即开始工作，无需显式调用这些任务的<code>Start</code>方法</p><h2 id="同步任务">同步任务</h2><p>任务不一定要使用线程池中的线程，也可以使用其他线程，任务也可以同步进行，以相同的线程作为主调线程</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> t1 = <span class="keyword">new</span> Task(() =&gt; TaskMethod(<span class="string">&quot;t1&quot;</span>));</span><br><span class="line">            t1.Start();</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;主线程调用结束&quot;</span>);</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">TaskMethod</span>(<span class="params"><span class="built_in">string</span> taskName</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Task &#123;0&#125; 运行在线程id为&#123;1&#125;的线程上。是否是线程池中线程？:&#123;2&#125;&quot;</span>,</span><br><span class="line">taskName, Thread.CurrentThread.ManagedThreadId, Thread.CurrentThread.IsThreadPoolThread);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t1 = <span class="keyword">new</span> Task(() =&gt; TaskMethod(<span class="string">&quot;t1&quot;</span>));</span><br><span class="line">    t1.RunSynchronously();</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;主线程调用结束&quot;</span>);</span><br><span class="line">    Console.ReadKey();</span><br></pre></td></tr></table></figure><h2 id="使用单独线程的任务">使用单独线程的任务</h2><p>如果任务的代码需要长时间运行，应该使用<code>TaskCreationOptions.LongRuning</code>告诉任务调度器创建一个新线程，而不是使用线程池中的线程。此时线程可以不受线程池管理</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t1 = <span class="keyword">new</span> Task(TaskMethod, TaskCreationOptions.LongRunning);</span><br><span class="line">t1.Start();</span><br></pre></td></tr></table></figure><h2 id="Task生命周期">Task生命周期</h2><table><thead><tr><th style="text-align:left">状态</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">Created</td><td style="text-align:left">该任务已初始化，但尚未被计划</td></tr><tr><td style="text-align:left">WaitingForActivation</td><td style="text-align:left">该任务正在等待 .NET Framework 基础结构在内部将其激活并进行计划</td></tr><tr><td style="text-align:left">WaitingToRun</td><td style="text-align:left">该任务已被计划执行，但尚未开始执行</td></tr><tr><td style="text-align:left">Running</td><td style="text-align:left">该任务正在运行，但尚未完成</td></tr><tr><td style="text-align:left">WaitingForChildrenToComplete</td><td style="text-align:left">该任务已完成执行，正在隐式等待附加的子任务完成</td></tr><tr><td style="text-align:left">RanToCompletion</td><td style="text-align:left">已成功完成执行的任务</td></tr><tr><td style="text-align:left">Canceled</td><td style="text-align:left">该任务已通过对其自身的 CancellationToken 引发 OperationCanceledException 对取消进行了确认，此时该标记处于已发送信号状态；或者在该任务开始执行之前，已向该任务的 CancellationToken 发出了信号</td></tr><tr><td style="text-align:left">Faulted</td><td style="text-align:left">由于未处理异常的原因而完成的任务</td></tr></tbody></table><h2 id="Task任务控制">Task任务控制</h2><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">Task.Wait</td><td style="text-align:left">task1.Wait();就是等待任务执行完成，task 的状态变为 Completed</td></tr><tr><td style="text-align:left">Task.WaitAll</td><td style="text-align:left">待所有的任务都执行完成</td></tr><tr><td style="text-align:left">Task.WaitAny</td><td style="text-align:left">等待任何一个任务完成就继续向下执行</td></tr><tr><td style="text-align:left">Task.ContinueWith</td><td style="text-align:left">第一个 Task 完成后自动启动下一个 Task，实现 Task 的延续 CancellationTokenSource</td></tr><tr><td style="text-align:left">CancellationTokenSource</td><td style="text-align:left">通过 cancellation 的 tokens 来取消一个 Task</td></tr></tbody></table><h2 id="Task返回类型">Task返回类型</h2><h3 id="void">void</h3><p>不关心结果，返回 void 类型</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[TestMethod]</span><br><span class="line">public void <span class="function"><span class="title">Task_Result_Void</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine($<span class="string">&quot;不关心结果,返回Void,--Start,线程Id:&#123;Thread.CurrentThread.ManagedThreadId&#125;&quot;</span>);</span><br><span class="line">    Print();</span><br><span class="line">    Console.WriteLine($<span class="string">&quot;不关心结果,返回Void,--End,线程Id:&#123;Thread.CurrentThread.ManagedThreadId&#125;&quot;</span>);</span><br><span class="line">    Assert.IsTrue(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    static async void <span class="function"><span class="title">Print</span></span>()</span><br><span class="line">    &#123;</span><br><span class="line">        await Task.Run(() =&gt;</span><br><span class="line">       &#123;</span><br><span class="line">           Console.WriteLine($<span class="string">&quot;Hello, 线程Id:&#123; Thread.CurrentThread.ManagedThreadId&#125;&quot;</span>);</span><br><span class="line">       &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Task">Task</h3><p>关心是否完成，返回 Task 类型</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public void <span class="function"><span class="title">Task_Result_Task</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine($<span class="string">&quot;看电视中...,线程Id:&#123;Thread.CurrentThread.ManagedThreadId&#125;&quot;</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;突然停电，看下是不是跳闸了&quot;</span>);</span><br><span class="line">    var task = OpenMainsSwitch();</span><br><span class="line">    Console.WriteLine($<span class="string">&quot;没电了先玩会儿手机吧，线程Id为：&#123;Thread.CurrentThread.ManagedThreadId&#125;&quot;</span>);</span><br><span class="line">    Thread.Sleep(100);</span><br><span class="line">    // 等着电源开关被打开</span><br><span class="line">    task.Wait();</span><br><span class="line">    Console.WriteLine($<span class="string">&quot;又有电了,继续看电视...,线程Id:&#123;Thread.CurrentThread.ManagedThreadId&#125;&quot;</span>);</span><br><span class="line">    Assert.IsTrue(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    static async Task <span class="function"><span class="title">OpenMainsSwitch</span></span>()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine($<span class="string">&quot;准备打开电源开关，线程Id：&#123; Thread.CurrentThread.ManagedThreadId&#125;&quot;</span>);</span><br><span class="line">        await Task.Run(() =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine($<span class="string">&quot;打开电源开关, 线程Id:&#123; Thread.CurrentThread.ManagedThreadId&#125;&quot;</span>);</span><br><span class="line">            Thread.Sleep(2000);</span><br><span class="line">        &#125;);</span><br><span class="line">        Console.WriteLine($<span class="string">&quot;电源开关打开了，线程Id：&#123; Thread.CurrentThread.ManagedThreadId&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Task-T"><code>Task&lt;T&gt;</code></h3><p>调用方法要从调用中获取一个<code>T</code>类型的值，异步方法的返回类型就必须是<code>Task&lt;T&gt;</code>。调用方法从<code>Task</code>的<code>Result</code>属性获取的就是<code>T</code>类型的值</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">Task_Result_TaskTAsync</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> message = <span class="string">$&quot;Today is <span class="subst">&#123;DateTime.Today:D&#125;</span>\n&quot;</span> + <span class="string">&quot;Today&#x27;s hours of leisure: &quot;</span> + <span class="string">$&quot;<span class="subst">&#123;<span class="keyword">await</span> GetLeisureHoursAsync()&#125;</span>&quot;</span>;</span><br><span class="line">    Console.WriteLine(message);</span><br><span class="line">    Assert.IsTrue(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task&lt;<span class="built_in">int</span>&gt; <span class="title">GetLeisureHoursAsync</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        DayOfWeek today = <span class="keyword">await</span> Task.FromResult(DateTime.Now.DayOfWeek);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> leisureHours =</span><br><span class="line">            today <span class="keyword">is</span> DayOfWeek.Saturday || today <span class="keyword">is</span> DayOfWeek.Sunday</span><br><span class="line">            ? <span class="number">16</span> : <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> leisureHours;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="连续任务">连续任务</h2><p>在指定任务完成后调用另一个指定任务</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Task_ContinueWith_Example</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Task&lt;<span class="built_in">string</span>&gt; t1 = <span class="keyword">new</span> Task&lt;<span class="built_in">string</span>&gt;(</span><br><span class="line">        () =&gt; TaskMethod1(<span class="string">&quot;t1&quot;</span>));</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Task1-创建,状态为:&#123;0&#125;&quot;</span>, t1.Status);</span><br><span class="line">    t1.Start();</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Task1-启动,状态为:&#123;0&#125;&quot;</span>, t1.Status);</span><br><span class="line">    Console.WriteLine(t1.Result);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Task1-完成,状态为:&#123;0&#125;&quot;</span>, t1.Status);</span><br><span class="line">    Task t2 = t1.ContinueWith(TaskMethod2);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Task2,状态为:&#123;0&#125;&quot;</span>, t2.Status);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">string</span> <span class="title">TaskMethod1</span>(<span class="params"><span class="built_in">string</span> taskName</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> result = <span class="built_in">string</span>.Format(<span class="string">$&quot;Task:<span class="subst">&#123;taskName&#125;</span> 运行在线程id:<span class="subst">&#123; Thread.CurrentThread.ManagedThreadId&#125;</span>的线程上,&quot;</span> +</span><br><span class="line">            <span class="string">$&quot;是否是线程池中线程？:<span class="subst">&#123;Thread.CurrentThread.IsThreadPoolThread&#125;</span>&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">TaskMethod2</span>(<span class="params">Task t</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;TaskID:<span class="subst">&#123; t.Id&#125;</span> 运行在线程id:<span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>的线程上。是否是线程池中线程？:<span class="subst">&#123;Thread.CurrentThread.IsThreadPoolThread&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    Assert.IsTrue(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>TaskContinuationOptions</code>枚举的值可以指定连续任务只有在起始任务成功或失败结束时启动</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Task t2 = t1.ContinueWith(TaskMethod2, TaskContinuationOptions.NotOnCanceled);</span><br></pre></td></tr></table></figure><h2 id="嵌套Task">嵌套Task</h2><h3 id="关联嵌套">关联嵌套</h3><p>在创建<code>cTask</code>时，加入了参数<code>TaskCreationOptions.AttachedToParent</code>，这个时候，<code>cTask</code>和<code>pTask</code>就会建立关联，<code>cTask</code>就会成为<code>pTask</code>的一部分</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">TestMethod</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Task_Relevance_Example</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> pTask = Task.Factory.StartNew(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">var</span> cTask= Task.Factory.StartNew(() =&gt;</span><br><span class="line">         &#123;</span><br><span class="line">             Console.WriteLine(<span class="string">&quot;Childen task finished!&quot;</span>);</span><br><span class="line">         &#125;, TaskCreationOptions.AttachedToParent);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Parent task finished!&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    pTask.Wait();</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Flag&quot;</span>);</span><br><span class="line">    Assert.IsTrue(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非关联嵌套">非关联嵌套</h3><p>外层的<code>pTask</code>运行完后，并不会等待内层的<code>cTask</code>，直接向下走先输出了<code>Flag</code>。这种嵌套有时候相当于创建两个Task，但是嵌套在一起的话，在Task比较多时会方便查找和管理，并且还可以在一个Task中途加入多个Task，让进度并行前进</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">TestMethod</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Task_NoRelevance_Example</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> pTask = Task.Factory.StartNew(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Task.Factory.StartNew(() =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Childen task finished!&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Parent task finished!&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    pTask.Wait();</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Flag&quot;</span>);</span><br><span class="line">    Assert.IsTrue(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>Task</code>内部创建<code>Task</code>，如果父任务在子任务之前结束，父任务状态就显示为<code>WaitingForChilderenToComplete</code>。所有的子任务也结束时，父任务的状态就改为<code>RanToCompletion</code>，如果使用<code>TaskContinuationOptions</code>枚举值创建子任务时会有不同结果，取消父任务也会取消子任务</p><h2 id="Task取消">Task取消</h2><h3 id="单个任务">单个任务</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">TestMethod</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Task_CancellationToken_SingleTask_Example</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    CancellationTokenSource cts = <span class="keyword">new</span> CancellationTokenSource();</span><br><span class="line">    Task t1 = Task.Run(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (cts.Token.IsCancellationRequested)</span><br><span class="line">            &#123;</span><br><span class="line">                cts.Token.ThrowIfCancellationRequested();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Thread.Sleep(<span class="number">500</span>);</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;任务t1,共执行30次,当前第&#123;0&#125;次&quot;</span>, i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, cts.Token);</span><br><span class="line">    Thread.Sleep(<span class="number">2000</span>);</span><br><span class="line">    <span class="comment">// 传达取消请求</span></span><br><span class="line">    cts.Cancel();</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;已停止,Status<span class="subst">&#123;t1.Status&#125;</span>&quot;</span>);</span><br><span class="line">    Assert.IsTrue(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多个任务">多个任务</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">TestMethod</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Task_CancellationToken_MultiTask_Example</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    CancellationTokenSource cts1 = <span class="keyword">new</span> CancellationTokenSource();</span><br><span class="line">    CancellationTokenSource cts2 = <span class="keyword">new</span> CancellationTokenSource();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 任何Task处于取消状态时其余也将取消</span></span><br><span class="line">    CancellationTokenSource ctsCombine =</span><br><span class="line">         CancellationTokenSource.CreateLinkedTokenSource(cts1.Token, cts2.Token);</span><br><span class="line">    Task t1 = Task.Run(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!ctsCombine.IsCancellationRequested)</span><br><span class="line">            &#123;</span><br><span class="line">                Thread.Sleep(<span class="number">500</span>);</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;任务t1,共执行30次,当前第&#123;0&#125;次&quot;</span>, i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, ctsCombine.Token);</span><br><span class="line"></span><br><span class="line">    Task t2 = Task.Run(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!ctsCombine.IsCancellationRequested)</span><br><span class="line">            &#123;</span><br><span class="line">                Thread.Sleep(<span class="number">500</span>);</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;任务t2,共执行30次,当前第&#123;0&#125;次&quot;</span>, i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, ctsCombine.Token);</span><br><span class="line">    Thread.Sleep(<span class="number">2000</span>);</span><br><span class="line">    cts1.Cancel();</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;t1:Status_<span class="subst">&#123;t1.Status&#125;</span>,t2:Status_<span class="subst">&#123;t2.Status&#125;</span>&quot;</span>);</span><br><span class="line">    Assert.IsTrue(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定时取消">定时取消</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    CancellationTokenSource cts = <span class="keyword">new</span> CancellationTokenSource();</span><br><span class="line">    cts.CancelAfter(<span class="number">8000</span>);</span><br><span class="line">    Task t1 = Task.Run(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (cts.Token.IsCancellationRequested)</span><br><span class="line">            &#123;</span><br><span class="line">                cts.Token.ThrowIfCancellationRequested();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Thread.Sleep(<span class="number">500</span>);</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;任务t1,共执行30次,当前第&#123;0&#125;次&quot;</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, cts.Token);</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        t1.Wait();</span><br><span class="line">    &#125;</span><br><span class="line">    catch (AggregateException e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> e.InnerExceptions)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Console.ReadKey();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>工作原理</strong><br>程序运行主线程创建-&gt;创建<code>CancellationTokenSource</code>对象-&gt;设置<code>task</code>在指定毫秒数后取消(这里是 8000)-&gt;创建<code>task</code>并传入<code>CancellationTokenSource</code>对象生成的<code>token</code>，循环打印 1~30，取消标记为<code>true</code>则抛出异常中止任务，<code>false</code>则正常输出。在输出前等待 500 毫秒(避免 8000 毫秒还没到任务就已经执行完成)-&gt;使用<code>try/catch</code>包裹<code>t1.Wait()</code>等待任务执行完成语句，并捕获处理异常。这里任务在执行完 15 次的时候被取消</p><h2 id="取消时回调">取消时回调</h2><p><code>CancellationTokenSource.Token.Register()</code>，使用<code>Register</code>，向取消标记登记一个回调方法。应用程序调用<code>CancellationTokenSource</code> 对象的 <code>Cancel</code> 方法时，这个回调就会运行。但是不能保证这个方法在什么时候执行,可能在任务执行完自己的取消处理之前或之后,也可能在那个过程之中</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">TestMethod</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Task_CancellationToken_Register_Example</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    CancellationTokenSource cts = <span class="keyword">new</span> CancellationTokenSource();</span><br><span class="line">    <span class="keyword">var</span> token = cts.Token;</span><br><span class="line">    cts.CancelAfter(<span class="number">8000</span>);</span><br><span class="line">    token.Register(Callback);</span><br><span class="line">    Task t1 = Task.Run(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (token.IsCancellationRequested)</span><br><span class="line">            &#123;</span><br><span class="line">                token.ThrowIfCancellationRequested();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Thread.Sleep(<span class="number">500</span>);</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;任务t1,共执行30次,当前第&#123;0&#125;次&quot;</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, token);</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        t1.Wait();</span><br><span class="line">    &#125;</span><br><span class="line">    catch (AggregateException e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> e.InnerExceptions)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Callback</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Register登记的任务取消回调函数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Assert.IsTrue(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问题记录">问题记录</h1><h2 id="async-await并不能提升性能">async/await并不能提升性能?</h2><p>问题描述：所谓的异步操作就是A线程在执行任务的时候，执行到一半再把任务交给B线程，然后A线程开始等待B的执行完成了，这不还是同步的吗?</p><blockquote><p>异步编程不能提高性能。异步编程只是提供一种简单的编程模型来提高系统的响应能力，比如，如果在UI线程上执行长时间IO操作，在操作完成之前界面就处在无法操作的状态。<br>可以提高性能的是并行技术，比如任务并行库（TPL，Task Parallel Library）、并行LINQ（PLINQ）等，这些技术可以充分利用CPU来提高计算性能。一般来说，耗时的IO操作使用异步简化代码，耗时的计算操作使用并行来提高性能</p></blockquote><blockquote><p>比如服务端最大处理请求是100个线程，那么同步模式下，150个请求过来，就有50个请求需要等待执行。async/await 模式下，正在执行的100个线程 可以空闲出来 处理后来的50个请求，前面100个请求异步完成后，再通过上下文切换到当前的100个线程，处理完后续的流程。工作线程是在不停的切换过程中提升了并发效率。而在单个请求中，async/await是有线程上下文切换的性能损耗，所以在处理一个本来就很快速的逻辑,例如读一个Redis缓存，那么性能会有比较显著的下降</p></blockquote><p>总结：异步编程只是提高了线程的利用率，针对一个本来就很“快”的操作，可能异步还不如同步。因为线程上下文的切换也会带来性能损耗</p><h2 id="async-await死锁问题">async/await死锁问题</h2><h3 id="可能发生死锁的程序类型">可能发生死锁的程序类型</h3><ul><li><code>WPF/WinForm</code>程序</li><li><a href="http://asp.net">asp.net</a>(<a href="http://xn--asp-628d60u5v0a.net">不包括asp.net</a> core)程序</li></ul><h3 id="什么情况下会产生死锁">什么情况下会产生死锁?</h3><p>调用 <code>Task.Wait()</code> 或者 <code>Task.Result</code> 立刻产生死锁的充分条件</p><ul><li>调用 <code>Wait()</code>或<code>Result</code>的代码位于<code>UI</code>线程</li><li><code>Task</code>的实际执行在其他线程，且需要返回<code>UI</code>线程</li></ul><h3 id="死锁的原因">死锁的原因?</h3><blockquote><p><code>UWP</code>、<code>WPF</code>、<code>Windows Forms</code>程序的 UI 线程都是单线程的。为了让使用了<code>async/await</code>的代码像使用同步代码一样简单，WPF 程序的<code>Application</code>类在构造的时候会将<code>主UI线程</code> Task的同步上下文设置为<code>DispatcherSynchronizationContext</code>的实例，当<code>Task</code>的任务结束时，会从<code>AsyncMethodStateMachine</code>中调用<code>Awaiter</code>的<code>OnComplete()</code>方法，而<code>await</code>后续方法的执行靠的就是<code>OnComplete()</code>方法中一层层调用到 <code>DispatcherSynchronizationContext</code>里的<code>Post</code>方法</p></blockquote><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Asynchronously invoke the callback in the SynchronizationContext.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Post</span>(<span class="params">SendOrPostCallback d, Object state</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Call BeginInvoke with the cached priority.  Note that BeginInvoke</span></span><br><span class="line">    <span class="comment">// preserves the behavior of passing exceptions to</span></span><br><span class="line">    <span class="comment">// Dispatcher.UnhandledException unlike InvokeAsync.  This is</span></span><br><span class="line">    <span class="comment">// desireable because there is no way to await the call to Post, so</span></span><br><span class="line">    <span class="comment">// exceptions are hard to observe.</span></span><br><span class="line">    _dispatcher.BeginInvoke(_priority, d, state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是问题的关键！！！</p><p>如果<code>_dispatcher.BeginInvoke(_priority, d, state);</code>这句代码在后台线程。那么此时<code>UI线程</code>处于<code>Wait()/Result</code>调用中的阻塞状态，<code>BeginInvoke</code>中的任务是无论如何也无法执行到的，于是无论如何都无法完成这个<code>Post</code>任务，即无论如何也无法退出此异步任务的执行，于是<code>Wait()</code>便无法完成等待，产生死锁</p><p>Example</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DoAsync().Wait();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">async</span> Task <span class="title">DoAsync</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">await</span> Task.Run(() =&gt; &#123; &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论是<code>WPF</code>还是<code>UWP</code>，只要在<code>UI</code>线程上调用上述代码，必然死锁</p><h3 id="There-Is-No-Thread">There Is No Thread</h3><p>读写文件，访问网络，这些 IO 阻塞的操作执行时，里面根本就没有线程。详情请阅读：<a href="https://blog.stephencleary.com/2013/11/there-is-no-thread.html">There Is No Thread</a></p><p>还有另一些操作，也没有后台线程的参与，于是也不存在从后台线程回到主线程导致死锁的情况。如<code>Task.Yield</code>，还有<code>InvokeAsync</code>，它们也不会造成死锁。如果是控制台程序，或者一个普通的非UI线程，其<code>SynchronizationContext</code>为<code>null</code>，那么异步任务执行完后不需要回到原有线程，也不会造成死锁</p><h3 id="不会造成死锁的充分条件">不会造成死锁的充分条件</h3><ul><li>异步操作执行完后不需要回到原有线程（例如非 UI 线程和控制台线程）</li><li>异步操作不需要单独的线程执行任务</li></ul><h2 id="如何避免死锁">如何避免死锁?</h2><ul><li>在 UI 线程，如果使用了<code>async/await</code>，就尽量不要再使用<code>Task.Wait()/Task.Result</code>了，就一直异步一条路走到黑好了（微软称其为<code>Async All the Way</code>）</li><li>如果可能，尽量在异步任务后添加<code>.ConfigureAwait(false);</code>这样，异步任务后面继续执行的代码就不会回到原<code>UI</code>线程了，而是直接从线程池中再取出一个线程执行；这样，即便<code>UI</code>线程后续可能有别的原因造成阻塞，也不会产生死锁了；把原来的代码改成这样，就不会死锁了</li></ul><p>只能是一路 <code>async/await</code>。微软将其描述为：<code>async/await 会像病毒一样在你的代码中传播</code>。</p><blockquote><p>Others have also noticed the spreading behavior of asynchronous programming and have called it “contagious” or compared it to a zombie virus.</p></blockquote><p>这句话的原文参见：<a href="https://docs.microsoft.com/en-us/archive/msdn-magazine/2013/march/async-await-best-practices-in-asynchronous-programming">Async/Await - Best Practices in Asynchronous Programming</a></p><p>如果你是类库提供者，因为不确定调用者程序是<code>WPF</code>/<code>Winform</code>…，为了防止代码调用者在同步方法中使用<code>Wait()/Result</code>调用异步方法，还需要考虑添加<code>.ConfigureAwait(false);</code></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">async</span> Task <span class="title">DoAsync</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">await</span> Task.Run(() =&gt; &#123; &#125;).ConfigureAwait(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一句的目的是防止执行上下文切换回 UI 线程。</p><p>这样，即便真的使用 DoAsync().Wait() 也不会发生死锁。注意，整个方法调用链都需要使用 <code>.ConfigureAwait(false)</code> 才能够防止线程切换，在调用方的 Wait() 方法中发生死锁。</p><h2 id="更多死锁相关">更多死锁相关</h2><ul><li><a href="https://blog.walterlv.com/post/deadlock-in-task-wait.html">https://blog.walterlv.com/post/deadlock-in-task-wait.html</a></li><li><a href="https://blog.walterlv.com/post/deadlock-of-invoke-in-lazy.html">https://blog.walterlv.com/post/deadlock-of-invoke-in-lazy.html</a></li><li><a href="https://blog.walterlv.com/post/deadlock-if-await-in-ui-lock-context.html">https://blog.walterlv.com/post/deadlock-if-await-in-ui-lock-context.html</a></li><li><a href="https://blog.walterlv.com/post/task-wait-may-cause-long-time-waiting.html">https://blog.walterlv.com/post/task-wait-may-cause-long-time-waiting.html</a></li></ul><p><strong>解决方法</strong></p><ul><li><a href="https://blog.walterlv.com/post/using-configure-await-to-avoid-deadlocks.html">https://blog.walterlv.com/post/using-configure-await-to-avoid-deadlocks.html</a></li><li><a href="https://blog.walterlv.com/post/convert-async-to-sync-by-push-frame.html">https://blog.walterlv.com/post/convert-async-to-sync-by-push-frame.html</a></li></ul><p><strong>参考</strong></p><ul><li><a href="https://blog.csdn.net/WPwalter/article/details/78370706">https://blog.csdn.net/WPwalter/article/details/78370706</a></li><li><a href="https://docs.microsoft.com/en-us/archive/msdn-magazine/2013/march/async-await-best-practices-in-asynchronous-programming">https://docs.microsoft.com/en-us/archive/msdn-magazine/2013/march/async-await-best-practices-in-asynchronous-programming</a></li><li><a href="https://www.cnblogs.com/qingfenglin/p/12058267.html">https://www.cnblogs.com/qingfenglin/p/12058267.html</a></li><li><a href="https://www.cnblogs.com/liqingwen/p/5844095.html">https://www.cnblogs.com/liqingwen/p/5844095.html</a></li><li><a href="https://www.cnblogs.com/zhaoshujie/p/11082753.html">https://www.cnblogs.com/zhaoshujie/p/11082753.html</a></li><li><a href="https://q.cnblogs.com/q/107005/">https://q.cnblogs.com/q/107005/</a></li><li><a href="https://rubikscode.net/2018/06/11/asynchronous-programming-in-net-benefits-and-tradeoffs-of-using-valuetask/">https://rubikscode.net/2018/06/11/asynchronous-programming-in-net-benefits-and-tradeoffs-of-using-valuetask/</a></li><li><a href="https://blog.scooletz.com/2018/05/14/task-async-await-valuetask-ivaluetasksource-and-how-to-keep-your-sanity-in-modern-net-world/">https://blog.scooletz.com/2018/05/14/task-async-await-valuetask-ivaluetasksource-and-how-to-keep-your-sanity-in-modern-net-world/</a></li><li><a href="https://www.cnblogs.com/ms27946/p/understanding-task-valuetask.html">https://www.cnblogs.com/ms27946/p/understanding-task-valuetask.html</a></li><li><a href="https://www.cnblogs.com/ittranslator/p/13703279.html">https://www.cnblogs.com/ittranslator/p/13703279.html</a></li><li><a href="https://devblogs.microsoft.com/dotnet/understanding-the-whys-whats-and-whens-of-valuetask/">https://devblogs.microsoft.com/dotnet/understanding-the-whys-whats-and-whens-of-valuetask/</a></li><li><a href="https://www.cnblogs.com/wcrBlog/p/11690460.html">https://www.cnblogs.com/wcrBlog/p/11690460.html</a></li><li><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/async/async-return-types#generalized-async-return-types-and-valuetasktresult">https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/async/async-return-types#generalized-async-return-types-and-valuetasktresult</a></li><li><a href="https://q.cnblogs.com/q/124633/">https://q.cnblogs.com/q/124633/</a></li><li><a href="https://www.cnblogs.com/dudu/p/9860959.html#!comments">https://www.cnblogs.com/dudu/p/9860959.html#!comments</a></li><li><a href="http://labs.criteo.com/2018/10/net-threadpool-starvation-and-how-queuing-makes-it-worse/">http://labs.criteo.com/2018/10/net-threadpool-starvation-and-how-queuing-makes-it-worse/</a></li><li><a href="https://www.cnblogs.com/xishuai/p/asp-net-sync-over-async.html">https://www.cnblogs.com/xishuai/p/asp-net-sync-over-async.html</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/dotnet/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/dotnet/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="数组">数组</h1><p>数组是一种特殊类型的数据类型，它可以使用特殊语法 <strong>顺序存储固定数量的值。</strong></p><p><img src="http://www.tutorialsteacher.com/Content/images/csharp/array.png#align=left&amp;display=inline&amp;height=147&amp;margin=%5Bobject%20Object%5D&amp;originHeight=147&amp;originWidth=404&amp;status=done&amp;style=none&amp;width=404" alt=""></p><p>数组声明：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> [] intArr;</span><br></pre></td></tr></table></figure><p>数组初始化：使用<code>new</code>关键字同时声明和初始化数组，下面三种方式等价</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[] intArr = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">5</span>]; </span><br><span class="line"><span class="built_in">int</span>[] intArr = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">5</span>]&#123;<span class="number">1</span>， <span class="number">2</span>， <span class="number">3</span>， <span class="number">4</span>， <span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">int</span>[] intArr = &#123;<span class="number">1</span>， <span class="number">2</span>， <span class="number">3</span>， <span class="number">4</span>， <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><p>延迟初始化：可以先声明后再初始化数组</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>[] strArr， strArr;</span><br><span class="line">strArr = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">5</span>]&#123; <span class="string">&quot;1st Element&quot;</span>，<span class="string">&quot;2nd Element&quot;</span>， <span class="string">&quot;3rd Element&quot;</span>&#125;;</span><br><span class="line">strArr = <span class="keyword">new</span> <span class="built_in">string</span>[]&#123; <span class="string">&quot;1st Element&quot;</span>，<span class="string">&quot;2nd Element&quot;</span>， <span class="string">&quot;3rd Element&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><p>索引访问数组中元素：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">intArr[索引位置];</span><br></pre></td></tr></table></figure><p>常用方法和属性：</p><table><thead><tr><th style="text-align:left"><strong>方法名称</strong></th><th style="text-align:left"><strong>描述</strong></th></tr></thead><tbody><tr><td style="text-align:left">GetLength(int维度)</td><td style="text-align:left">返回指定维度中的元素数</td></tr><tr><td style="text-align:left">GetLowerBound(int维度)</td><td style="text-align:left">返回指定维度的最低索引</td></tr><tr><td style="text-align:left">GetUpperBound(int维度)</td><td style="text-align:left">返回指定维度的最高索引</td></tr><tr><td style="text-align:left">GetValue(int index)</td><td style="text-align:left">返回指定索引处的值</td></tr></tbody></table><table><thead><tr><th><strong>属性</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>Length</td><td>返回数组中元素的总数</td></tr></tbody></table><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">TestMethod</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ArrayDefinition</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 数组可以先声明后赋值,也可以声明同时赋值,下面的方式是等价的,数组中必须存储同一类型数据,这在数组被定义时就已经确定</span></span><br><span class="line">    <span class="comment">// 第一种</span></span><br><span class="line">    <span class="built_in">int</span>[] intArr = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">5</span>];</span><br><span class="line">    intArr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    intArr[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    intArr[<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">    intArr[<span class="number">3</span>] = <span class="number">4</span>;</span><br><span class="line">    intArr[<span class="number">4</span>] = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二种</span></span><br><span class="line">    <span class="built_in">int</span>[] intArr2 = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">5</span>] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三种</span></span><br><span class="line">    <span class="built_in">int</span>[] intArr3 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意这里是维度不是索引</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;GetLength(int维度):返回指定维度中的元素数,值为：&#123;0&#125;&quot;</span>, intArr.GetLength(<span class="number">0</span>));</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;GetLowerBound(int维度):返回指定维度的最低索引,值为：&#123;0&#125;&quot;</span>, intArr.GetLowerBound(<span class="number">0</span>));</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;GetUpperBound(int维度):返回指定维度的最高索引,值为：&#123;0&#125;&quot;</span>, intArr.GetUpperBound(<span class="number">0</span>));</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;GetValue(int index):返回指定索引处的值,值为：&#123;0&#125;&quot;</span>, intArr.GetValue(<span class="number">2</span>));</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;属性:Length:返回数组中元素的总数,值为：&#123;0&#125;&quot;</span>, intArr.Length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用索引来访问数组元素</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;使用索引访问数组元素,索引为2的值为：&#123;0&#125;&quot;</span>, intArr[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 试图访问数组中不存在的索引元素,会发生数组越界</span></span><br><span class="line">    Assert.ThrowsException&lt;IndexOutOfRangeException&gt;(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;使用索引访问数组元素,索引为10的值为：&#123;0&#125;&quot;</span>, intArr[<span class="number">10</span>]);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; intArr.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(intArr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> intArr)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Person p1 = <span class="keyword">new</span>() &#123; Address = <span class="string">&quot;wang&quot;</span> &#125;;</span><br><span class="line">    Person p2 = <span class="keyword">new</span>() &#123; Address = <span class="string">&quot;li&quot;</span> &#125;;</span><br><span class="line">    Person[] persons = <span class="keyword">new</span> Person[<span class="number">2</span>] &#123; p1, p2 &#125;;</span><br><span class="line">    Assert.AreEqual(<span class="string">&quot;wang&quot;</span>, persons[<span class="number">0</span>].Address);</span><br><span class="line">    Assert.AreEqual(<span class="string">&quot;li&quot;</span>, persons[<span class="number">1</span>].Address);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多维数组">多维数组</h2><p>多维数组是行和列的二维系列。多维数组又称为矩形数组；在本质上，是个一维数组的列表。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">TestMethod</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MultidimensionalArray</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 下面的两种创建方式等价</span></span><br><span class="line">    <span class="comment">// 第一种</span></span><br><span class="line">    <span class="built_in">int</span>[,] intArray1 = &#123; &#123; <span class="number">1</span>, <span class="number">1</span> &#125;, &#123; <span class="number">1</span>, <span class="number">2</span> &#125;, &#123; <span class="number">1</span>, <span class="number">3</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二种</span></span><br><span class="line">    <span class="built_in">int</span>[,] intArray2 = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">    &#123;    <span class="comment">/*  初始化化一个三行四列的数组 */</span></span><br><span class="line">           &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; ,                <span class="comment">/*  初始化索引号为 0 的行 */</span></span><br><span class="line">           &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125; ,                <span class="comment">/*  初始化索引号为 1 的行 */</span></span><br><span class="line">           &#123;<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125;                <span class="comment">/*  初始化索引号为 2 的行 */</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 获取数组中第3行第4个元素                                </span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;二维数组中的元素是通过使用下标（即数组的行索引和列索引）来访问,值为：&#123;0&#125;&quot;</span>, intArray2[<span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;属性:Length:返回数组中元素的总数,值为：&#123;0&#125;&quot;</span>, intArray1.Length);</span><br><span class="line">    Assert.AreEqual(<span class="number">11</span>, intArray2[<span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用两个索引访问多维数组的值。第一个索引用于行，第二个索引用于列。两个索引都从零开始。</p><h2 id="锯齿状数组">锯齿状数组</h2><p>锯齿状数组是数组的数组。<code>Jagged</code>数组直接存储数组而不是任何其他数据类型值。锯齿状数组用两个方括号 <code>[][]</code> 初始化。</p><p>第一个括号指定数组的大小，第二个括号指定将作为值存储的数组的维度。(锯齿状数组总是存储一个数组)，二维数组的大小是矩形的。</p><p><strong>例如：</strong> 3×3个元素。而锯齿数组的大小设置是比较灵活的，在锯齿数组中，每一行都可以有不同的大小</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">TestMethod</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">JaggedArray</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span>[][] intJaggedArray = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">2</span>][];</span><br><span class="line">    intJaggedArray[<span class="number">0</span>] = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">3</span>] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">    intJaggedArray[<span class="number">1</span>] = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">2</span>] &#123; <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line">    Assert.AreEqual(<span class="number">1</span>, intJaggedArray[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">    Assert.AreEqual(<span class="number">3</span>, intJaggedArray[<span class="number">0</span>][<span class="number">2</span>]);</span><br><span class="line">    Assert.AreEqual(<span class="number">5</span>, intJaggedArray[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Array">Array</h1><p>.NET提供了一个抽象类 <code>Array</code> ，作为所有数组的基类。它提供了用于创建，操作，搜索和排序数组的静态方法。</p><table><thead><tr><th><strong>属性</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>IsFixedSize</td><td>获取一个值，该值指示数组是否带有固定大小</td></tr><tr><td>IsReadOnly</td><td>获取一个值，该值指示数组是否只读</td></tr><tr><td>Length</td><td>获取一个 32 位整数，该值表示所有维度的数组中的元素总数</td></tr><tr><td>LongLength</td><td>获取一个 64 位整数，该值表示所有维度的数组中的元素总数</td></tr><tr><td>Rank</td><td>获取数组的秩（维度）</td></tr></tbody></table><table><thead><tr><th style="text-align:left"><strong>方法</strong></th><th style="text-align:left"><strong>描述</strong></th></tr></thead><tbody><tr><td style="text-align:left">Clear</td><td style="text-align:left">根据元素的类型，设置数组中某个范围的元素为零、为 false 或者为 null</td></tr><tr><td style="text-align:left">Copy(Array,Array,Int32)</td><td style="text-align:left">从数组的第一个元素开始复制某个范围的元素到另一个数组的第一个元素位置。长度由一个 32 位整数指定</td></tr><tr><td style="text-align:left">CopyTo(Array,Int32)</td><td style="text-align:left">从当前的一维数组中复制所有的元素到一个指定的一维数组的指定索引位置。索引由一个 32 位整数指定</td></tr><tr><td style="text-align:left">GetLength</td><td style="text-align:left">获取一个 32 位整数，该值表示指定维度的数组中的元素总数</td></tr><tr><td style="text-align:left">GetLongLength</td><td style="text-align:left">获取一个 64 位整数，该值表示指定维度的数组中的元素总数</td></tr><tr><td style="text-align:left">GetLowerBound</td><td style="text-align:left">获取数组中指定维度的下界</td></tr><tr><td style="text-align:left">GetType</td><td style="text-align:left">获取当前实例的类型。从对象（Object）继承</td></tr><tr><td style="text-align:left">GetUpperBound</td><td style="text-align:left">获取数组中指定维度的上界</td></tr><tr><td style="text-align:left">GetValue(Int32)</td><td style="text-align:left">获取一维数组中指定位置的值。索引由一个 32 位整数指定</td></tr><tr><td style="text-align:left">IndexOf(Array,Object)</td><td style="text-align:left">搜索指定的对象，返回整个一维数组中第一次出现的索引</td></tr><tr><td style="text-align:left">Reverse(Array)</td><td style="text-align:left">逆转整个一维数组中元素的顺序</td></tr><tr><td style="text-align:left">SetValue(Object, Int32)</td><td style="text-align:left">给一维数组中指定位置的元素设置值。索引由一个 32 位整数指定</td></tr><tr><td style="text-align:left">Sort(Array)</td><td style="text-align:left">使用数组的每个元素的 IComparable 实现来排序整个一维数组中的元素</td></tr><tr><td style="text-align:left">ToString</td><td style="text-align:left">返回一个表示当前对象的字符串。从对象（Object）继承</td></tr></tbody></table><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">TestMethod</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ArrayClass</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Array arr = Array.CreateInstance(<span class="keyword">typeof</span>(<span class="built_in">int</span>), <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 第一个参数是value,第二个参数是index</span></span><br><span class="line">        arr.SetValue(i, i);</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;IsFixedSize:数组是否带有固定大小,值为：&#123;0&#125;&quot;</span>, arr.IsFixedSize);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;IsReadOnly :数组是否只读,值为：&#123;0&#125;&quot;</span>, arr.IsReadOnly);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Length     :32位整数,数组元素总数,值为：&#123;0&#125;&quot;</span>, arr.Length);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;LongLength :64位整数,数组元素总数,值为：&#123;0&#125;&quot;</span>, arr.LongLength);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Rank       :数组的维度,值为：&#123;0&#125;&quot;</span>, arr.Rank);</span><br><span class="line"></span><br><span class="line">    Array.Clear(arr, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Assert.AreEqual(<span class="number">0</span>, arr.GetValue(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显式将arr转换为数组</span></span><br><span class="line">    <span class="built_in">int</span>[] arr2 = (<span class="built_in">int</span>[])arr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr2.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Assert.AreEqual(<span class="number">0</span>, arr2[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="非泛型集合">非泛型集合</h1><p>每个集合类都实现 <code>IEnumerable</code>接口，因此可以使用 <code>foreach</code> 循环访问集合中的值。<code>System.Collections</code> 命名空间中包括以下非泛型集合：</p><table><thead><tr><th style="text-align:left"><strong>类型</strong></th><th style="text-align:left"><strong>用法</strong></th></tr></thead><tbody><tr><td style="text-align:left">ArrayList</td><td style="text-align:left">ArrayList存储任何类型的对象，如数组。但是，当数组自动增长时，无需像数组那样指定ArrayList的大小</td></tr><tr><td style="text-align:left">SortedList</td><td style="text-align:left">SortedList存储键和值对。它默认按键的升序自动排列元素。C＃包括泛型和非泛型SortedList集合</td></tr><tr><td style="text-align:left">Stack</td><td style="text-align:left">Stack以LIFO样式存储值(后进先出)。它提供了一个Push()方法来添加一个值，Pop()和Peek()方法来检索值。C＃包括通用和非通用堆栈</td></tr><tr><td style="text-align:left">Queue</td><td style="text-align:left">队列以FIFO样式(先进先出)存储值。它保持添加值的顺序。它提供了一个Enqueue()方法来添加值，还提供了一个Dequeue()方法来从集合中检索值。C＃包括通用和非通用队列</td></tr><tr><td style="text-align:left">Hashtable</td><td style="text-align:left">Hashtable存储键和值对。它通过比较键的哈希值来检索值</td></tr><tr><td style="text-align:left">BitArray</td><td style="text-align:left">BitArray管理一个紧凑的位值数组，表示为布尔值，其中true表示该位为on(1)，false表示该位为off(0)</td></tr></tbody></table><h2 id="ArrayList">ArrayList</h2><p>可以包含任何数据类型的元素。类似于数组，但是在添加元素时不需要指定大小， <code>ArrayList</code> 的大小会自动增长。</p><p>要点：</p><ul><li>可以存储任何数据类型的项(元素)</li><li>添加元素时会自动调整大小</li><li>可以包含多个<code>null</code></li><li>可以使用 <code>foreach</code> 或 <code>for</code> 循环或索引器访问</li></ul><table><thead><tr><th><strong>属性</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>Capacity</td><td>获取或设置ArrayList可以包含的元素数</td></tr><tr><td>Count</td><td>获取ArrayList中实际包含的元素数</td></tr><tr><td>IsFixedSize</td><td>获取一个值，该值指示ArrayList是否具有固定大小</td></tr><tr><td>IsReadOnly</td><td>获取一个值，该值指示ArrayList是否为只读</td></tr><tr><td>Item</td><td>获取或设置指定索引处的元素</td></tr></tbody></table><table><thead><tr><th><strong>方法</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>Add()/AddRange()</td><td>Add()方法在ArrayList的末尾添加单个元素。 AddRange()方法将指定集合中的所有元素添加到ArrayList中</td></tr><tr><td>Insert()/InsertRange()</td><td>Insert()方法在ArrayList中的指定索引处插入单个元素。 InsertRange()方法从ArrayList中的指定索引开始插入指定collection的所有元素</td></tr><tr><td>Remove()/RemoveRange()</td><td>Remove()方法从ArrayList中删除指定的元素。 RemoveRange()方法从ArrayList中删除一系列元素</td></tr><tr><td>RemoveAt()</td><td>从ArrayList中删除指定索引处的元素</td></tr><tr><td>Sort()</td><td>对ArrayList的整个元素进行排序</td></tr><tr><td>Reverse()</td><td>反转整个ArrayList中元素的顺序</td></tr><tr><td>Contains</td><td>检查ArrayList中是否存在指定的元素。如果存在则返回true，否则返回false</td></tr><tr><td>Clear</td><td>删除ArrayList中的所有元素</td></tr><tr><td>CopyTo</td><td>将所有元素或元素范围复制到compitible Array</td></tr><tr><td>GetRange</td><td>从ArrayList返回指定索引中指定数量的元素</td></tr><tr><td>IndexOf</td><td>搜索指定的元素并返回零基索引(如果找到)。如果找不到元素，则返回-1</td></tr><tr><td>ToArray</td><td>从ArrayList返回compitible数组</td></tr></tbody></table><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">TestMethod</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ArrayList</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ArrayList arrayList = <span class="keyword">new</span>();</span><br><span class="line">    arrayList.Add(<span class="string">&quot;wang&quot;</span>);</span><br><span class="line">    arrayList.Add(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// ArrayList允许插入null</span></span><br><span class="line">    arrayList.Add(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> arrayList)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(item);</span><br><span class="line">    &#125;</span><br><span class="line">    Assert.AreEqual(<span class="string">&quot;wang&quot;</span>, arrayList[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SortedList">SortedList</h2><p><code>SortedList</code> 集合默认按键的升序存储键值对。<code>SortedList</code> 类实现了 <code>IDictionary</code> 和 <code>ICollection</code> 接口，因此可以通过键和索引访问元素。</p><p>要点：</p><ul><li>C#具有泛型和非泛型 <code>SortedList</code></li><li><code>SortedList</code> 按键的升序存储键值对。键必须是唯一的，不能为<code>null</code>，而值可以为<code>null</code>或重复项</li><li>非泛型 <code>SortedList</code> 存储任何数据类型的键和值。因此，需要将值转换为适当的数据类型</li><li>键值对可以强制转换为 <code>DictionaryEntry</code></li><li>使用索引器访问单个值。<code>SortedList</code> 索引器接受键并返回与之关联的值</li></ul><table><thead><tr><th><strong>属性</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>Capacity</td><td>获取或设置SortedList实例可以存储的元素数</td></tr><tr><td>Count</td><td>获取SortedList中实际包含的元素数</td></tr><tr><td>IsFixedSize</td><td>获取SortedList中实际包含的元素数</td></tr><tr><td>IsReadOnly</td><td>获取一个值，该值指示SortedList是否为只读</td></tr><tr><td>Item</td><td>获取或设置SortedList中指定键的元素</td></tr><tr><td>Keys</td><td>获取SortedList的键列表</td></tr><tr><td>Values</td><td>获取SortedList中的值列表</td></tr></tbody></table><table><thead><tr><th><strong>方法</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>Add(object key， object value)</td><td>将键值对添加到SortedList中</td></tr><tr><td>Remove(object key)</td><td>删除具有指定键的元素</td></tr><tr><td>RemoveAt(int index)</td><td>删除指定索引处的元素</td></tr><tr><td>Contains(object key)</td><td>检查SortedList中是否存在指定的键</td></tr><tr><td>Clear()</td><td>从SortedList中删除所有元素</td></tr><tr><td>GetByIndex(int index)</td><td>返回存储在内部数组中的索引值</td></tr><tr><td>GetKey(int index)</td><td>检返回存储在内部数组中指定索引处的键</td></tr><tr><td>IndexOfKey(object key)</td><td>返回存储在内部数组中的指定键的索引</td></tr><tr><td>IndexOfValue(object value)</td><td>返回存储在内部数组中的指定值的索引</td></tr></tbody></table><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">TestMethod</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SortedList</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    SortedList sortedList = <span class="keyword">new</span>();</span><br><span class="line">    sortedList.Add(<span class="number">2</span>, <span class="string">&quot;wang&quot;</span>);</span><br><span class="line">    sortedList.Add(<span class="number">5</span>, <span class="string">&quot;li&quot;</span>);</span><br><span class="line">    sortedList.Add(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SortedList键可以是任何数据类型，但不能在同一SortedList中添加不同数据类型的键。</span></span><br><span class="line">    Assert.ThrowsException&lt;InvalidOperationException&gt;(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        sortedList.Add(<span class="string">&quot;wang&quot;</span>, <span class="number">32</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; sortedList.Count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;key:&#123;0&#125;，value:&#123;1&#125;&quot;</span>, sortedList.GetKey(i), sortedList.GetByIndex(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (DictionaryEntry item <span class="keyword">in</span> sortedList)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;key:&#123;0&#125;，value:&#123;1&#125;&quot;</span>, item.Key, item.Value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Stack">Stack</h2><p>以 <code>LIFO</code> 样式存储元素（后进先出）。C#包括通用和非通用堆栈，非泛型堆栈。<code>Stack</code>允许空值以及重复值。它提供了一个 <code>Push()</code> 方法来添加一个值， <code>Pop()</code> 或 <code>Peek()</code> 方法来检索值。</p><p>要点：</p><ul><li>最后添加的元素将是首先出现的元素<code>LIFO(后进先出)</code></li><li>使用 <code>Push()</code> 方法添加元素</li><li><code>Pop() </code>方法返回并从堆栈顶部删除元素。在空 <code>Stack</code> 上调用 <code>Pop()</code> 方法将引发异常</li><li><code>Peek()</code> 方法返回 <code>Stack</code> 中最顶层的元素</li></ul><p><img src="http://www.tutorialsteacher.com/Content/images/csharp/stack.png#align=left&amp;display=inline&amp;height=223&amp;margin=%5Bobject%20Object%5D&amp;originHeight=254&amp;originWidth=296&amp;status=done&amp;style=none&amp;width=260" alt=""></p><table><thead><tr><th><strong>属性</strong></th><th><strong>方法</strong></th></tr></thead><tbody><tr><td>Count</td><td>返回Stack中元素的总数</td></tr></tbody></table><table><thead><tr><th style="text-align:left"><strong>方法</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td style="text-align:left">Push</td><td>在堆栈顶部插入一个项目</td></tr><tr><td style="text-align:left">Peek</td><td>返回堆栈中的顶部项</td></tr><tr><td style="text-align:left">Pop</td><td>从堆栈顶部删除并返回项目</td></tr><tr><td style="text-align:left">Contains</td><td>检查堆栈中是否存在项目</td></tr><tr><td style="text-align:left">Clear</td><td>从堆栈中删除所有项目</td></tr></tbody></table><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">TestMethod</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Stack</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Stack stack = <span class="keyword">new</span>();</span><br><span class="line">    stack.Push(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    stack.Push(<span class="number">1</span>);</span><br><span class="line">    stack.Push(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> stack)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Queue">Queue</h2><p>以<code>FIFO</code>样式(先进先出)存储元素。与<code>Stack</code>集合完全相反，它按照添加顺序包含元素。队列集合允许多个空值和重复值。使用 <code>Enqueue()</code> 方法添加值，使用<code>Dequeue()</code>方法从队列中检索值。</p><p>要点：</p><ul><li>首先添加的元素将首先出现<code>FIFO(先进先出)</code></li><li>使用<code>Enqueue()</code>方法添加元素</li><li><code>Dequeue()</code>方法返回并从队列的开头删除元素。在空队列上调用<code>Dequeue()</code>方法将引发异常</li><li><code>Peek()</code>方法总是返回最顶层的元素</li></ul><p><img src="http://www.tutorialsteacher.com/Content/images/csharp/csharp-queue.png#align=left&amp;display=inline&amp;height=221&amp;margin=%5Bobject%20Object%5D&amp;originHeight=221&amp;originWidth=460&amp;status=done&amp;style=none&amp;width=460" alt=""></p><table><thead><tr><th><strong>属性</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>Count</td><td>返回Stack中元素的总数</td></tr></tbody></table><table><thead><tr><th><strong>方法</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>Enqueue</td><td>将项添加到队列中</td></tr><tr><td>Dequeue</td><td>从队列的开头删除并返回一个项目</td></tr><tr><td>Peek</td><td>返回队列中的第一个项目</td></tr><tr><td>Contains</td><td>检查项目是否在队列中</td></tr><tr><td>Clear</td><td>从队列中删除所有项目</td></tr><tr><td>TrimToSize</td><td>将队列的容量设置为队列中的实际项目数</td></tr></tbody></table><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">TestMethod</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Queue</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Queue queue = <span class="keyword">new</span>();</span><br><span class="line">    queue.Enqueue(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    queue.Enqueue(<span class="number">1</span>);</span><br><span class="line">    queue.Enqueue(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> queue)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Hashtable">Hashtable</h2><p>类似于通用字典集合。<code>Hashtable</code>集合存储键值对。通过计算每个密钥的哈希码来优化查找，并在内部将其存储在不同的存储桶中，然后在访问值时匹配指定密钥的哈希码。</p><p>要点：</p><ul><li>存储<code>Key</code>必须唯一的任何数据类型的键值对</li><li>键不能为<code>null</code>，而值可以为<code>null</code></li><li>通过比较键的哈希码来检索项目。因此性能比 <code>Dictionary</code> 集合慢</li><li>使用默认的哈希码提供程序，即 <code>object.GetHash()</code>。还可以使用自定义哈希码提供程序</li><li>将 <code>DictionaryEntry</code> 与 <code>foreach</code> 语句一起使用以迭代 <code>Hashtable</code></li></ul><table><thead><tr><th><strong>属性</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>Count</td><td>获取Hashtable中键/值对的总数</td></tr><tr><td>IsReadOnly</td><td>获取布尔值，指示Hashtable是否为只读</td></tr><tr><td>Item</td><td>获取或设置与指定键关联的值</td></tr><tr><td>Keys</td><td>获取Hashtable中的键的ICollection</td></tr><tr><td>Values</td><td>获取Hashtable中值的ICollection</td></tr></tbody></table><table><thead><tr><th><strong>方法</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>Add</td><td>将具有键和值的项添加到哈希表中</td></tr><tr><td>Remove</td><td>从散列表中删除具有指定键的项</td></tr><tr><td>Clear</td><td>从哈希表中删除所有项目</td></tr><tr><td>Contains</td><td>检查哈希表是否包含特定密钥</td></tr><tr><td>ContainsKey</td><td>检查哈希表是否包含特定密钥</td></tr><tr><td>ContainsValue</td><td>检查哈希表是否包含特定值</td></tr><tr><td>GetHash</td><td>返回指定键的哈希码</td></tr></tbody></table><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">TestMethod</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Hashtable</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Hashtable hashtable = <span class="keyword">new</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        &#123; <span class="number">1</span>, <span class="string">&quot;wang&quot;</span> &#125;,</span><br><span class="line">        &#123; <span class="number">3</span>, <span class="literal">false</span> &#125;,</span><br><span class="line">        &#123; <span class="number">2</span>, <span class="string">&quot;li&quot;</span> &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (DictionaryEntry item <span class="keyword">in</span> hashtable)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;key:&#123;0&#125;, value:&#123;1&#125;&quot;</span>, item.Key, item.Value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BitArray">BitArray</h2><p><code>BitArray</code> 类管理一个紧凑型的位值数组，它使用布尔值来表示，其中<code>true</code>表示位是开启的(1)，false 表示位是关闭的(0)。当需要存储位但是事先不知道位数时，则使用点阵列。可以使用整型索引从点阵列集合中访问各项，索引从零开始。</p><table><thead><tr><th><strong>属性</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>Count</td><td>获取 BitArray 中包含的元素个数。</td></tr><tr><td>IsReadOnly</td><td>获取一个值，表示 BitArray 是否只读。</td></tr><tr><td>Item</td><td>获取或设置 BitArray 中指定位置的位的值。</td></tr><tr><td>Length</td><td>获取或设置 BitArray 中的元素个数。</td></tr></tbody></table><table><thead><tr><th><strong>方法</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>public BitArray And( BitArray value );</td><td>对当前的 BitArray 中的元素和指定的 BitArray 中的相对应的元素执行按位与操作。</td></tr><tr><td>public bool Get( int index );</td><td>获取 BitArray 中指定位置的位的值。</td></tr><tr><td>public BitArray Not();</td><td>把当前的 BitArray 中的位值反转，以便设置为 true 的元素变为 false，设置为 false 的元素变为 true。</td></tr><tr><td>public BitArray Or( BitArray value );</td><td>对当前的 BitArray 中的元素和指定的 BitArray 中的相对应的元素执行按位或操作。</td></tr><tr><td>public void Set( int index, bool value );</td><td>把 BitArray 中指定位置的位设置为指定的值。</td></tr><tr><td>public void SetAll( bool value );</td><td>把 BitArray 中的所有位设置为指定的值。</td></tr><tr><td>public BitArray Xor( BitArray value );</td><td>对当前的 BitArray 中的元素和指定的 BitArray 中的相对应的元素执行按位异或操作。</td></tr></tbody></table><h1 id="泛型集合">泛型集合</h1><p>同传统的集合相比，泛型集合是一种强类型的集合，它解决了类型安全问题，同时避免了集合中每次的装箱与拆箱的操作，提升了性能。</p><h2 id="List-T"><code>List&lt;T&gt;</code></h2><p><code>List&lt;T&gt;</code> 在C#应用程序中是一种快捷、易于使用的泛型集合类型，使用泛型编程为编写面向对象程序增加了极大的效率和灵活性，不会强行对值类型进行装箱和拆箱，或对引用类型进行向下强制类型转换。</p><table><thead><tr><th><strong>名称</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>Add</td><td>将对象添加到 List的结尾处</td></tr><tr><td>AddRange</td><td>将指定集合的元素添加到 List的末尾</td></tr><tr><td>AsReadOnly</td><td>返回当前集合的只读 IList包装</td></tr><tr><td>BinarySearch(T)</td><td>使用默认的比较器在整个已排序的 List中搜索元素，并返回该元素从零开始的索引</td></tr><tr><td>BinarySearch(T, IComparer)</td><td>使用指定的比较器在整个已排序的 List中搜索元素，并返回该元素从零开始的索引</td></tr><tr><td>BinarySearch(Int32, Int32, T, IComparer)</td><td>使用指定的比较器在已排序 List的某个元素范围中搜索元素，并返回该元素从零开始的索引</td></tr><tr><td>Clear</td><td>从 List中移除所有元素</td></tr><tr><td>Contains</td><td>确定某元素是否在 List中</td></tr><tr><td>ConvertAll</td><td>将当前 List&lt;T中的元素转换为另一种类型，并返回包含转换后的元素的列表</td></tr><tr><td>CopyTo(T[])</td><td>将整个 List&lt;T复制到兼容的一维数组中，从目标数组的开头开始放置</td></tr><tr><td>Exists</td><td>确定 List&lt;T是否包含与指定谓词所定义的条件相匹配的元素</td></tr><tr><td>Find</td><td>搜索与指定谓词所定义的条件相匹配的元素，并返回整个 List中的第一个匹配 元素</td></tr><tr><td>FindIndex(Predicate)</td><td>搜索与指定谓词所定义的条件相匹配的元素，并返回整个List 中第一个匹配元素的从零开始的索引</td></tr><tr><td>ForEach</td><td>对 List的每个元素执行指定操作。  GetEnumerator  返回循环访问 List的枚举器</td></tr><tr><td>IndexOf(T)</td><td>搜索指定的对象，并返回整个 List中第一个匹配项的从零开始的索引</td></tr><tr><td>Insert</td><td>将元素插入 List的指定索引处</td></tr><tr><td>InsertRange</td><td>将集合中的某个元素插入 List的指定索引处</td></tr><tr><td>LastIndexOf(T)</td><td>搜索指定的对象，并返回整个 List中最后一个匹配项的从零开始的索引</td></tr><tr><td>Remove</td><td>从 List中移除特定对象的第一个匹配项</td></tr><tr><td>Reverse()</td><td>将整个 List中元素的顺序反转</td></tr><tr><td>Sort()</td><td>使用默认比较器对整个 List中的元素进行排序</td></tr></tbody></table><h2 id="Stack-T"><code>Stack&lt;T&gt;</code></h2><p>以 <strong>后进先出</strong> 的方式维护数据的集合，包含 <code>pop()</code> 和 <code>push()</code> 从栈内压入或移除数据。</p><h2 id="Quenue-T"><code>Quenue&lt;T&gt;</code></h2><p>以 <strong>先进先出</strong> 的方式访问数据，使用 <code>Enqueue()</code> 和 <code>Dequeue()</code>添加数据和移除数据。</p><h2 id="SortedSet-T"><code>SortedSet&lt;T&gt;</code></h2><p>这个类中的数据是排序的，在插入和移除数据之后仍然能自动排序，需要向其构造函数中传递一个实现了<code>IComparer&lt;T&gt;</code>，该接口定义了<code>Compare</code>方法。</p><h2 id="ObservableCollection-T"><code>ObservableCollection&lt;T&gt;</code></h2><p>表示能在添加、移除或者刷新整个列表时提供通知的动态数据集合， <code>ReadOnlyObservableCollection&lt;T&gt;</code> 的操作与之类似，不过是只读的<code>ObservableCollection&lt;T&gt;</code> 实现了一个名为<code>CollectionChanged</code>事件，该事件在插入新的数据或者移除数据时触发。</p><h2 id="Dictionary-k-v"><code>Dictionary&lt;k,v&gt;</code></h2><p>提供快速的基于键值的元素查找。结构是：<code>Dictionary &lt;[key],[value]&gt;</code>，当有很多元素的时候可以用它。在使用前，必须声明它的键类型和值类型。</p><h1 id="数组池">数组池</h1><p>如果需要多次创建/销毁数组,为了减少GC操作,可以通过ArrayPool类使用数组池</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">TestMethod</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ArrayPool</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// maxArrayLengthDefaultValue: 1024 * 1024</span></span><br><span class="line">    <span class="comment">// maxArraysPerBucketDefaultValue: 50</span></span><br><span class="line">    ArrayPool&lt;<span class="built_in">int</span>&gt; arrayPool = ArrayPool&lt;<span class="built_in">int</span>&gt;</span><br><span class="line">        .Create(maxArrayLength: <span class="number">4000</span>, maxArraysPerBucket: <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用预定义的共享池</span></span><br><span class="line">    ArrayPool&lt;<span class="built_in">int</span>&gt; sharePool = ArrayPool&lt;<span class="built_in">int</span>&gt;.Shared;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;arrayPool&#125;</span>,<span class="subst">&#123;sharePool&#125;</span>&quot;</span>);</span><br><span class="line">    Assert.IsTrue(sharePool != <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数组-ArrayList-List区别">数组/ArrayList/List区别</h1><ul><li>数组：针对特定类型固定长度，值不可为<code>null</code>，在声明数组的时候必须指定数组的长度，可有多个维度</li><li>Array：数组的另一种创建方式抽象类，作为所有数组的基类，针对任意类型固定长度，值可以为<code>null</code>，输出会被替换为0</li><li>ArrayList：针对任意类型、任意长度的，值可以为<code>null</code>，存储或检索值类型时通常发生装箱和拆箱操作，带来很大的性能耗损</li><li>List：强类型的集合，固定类型、任意长度，值不可为<code>null</code>，是类型安全的</li></ul><h1 id="枚举器">枚举器</h1><h1 id="迭代器">迭代器</h1><h1 id="索引器">索引器</h1><p><code>Indexer </code>是一种特殊类型的属性，允许以访问数组相同的方式访问类或结构。除了使用带有方括号和参数的此关键字定义的属性外，它与属性相同。</p><ul><li>索引器与属性相同，除了它使用带有方括号的此关键字定义，该参数具有参数</li><li>可以通过具有不同类型的参数来覆盖索引器</li><li>不支持使用索引器的<code>Ref</code>和<code>out</code>参数</li><li>索引器可以作为接口成员包含在内</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;<span class="keyword">return</span> typethis[&lt;parameter typeindex]</span><br><span class="line">&#123;</span><br><span class="line">    Get&#123;</span><br><span class="line">    <span class="comment">// return the value from the specified index</span></span><br><span class="line">    &#125;</span><br><span class="line">    Set&#123;</span><br><span class="line">    <span class="comment">// set values at the specified index</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Indexer</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">int</span>[] indexs = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> <span class="keyword">this</span>[<span class="built_in">int</span> index]</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span> &#123; <span class="keyword">return</span> indexs[index]; &#125;</span><br><span class="line">            <span class="keyword">set</span></span><br><span class="line">            &#123;</span><br><span class="line">                indexs[index] = <span class="keyword">value</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Indexer是一种特殊类型的属性，允许以与其内部集合的数组相同的方式访问类或结构。</span></span><br><span class="line"><span class="comment">除了使用带有方括号和参数的此关键字定义的属性外，它与属性相同。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;********************索引器*********************&quot;</span>);</span><br><span class="line"></span><br><span class="line">Indexer indexer = <span class="keyword">new</span> Indexer();</span><br><span class="line">indexer[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">indexer[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">Console.WriteLine(indexer[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/dotnet/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
      <url>/dotnet/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="类（Class）">类（Class）</h1><p>类中的数据和函数称为类的成员，除了这些成员外，类还可以包含嵌套的类型(如其它类)，成员的可访问性有：</p><ul><li><code>public</code></li><li><code>protected</code></li><li><code>internalprotected</code></li><li><code>private</code></li><li><code>internal</code></li></ul><h2 id="数据成员">数据成员</h2><p>数据成员是包含类的数据：字段、常量和事件的成员，数据成员可以是静态数据，类成员总是实例成员，除非用 <code>static</code> 进行显式声明。</p><h2 id="函数成员">函数成员</h2><p>函数成员提供了操作类中数据的某些功能，包括方法、属性、构造函数和终结器、运算符以及索引器</p><ul><li>方法是与某个类相关的函数，与数据成员一样，函数成员默认为实例成员，使用 <code>static</code> 修饰符可以把方法定义为静态方法</li><li>属性是可以从客户端访问的函数组，访问方式与访问类的公共字段类似，<code>C#</code>为读写类中的属性提供了专用语法，所以不必使用名称中嵌有<code>Get</code> 或 <code>set</code>的方法</li><li>构造函数是在实例化对象时自动调用的特殊函数，必须与所属的类同名，且不能有返回类型，构造函数用于初始化字段的值</li><li>终结器类似于构造函数，在<code>CLR</code> 检测到不再需要某个对象时调用它，它们名称与类相同，但前面有一个 <code>~</code></li><li>运算符执行的最简单的操作就是加法和减法。 两个整数相加时严格地说是对整数使用 <code>+</code> 运算符，C#允许指定把已有的运算符应用于自己的类（<strong>运算符重载</strong>）</li><li>索引器允许对象以数组或集合的方式进行索引</li></ul><h1 id="方法（Method）">方法（Method）</h1><h2 id="方法声明">方法声明</h2><p>C#中方法的定义包括：任意方法修饰符(如方法的可访问性)、返回值的类型，然后依次是方法名和输入参数的列表和方法体。每个参数都包括参数的类型名和在方法体中的引用名称。 如果方法有返回值， <code>return</code> 语句就必须与返回值一起使用。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">modifiers</span>] <span class="function">return_type <span class="title">MethodName</span>(<span class="params">[parameters]</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">      <span class="comment">// Method body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 实例方法</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Show</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Test下实例方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 静态方法属于类本身</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Show2</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Test下静态方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法调用">方法调用</h2><p>在实例化类得到类的对象后，即可通过 <code>对象.方法名称</code> 进行方法的调用。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例方法调用</span></span><br><span class="line">Test test = <span class="keyword">new</span> Test();</span><br><span class="line">test.Show();</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态方法调用</span></span><br><span class="line">Test.Show2();</span><br></pre></td></tr></table></figure><blockquote><p>注意：使用 <code>static</code> 修饰的方法属于类的本身，无法使用类的实例化对象进行调用，使用类名.方法名即可</p></blockquote><h2 id="表达式方法体">表达式方法体</h2><p>如果方法的实现只有一条语句，C# 为方法定义提供了一个简化的语法：表达式体方法，使用 <code>=&gt;</code> 区分操作符左边的声明和操作符右边的实现代码。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintName</span>(<span class="params"></span>)</span> =&gt; Console.WriteLine(_name);</span><br></pre></td></tr></table></figure><h2 id="命名参数">命名参数</h2><p>参数一般需要按定义的顺序传送给方法，命名参数允许按任意顺序传递。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//下面两种调用方式结果是一样的</span></span><br><span class="line">        Print(<span class="string">&quot;hello&quot;</span>， <span class="string">&quot;world&quot;</span>);</span><br><span class="line">        Print(b: <span class="string">&quot;world&quot;</span>， a: <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Print</span>(<span class="params"><span class="built_in">string</span> a， <span class="built_in">string</span> b</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;&#123;0&#125;，&#123;1&#125;&quot;</span>， a， b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可选参数">可选参数</h2><p>参数也可以是可选的，必须为可选参数提供默认值，可选参数还必须是方法定义的最后一个参数。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Print</span>(<span class="params"><span class="built_in">string</span> a， <span class="built_in">string</span> b = <span class="string">&quot;world&quot;</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;&#123;0&#125;，&#123;1&#125;&quot;</span>， a， b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Print(<span class="string">&quot;hello&quot;</span>);<span class="comment">//输出hello，world</span></span><br><span class="line">Print(<span class="string">&quot;hello&quot;</span>，<span class="string">&quot;wang&quot;</span>);<span class="comment">//输出hello，wang</span></span><br></pre></td></tr></table></figure><h2 id="个数可变的参数">个数可变的参数</h2><p>使用 <code>params[]</code> 数组的方式可以定义数量可变的参数，如果 <code>params[]</code> 关键字与方法签名定义的多个参数一起使用，则只能使用一次，而且必须是最后一个参数。</p><h2 id="方法重载">方法重载</h2><p>方法名相同，但参数的个数或类型不同。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Print</span>(<span class="params"><span class="built_in">string</span> a</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;&#123;0&#125;&quot;</span>， a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Print</span>(<span class="params"><span class="built_in">string</span> a， <span class="built_in">string</span> b = <span class="string">&quot;world&quot;</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">     Console.WriteLine(<span class="string">&quot;&#123;0&#125;，&#123;1&#125;&quot;</span>， a， b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><p>两个方法不能仅在返回类型上有区别</p><p>两个方法不能仅根据参数是声明为 <code>ref</code> 还是 <code>out</code> 来区分</p><h1 id="属性（Property）">属性（Property）</h1><p>它是一个方法或一对方法，在客户端代码看来，它(们)是一个字段。</p><h2 id="属性定义">属性定义</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> SomeProperty</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;This is the property value&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//type string</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="只读和只写属性">只读和只写属性</h2><p>在属性定义中省略 <code>set</code> 访问器，就可以创建只读属性；同样在属性定义中省略 <code>get</code> 访问器，就可以创建只写属性。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="comment">//只读属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Age</span><br><span class="line">    &#123;        </span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> age;</span><br><span class="line">        &#125;           </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//只写属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name</span><br><span class="line">    &#123;        </span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">value</span>= name;</span><br><span class="line">        &#125;           </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="属性的访问修饰符">属性的访问修饰符</h2><p>C# 允许给属性的 <code>get</code> 和  <code>set</code> 访问器设置不同的访问修饰符，所以属性可以有公有的 <code>get</code> 访问器和私有或受保护的 <code>set</code> 访问器。有助于控制属性的设置方式。</p><h2 id="自动实现的属性">自动实现的属性</h2><p>如果属性的 <code>get</code> 和  <code>set</code> 访问器中没有任何逻辑，就可以使用自动实现的属性，使用自动实现的属性，就不能在属性设置中验证属性的有效性。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="构造函数">构造函数</h1><p>声明基本构造函数的语法就是声明一个与包含的类同名的方法，但该方法没有返回类型。</p><h2 id="构造函数声明">构造函数声明</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">   Person()</span><br><span class="line">   &#123;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：没有必要给类显式提供构造函数，原因在于：如果没有在类中没有提供任何构造函数，编译器会在后台创建一个默认的无参构造函数用来把所有的成员字段初始化为标准的默认值。</p><h2 id="构造函数重载">构造函数重载</h2><p>构造函数重载遵循与其他方法相同的规则，就是说允许为构造函数提供任意多的重载。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//调用无参构造函数实例化对象</span></span><br><span class="line">        Person person1 = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用带参数的构造函数实例化对象</span></span><br><span class="line">        Person person2 = <span class="keyword">new</span> Person(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//因为带name参数的构造函数是private的，所以这里无法实例化</span></span><br><span class="line">        <span class="comment">//Person person3 = new Person(20， &quot;wang&quot;);</span></span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">int</span> age</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//使用this关键字区分成员字段和同名参数</span></span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Person</span>(<span class="params"><span class="built_in">int</span> age， <span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name;       </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Person</span>(<span class="params"><span class="built_in">int</span> age， <span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子没有为 <code>Person</code> 类定义任何公有的或受保护的构造函数。这就使 <code>Person</code> 不能使用 <code>new</code> 运算符在外部代码中实例化(但可以在 <code>Person</code> 中编写一个公有静态属性或方法，以实例化该类)。 这在下面两种情况下是有用的：</p><ul><li>类仅用作某些静态成员或属性的容器，因此永远不会实例化它</li><li>希望类仅通过调用某个静态成员函数来实例化(单例模式）</li></ul><p><strong>注意</strong>：如果提供了带参数的构造函数，编译器就不会隐式的自动创建默认的构造函数。</p><h2 id="构造函数初始化器">构造函数初始化器</h2><p>有时，在一个类中有几个构造函数，以容纳某些可选参数，这些构造函数包含一些共同的代码。需要做到从构造函数中调用其他构造函数时可以使用构造函数初始化器。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Person person1 = <span class="keyword">new</span> Person(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        Person person2 = <span class="keyword">new</span> Person(<span class="number">20</span>， <span class="string">&quot;li&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;person1:age=&#123;0&#125;，name=&#123;1&#125;&quot;</span>， person1.age， person1.name);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;person2:age=&#123;0&#125;，name=&#123;1&#125;&quot;</span>， person2.age， person2.name);</span><br><span class="line"></span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">int</span> age</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">&quot;wang&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">int</span> age， <span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子是一个简单的构造函数重载，然后通过调用不同的构造函数实例化对象，<code>Person</code> 类的两个构造函数初始化了相同的字段 <code>age</code> ，显然最好把所有的代码放在一个地方，C#中使用构造函数初始化器，可以实现此目的：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Person person1 = <span class="keyword">new</span> Person(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        Person person2 = <span class="keyword">new</span> Person(<span class="number">20</span>， <span class="string">&quot;li&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;person1:age=&#123;0&#125;，name=&#123;1&#125;&quot;</span>， person1.age， person1.name);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;person2:age=&#123;0&#125;，name=&#123;1&#125;&quot;</span>， person2.age， person2.name);</span><br><span class="line"></span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">int</span> age</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">&quot;wang&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">int</span> age， <span class="built_in">string</span> name</span>) : <span class="title">this</span>(<span class="params">age</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 <code>this</code> 关键字仅调用参数最匹配的那个构造函数。</p><p><strong>注意</strong>：构造函数初始化器在构造函数的函数体之前执行。C#构造函数初始化器可以包含对同一个类的另一个构造函数的调用(使用前面介绍的语法)，也可以包含对直接基类的构造函数的调用(使用相同的语法，但应使用<code>base</code>关键字代替 <code>this</code>。初始化器中不能有多个调用。</p><h1 id="静态类">静态类</h1><p>如果类只包含静态的方法和属性，该类就是静态的。静态类在功能上与使用私有静态函数创建的类相同，不能创建静态类的实例。</p><h1 id="静态构造函数">静态构造函数</h1><p>静态构造函数只执行一次，而前面的构造函数是实例构造函数，只要创建类的对象，就会被执行。编写静态构造函数的一个原因是，类有一些静态字段或属性，需要在第一次使用类之前，从外部源中初始化这些静态字段和属性。</p><blockquote><p>注意：.Net 运行库没有确保什么时候执行静态构造函数，所以不应把要求在某个特定时刻(例如，加载程序集时)执行的代码放在静态构造函数中。也不能预计不同类的静态构造函数按照什么顺序执行。但是，可以确保静态构造函数最多运行一次，即在代码引用类之前调用它</p></blockquote><p>在C#中，通常在第一次调用类的任何成员之前执行静态构造函数。静态构造函数没有访问修饰符，其他C#代码从来不调用它，但在加载类时，总是由.NET运行库调用它，所以像 <code>public</code>  或  <code>private</code>  这样的访问修饰符就没有任何意义。出于同样原因，静态构造函数不能带任何参数，一个类也只能有一个静态构造函数。很显然，<strong>静态构造函数只能访问类的静态成员，不能访问类的实例成员。</strong></p><p>无参数的实例构造函数与静态构造函数可以在同一个类中同时定义。尽管参数列表相同，但这并不矛盾，<strong>因为在加载类时执行静态构造函数，而在创建实例时执行实例构造函数</strong>，所以何时执行哪个构造函数不会有冲突。如果多个类都有静态构造函数，先执行哪个静态构造函数就不确定。此时静态构造函数中的代码不应依赖于其他静态构造函数的执行情况。 另一方面，如果任何静态字段有默认值，就在调用静态构造函数之前指定它们。</p><h1 id="结构">结构</h1><h2 id="结构是值类型">结构是值类型</h2><p>结构是会影响性能的值类型，但根据使用结构的方式，这种影响可能是正面的，也可能是负面的。 正面的影响是：<strong>为结构分配内存时，速度非常快，因为它们将内联或者保存在栈中。 在结构超出了作用域被删除时，速度也很快</strong>。负面影响是：<strong>只要把结构作为参数来传递或者把一个结构赋予另一个结构(如A-B，其 中A和 B是结构)，结构的所有内容就被复制，而对于类，则只复制引用</strong>。 这样就会有性能损失，根据结构的大小，性能损失也不同。</p><blockquote><p>注意：结构主要用于小的数据结构。但当把结构作为参数传递给方法时，应把它作为 <code>ref</code> 参数传递，以避免性能损失，此时只传递了结构在内存中的地址，这样传递速度就与在类中的传递速度一样快了。但如果这样做，就必须注意被调用的方法可以改变结构的值</p></blockquote><h2 id="结构不支持继承">结构不支持继承</h2><p>结构(和C#中的其他类型一样)最终派生于类 <code>System.Object</code>。因此结构也可以访问 <code>System.Object</code> 的方法。在结构中，甚至可以重写 <code>System.Object</code> 中的方法（如重写Tostring)方法。 结构的继承链是：每个结构派生自 <code>System.ValueType</code> 类 ，<code>System.ValueType</code> 类又派生自 <code>System.Object</code> 。 <code>ValueType</code> 并没有给 <code>Object</code> 添加任何新成员，但提供了一些更适合结构的实现方式。</p><blockquote><p>注意：不能为结构提供其他基类，每个结构都派生自 <code>ValueType</code></p></blockquote><h2 id="结构的构造函数">结构的构造函数</h2><p>为结构定义构造函数的方式与为类定义构造函数的方式相同，但不允许定义无参数的构造函数。</p><blockquote><p>注意：.Net运行库禁止在C#结构内定义无参构造函数</p></blockquote><h1 id="类和结构的区别">类和结构的区别</h1><p>结构与类的区别是它们在内存中的存储方式、访问方式(<strong>类是存储在堆上的引用类型，而结构是存储在栈上的值类型</strong>)和它们的一些特征(如结构不支持继承。较小的数据类型使用结构可提高性能。但在语法上，结构与类非常相似，主要的区别是使用关键字 <code>struct</code> 代替 <code>class</code> 来声明结构。对于类和结构，都使用关键字 <code>new</code> 来声明实例创建对象并对其进行初始化。</p><h1 id="匿名类型">匿名类型</h1><p>匿名类型只是一个继承自 <code>Object</code> 且没有名称的类。该类的定义从初始化器中推断，类似于隐式类型化的变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var person = new &#123; Name = &quot;wang&quot;， Age = 22 &#125;;</span><br></pre></td></tr></table></figure><h1 id="继承">继承</h1><p>在面向对象编程中，有两种截然不同的继承类型，实现继承和接口继承。<code>C#</code> 不支持多重继承但可以派生自另一个类和任意多的接口。</p><ul><li>实现继承：表示一个类型派生自一个基类型，它拥有该基类型的所有成员字段和函数，在需要给现有类型添加功能或者许多相关类型共享一组重要的公共功能时这种类型继承非常有用</li><li>接口继承：表示一个类型只继承了函数的签名，没有继承任何的实现代码</li></ul><h2 id="实现继承">实现继承</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 基类</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 使用virtual关键字定义的方法允许在派生类中使用override重写</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SayHello</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;基类的SayHello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 派生自Person</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title">ChinaPerson</span> : <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 使用override关键字重写基类的SayHello方法</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">SayHello</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 派生自Person</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title">ThailandPerson</span> : <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">SayHello</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;萨瓦迪卡&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把一个基类函数声明为 <code>virtual</code>，就可以在任何派生类中重写该函数，<code>virtual</code> 也适用于属性。</p><blockquote><p>注意：成员字段和静态函数都不能声明为 <code>virtual</code> ，因为这个概念只对类中的实例成员有意义</p></blockquote><h2 id="接口继承">接口继承</h2><p>表示一个类型只继承了函数的签名，没有继承任何实现代码。在需要指定该类型具有某些可用的特性时，最好使用这种类型的继承。接口名称通常以字母 <code>I</code> 开头，以便知道这是一个接口。C#支持多接口继承和单一实现继承，接口继承中又分为隐式实现和显式实现。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IPerson</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SayHello</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 隐式实现接口</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title">ChinaPerson</span> : <span class="title">IPerson</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SayHello</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 显式实现接口</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title">ThailandPerson</span> : <span class="title">IPerson</span></span><br><span class="line">&#123;      </span><br><span class="line">    <span class="keyword">void</span> IPerson.SayHello()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;莎娃迪卡&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于隐式实现的接口调用这两种方式都可以：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ChinaPerson chinaPerson = <span class="keyword">new</span> ChinaPerson();</span><br><span class="line">IPerson person = <span class="keyword">new</span> ChinaPerson();</span><br><span class="line">person.SayHello();</span><br><span class="line">chinaPerson.SayHello();</span><br></pre></td></tr></table></figure><p>对于显式实现的接口调用只能使用接口调用：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IPerson thailandPerson = <span class="keyword">new</span> ThailandPerson();</span><br><span class="line">thailandPerson.SayHello();</span><br></pre></td></tr></table></figure><h2 id="隐藏方法">隐藏方法</h2><p>如果签名相同的方法在基类和派生类中都进行了声明，但该方法没有声明为 <code>virtual</code> 和 <code>override</code>，派生类会隐藏基类方法。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SayHello</span>(<span class="params"></span>)</span></span><br><span class="line">       &#123;</span><br><span class="line">           Console.WriteLine(<span class="string">&quot;基类的SayHello&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">class</span> <span class="title">ChinaPerson</span> : <span class="title">Person</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">//提示:隐藏继承的成员Person.SayHello，如果有意的，请使用关键字new</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SayHello</span>(<span class="params"></span>)</span></span><br><span class="line">       &#123;</span><br><span class="line">           Console.WriteLine(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="调用基类方法">调用基类方法</h2><p>C#中可以使用 <code>base.</code> 这种语法来调用方法的基类版本。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SayHello</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;基类的SayHello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">ChinaPerson</span> : <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">SayHello</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">base</span>.SayHello();</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="派生类构造函数执行顺序">派生类构造函数执行顺序</h2><p>首先定义基类 <code>A</code>，为了方便查看，显式指明基类的无参构造函数</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">A</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">A</span>(<span class="params"></span>)</span></span><br><span class="line">       &#123;</span><br><span class="line">           Console.WriteLine(<span class="string">&quot;A类无参构造函数&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>然后定义<code>B</code>类继承自<code>A</code>类</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">B</span> : <span class="title">A</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">B</span>(<span class="params"></span>)</span></span><br><span class="line">       &#123;</span><br><span class="line">           Console.WriteLine(<span class="string">&quot;B类无参构造函数&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>实例化<code>B</code>类</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">       B b = <span class="keyword">new</span> B();</span><br><span class="line">       Console.ReadKey();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong><br>A类无参构造函数<br>B类无参构造函数</p><blockquote><p>实例化子类时，只可以<code>new</code>子类，执行顺序为：先执行父类构造函数=&gt;再执行子类构造函数</p></blockquote><p>如果父类存在多个构造函数会怎么样？</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;A类无参构造函数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span>(<span class="params"><span class="built_in">int</span> age， <span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;A类带参构造函数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">B</span> : <span class="title">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;B类无参构造函数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次实例化<code>B</code>类</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">     &#123;</span><br><span class="line">         B b = <span class="keyword">new</span> B();</span><br><span class="line">         Console.ReadKey();</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong><br>A类无参构造函数<br>B类无参构造函数</p><blockquote><p>实例化子类时，会先执行父类的构造函数(默认为父类的无参构造函数)，也可以在子类中使用<code>base</code>关键字指定调用父类的哪个构造函数</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">     &#123;</span><br><span class="line">         B b = <span class="keyword">new</span> B(<span class="number">3</span>);</span><br><span class="line">         Console.ReadKey();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">A</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">A</span>(<span class="params"></span>)</span></span><br><span class="line">     &#123;</span><br><span class="line">         Console.WriteLine(<span class="string">&quot;A类无参构造函数&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">A</span>(<span class="params"><span class="built_in">int</span> age</span>)</span></span><br><span class="line">     &#123;</span><br><span class="line">         Console.WriteLine(<span class="string">&quot;A类带参构造函数&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">B</span> : <span class="title">A</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">B</span>(<span class="params"></span>) : <span class="title">base</span>(<span class="params"><span class="number">3</span></span>)</span></span><br><span class="line">     &#123;</span><br><span class="line">         Console.WriteLine(<span class="string">&quot;B类无参构造函数调用父类带参构造函数&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong><br>A类带参构造函数<br>B类无参构造函数调用父类带参构造函数</p><p><strong>总结：</strong></p><ul><li>实例化父类时，可以使用 <code>new</code> 子类，执行构造函数顺序为：执行父类构造函数=&gt;执行子类构造函数</li><li>实例化子类时，只可以 <code>new</code> 子类，执行顺序同上</li><li>父类实例化后，只能执行父类的方法，获得父类的属性等</li><li>实例化子类后，可同时执行子类和父类的方法和属性，如同名方法，则执行子类的方法</li><li>子类构造函数可以使用 <code>base</code> 关键字指定调用的父类构造函数</li></ul><p>类和结构都是创建对象的模板，每个对象都包含数据，并提供了处理和访问数据的方法。类定义了类的每个对象(称为实例)可以包含什么数据和功能。还可以定义处理在这些字段中存储的数据的功能。</p><h1 id="抽象类和抽象函数">抽象类和抽象函数</h1><ul><li>C#中允许把类或函数声明为<code>abstract</code> ，抽象类不能被实例化。抽象函数也不能直接实现，必须在非抽象的派生类中重写</li><li>如果类包含抽象函数，则该类也必须被声明为抽象的</li><li>抽象方法只在派生类中真正实现，这表明抽象方法只存放函数原型不涉及主体代码</li><li>派生自抽象类的类需要实现其基类的抽象方法，才能实例化对象</li><li>使用 <code>override</code> 关键字可在派生类中实现抽象方法，经 <code>override</code> 声明重写的方法称为重写基类方法，其签名必须与 <code>override</code> 方法的签名相同</li></ul><h1 id="密封类和密封方法">密封类和密封方法</h1><p>C#允许把类和方法声明为 <code>sealed</code> ，对于类这表示不能继承。对于方法这表示不能重写该方法。</p><h1 id="抽象类和接口的区别">抽象类和接口的区别</h1><p><strong>相同点</strong></p><ul><li>都可以被继承</li><li>都不能被实例化</li><li>都包含方法声明</li><li>派生类必须实现未实现的方法</li></ul><p><strong>区别</strong></p><ul><li>抽象基类可以定义字段/属性/方法实现.接口只能定义属性/索引器/事件/方法声明</li><li>抽象类是一个不完整的类，需要通过集成进一步细化。而接口更像是一个行为规范表明能做什么</li><li>接口是可以被多重实现的，可以有多个类实现接口，因为类的单一继承性，抽象类只能被单一继承</li><li>抽象类实现继承需要使用 <code>override</code> 关键字，接口则不用</li><li>如果抽象类实现接口，可以把接口方法映射到抽象类中作为抽象方法不必实现，而在抽象类的子类中实现接口方法</li><li>抽象类表示的是这个对象是什么；接口表示的是这个对象能做什么；使用抽象类是为了代码的复用，使用接口是为了实现多态性</li></ul><h1 id="普通类和抽象类的区别">普通类和抽象类的区别</h1><ul><li>都可以被继承</li><li>抽象类不能实例化，普通类允许实例化</li><li>抽象方法只包含方法声明而且必须包含在抽象类中</li><li>子类继承抽象类必须实现抽象类中的抽象方法除非子类也是抽象类</li><li>抽象类中可以包含抽象方法和实例方法</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/dotnet/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/dotnet/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>使用多线程可以充分利用 <code>CPU</code> 资源。提高 <code>CPU</code> 的使用率，采用多线程的方式去同时完成几件事情而不互相干扰。在处理大量的<code>IO</code>操作或处理的情况需要花费大量的时间时(如:读写文件，视频图像的采集，处理，显示，保存等)有较大优势。</p><p><strong>优点</strong></p><ul><li>多线程可以把占据时间长的程序中的任务放到后台去处理而不影响主程序的运行</li><li>程序的运行效率可能会提高</li><li>在一些等待的任务实现上如用户输入，文件读取和网络收发数据等，线程比较有用</li></ul><p><strong>不足</strong></p><ul><li>如果有大量的线程，会影响性能，因为操作系统需要在它们之间切换</li><li>更多的线程需要更多的内存空间</li></ul><h1 id="概念了解">概念了解</h1><h2 id="并发-Concurrency">并发(Concurrency)</h2><p>逻辑上的同时发生，一个处理器（在不同时刻或者说在同一时间间隔内）&quot;同时&quot;处理多个任务。宏观上是并发的，微观上是按排队等待、唤醒、执行的步骤序列执行。并发性是对有限物理资源强制行使多用户共享（多路复用）以提高效率。</p><h2 id="并行-Parallel">并行(Parallel)</h2><p>物理上的同时发生，多核处理器或多个处理器（在同一时刻）同时处理多个任务。并行性允许多个程序同一时刻可在不同 CPU 上同时执行。</p><h2 id="进程-Process">进程(Process)</h2><p>程序在计算机上的一次执行活动。运行一个程序、启动一个进程.程序是死的（静态的），进程是活的（动态的）。Windows 系统利用进程把工作划分为多个独立的区域，每个应用程序实例对应一个进程。进程是操作系统分配和使用系统资源的基本单位.进程包含一个运行-ing 应用程序的所有资源、进程（占用的资源）间相互独立。</p><h2 id="线程-Thread">线程(Thread)</h2><p>轻量级进程，是进程的一个实体（线程本质上是进程中一段并发运行的代码），执行线程、体现程序的真实执行情况，是处理器上系统独立调度和时间分配的最基本的执行单元。同一进程的所有线程共享相同的资源和内存（共享代码，全局变量，环境字符串等），使得线程间上下文切换更快、可以在同一地址空间内访问内存。</p><h2 id="同步">同步</h2><p>如果一个程序调用某个方法，等待其执行所有处理后才继续执行，这样的方法是同步的。</p><h2 id="异步">异步</h2><p>如果一个程序调用某个方法，在该方法处理完成之前就返回到调用方法，则这个方法是异步的。</p><h1 id="线程创建">线程创建</h1><h2 id="默认创建">默认创建</h2><p>C#中使用 <code>Thread</code> 类创建和控制线程，该类允许创建线程，以及设置线程的优先级。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 线程创建</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ThreadCreate_Basic</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ThreadMethod</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Thread.Sleep(<span class="number">2000</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;子线程结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;程序在启动时创建一个线程，称为主线程&quot;</span>);</span><br><span class="line">    <span class="comment">//创建线程</span></span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(ThreadMethod);</span><br><span class="line">    <span class="comment">//启动线程</span></span><br><span class="line">    t.Start();</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;主线程结束&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Thread</code> 构造函数接收 <code>ParameterrizeThreadStart</code> 和 <code>ThreadStart</code> 委托参数，所以也可以这么写：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadStart(ThreadMethod));</span><br></pre></td></tr></table></figure><h2 id="lambad-表达式创建">lambad 表达式创建</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread t = <span class="keyword">new</span> Thread(() =&gt; Console.WriteLine(<span class="string">&quot;ThreadMethod&quot;</span>));</span><br></pre></td></tr></table></figure><h1 id="线程调用顺序">线程调用顺序</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 线程调用顺序</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;remarks&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 观察输出结果说明</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 线程是由操作系统调度的，每次哪个线程先被执行不确定，线程的调度是无序的</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span><span class="doctag">&lt;/remarks&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Thread_Order</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;程序在启动时创建一个线程，称为主线程&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(() =&gt; Console.WriteLine(<span class="string">&quot;A&quot;</span>));</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(() =&gt; Console.WriteLine(<span class="string">&quot;B&quot;</span>));</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(() =&gt; Console.WriteLine(<span class="string">&quot;C&quot;</span>));</span><br><span class="line">    Thread t3 = <span class="keyword">new</span> Thread(() =&gt; Console.WriteLine(<span class="string">&quot;D&quot;</span>));</span><br><span class="line">    t.Start();</span><br><span class="line">    t1.Start();</span><br><span class="line">    t2.Start();</span><br><span class="line">    t3.Start();</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;主线程结束&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：线程是由操作系统调度的，每次哪个线程先被执行可以不同，就是说该例中线程的调度是无序的。不同 PC 运行结果可能不一致，只作示例。</p></blockquote><h1 id="线程传递数据">线程传递数据</h1><p>使用带 <code>ParameterrizeThreadStart</code> 委托参数的 <code>Thread</code> 构造函数创建自定义类。把线程方法定义为实例方法，之后初始化实例数据，启动线程。<br>不带参数：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread t = <span class="keyword">new</span> Thread(() =&gt; Console.WriteLine(<span class="string">&quot;ThreadMethod&quot;</span>));</span><br></pre></td></tr></table></figure><p>一个参数：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread t = <span class="keyword">new</span> Thread((<span class="built_in">object</span> message) =&gt; Console.WriteLine(message));</span><br></pre></td></tr></table></figure><p>多个参数(自定义类)：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Data</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> age;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Data</span>(<span class="params"><span class="built_in">string</span> name， <span class="built_in">int</span> age</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Write</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;name:&#123;0&#125;，age:&#123;1&#125;&quot;</span>， <span class="keyword">this</span>.name， <span class="keyword">this</span>.age);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = <span class="keyword">new</span> Data(<span class="string">&quot;Wang&quot;</span>， <span class="number">24</span>);</span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(data.Write);</span><br><span class="line">       t.Start();</span><br></pre></td></tr></table></figure><h1 id="后台线程">后台线程</h1><p>默认情况下：<em>用 <code>Thread</code> 类创建的线程总是前台线程，线程池中的线程总是后台线程。</em></p><p>前台线程和后台线程的区别在于：</p><ul><li>前台线程：应用程序必须运行完所有的前台线程才可以退出</li><li>后台线程：应用程序可以不考虑其是否已经运行完毕而直接退出，所有的后台线程在应用程序退出时都会自动结束</li></ul><p><strong>前台线程阻止进程的关闭</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Thread thread = <span class="keyword">new</span> Thread(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Thread.Sleep(<span class="number">5000</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;前台线程执行&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">thread.Start();</span><br><span class="line">Console.WriteLine(<span class="string">&quot;主线程执行完毕&quot;</span>);</span><br></pre></td></tr></table></figure><p>这里主线程马上执行完成，并不马上关闭，前台线程等待 5 秒再执行输出，然后控制台退出。</p><p><strong>后台线程不阻止进程的关闭</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Thread thread = <span class="keyword">new</span> Thread(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Thread.Sleep(<span class="number">5000</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;前台线程执行&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">&#123; IsBackground = <span class="literal">true</span> &#125;;</span><br><span class="line"></span><br><span class="line">thread.Start();</span><br><span class="line">Console.WriteLine(<span class="string">&quot;主线程执行完毕&quot;</span>);</span><br></pre></td></tr></table></figure><p>不等后台线程执行完毕，主线程执行完毕后立即退出，控制台立即退出。</p><h1 id="线程优先级">线程优先级</h1><p>之前说到，线程是由操作系统调度的，给线程指定优先级，可以影响调度顺序，C#中 <code>Thread</code> 类的 <code>Priority</code> 属性提供了五种线程优先级别，这是一个枚举对象</p><ul><li><code>Normal</code>(正常，默认值)</li><li><code>Highest</code> (最高)</li><li><code>AboseNormal</code>(高于正常)</li><li><code>BelowNormal</code>(低于正常)</li><li><code>Lowest</code>(最低)</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Thread normal = <span class="keyword">new</span> Thread(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;优先级为正常线程&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">normal.Start();</span><br><span class="line"></span><br><span class="line">Thread aboseNormal = <span class="keyword">new</span> Thread(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;优先级为高于正常线程&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">&#123; Priority = ThreadPriority.AboveNormal &#125;;</span><br><span class="line">aboseNormal.Start();</span><br><span class="line"></span><br><span class="line">Thread belowNormal = <span class="keyword">new</span> Thread(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;优先级为低于正常线程&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">&#123; Priority = ThreadPriority.BelowNormal &#125;;</span><br><span class="line">belowNormal.Start();</span><br><span class="line"></span><br><span class="line">Thread highest = <span class="keyword">new</span> Thread(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;优先级最高线程&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">&#123; Priority = ThreadPriority.Highest &#125;;</span><br><span class="line">highest.Start();</span><br><span class="line"></span><br><span class="line">Thread lowest = <span class="keyword">new</span> Thread(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;优先级最低线程&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">&#123; Priority = ThreadPriority.Lowest &#125;;</span><br><span class="line">lowest.Start();</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;主线程执行完毕&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="/images/2021-09-02-22-17-42.png" alt=""><br>结果可知：设置优先级并不会指定线程固定执行的顺序，设置线程优先级只是提高了线程被调用的概率，并不是定义 <code>CPU</code> 调用线程的顺序，具体还是要由操作系统内部来调度。</p><h1 id="线程控制">线程控制</h1><table><thead><tr><th style="text-align:left"><strong>属性</strong></th><th style="text-align:left"><strong>描述</strong></th></tr></thead><tbody><tr><td style="text-align:left">CurrentThread</td><td style="text-align:left">获取当前正在运行的线程</td></tr><tr><td style="text-align:left">IsAlive</td><td style="text-align:left">获取一个值，该值指示当前线程的执行状态</td></tr><tr><td style="text-align:left">Name</td><td style="text-align:left">获取或设置线程的名称</td></tr><tr><td style="text-align:left">Priority</td><td style="text-align:left">获取或设置一个值，该值指示线程的调度优先级</td></tr><tr><td style="text-align:left">ThreadState</td><td style="text-align:left">获取一个值，该值包含当前线程的状态</td></tr><tr><td style="text-align:left"><strong>方法</strong></td><td style="text-align:left"><strong>描述</strong></td></tr><tr><td style="text-align:left">Abort</td><td style="text-align:left">调用此方法通常会终止线程</td></tr><tr><td style="text-align:left">Join</td><td style="text-align:left">阻止调用线程，直到某个线程终止时为止</td></tr><tr><td style="text-align:left">Resume</td><td style="text-align:left">继续已挂起的线程</td></tr><tr><td style="text-align:left">Sleep</td><td style="text-align:left">将当前线程阻止指定的毫秒数</td></tr><tr><td style="text-align:left">Start</td><td style="text-align:left">使线程被安排进行执行</td></tr><tr><td style="text-align:left">Suspend</td><td style="text-align:left">挂起线程，或者如果线程已挂起，则不起作用</td></tr></tbody></table><h2 id="Thread-Sleep">Thread.Sleep()</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ThreadMethod</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ThreadMethodSleep</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//暂停2s</span></span><br><span class="line">        Thread.Sleep(TimeSpan.FromSeconds(<span class="number">2</span>));</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(ThreadMethodSleep);</span><br><span class="line">t.Start();</span><br><span class="line">ThreadMethod();</span><br></pre></td></tr></table></figure><p><strong>工作原理</strong><br>当程序运行时，主线程创建，而后创建线程 <code>t</code> ，该线程首先执行 <code>ThreadMethodSleep</code> 方法中的代码。然后会立即执行 <code>ThreadMethod</code> 方法。关键之处在于在<code>ThreadMethodSleep</code> 方法中加入了 <code>Thread.Sleep</code> 方法调用。这将导致线程执行该代码时，在打印任何数字之前会等待指定的时间(本例中是 2 秒)，当线程处于休眠状态时，它会占用尽可能少的 CPU 时间。结果发现通常后运行的 <code>ThreadMethod</code> 方法中的代码会比独立线程中的 <code>ThreadMethodSleep</code> 方法中的代码先执行。</p><h2 id="Thread-Join">Thread.Join()</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ThreadMethod</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ThreadMethodSleep</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//暂停2s</span></span><br><span class="line">        Thread.Sleep(TimeSpan.FromSeconds(<span class="number">2</span>));</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(ThreadMethodSleep);</span><br><span class="line">t.Start();</span><br><span class="line">Thread.Sleep(TimeSpan.FromSeconds(<span class="number">5</span>));</span><br><span class="line">t.Abort();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ThreadMethodSleep</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//暂停2s</span></span><br><span class="line">        Thread.Sleep(TimeSpan.FromSeconds(<span class="number">2</span>));</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(ThreadMethodSleep);</span><br><span class="line">t.Start();</span><br><span class="line">t.Join();</span><br><span class="line">ThreadMethod();</span><br></pre></td></tr></table></figure><p><strong>工作原理</strong><br>程序运行后，创建线程 <code>t</code> ，调用 <code>ThreadMethodSleep()</code> 方法，该方法循环打印 3 个&quot;b&quot;，但是每次打印前都要暂停 2s，在主程序中调用 <code>t.join</code> 方法，该方法允许等待线程 <code>t</code> 完成，只有 <code>t</code> 线程完成后才会继续执行主程序的代码，该例中就是主线程等待 <code>t</code> 线程完成后再继续执行，主线程等待时处于阻塞状态。</p><h2 id="Suspend-Resume">Suspend/Resume</h2><p>需要多线程编程时为了挂起与恢复线程可以使用 <code>Thread</code> 类的 <code>Suspend()</code> 与 <code>Resume()</code> 方法。</p><blockquote><p>注意：这两个方法已经过时</p></blockquote><h2 id="Thread-Abort">Thread.Abort()</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ThreadMethodSleep</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//暂停2s</span></span><br><span class="line">        Thread.Sleep(TimeSpan.FromSeconds(<span class="number">2</span>));</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(ThreadMethodSleep);</span><br><span class="line">t.Start();</span><br><span class="line">Thread.Sleep(TimeSpan.FromSeconds(<span class="number">5</span>));</span><br><span class="line">t.Abort();</span><br></pre></td></tr></table></figure><p><strong>工作原理</strong><br>程序运行后，创建线程 <code>t</code> ，调用 <code>ThreadMethodSleep()</code> 方法，该方法循环打印 20 个&quot;b&quot;，但是每次打印前都要暂停 2s，在主线程中设置等待 6s 后调用 <code>t.Abort()</code> 方法，这有可能给线程注入了 <code>ThreadAbortException</code> 异常，导致线程被终结。这非常危险，因为该异常可以在任何时刻发生并可能彻底摧毁应用程序。另外，使用该技术也不一定总能终止线程。目标线程可以通过处理该异常并调用 <code>Thread.ResetAbort</code> 方法来拒绝被终止。因此并不推荐使用 <code>Abort</code> 方法来关闭线程。可优先使用一些其他方法，比如提供一个 <code>CancellationToken</code> 方法来，取消线程的执行。</p><h2 id="Thread-ThreadState">Thread.ThreadState</h2><p>通过 <code>Thread.ThreadState</code> 属性读取当前线程状态。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ThreadMethodSleep</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//暂停2s</span></span><br><span class="line">        Thread.Sleep(TimeSpan.FromSeconds(<span class="number">2</span>));</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(ThreadMethodSleep);</span><br><span class="line">Console.WriteLine(<span class="string">&quot;创建线程，线程状态:&#123;0&#125;&quot;</span>， t.ThreadState);</span><br><span class="line">t.Start();</span><br><span class="line">Console.WriteLine(<span class="string">&quot;线程调用Start()方法，线程状态:&#123;0&#125;&quot;</span>， t.ThreadState);</span><br><span class="line">Thread.Sleep(TimeSpan.FromSeconds(<span class="number">5</span>));</span><br><span class="line">Console.WriteLine(<span class="string">&quot;线程休眠5s，线程状态:&#123;0&#125;&quot;</span>， t.ThreadState);</span><br><span class="line">t.Join();</span><br><span class="line">Console.WriteLine(<span class="string">&quot;等待线程结束，线程状态:&#123;0&#125;&quot;</span>， t.ThreadState);</span><br></pre></td></tr></table></figure><p><strong>工作原理</strong><br>程序运行后，创建线程 <code>t</code> (Unstarted)-&gt; <code>t.start()</code> (Running)-&gt; <code>t.sleep()</code> (WaitSleepJoin)-&gt; <code>t.join()</code> 线程结束(Stopped)</p><h1 id="异常处理-v2">异常处理</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ThreadMethodA</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;AError&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ThreadMethodB</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;BError&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Exception ex)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Error:&#123;0&#125;&quot;</span>， ex.Message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(ThreadMethodB);</span><br><span class="line">t.Start();</span><br><span class="line">t.Join();</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(ThreadMethodA);</span><br><span class="line">    t1.Start();</span><br><span class="line">&#125;</span><br><span class="line">catch (Exception e)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Error:&#123;0&#125;&quot;</span>， e.Message);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddThread</span>(<span class="params"><span class="built_in">object</span> e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;当前线程ID:&#123;0&#125;&quot;</span>， Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThreadPool.GetMaxThreads(<span class="keyword">out</span> <span class="built_in">int</span> workThread， <span class="keyword">out</span> <span class="built_in">int</span> ioThread);</span><br><span class="line">Console.WriteLine(<span class="string">&quot;工作线程数:&#123;0&#125;，io线程数&#123;1&#125;&quot;</span>， workThread， ioThread);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    ThreadPool.QueueUserWorkItem(AddThread);</span><br><span class="line">    workThread = ioThread = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;workThread&#125;</span>，<span class="subst">&#123;ioThread&#125;</span>&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>工作原理</strong><br>程序运行后，定义了两个会抛出异常的线程，其中一个对异常进行了处理，另一个没有，可以看到 <code>ThreadMethodB()</code> 方法中的异常没有被主程序包裹线程启动的 <code>try/catch</code>代码块捕获到，所以如果直接使用线程，一般不要在线程中抛出异常，而在线程代码中使用 <code>try/catch</code> 代码块。</p><h1 id="线程池-ThreadPool">线程池 ThreadPool</h1><p>创建线程需要时间，如果有不同的短任务要完成，就可以事先创建许多线程，在应完成这些任务时发出请求。这个线程数最好在需要更多的线程时增加，在需要释放资源时减少。C#中不需要自己创建维护这样一个列表，该列表由 <code>ThreadPool</code> 类托管。该类会在需要时增减池中线程的线程数，直到最大线程数，线程数的值是可配置的。如果线程池中个数到达了设置的极限，还是有更多的作业要处理，最新的作业就要排队，且必须等待线程完成其任务。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddThread</span>(<span class="params"><span class="built_in">object</span> e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;当前线程ID:&#123;0&#125;&quot;</span>， Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThreadPool.GetMaxThreads(<span class="keyword">out</span> <span class="built_in">int</span> workThread， <span class="keyword">out</span> <span class="built_in">int</span> ioThread);</span><br><span class="line">Console.WriteLine(<span class="string">&quot;工作线程数:&#123;0&#125;，io线程数&#123;1&#125;&quot;</span>， workThread， ioThread);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    ThreadPool.QueueUserWorkItem(AddThread);</span><br><span class="line">    workThread = ioThread = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;workThread&#125;</span>，<span class="subst">&#123;ioThread&#125;</span>&quot;</span>);</span><br></pre></td></tr></table></figure><p><code>ThreadPool.GetMaxThreads(out workThread， out ioThread)</code> 接收两个 <code>out int</code> 类型参数返回最大工作线程数和 io 线程数，for 循环中使用<code>ThreadPool.QueueUserWorkItem()</code> 方法传递 <code>WaitCallback</code> 类型委托，将 <code>AddThread()</code> 方法赋予线程池中的线程，线程池收到请求后，如果线程池还没有运行，就会创建一个线程池，并启动第一个线程，如果已经启动，且有一个空闲线程来完成任务，就把该任务传递给这个线程。</p><h1 id="线程池使用限制">线程池使用限制</h1><ul><li>线程池中所有线程都是后台线程，如果进程的所有前台线程都结束了，所有的后台线程就会停止，不能把入池的线程改为前台线程</li><li>不能给入池的线程设置优先级或名称</li><li>入池的线程只能用于时间较短的任务，如果线程要一直运行，就应使用 <code>Thread</code> 类创建一个线程</li><li>对于<code>COM</code>对象，入池的所有线程都是多线程单元(MTA)线程，许多 COM 对象都需要单线程单元(STA)</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/dotnet/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
      <url>/dotnet/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<p>当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作。直到该线程完成操作，其他线程才能对该内存地址进行操作，而其他线程又处于等待状态，这种时候很容易出现问题。</p><h1 id="争用条件">争用条件</h1><p>如果两个或多个线程访问相同的对象。并且对共享状态的访问没有同步，就会出现争用条件。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">StateObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> state = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ChangeState</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            state++;</span><br><span class="line">            <span class="keyword">if</span> (state == <span class="number">5</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;value=5&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            state = <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ThreadSync_Lock_Example_01</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    StateObject m = <span class="keyword">new</span> StateObject();</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(ChangeState);</span><br><span class="line">    t1.Start(m);</span><br><span class="line">    Console.ReadKey();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ChangeState</span>(<span class="params"><span class="built_in">object</span> o</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        StateObject m = o <span class="keyword">as</span> StateObject;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m.ChangeState();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时运行程序是没有输出的，因为 <code>StateObject</code> 类中 <code>state</code> 初始值是5，<code>if </code>条件不会进入,随后又将 <code>state</code>重新初始化为5。</p><p><strong>两个线程执行</strong></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ThreadSync_Lock_Example_02</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    StateObject m = <span class="keyword">new</span> StateObject();</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(ChangeState);</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(ChangeState);</span><br><span class="line">    t1.Start(m);</span><br><span class="line">    t2.Start(m);</span><br><span class="line">    Console.ReadKey();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ChangeState</span>(<span class="params"><span class="built_in">object</span> o</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        StateObject m = o <span class="keyword">as</span> StateObject;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m.ChangeState();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时会不停的打印&quot;value=5&quot;，原因在于：一个线程在判断语句处时，另一个线程可能又将 <code>state</code> 的值改为了5，而导致输出合法。</p><h1 id="死锁">死锁</h1><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Deadlock</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> StateObject o1 = <span class="keyword">new</span> StateObject();</span><br><span class="line">    <span class="keyword">static</span> StateObject o2 = <span class="keyword">new</span> StateObject();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DeadlockA</span>(<span class="params"><span class="built_in">object</span> o</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">lock</span> (o1)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;我是线程&#123;0&#125;,我锁定了对象o1&quot;</span>, o);</span><br><span class="line">            <span class="keyword">lock</span> (o2)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;我是线程&#123;0&#125;,我锁定了对象o2&quot;</span>, o);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DeadlockB</span>(<span class="params"><span class="built_in">object</span> o</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">lock</span> (o2)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;我是线程&#123;0&#125;,我锁定了对象o2&quot;</span>, o);</span><br><span class="line">            <span class="keyword">lock</span> (o1)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;我是线程&#123;0&#125;,我锁定了对象o1&quot;</span>, o);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread t1 = <span class="keyword">new</span> Thread(Deadlock.DeadlockA);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(Deadlock.DeadlockB);</span><br><span class="line">       t1.Start(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">       t2.Start(<span class="string">&quot;t2&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="/images/2021-09-02-22-22-40.png" alt=""><br><code>t1</code> 线程执行 <code>DeadlockA()</code> 方法顺序锁定<code>o1</code>和<code>o2</code><br><code>t2</code> 线程执行 <code>DeadlockB()</code> 方法顺序锁定<code>o2</code>和<code>o1</code><br>当前结果显示t1线程锁定了<code>o1</code>后，<code>t2</code>线程在<code>t1</code>线程锁定<code>o1</code>后抢占进来，锁定了<code>o2</code>。<code>t2</code>在等<code>t1</code>解锁,<code>t1</code>在等<code>t2</code>解锁，都处于挂起状态在等对方解锁，这就形成了死锁，线程将无限等待下去。</p><p>这个问题应该从一开始就设计好锁定顺序，也可以为锁定义超时时间来处理，保证“上锁”这个操作在一个线程上执行也是避免死锁的方法之一。</p><p>C#中有多个用于多线程的同步技术</p><ul><li>lock语句</li><li>Interlocked类</li><li>Monitor类</li><li>SpinLock类</li><li>WaitHandle类</li><li>Mutex类</li><li>Semapphore类</li><li>Event类</li><li>Barrier类</li><li>ReaderWriteLockSlim类</li></ul><p>其中lock语句/Interlocked类/Monitor类可用于进程内存的同步，其它几个提供了多进程之间的线程同步。</p><h1 id="Lock">Lock</h1><p>C#使用 <code>lock</code> 语句锁定在线程中共享的变量，如果一个线程锁定了变量，另一个线程就必须等待该锁定的解除。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ChangeState</span>(<span class="params"><span class="built_in">object</span> o</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    StateObject m = o <span class="keyword">as</span> StateObject;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">       &#123;</span><br><span class="line">　　　　　　　<span class="comment">//给变量m加锁</span></span><br><span class="line">          <span class="keyword">lock</span> (m)</span><br><span class="line">            &#123;</span><br><span class="line">              m.ChangeState();</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为实例的对象也可以用于外部的同步访问，而且不能在类自身控制这种访问，所以应采用<code>SyncRoot</code>模式，创建私有对象，将这个对象用于 <code>lock</code> 语句。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">object</span> syncRoot= <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ChangeState</span>(<span class="params"><span class="built_in">object</span> o</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    StateObject m = o <span class="keyword">as</span> StateObject;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">         &#123;</span><br><span class="line">           <span class="keyword">lock</span> (aync)</span><br><span class="line">           &#123;</span><br><span class="line">               m.ChangeState();</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><ol><li><code>lock</code>只能锁定对象，即引用类型，不能锁定值类型</li><li><code>lock</code>不能锁定空值,因为<code>null</code>是不需要被释放的</li><li>不能锁定<code>string</code>类型,虽然它也是引用类型的。因为字符串类型被<code>CLR暂留</code>，这意味着整个程序中任何给定字符串都只有一个实例，具有相同内容的字符串上放置了锁，就将锁定应用程序中该字符串的所有实例</li><li>避免锁定<code>public</code>类型,如果该实例可以被公开访问，则 <code>lock(this)</code> 可能会有问题，因为不受控制的代码也可能会锁定该对象</li></ol><h1 id="锁是否必须是静态类型？">锁是否必须是静态类型？</h1><p>如果被锁定的方法是静态的，那么这个锁必须是静态类型。这样就是在全局锁定了该方法，不管该类有多少个实例，都要排队执行。</p><p>如果被锁定的方法不是静态的，那么不能使用静态类型的锁，因为被锁定的方法是属于实例的。只要该实例调用锁定方法不产生损坏就可以，不同实例间是不需要锁的。这个锁只锁该实例的方法，而不是锁所有实例的方法。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ThreadSafe</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">object</span> _locker = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Go</span>(<span class="params"></span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">lock</span> (_locker)</span><br><span class="line">    &#123;</span><br><span class="line">      ......<span class="comment">//共享数据的操作 （Static Method）,使用静态锁确保所有实例排队执行</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">object</span> _locker2=<span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">GoTo</span>(<span class="params"></span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">lock</span>(_locker2)</span><br><span class="line">    <span class="comment">//共享数据的操作，非静态方法，是用非静态锁，确保同一个实例的方法调用者排队执行</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同步对象可以兼作它 <code>lock</code> 的对象。比如：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ThreadSafe</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="title">List</span> &lt;<span class="built_in">string</span>&gt; _list</span> = <span class="keyword">new</span> List &lt;<span class="built_in">string</span>&gt;(); </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Test</span>(<span class="params"></span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">lock</span> (_list)</span><br><span class="line">    &#123;</span><br><span class="line">      _list.Add (<span class="string">&quot;Item 1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Monitors">Monitors</h1><p><code>lock</code> 其实是 <code>Monitors</code> 的简洁写法。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lock</span> (syncRoot)</span><br><span class="line">&#123;</span><br><span class="line">    m.ChangeState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两者其实是一样的</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Monitor.Enter(syncRoot);</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    m.ChangeState();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">    Monitor.Exit(syncRoot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Mutex">Mutex</h1><p>互斥锁是一个互斥的同步对象，同一时间有且仅有一个线程可以获取它。可以实现进程级别上线程的同步。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ThreadSync_Mutex_Example_01</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//在不同的线程中调用受互斥锁保护的方法</span></span><br><span class="line">        Thread test = <span class="keyword">new</span> Thread(MutexMethod);</span><br><span class="line">        test.Start();</span><br><span class="line">    &#125;</span><br><span class="line">    Console.Read();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MutexMethod</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//实例化一个互斥锁</span></span><br><span class="line">        Mutex mutex = <span class="keyword">new</span> Mutex();</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;&#123;0&#125; 请求获取互斥锁&quot;</span>, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">        mutex.WaitOne();</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;&#123;0&#125; 已获取到互斥锁&quot;</span>, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;&#123;0&#125; 准备释放互斥锁&quot;</span>, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">        <span class="comment">// 释放互斥锁</span></span><br><span class="line">        mutex.ReleaseMutex();</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;&#123;0&#125; 已经释放互斥锁&quot;</span>, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>互斥锁的带有三个参数的构造函数</p><ul><li><code>initiallyOwned</code> : 如果 <code>initiallyOwned</code> 为 <code>true</code>，互斥锁的初始状态就是被所实例化的线程所获取，否则实例化的线程处于未获取状态</li><li><code>name</code>：该互斥锁的名字，在操作系统中只有一个命名为<code>name</code>的互斥锁<code>mutex</code>，如果一个线程得到这个<code>name</code>的互斥锁，其他线程就无法得到这个互斥锁了，必须等待那个线程对这个线程释放</li><li><code>createNew</code>：如果指定名称的互斥体已经存在就返回<code>false</code>，否则返回<code>true</code></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/dotnet/%E5%A7%94%E6%89%98%E5%92%8C%E4%BA%8B%E4%BB%B6/"/>
      <url>/dotnet/%E5%A7%94%E6%89%98%E5%92%8C%E4%BA%8B%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>委托是一个类，它定义了方法的类型，指明了这个委托类型的变量可接受的函数，表示对具有特定参数列表和返回类型的方法的引用，使得可以将方法当作另一个方法的参数来进行传递</p><blockquote><p><strong>不管什么函数只要返回值类型和参数能匹配委托所指定的，那么这个函数就能存储为一个委托变量的引用。</strong></p></blockquote><h1 id="为什么需要委托">为什么需要委托</h1><ul><li>委托可以将方法作为参数</li><li>逻辑解耦，保持稳定</li><li>代码复用，保证项目规范</li></ul><h1 id="委托使用步骤">委托使用步骤</h1><ul><li>使用 <code>delegate</code> 关键字定义委托</li><li>声明委托对应的方法</li><li>实例化委托将方法作为参数传入</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">DelegateTest</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="comment">//step01：使用delegate关键字定义委托</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">Sum</span>(<span class="params"><span class="built_in">int</span> x， <span class="built_in">int</span> y</span>)</span>;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="comment">// step03：实例化委托将方法作为参数传入</span></span><br><span class="line">         Sum sum = <span class="keyword">new</span> Sum(<span class="keyword">new</span> DelegateTest().Add);</span><br><span class="line">         <span class="built_in">int</span> result = sum.Invoke(<span class="number">1</span>， <span class="number">2</span>);</span><br><span class="line">         Console.WriteLine(result);</span><br><span class="line">         Console.ReadKey();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// step02：声明委托对应的方法</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> x， <span class="built_in">int</span> y</span>)</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">return</span> x + y;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ol><li>使用 <code>delegate</code> 关键字定义委托</li><li>声明委托对应的方法</li><li>实例化委托将方法作为参数传入</li></ol><p>至此，一个委托就完成了。</p><h1 id="匿名方法">匿名方法</h1><p>上面说到完成一个委托要分三步走缺一步都不行，但是微软可能感觉这么实现比较麻烦，非要把三步做成两步来走！所以就用匿名方法来简化上边的三个步骤。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// step01：首先用delegate定义一个委托 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">Sum</span>(<span class="params"><span class="built_in">int</span> x， <span class="built_in">int</span> y</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// step02：使用匿名方法的写法把一个方法赋值给委托</span></span><br><span class="line">    Sum sum = <span class="built_in">delegate</span> (<span class="built_in">int</span> x， <span class="built_in">int</span> y) &#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line">    <span class="built_in">int</span> result = sum.Invoke(<span class="number">1</span>， <span class="number">2</span>);</span><br><span class="line">    Console.WriteLine(result);</span><br><span class="line">    Console.ReadKey();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>step01</strong>：使用 <code>delegate</code> 关键字定义委托<br><strong>step02</strong>：使用匿名方法的写法把一个方法赋值给委托</p><p>这时会发现这里省略了定义方法这一步，将三步简化成了两步。</p><h1 id="Lambda表达式">Lambda表达式</h1><p>微软对C#的设计理念是简单易用。这时候发现对匿名方法的方式依旧不太满意，就想方设法的来简化 <code>delegate(int x， int y) &#123; return x + y; &#125;</code> 这个匿名方法，<code>Lambda</code> 就出现了。</p><p><code>lambda</code> 运算符 <code>=&gt;</code> 左边列出了需要的参数，右边定义了赋予 <code>lambda</code> 变量的方法实现代码。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// step01：首先用delegate定义一个委托 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">Sum</span>(<span class="params"><span class="built_in">int</span> x， <span class="built_in">int</span> y</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 方法一：</span></span><br><span class="line">    Sum sum1 = (<span class="built_in">int</span> x， <span class="built_in">int</span> y) =&gt; &#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line">    <span class="built_in">int</span> result1 = sum1(<span class="number">1</span>， <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法二：</span></span><br><span class="line">    Sum sum2 = (x， y) =&gt; &#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line">    <span class="built_in">int</span> result2 = sum2(<span class="number">1</span>， <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法三：</span></span><br><span class="line">    Sum sum3 = (x， y) =&gt; x + y;</span><br><span class="line">    <span class="built_in">int</span> result3 = sum3(<span class="number">1</span>， <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法一</strong>：简单的把 <code>delegate</code> 去掉，在 <code>()</code> 与 <code>&#123;&#125;</code> 之间加上 <code>=&gt;</code><br><strong>方法二</strong>：在方法一的基础上把参数类型都干掉了<br><strong>方法三</strong>：要干就干彻底些，把 <code>&#123;&#125;</code> 以及 <code>return</code> 关键字都去掉了</p><blockquote><p>注意：这三种方法随便怎么写都行</p></blockquote><h1 id="Lambda表达式简写">Lambda表达式简写</h1><p>如果 <code>lambda</code> 表达式只有一句，方法块内就可以省略花括号和 <code>return</code> 语句，这时编译器会添加一条隐式的 <code>return</code> 语句。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Func&lt;<span class="built_in">double</span>， <span class="built_in">double</span>&gt; func = param =&gt; param * param;</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Func&lt;<span class="built_in">double</span>， <span class="built_in">double</span>&gt; func = param =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> param * <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="泛型委托-v2">泛型委托</h1><p>随着.Net版本的不断升级，微软又来玩新花样了，不管是匿名方法还是 <code>Lambda</code> 表达式，完成一个委托的应用，都逃不过两个步骤，一步是定义一个委托，另一步是用一个方法来实例化一个委托。微软干脆把这两步都合成一步来走了。用 <code>Func</code> 来简化一个委托的定义。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//方法一：</span></span><br><span class="line">    Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>&gt; add1 = (<span class="built_in">int</span> x, <span class="built_in">int</span> y) =&gt; &#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line">    <span class="built_in">int</span> result1 = add1(<span class="number">1</span>， <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法二：</span></span><br><span class="line">    Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>&gt; add2 = (x， y) =&gt; &#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line">    <span class="built_in">int</span> result2 = add2(<span class="number">1</span>， <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法三：</span></span><br><span class="line">    Func&lt;<span class="built_in">int</span>， <span class="built_in">int</span>， <span class="built_in">int</span>&gt; add3 = (x， y) =&gt; x + y;</span><br><span class="line">    <span class="built_in">int</span> result3 = add3(<span class="number">1</span>， <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此一个委托的应用就可用 <code>Func&lt;int， int， int&gt; add3 = (x， y) =&gt; x + y;</code>  一句话来完成了，其中的 <code>Func</code> 就是所谓的泛型委托。</p><p>微软提供了 <code>Action&lt;T&gt;</code> 和 <code>Func&lt;T&gt;</code> 两种泛型委托，用于简化方法定义。</p><h2 id="Action">Action</h2><p>表示引用一个 <code>void</code> 返回类型的方法，可以传递最多<strong>16种不同的参数类型</strong>，没有泛型参数的 <code>Action</code> 类可调用没有参数的方法。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Action：无参数</span></span><br><span class="line">Action action1 = () =&gt; &#123; Console.WriteLine(<span class="string">&quot;啦啦啦啦&quot;</span>); &#125;;</span><br><span class="line">action1();</span><br><span class="line"><span class="comment">// Action：一个参数</span></span><br><span class="line">Action&lt;<span class="built_in">string</span>&gt; action2 = p =&gt; &#123; Console.WriteLine(<span class="string">&quot;啦啦啦啦，name:&#123;0&#125;&quot;</span>,p); &#125;;</span><br><span class="line">action2(<span class="string">&quot;wang&quot;</span>);</span><br><span class="line"><span class="comment">// Action：多个参数</span></span><br><span class="line">Action&lt;<span class="built_in">string</span>, <span class="built_in">int</span>&gt; action3 = (name,age) =&gt; &#123; Console.WriteLine(<span class="string">&quot;啦，name:&#123;0&#125;，age:&#123;1&#125;&quot;</span>, name,age); &#125;;</span><br><span class="line">action3(<span class="string">&quot;wang&quot;</span>,<span class="number">25</span>);</span><br></pre></td></tr></table></figure><h2 id="Func">Func</h2><p><code>Func&lt;T&gt;</code> 允许调用带返回类型的方法，可以传递**<code>16种不同类型的参数和一个返回类型</code>**，<code>Func&lt;out TResult&gt;</code> 委托类型可以调用带返回值且无参数的方法。</p><p><strong>总结</strong></p><ul><li><code>Action&lt;T&gt;</code> 用于没有返回值的方法（参数根据自己情况进行传递）</li><li><code>Func&lt;T&gt;</code> 用于有返回值的方法（参数根据自己情况传递）</li></ul><p>记住无返回就用 <code>Action&lt;T&gt;</code>，有返回就用 <code>Func&lt;T&gt;</code>。</p><h1 id="表达式树">表达式树</h1><p>表达式树其实与委托已经没什么关系了，如果非要扯上关系，表达式树是存放委托的容器。如果非要说的更专业一些，表达式树是存取 <code>Lambda</code> 表达式的一种数据结构。要用 <code>Lambda</code> 表达式的时候，直接从表达式中获取出来 <code>Compile()</code> 就可以直接用了。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Expression&lt;Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>&gt;&gt; exp = (x, y) =&gt; x + y;</span><br><span class="line">    Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>&gt; fun = exp.Compile();</span><br><span class="line">    <span class="built_in">int</span> result = fun(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Invoke">Invoke</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Sum sum = <span class="built_in">delegate</span> (<span class="built_in">int</span> x, <span class="built_in">int</span> y) &#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line"><span class="built_in">int</span> result = sum.Invoke(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="built_in">int</span> result = sum(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure><h1 id="委托数组">委托数组</h1><p>定义 <code>Math</code> 类提供两个静态方法接收一个 <code>double</code> 类型的参数，用于计算倍数和阶乘。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Math</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">double</span> <span class="title">MultipleTwo</span>(<span class="params"><span class="built_in">double</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">value</span> * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">double</span> <span class="title">Square</span>(<span class="params"><span class="built_in">double</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">value</span> * <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>添加MathOperation操作方法，传递委托和double类型参数</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="built_in">double</span> <span class="title">MyDelegate</span>(<span class="params"><span class="built_in">double</span> <span class="keyword">value</span></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//定义委托数组</span></span><br><span class="line">        MyDelegate[] myDelegates = &#123;</span><br><span class="line">            Math.MultipleTwo，</span><br><span class="line">            Math.Square</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//使用委托数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; myDelegates.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            MathOperation(myDelegates[i]， <span class="number">3.7</span>);</span><br><span class="line">            MathOperation(myDelegates[i]， <span class="number">3.0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MathOperation</span>(<span class="params">MyDelegate myDelegate， <span class="built_in">double</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> result = myDelegate(<span class="keyword">value</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Delegate is &#123;0&#125;，value is &#123;1&#125;&quot;</span>， myDelegate，result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="多播委托">多播委托</h1><p>之前的每个委托都只包含一个方法调用，调用委托的次数与调用方法的次数相同，如果要调用多个方法，就需要多次显式调用这个委托。</p><p>但委托中也可以包含多个方法，称为多播委托。多播委托可以按顺序调用多个方法，为此<strong>委托的签名必须返回<code>void</code>，否则就只能得到委托最后调用的最后一个方法的结果。</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Func&lt;<span class="built_in">double</span>, <span class="built_in">double</span>&gt; func = Math.MultipleTwo;</span><br><span class="line">func += Math.Square;</span><br><span class="line"><span class="keyword">var</span> result = func(<span class="number">3.0</span>);</span><br><span class="line">Console.WriteLine(result);</span><br><span class="line"></span><br><span class="line">MyDelegate myDelegate = Math.MultipleTwo;</span><br><span class="line">myDelegate += Math.Square;</span><br><span class="line"><span class="keyword">var</span> result2 = myDelegate(<span class="number">3.0</span>);</span><br><span class="line">Console.WriteLine(result2);</span><br><span class="line">Console.ReadKey();</span><br></pre></td></tr></table></figure><p>只返回了3.0阶乘的值</p><h2 id="和">+= 和 -=</h2><p>多播委托使用 <code>+=</code> 和 <code>-=</code>，在委托中增加或删除方法调用。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Action action = Print.First;</span><br><span class="line">    action += Print.Second;</span><br><span class="line">    action();</span><br><span class="line"></span><br><span class="line">    Action action2 = Print.First;</span><br><span class="line">    action2 += Print.Second;</span><br><span class="line">    action2 -= Print.First;</span><br><span class="line">    action2();</span><br><span class="line">    Console.ReadKey();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Print</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">First</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;FirstMethod&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Second</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;SecondMethod&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要使用多播委托，就要知道对同一个委托调用方法链的顺序并未正式定义，因此要避免编写依赖于特定顺序调用方法的代码。</p><h2 id="多播委托异常处理">多播委托异常处理</h2><p>使用多播委托，意味着多播委托里包含一个逐个调用的委托集合，如果集合其中一个方法抛出异常.整个迭代就会停止。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="built_in">double</span> <span class="title">MyDelegate</span>(<span class="params"><span class="keyword">out</span> <span class="built_in">double</span> <span class="keyword">value</span></span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Action action = Print.First;</span><br><span class="line">            action += Print.Second;</span><br><span class="line">            action();</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Print</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">First</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;FirstMethod&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Second</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;SecondMethod&quot;</span>);          </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>委托只调用了第一个方法，因为第一个方法抛出了异常，委托的迭代停止，不再调用 <code>Second()</code></p><h2 id="GetInvocationList">GetInvocationList</h2><p>使用 <code>Delegate的GetInvocationList()</code> 方法自己迭代方法列表。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Action action = Print.First;</span><br><span class="line">action += Print.Second;</span><br><span class="line"></span><br><span class="line">Delegate[] delegates = action.GetInvocationList();</span><br><span class="line"><span class="keyword">foreach</span> (Action item <span class="keyword">in</span> delegates)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        item();</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Exception error)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(error.Message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Console.ReadKey();</span><br></pre></td></tr></table></figure><p>修改后，程序在捕获异常后，会迭代下一个方法。</p><h1 id="闭包的陷阱">闭包的陷阱</h1><p><a href="https://www.cnblogs.com/aehyok/p/3730417.html">https://www.cnblogs.com/aehyok/p/3730417.html</a></p><p>源码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Action&gt; list = <span class="keyword">new</span> List&lt;Action&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    Action t = () =&gt; Console.WriteLine(i.ToString());</span><br><span class="line">    list.Add(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">foreach</span> (Action t <span class="keyword">in</span> list)</span><br><span class="line">&#123;</span><br><span class="line">    t();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IL反编译</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Action&gt; list = <span class="keyword">new</span> List&lt;Action&gt;();</span><br><span class="line">TempClass tempClass = <span class="keyword">new</span> TempClass();</span><br><span class="line"><span class="keyword">for</span> (tempClass.i = <span class="number">0</span>; tempClass.i &lt; <span class="number">5</span>; tempClass.i++)</span><br><span class="line">&#123;</span><br><span class="line">    Action t = tempClass.TempFunc;</span><br><span class="line">    list.Add(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">foreach</span> (Action t <span class="keyword">in</span> list)</span><br><span class="line">&#123;</span><br><span class="line">    t();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TempClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TempFunc</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(i.ToString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所谓的闭包对象，指的是上面这种情形中的 <code>TempClass</code> 对象。如果匿名方法（Lambda表达式）引用了某个局部变量，编译器就会自动将该引用提升到该闭包对象中。即将<code>for</code>循环中的变量 <code>i</code> 修改成了引用闭包对象的公共变量 <code>i</code>。这样一来，即使代码执行后离开了原局部变量 <code>i</code> 的作用域(如for循环)，包含该闭包对象的作用域也还存在。<br><img src="/images/2021-09-02-22-09-49.png" alt=""><br>修改一下源代码</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Action&gt; list = <span class="keyword">new</span> List&lt;Action&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> temp = i;</span><br><span class="line">    Action t = () =&gt; Console.WriteLine(temp.ToString());</span><br><span class="line">    list.Add(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">foreach</span> (Action t <span class="keyword">in</span> list)</span><br><span class="line">&#123;</span><br><span class="line">    t();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/2021-09-02-22-10-27.png" alt=""></p><h1 id="事件">事件</h1><blockquote><p><strong>事件是一种引用类型</strong>，实际上也是一种特殊的委托。<strong>事件基于委托，是提供了发布/订阅机制的委托，事件是将委托封装，并对外公布了订阅和取消订阅的接口。</strong></p></blockquote><p><strong>Example_01</strong></p><p>不使用委托和事件的代码，耦合度高</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Player</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Die</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        GameConfiguration configuration = <span class="keyword">new</span> GameConfiguration();</span><br><span class="line">        configuration.OnPlayerDeath();</span><br><span class="line">        UI ui = <span class="keyword">new</span> UI();</span><br><span class="line">        ui.OnPlayerDeath();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UI</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnPlayerDeath</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.Write(<span class="string">&quot;GameOver&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GameConfiguration</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> DeathNumber &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnPlayerDeath</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        DeathNumber++;</span><br><span class="line">        Console.WriteLine(DeathNumber);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">TestMethod</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Example_01</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Player player = <span class="keyword">new</span> Player();</span><br><span class="line">    player.Die();</span><br><span class="line">    Assert.IsTrue(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Example_02</strong></p><p>使用委托和事件解耦代码</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 热水器</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Heater</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 温度字段</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> temperature;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 事件委托</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;param&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">BoilHandler</span>(<span class="params"><span class="built_in">int</span> param</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 将委托封装，并对外公布订阅和取消订阅的接口</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> BoilHandler BoilEvent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BoilWater</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            temperature = i;</span><br><span class="line">            <span class="keyword">if</span> (temperature &gt; <span class="number">95</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 调用所有注册对象的方法</span></span><br><span class="line">                BoilEvent?.Invoke(temperature);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 警报器</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Alarm</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Alert</span>(<span class="params"><span class="built_in">int</span> param</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Alarm：dddddddd，水已经 &#123;0&#125; 度了：&quot;</span>， param);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 显示器</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Display</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ShowMsg</span>(<span class="params"><span class="built_in">int</span> param</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Display：水已烧开，当前温度：&#123;0&#125;度.&quot;</span>， param);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">TestMethod</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Example_02</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Heater heater = <span class="keyword">new</span> Heater();</span><br><span class="line">    Alarm alarm = <span class="keyword">new</span> Alarm();</span><br><span class="line">    <span class="comment">// 注册方法</span></span><br><span class="line">    heater.BoilEvent += alarm.Alert;</span><br><span class="line">    <span class="comment">//heater.BoilEvent += (new Alarm()).MakeAlert; // 匿名对象注册方法</span></span><br><span class="line">    <span class="comment">// 注册静态方法</span></span><br><span class="line">    heater.BoilEvent += Display.ShowMsg;</span><br><span class="line">    <span class="comment">// 烧水，会自动调用注册过对象的方法</span></span><br><span class="line">    heater.BoilWater();</span><br><span class="line">    Assert.IsTrue(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Example_03</strong></p><ul><li>委托类型的名称都应该以<code>EventHandler</code> 结束</li><li>委托的原型定义：有一个 <code>void</code> 返回值，并接受两个输入参数：一个 <code>Object</code> 类型，一个 <code>EventArgs</code> 类型(或继承自<code>EventArgs</code>)</li><li>事件的命名为委托去掉 <code>EventHandler</code> 之后剩余的部分.</li><li>继承自 <code>EventArgs</code> 的类型应该以 <code>EventArgs</code> 结尾</li></ul><p>委托声明原型中的 <code>Object</code> 类型的参数代表了<code>Subject</code>，也就是监视对象，在本例中是 Heater(热水器).回调函数(比如Alarm的Alert)可以通过它访问触发事件的对象(Heater)，<code>EventArgs</code> 对象包含了<code>Observer</code>所感兴趣的数据，在本例中是<code>temperature</code>。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Heater</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 温度</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> temperature;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 添加型号作为演示</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> type = <span class="string">&quot;01&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 添加产地作为演示</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> area = <span class="string">&quot;China&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">BoiledEventHandler</span>(<span class="params"><span class="built_in">object</span> sender， BoiledEventArgs e</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> BoiledEventHandler Boiled;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 定义 BoiledEventArgs类，传递给 Observer 所感兴趣的信息</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BoiledEventArgs</span> : <span class="title">EventArgs</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">readonly</span> <span class="built_in">int</span> temperature;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">BoiledEventArgs</span>(<span class="params"><span class="built_in">int</span> temperature</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.temperature = temperature;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 提供继承自Heater的类重写，以便继承类拒绝其他对象对它的监视</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;e&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnBoiled</span>(<span class="params">BoiledEventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果有对象注册</span></span><br><span class="line">        Boiled?.Invoke(<span class="keyword">this</span>， e);  <span class="comment">// 调用所有注册对象的方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BoilWater</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            temperature = i;</span><br><span class="line">            <span class="keyword">if</span> (temperature &gt; <span class="number">95</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 建立BoiledEventArgs 对象.</span></span><br><span class="line">                BoiledEventArgs e = <span class="keyword">new</span> BoiledEventArgs(temperature);</span><br><span class="line">                OnBoiled(e); <span class="comment">// 调用 OnBolied 方法</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 警报器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Alarm</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MakeAlert</span>(<span class="params"><span class="built_in">object</span> sender， Heater.BoiledEventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Heater heater = (Heater)sender;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Alarm：&#123;0&#125; - &#123;1&#125;: &quot;</span>， heater.area， heater.type);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Alarm: 嘀嘀嘀，水已经 &#123;0&#125; 度了：&quot;</span>， e.temperature);</span><br><span class="line">        Console.WriteLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Display</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ShowMsg</span>(<span class="params"><span class="built_in">object</span> sender， Heater.BoiledEventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//静态方法</span></span><br><span class="line">        Heater heater = (Heater)sender;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Display：&#123;0&#125; - &#123;1&#125;: &quot;</span>， heater.area， heater.type);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Display：水快烧开了，当前温度：&#123;0&#125;度.&quot;</span>， e.temperature);</span><br><span class="line">        Console.WriteLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">TestMethod</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Example_03</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Heater heater = <span class="keyword">new</span> Heater();</span><br><span class="line">    Alarm alarm = <span class="keyword">new</span> Alarm();</span><br><span class="line">    heater.Boiled += alarm.MakeAlert;   <span class="comment">//注册方法</span></span><br><span class="line">    <span class="comment">//heater.Boiled += (new Alarm()).MakeAlert;      //给匿名对象注册方法</span></span><br><span class="line">    <span class="comment">//heater.Boiled += new Heater.BoiledEventHandler(alarm.MakeAlert);    //也可以这么注册</span></span><br><span class="line">    heater.Boiled += Display.ShowMsg;       <span class="comment">//注册静态方法</span></span><br><span class="line">    heater.BoilWater();   <span class="comment">//烧水，会自动调用注册过对象的方法</span></span><br><span class="line">    Assert.IsTrue(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考-v2">参考</h1><ul><li><a href="https://www.cnblogs.com/jujusharp/archive/2011/08/04/2127999.html">https://www.cnblogs.com/jujusharp/archive/2011/08/04/2127999.html</a></li><li><a href="https://www.cnblogs.com/HQFZ/p/4903400.html">https://www.cnblogs.com/HQFZ/p/4903400.html</a></li><li><a href="https://www.cnblogs.com/wangjiming/p/8300103.html">https://www.cnblogs.com/wangjiming/p/8300103.html</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/dotnet/%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
      <url>/dotnet/%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="值类型和引用类型">值类型和引用类型</h1><p>C#的类型一共分为两类</p><ul><li>值类型 <code>ValueType</code></li><li>引用类型 <code>ReferenceType</code></li></ul><p>值类型和引用类型都继承自 <code>System.Object</code> 类。不同的是几乎所有的引用类型都直接从 <code>System.Object</code> 继承，而值类型则继承 <code>System.ValueType </code>。<code>System.ValueType</code>直接派生于<code>System.Object</code>。即<code>System.ValueType</code>本身是一个类类型，而不是值类型。关键在于<code>ValueType</code>重写了<code>Equals()</code>方法，从而对值类型按照实例的值来比较，而不是引用地址来比较。</p><h1 id="区别">区别</h1><ul><li>引用类型变量的赋值只复制对对象的引用而不复制对象本身。而将一个值类型变量赋给另一个值类型变量时，将复制包含的值</li><li>引用类型可以派生出新的类型，而值类型不能</li><li>引用类型可以包含 <code>null</code> 值，值类型不能（<strong>可空类型功能允许将 null 赋给值类型</strong>）</li><li>引用类型存储在堆中。类实例化时会在堆中开辟一部分空间存储类的实例，类实例的引用（指针）还是存储在栈中。值类型总是分配在它声明的地方(作为字段时跟随其所属的实例存储在堆上。作为局部变量时存储在栈上)。</li></ul><blockquote><p>误区：“引用类型存储在堆上，值类型保存在栈上”，这句话前半部分是正确的，引用类型的实例总是在堆上创建的。但是变量的值是在声明的位置存储的，所以假定一个类中有一个<code>int</code>类型的实例变量，那么这个变量的值是跟对象中的其他数据在一起也就是堆上。只有局部变量（方法内部声明的变量）和方法参数在栈上。</p></blockquote><h1 id="使用场合">使用场合</h1><ul><li>值类型：在内存管理方面具有更好的效率，但不支持多态不能派生新的类型，适合用做存储数据的载体</li><li>引用类型：支持多态可以派生新的类型</li></ul><h1 id="内存的逻辑划分之栈和堆">内存的逻辑划分之栈和堆</h1><p>C#程序在CLR上运行时，内存从逻辑上划分两大块：栈、堆，这两个基本元素组成了C#程序的运行环境。</p><ul><li>栈：在程序运行的时候，每个线程(<code>Thread</code>)都会维护一个自己的专属线程堆栈</li><li>堆：是程序在运行的时候请求操作系统分配给自己的内存空间，储存着使用的各种对象等信息，跟栈不同的是它们被调用完毕不会立即被清理掉</li></ul><h2 id="栈的特征">栈的特征</h2><ul><li>栈空间比较小（每个线程只有一个栈占用 <code>1MB</code>，栈内存溢出抛出 <code>StackOverflowException</code> 但是读取速度快</li><li>数据只能从栈的顶端插入或删除，是连续存储的，<strong>把数据放到栈顶称为入栈</strong>，<strong>从栈顶删除数据称为出栈</strong>​</li><li>存放方法的参数、局部变量、返回地址等值，当一个方法执行完毕后立刻自动清除</li></ul><h2 id="栈的结构">栈的结构</h2><p><img src="/images/2021-09-02-22-41-17.png" alt=""></p><blockquote><p>栈帧：每个方法执行都会分配一块独立的内存空间来存储方法运行需要的数据，按<strong>后入先出</strong>的方式进入和弹出线程栈。</p></blockquote><h2 id="堆的特征">堆的特征</h2><ul><li>堆空间比较大（32位最多分配1.5GB，64位最多分配8TB，堆内存溢出抛出 <code>OutOfMemoryException</code> ，但是读取速度慢</li><li>数据存储不连续，与栈不同：堆里的内存能够以任意顺序存入和移除</li><li>存放引用类型的对象，通过<code>GC</code>清理</li></ul><h2 id="堆的结构">堆的结构</h2><p>参考：<a href="https://docs.microsoft.com/en-us/archive/msdn-magazine/2005/may/net-framework-internals-how-the-clr-creates-runtime-objects">Drill Into .NET Framework Internals to See How the CLR Creates Runtime Objects</a><br>​</p><h1 id="代码运行时内存分配情况">代码运行时内存分配情况</h1><h2 id="变量和对象在内存中的分配">变量和对象在内存中的分配</h2><p><strong>示例代码</strong>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">TestClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> x;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test1</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> a=<span class="number">1</span>; </span><br><span class="line">  <span class="keyword">var</span> b=<span class="keyword">new</span> TestClass();</span><br><span class="line">  <span class="keyword">var</span> c=a;</span><br><span class="line">  <span class="keyword">var</span> d=b;</span><br><span class="line">  <span class="keyword">var</span> e=d.x;</span><br><span class="line">  <span class="keyword">var</span> f=TestClass.y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>内存分配情况</strong>：</p><p><img src="/images/2021-09-02-22-42-10.png" alt=""></p><ol><li><code>Test1()</code>方法被调用：系统为该方法创建一个栈桢，用于存储该方法使用到的值类型的变量、指针、调用其他方法的返回地址等</li><li>方法执行到 <code>var a=1</code>：变量<code>a</code>的值<code>1</code>首先入栈存储，栈的起始地址为<code>0x000000671b77e5a4</code></li><li>方法执行到 <code>var b=new TestClass()</code>：在堆中开辟一块内存用于存储<code>TestClass</code>实例对象，然后变量<code>b</code>入栈，变量<code>b</code>的值为<code>TestClass</code>实例对象的引用（实际存储的是<code>TestClass</code>实例在堆上的内存地址，也就是指针）</li><li>方法执行到 <code>var c=a</code>：将变量<code>c</code>压入栈，因为<code>a</code>是值类型，所以将变量<code>a</code>的值拷贝赋值给<code>c</code></li><li>方法执行到 <code>var d=b</code>：将变量<code>d</code>压入栈，因为<code>b</code>是引用类型，所以将变量<code>b</code>引用的地址赋值给变量<code>d</code>，此时变量<code>b</code>和<code>d</code>都指向堆内存中的<code>TestClass</code>实例对象</li><li>方法执行到 <code>var e=d.x</code>时：将变量<code>e</code>压入栈，因为<code>x</code>字段是值类型，所以将<code>x</code>的实际值0（int类型初始化的默认值为0）赋值给<code>e</code></li><li>方法执行到 <code>var f=TestClass.y</code>：将变量<code>f</code>压入栈，因为<code>y</code>字段是引用类型，所以<code>f</code>变量的值为<code>y</code> 字段的引用</li></ol><h2 id="方法参数在栈中的分配">方法参数在栈中的分配</h2><p><strong>示例代码：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">TestClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> x;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">sum</span>(<span class="params"><span class="built_in">int</span> i,<span class="built_in">int</span> j</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i+j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test1</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> a=<span class="keyword">new</span> TestClass();</span><br><span class="line">  <span class="built_in">int</span> b = <span class="number">0</span>;</span><br><span class="line">  b=a.sum(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>内存分配情况：</strong></p><p><img src="/images/2021-09-02-22-42-35.png" alt=""><br>​</p><ol><li>方法执行到 <code>var a=new TestClass()</code> : 在堆中开辟一块内存用于存储<code>TestClass</code>实例对象，然后变量<code>a</code>入栈，变量<code>a</code>的值为<code>TestClass</code>实例对象的引用（实际上存储的是<code>TestClass</code>实例在堆上的内存地址，也就是指针）</li><li>方法执行到 <code>int b = 0</code>：将局部变量<code>b</code>压入栈，因为<code>b</code>是值类型所以值<code>0</code>存储在栈中</li><li>方法执行到 <code>b=a.sum(1,2)</code>：首先两个<code>int</code>类型实参<code>1，2</code>分别入栈，并将<code>sum</code>方法的返回地址压入栈，<code>sum</code>方法执行结束之后应返回至该位置</li></ol><h1 id="System-String">System.String</h1><ul><li>特性一：字符串是不可变的，字符串一经创建便不能更改，不能变长、变短或修改其中的任何字符。</li><li>特性二：字符串驻留（字符串池化），<code>CLR</code>可通过一个<code>String</code>对象共享多个完全一致的<code>String</code>内容，这样能减少系统中字符串的数量，从而节省内存。<code>String</code>的驻留机制实际上是在<code>SystemDomain</code>中进行的。 当<code>CLR</code>被加载之后，会在<code>SystemDomain</code>对应的<code>managed heap</code>中创建一个<code>Hashtable</code>，<code>Hashtable</code>中记录了所有在代码中使用字面量声明的字符串实例的引用，<code>Hashtable</code>的<code>Key</code>为字符串本身，<code>Value</code>为字符串对象的地址。</li></ul><p><strong>示例代码：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//申请一块堆内存，把地址放在Hashtable的key为hello的元素中</span></span><br><span class="line">   <span class="built_in">string</span> str1 = <span class="string">&quot;hello&quot;</span>; </span><br><span class="line">    </span><br><span class="line">   <span class="comment">//由于上一句已经创建了key为hello的元素，所以不需要申请新的堆内存</span></span><br><span class="line">   <span class="built_in">string</span> str2 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//编译成MSIL语言时 已经与string str3 = &quot;hello&quot;一样了</span></span><br><span class="line">   <span class="built_in">string</span> str3 = <span class="string">&quot;&quot;</span> + <span class="string">&quot;e&quot;</span> + <span class="string">&quot;l&quot;</span> + <span class="string">&quot;l&quot;</span> + <span class="string">&quot;o&quot;</span>; </span><br><span class="line">    </span><br><span class="line">   <span class="comment">//显式new</span></span><br><span class="line">   <span class="built_in">string</span> str4 = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="keyword">new</span> <span class="built_in">char</span>[] &#123; <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span> &#125;); </span><br><span class="line">    </span><br><span class="line">   <span class="comment">//申请一块堆内存，把地址放在Hashtable的key为hello2的元素中</span></span><br><span class="line">   <span class="built_in">string</span> str5 = <span class="string">&quot;hello2&quot;</span>;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//True 引用同一块堆内存 </span></span><br><span class="line">   Console.WriteLine(<span class="built_in">object</span>.ReferenceEquals(str1, str2).ToString());</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//True 也是引用同一块堆内存</span></span><br><span class="line">   Console.WriteLine(<span class="built_in">object</span>.ReferenceEquals(str1, str3).ToString()); </span><br><span class="line">    </span><br><span class="line">   <span class="comment">//False 引用了不同的堆内存 </span></span><br><span class="line">   Console.WriteLine(<span class="built_in">object</span>.ReferenceEquals(str1, str4).ToString());</span><br><span class="line">    </span><br><span class="line">   <span class="comment">// 先从Hashtable中检索是否有重复的key ，检索到了hello2，所以不需要申请新的堆内存</span></span><br><span class="line">   str2 = <span class="string">&quot;hello2&quot;</span>; </span><br><span class="line">    </span><br><span class="line">   <span class="comment">//False str2与str1已经不引用同一个堆</span></span><br><span class="line">   Console.WriteLine(<span class="built_in">object</span>.ReferenceEquals(str1, str2).ToString());</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//True 变成与str5引用同一个堆内存</span></span><br><span class="line">   Console.WriteLine(<span class="built_in">object</span>.ReferenceEquals(str2, str5).ToString()); </span><br><span class="line">    </span><br><span class="line">   <span class="comment">// 控制台输入两个相同的字符串</span></span><br><span class="line">   str1 = Console.ReadLine();</span><br><span class="line">   str2 = Console.ReadLine();</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//False 因为 str1 和 str2 两个变量并非字面量声明的字符串，所以不会触发字符串驻留机制</span></span><br><span class="line">   Console.WriteLine(<span class="built_in">object</span>.ReferenceEquals(str1, str2).ToString());</span><br><span class="line">   Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="静态字段和属性">静态字段和属性</h1><p>类型的静态字段和静态属性的支持字段（例如 int）存储在类型对象（加载堆）中。</p><p><code>JIT</code> 会在进行编译时找到这些静态成员的地址，并在之后的编译时硬编码它们，然后写在机器码中。</p><p>这样，再次访问静态成员时就不需要通过类型对象。程序中所有类型的静态成员组成一个全局的数组，它包括每一个类型中的基元类型静态成员的内存地址。</p><p>数组的地址会被钉死 (pinned)，使得它不会被 <code>GC</code> 回收掉（除非卸载应用程序域），这样机器码中的硬编码将一直有意义，直到程序终止。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/dotnet/%E5%8F%8D%E5%B0%84%E6%8A%80%E6%9C%AF/"/>
      <url>/dotnet/%E5%8F%8D%E5%B0%84%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<p>反射提供了封装程序集、模块和类型的对象(Type类型)。可以使用反射动态创建类型的实例，将类型绑定到现有对象，或从现有对象获取类型并调用其方法或访问其字段和属性。</p><h1 id="使用场景">使用场景</h1><ul><li>需要访问程序元数据的特性</li><li>检查和实例化程序集中的类型</li><li>在运行时构建新类型。使用  <code>System.Reflection.Emit</code>  中的类</li><li>执行后期绑定，访问在运行时创建的类型的方法</li></ul><h1 id="反射用途">反射用途</h1><table><thead><tr><th><strong>类型</strong></th><th style="text-align:left"><strong>作用</strong></th></tr></thead><tbody><tr><td><code>Assembly</code></td><td style="text-align:left">定义和加载程序集，加载程序集清单中列出的模块，以及从此程序集中查找类型并创建该类型的实例</td></tr><tr><td><code>Module</code></td><td style="text-align:left">了解包含模块的程序集以及模块中的类等，还可以获取在模块上定义的所有全局方法或其他特定的非全局方法</td></tr><tr><td><code>ConstructorInfo</code></td><td style="text-align:left">了解构造器的名称、参数、访问修饰符（如public或private）和实现详细信息（如abstract或virtual）等。使用Type的GetConstructors或GetConstructor方法来调用特定的构造函数</td></tr><tr><td><code>MethodInfo</code></td><td style="text-align:left">了解方法的名称、返回类型、参数、访问修饰符（如public或private）和实现详细信息（如abstract或virtual）等。使用Type的GetMethods或GetMethod方法来调用特定的方法</td></tr><tr><td><code>FieldInfo</code></td><td style="text-align:left">了解字段的名称、访问修饰符（如public或private）和实现详细信息（如static）等，并获取或设置字段值</td></tr><tr><td><code>EventInfo</code></td><td style="text-align:left">了解事件的名称、事件处理程序数据类型、自定义特性、声明类型和反射类型等，并添加或移除事件处理程序</td></tr><tr><td><code>PropertyInfo</code></td><td style="text-align:left">了解属性的名称、数据类型、声明类型、反射类型和只读或可写状态等，并获取或设置属性值</td></tr><tr><td><code>ParameterInfo</code></td><td style="text-align:left">了解参数的名称、数据类型、参数是输入参数还是输出参数等，以及参数在方法签名中的位置等</td></tr></tbody></table><h1 id="反射用到的命名空间">反射用到的命名空间</h1><ul><li><code>System.Reflection</code></li><li><code>System.Type</code></li><li><code>System.Reflection.Assembly</code></li></ul><h1 id="反射用到的主要类">反射用到的主要类</h1><ul><li><code>System.Type</code> ：通过这个类可以访问任何给定数据类型的信息</li><li><code>System.Reflection.Assembly</code>：  可以用于访问给定程序集的信息，或者把这个程序集加载到程序中</li></ul><h1 id="System-Type">System.Type</h1><p>一个抽象的基类。<code>Type</code> 有与每种数据类型对应的派生类，使用这个派生类的对象的方法、字段、属性来查找有关该类型的所有信息。</p><h2 id="获取给定类型Type值">获取给定类型Type值</h2><p><strong>typeof 运算符</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Type t = <span class="keyword">typeof</span>(<span class="built_in">string</span>);</span><br></pre></td></tr></table></figure><p><strong>对象的GetType()方法</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">&quot;guo&quot;</span>;</span><br><span class="line">Type t = s.GetType();</span><br></pre></td></tr></table></figure><p><strong>Type类的静态方法GetType()</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Type t = Type.GetType(<span class="string">&quot;System.String&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="Type-属性">Type 属性</h2><table><thead><tr><th><strong>属性</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>Name</td><td>数据类型名</td></tr><tr><td>FullName</td><td>数据类型的完全限定名(包括命名空间名)</td></tr><tr><td>Namespace</td><td>定义数据类型的命名空间名</td></tr><tr><td>IsAbstract</td><td>指示该类型是否是抽象类型</td></tr><tr><td>IsArray</td><td>指示该类型是否是数组</td></tr><tr><td>IsClass</td><td>指示该类型是否是类</td></tr><tr><td>IsEnum</td><td>指示该类型是否是枚举</td></tr><tr><td>IsInterface</td><td>指示该类型是否是接口</td></tr><tr><td>IsPublic</td><td>指示该类型是否是公有的</td></tr><tr><td>IsSealed</td><td>指示该类型是否是密封类</td></tr><tr><td>IsValueType</td><td>指示该类型是否是值类型</td></tr></tbody></table><h2 id="Type-方法">Type 方法</h2><table><thead><tr><th><strong>方法名称</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>GetConstructor(), GetConstructors()</td><td>返回ConstructorInfo类型，用于取得该类的构造函数的信息</td></tr><tr><td>GetEvent(), GetEvents()</td><td>返回EventInfo类型，用于取得该类的事件的信息</td></tr><tr><td>GetField(), GetFields()</td><td>返回FieldInfo类型，用于取得该类的字段（成员变量）的信息</td></tr><tr><td>GetInterface(), GetInterfaces()</td><td>返回InterfaceInfo类型，用于取得该类实现的接口的信息</td></tr><tr><td>GetMember(), GetMembers()</td><td>返回MemberInfo类型，用于取得该类的所有成员的信息</td></tr><tr><td>GetMethod(), GetMethods()</td><td>返回MethodInfo类型，用于取得该类的方法的信息</td></tr><tr><td>GetProperty(), GetProperties()</td><td>返回PropertyInfo类型，用于取得该类的属性的信息</td></tr></tbody></table><p>可以调用这些成员，其方式是调用 <code>Type</code> 的 <code>InvokeMember()</code> 方法，或者调用 <code>MethodInfo</code> , <code>PropertyInfo</code> 和其他类的 <code>Invoke()</code> 方法。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ReflectClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Sex &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReflectClass</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReflectClass</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.Name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReflectClass</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">string</span> sex</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.Name = name;</span><br><span class="line">            <span class="keyword">this</span>.Sex = sex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Show</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;姓名：&quot;</span> + Name + <span class="string">&quot;\n&quot;</span> + <span class="string">&quot;年龄：&quot;</span> + Age + <span class="string">&quot;\n&quot;</span> + <span class="string">&quot;性别：&quot;</span> + Sex);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取所有构造函数">获取所有构造函数</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">TestMethod</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetConstructors</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Type t = <span class="keyword">new</span> ReflectClass().GetType();</span><br><span class="line">    <span class="comment">// 获取类的所有构造函数</span></span><br><span class="line">    ConstructorInfo[] constructorInfos = t.GetConstructors();</span><br><span class="line">    <span class="keyword">foreach</span> (ConstructorInfo ci <span class="keyword">in</span> constructorInfos)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取每个构造函数的参数</span></span><br><span class="line">        ParameterInfo[] parameterInfos = ci.GetParameters();</span><br><span class="line">        <span class="keyword">foreach</span> (ParameterInfo p <span class="keyword">in</span> parameterInfos)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(p.ParameterType.ToString() + <span class="string">&quot;\n&quot;</span> + p.Name + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Assert.IsTrue(constructorInfos.Length &gt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态创建对象">动态创建对象</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">TestMethod</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DynamicCreateObject</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Type t = <span class="keyword">typeof</span>(ReflectClass);</span><br><span class="line">    Type[] pt = <span class="keyword">new</span> Type[<span class="number">2</span>];</span><br><span class="line">    pt[<span class="number">0</span>] = <span class="keyword">typeof</span>(<span class="built_in">string</span>);</span><br><span class="line">    pt[<span class="number">1</span>] = <span class="keyword">typeof</span>(<span class="built_in">string</span>);</span><br><span class="line">    <span class="comment">//根据参数类型获取构造函数</span></span><br><span class="line">    ConstructorInfo ci = t.GetConstructor(pt);</span><br><span class="line">    <span class="comment">//构造Object数组，作为构造函数的输入参数</span></span><br><span class="line">    <span class="built_in">object</span>[] obj = <span class="keyword">new</span> <span class="built_in">object</span>[<span class="number">2</span>] &#123; <span class="string">&quot;wang&quot;</span>, <span class="string">&quot;男&quot;</span> &#125;;</span><br><span class="line">    <span class="comment">//调用构造函数生成对象</span></span><br><span class="line">    <span class="built_in">object</span> @object = ci.Invoke(obj);</span><br><span class="line">    <span class="comment">//调用生成的对象的方法测试是否对象生成成功</span></span><br><span class="line">    ((ReflectClass)@object).Show();</span><br><span class="line">    Assert.IsTrue(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用Activator动态创建对象">使用Activator动态创建对象</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">TestMethod</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ActivatorDynamicCreateObject</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Type t = <span class="keyword">typeof</span>(ReflectClass);</span><br><span class="line">    <span class="built_in">object</span>[] obj = <span class="keyword">new</span> <span class="built_in">object</span>[<span class="number">2</span>] &#123; <span class="string">&quot;wang&quot;</span>, <span class="string">&quot;男&quot;</span> &#125;;</span><br><span class="line">    <span class="comment">//用Activator的CreateInstance静态方法，生成新对象</span></span><br><span class="line">    <span class="built_in">object</span> @object = Activator.CreateInstance(t, obj);</span><br><span class="line">    ((ReflectClass)@object).Show();</span><br><span class="line">    Assert.IsTrue(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取类中的Public属性">获取类中的Public属性</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">TestMethod</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetProperties</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Type t = <span class="keyword">new</span> ReflectClass().GetType();</span><br><span class="line">    PropertyInfo[] propertyInfos = t.GetProperties();</span><br><span class="line">    <span class="keyword">foreach</span> (PropertyInfo p <span class="keyword">in</span> propertyInfos)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(p.Name);</span><br><span class="line">    &#125;</span><br><span class="line">    Assert.IsTrue(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取类中Public方法">获取类中Public方法</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">TestMethod</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetPublicMethod</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Type t = <span class="keyword">new</span> ReflectClass().GetType();</span><br><span class="line">    MethodInfo[] mi = t.GetMethods();</span><br><span class="line">    <span class="keyword">foreach</span> (MethodInfo method <span class="keyword">in</span> mi)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(method.ReturnType + <span class="string">&quot;|&quot;</span> + method.Name);</span><br><span class="line">    &#125;</span><br><span class="line">    Assert.IsTrue(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取类中Public字段">获取类中Public字段</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">TestMethod</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetField</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Type t = <span class="keyword">new</span> ReflectClass().GetType();</span><br><span class="line">    FieldInfo[] fieldInfos = t.GetFields();</span><br><span class="line">    <span class="keyword">foreach</span> (FieldInfo fieldInfo <span class="keyword">in</span> fieldInfos)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(fieldInfo.Name);</span><br><span class="line">    &#125;</span><br><span class="line">    Assert.IsTrue(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">TestMethod</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Example_01</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ReflectClass rc = <span class="keyword">new</span> ReflectClass();</span><br><span class="line">    Type t = rc.GetType();</span><br><span class="line">    <span class="built_in">object</span> obj = Activator.CreateInstance(t);</span><br><span class="line"></span><br><span class="line">    FieldInfo address = t.GetField(<span class="string">&quot;Address&quot;</span>);</span><br><span class="line">    address.SetValue(obj, <span class="string">&quot;Beijing&quot;</span>);</span><br><span class="line"></span><br><span class="line">    PropertyInfo name = t.GetProperty(<span class="string">&quot;Name&quot;</span>);</span><br><span class="line">    name.SetValue(obj, <span class="string">&quot;wang&quot;</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    PropertyInfo age = t.GetProperty(<span class="string">&quot;Age&quot;</span>);</span><br><span class="line">    age.SetValue(obj, <span class="number">20</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    MethodInfo method = t.GetMethod(<span class="string">&quot;Show&quot;</span>);</span><br><span class="line">    method.Invoke(obj, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Address为：&quot;</span> + ((ReflectClass)obj).Address);</span><br><span class="line">    Assert.IsTrue(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Assembly">Assembly</h1><h2 id="GetAssembly">GetAssembly</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">TestMethod</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetAssembly</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 通过程序集名称返回Assembly对象</span></span><br><span class="line">    Assembly assembly = Assembly.Load(<span class="string">&quot;CodeSnippet&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过Assembly获取程序集中类(参数必须是类的全名)</span></span><br><span class="line">    Type type = assembly.GetType(<span class="string">&quot;CodeSnippet.Csharp.ReflectClass&quot;</span>);</span><br><span class="line">    Assert.IsNotNull(type);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过Assembly获取程序集中所有的类</span></span><br><span class="line">    Type[] types = assembly.GetTypes();</span><br><span class="line">    Assert.IsNotNull(types);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过DLL文件名称返回Assembly对象</span></span><br><span class="line">warning disable S3885 <span class="comment">// &quot;Assembly.Load&quot; should be used</span></span><br><span class="line">    Assembly assembly2 = Assembly.LoadFrom(<span class="string">&quot;CodeSnippet.dll&quot;</span>);</span><br><span class="line">warning restore S3885 <span class="comment">// &quot;Assembly.Load&quot; should be used</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过Assembly获取程序集中类(参数必须是类的全名)</span></span><br><span class="line">    Type type2 = assembly2.GetType(<span class="string">&quot;CodeSnippet.Csharp.ReflectClass&quot;</span>);</span><br><span class="line">    Assert.IsNotNull(type2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过Assembly获取程序集中所有的类</span></span><br><span class="line">    Type[] types2 = assembly2.GetTypes();</span><br><span class="line">    Assert.IsNotNull(types2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通过程序集名称反射">通过程序集名称反射</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">TestMethod</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Example_02</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Assembly assembly = Assembly.Load(<span class="string">&quot;CodeSnippet&quot;</span>);</span><br><span class="line">    <span class="comment">//参数必须是类的全名</span></span><br><span class="line">    Type t = assembly.GetType(<span class="string">&quot;CodeSnippet.Csharp.ReflectClass&quot;</span>);</span><br><span class="line">    <span class="built_in">object</span> o = Activator.CreateInstance(t, <span class="string">&quot;男&quot;</span>);</span><br><span class="line">    MethodInfo mi = t.GetMethod(<span class="string">&quot;Show&quot;</span>);</span><br><span class="line">    mi.Invoke(o, <span class="literal">null</span>);</span><br><span class="line">    Assert.IsNotNull(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通过DLL文件反射其中的所有类型">通过DLL文件反射其中的所有类型</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">TestMethod</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Example_03</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">warning disable S3885 <span class="comment">// &quot;Assembly.Load&quot; should be used</span></span><br><span class="line">    Assembly assembly = Assembly.LoadFrom(<span class="string">&quot;CodeSnippet.dll&quot;</span>);</span><br><span class="line">warning restore S3885 <span class="comment">// &quot;Assembly.Load&quot; should be used</span></span><br><span class="line">    Type[] types = assembly.GetTypes();</span><br><span class="line">    <span class="keyword">foreach</span> (Type t <span class="keyword">in</span> types)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (t.FullName == <span class="string">&quot;CodeSnippet.Csharp.ReflectClass&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">object</span> o = Activator.CreateInstance(t);</span><br><span class="line">            Assert.IsNotNull(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="BindingFlags">BindingFlags</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//     Specifies flags that control binding and the way in which the search for members</span></span><br><span class="line"><span class="comment">//     and types is conducted by reflection.</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/dotnet/%E5%9F%BA%E7%A1%80%E5%90%88%E9%9B%86/"/>
      <url>/dotnet/%E5%9F%BA%E7%A1%80%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p>C# 是面向对象的强类型高级语言，内置了用于存储不同类型数据的内置数据类型。每种数据类型都包含特定的取值范围，使用这些数据类型来表示在应用程序中存储的数据。数据类型进一步又被分为：</p><ul><li>值类型  <code>Value types</code></li><li>引用类型 <code>Reference types</code></li><li>指针类型 <code>Pointer types</code></li></ul><h1 id="值类型">值类型</h1><p>值类型特点是：变量直接存储其值，派生于 <code>System.ValueType</code>。</p><blockquote><p>值类型又细分为简单类型、枚举类型、结构类型、可以为 <code>null</code> 的值类型</p></blockquote><p><strong>简单类型</strong>：</p><ul><li>有符号的整型：<code>sbyte</code>、<code>short</code>、<code>int</code>、<code>long</code></li><li>无符号的整型：<code>byte</code>、<code>ushort</code>、<code>uint</code>、<code>ulong</code></li><li>Unicode 字符：<code>char</code></li><li>IEEE 二进制浮点：<code>float</code>、<code>double</code></li><li>高精度十进制浮点数：<code>decimal</code></li><li>布尔：<code>bool</code></li></ul><h1 id="引用类型">引用类型</h1><p>引用类型特点是：引用类型不直接存储其值，派生于 <code>System.Object</code>，它存储值的引用内存地址。多个变量指向一个内存位置时。如果内存位置的数据是由一个变量改变的，其他变量会自动反映这种值的变化。</p><p>类类型：</p><ul><li>所有类型的最终基类：<code>object</code></li><li>Unicode 字符串：<code>string</code></li><li>格式为：<code>class C &#123;…&#125;</code> 的用户定义类型</li></ul><p>接口类型、数组类型、委托类型，有关数值类型的详细信息，参考：<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/integral-numeric-types">整型类型</a> / <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/floating-point-numeric-types">浮点类型表</a>。</p><h1 id="变量">变量</h1><p>编译器需要用某个初始值对变量进行初始化，之后才能在操作中使用该变量。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法</span></span><br><span class="line">&lt;datatype&gt;&lt;variablename&gt;=&lt;<span class="keyword">value</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="built_in">string</span> name = <span class="string">&quot;wang&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同时声明多个</span></span><br><span class="line"><span class="built_in">string</span> name1,name2 = <span class="string">&quot;wang&quot;</span>;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>变量是类或结构中的字段，如果没有显式初始化，创建这些变量时，默认值就是类型默认值</li><li>方法的局部变量必须在代码中显式初始化才能在语句中使用</li><li>在C#中实例化一个引用对象需要使用 <code>new</code> 关键字把该引用指向存储在堆上的一个对象</li></ul><h1 id="变量作用域">变量作用域</h1><p>变量作用域指的是：可以访问该变量的代码区域</p><p><strong>注意</strong>：</p><ul><li>只要类在某个作用域内，其字段(也称为成员变量)也在该作用域内</li><li>局部变量存在于表示声明该变量的块语句或方法结束的右花括号之前的作用域内</li><li>在 <code>for</code>、 <code>while</code> 或类似语句中声明的局部变量存在于该循环体内</li></ul><h1 id="类型推断">类型推断</h1><p>使用 <code>var</code> 类型预先不用知道变量的类型，编译器可以根据变量的初始化值“推断”变量类型。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name =<span class="string">&quot;wang&quot;</span>;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><ul><li>变量必须初始化，否则编译器就没有推断变量类型的依据</li><li>初始化器不能为空</li><li>初始化器必须放在表达式中</li><li>不能把初始化器设置为一个对象，除非在初始化器中创建了一个新对象</li></ul><h1 id="常量">常量</h1><p>常量指的是：其值在使用过程中不会发生变化的变量。在声明和初始化变量时，在变量的前面加上关键字 <code>const</code>，就可以把该变量指定为一个常量。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> conntionName = <span class="string">&quot;testConntion&quot;</span>;</span><br></pre></td></tr></table></figure><p>常量具有如下特点：</p><ul><li>常量必须在声明时初始化。指定其值后就不能再改写</li><li>常量的值必须能在编译时用于计算。因此不能用从一个变量中提取的值来初始化常量。如果需要这么做，应使用只读字段 <code>readonly</code></li><li>常量总是静态的，但注意：不必(实际上，是不允许)在常量声明中包含修饰符</li></ul><p>使用常量的好处：</p><ul><li>常量使程序变得更易于阅读（使用易于读取理解的名称替代了较难读取的数字或字符串）</li><li>常量使程序更易于修改</li><li>常量更容易避免程序出现错误，如果在声明常量的位置以外将另一个值赋给常量，编译器就会报错</li></ul><h1 id="只读字段">只读字段</h1><p>常量的概念是一个包含不能修改的值的变量。但有时可能需要一些变量，其值不应改变，但在运行前其值是未知的。C#为这种情形提供了另一种类型的变量：只读字段。</p><blockquote><p>readonly 关键字比 const 灵活，允许把一个字段设置为常量，但还需要执行一些计算，以确定它的初始值。其规则是：可以在构造函数中给只读段赋值，但不能在其他地方赋值。只读字段可以是一个实例字段，而不是静态字段，类的每个实例可以有不同的值。与const 字段不同，如果要把只读字段设置为静态，就必须显式声明</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例只读字段</span></span><br><span class="line"><span class="keyword">readonly</span> <span class="built_in">double</span> taxRate;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态字段字段</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">double</span> taxRate1;</span><br><span class="line"></span><br><span class="line">BasicsTest()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 只读字段可以在声明时赋值，也可以在构造函数中赋值</span></span><br><span class="line">    taxRate = <span class="number">0.8</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">BasicsTest</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 静态只读字段在类的静态构造函数中赋值</span></span><br><span class="line">    taxRate1 = <span class="number">0.9</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="常量和只读字段的区别">常量和只读字段的区别</h1><ol><li>常量只能在声明语句中初始化，而且必须初始化，初始化之后在任何地方都不能改变。 <code>readonly</code> 字段既可以在声明时初始化，也可以在构造函数中改变它的值。（如果是 <strong>实例只读字段</strong> 可以在实例构造函数中改变它的值，如果是 <strong>静态只读字段</strong> 则可以在静态构造函数中改变它的值）</li><li>常量的值必须在编译时决定，编译完成之后它的值就被替换为字面量。 <code>readonly</code> 字段的值可以在运行时决定，可以在不同的构造函数中设置不同的值</li><li>常量总是像静态字段，在类的外部要通过 <strong>类名.常量名</strong> 的方式访问。<code>readonly</code> 字段既可以是静态字段，也可以是实例字段</li><li>常量在内存中没有存储位置，而 <code>readonly</code> 字段在内存中有存储位置</li></ol><h1 id="值类型和引用类型空值">值类型和引用类型空值</h1><p>默认情况下，引用类型在未初始化时具有空值。</p><ul><li>一个字符串变量(或引用类型数据类型的任何其他变量)，但没有赋值。这种情况下它具有空值，这意味着它不指向任何其他内存位置</li><li>值类型变量不能为 <code>null </code>，因为它包含值而不是内存地址。所以必须在使用前为值类型变量分配值</li></ul><h1 id="可空类型">可空类型</h1><p>C#2.0 为值类型引入了可空类型，允许为值类型变量赋值 <code>null</code> 或声明值类型变量而不为其赋值。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>? age = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h1 id="类型转换">类型转换</h1><p>C# 是一门强类型语言，对类型要求比较严格。但是在一定的条件下是可以相互转换的，如将 <code>int</code> 型数据转换成 <code>double</code> 型数据。C# 允许使用两种转换方式：隐式转换、显式转换。</p><h2 id="隐式转换">隐式转换</h2><p>隐式转换是系统默认的，不需要加以声明就会自动执行隐式类型转换，在隐式转换过程，编译器无需对转换进行详细检查就能够安全的执行。隐式类型转换是 <strong>从低精度数值类型=&gt;高精度数值类型</strong>。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">double</span> b = a;<span class="comment">// 自动隐式类型转换</span></span><br></pre></td></tr></table></figure><h2 id="显式转换">显式转换</h2><p><strong>高精度值=&gt;低精度</strong> 进行数据转换时，可能会丢失数据，这时候需要使用显式转换。并且要考虑到可能出现算术溢出。显式转换需要明确指出要转换的类型。显式转换可能导致错误，进行这种转换时编译器会对转换进行溢出检测，如果有溢出说明转换失败，表示源类型不是一个合法的目标类型无法进行类型转换，强制类型转换会造成数据精度丢失。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">double</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">int</span> b = (<span class="built_in">int</span>)a;<span class="comment">// 显式将double类型转换为int</span></span><br></pre></td></tr></table></figure><p>可空类型数据转换=&gt;非可空类型或者另一个可空类型，其中可能会丢失数据，就必须使用显式类型转换。并且如果从可空类型转换为非可空类型时变量值为 <code>null</code>，会抛出 <code>InvalidOperationException</code> 异常。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>? a = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">int</span> b = (<span class="built_in">int</span>)a;</span><br><span class="line"><span class="comment">// System.InvalidOperationException:“可为空的对象必须具有一个值。</span></span><br></pre></td></tr></table></figure><h2 id="通过方法进行转换">通过方法进行转换</h2><p><strong>ToString()</strong></p><p>C#中的类型基类都继承自 <code>Object</code> 类，所以都可以使用 <code>ToString()</code> 来转换成字符串。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">string</span> s = a.ToString();</span><br></pre></td></tr></table></figure><p><strong>Int.Parse()</strong></p><p>将 <code>string</code> 类型参数转换为 <code>int</code> ，注意： <code>string</code> 类型参数不能为 <code>null</code> ，并且也只能是各种整型，不能是浮点型。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> a = <span class="string">&quot;2&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> b = <span class="string">&quot;2.6&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> c = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">int</span> a1 = <span class="built_in">int</span>.Parse(a);<span class="comment">//正常</span></span><br><span class="line"><span class="built_in">int</span> a2 = <span class="built_in">int</span>.Parse(b);<span class="comment">//错误:输入字符串格式错误</span></span><br><span class="line"><span class="built_in">int</span> a3 = <span class="built_in">int</span>.Parse(c);<span class="comment">//值不能为null</span></span><br></pre></td></tr></table></figure><p><strong>Int.TryParse()</strong></p><p>该方法与 <code>Int.Parse()</code> 方法类似，不同点在于 <code>Int.Parse()</code> 方法无法转换成功时会抛出异常。而 <code>Int.TryParse()</code> 方法在无法进行转换时会返回 <code>false</code> ， <code>Int.TryParse()</code> 方法需要一个 <code>out</code> 类型的参数，如果转换成功， <code>out</code> 参数的值就是正常转换的值，否则返回 <code>false</code> 。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> a = <span class="string">&quot;2&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> b = <span class="string">&quot;2.6&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> c = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">int</span> i;</span><br><span class="line"><span class="built_in">bool</span> a1 = <span class="built_in">int</span>.TryParse(a，<span class="keyword">out</span> i);<span class="comment">//转换成功，i=2</span></span><br><span class="line"><span class="built_in">bool</span> a2 = <span class="built_in">int</span>.TryParse(b， <span class="keyword">out</span> i);<span class="comment">//转换失败，a2=false</span></span><br><span class="line"><span class="built_in">bool</span> a3 = <span class="built_in">int</span>.TryParse(c， <span class="keyword">out</span> i);<span class="comment">//转换失败，a3=false</span></span><br></pre></td></tr></table></figure><p><strong>Convert()</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> a = <span class="string">&quot;2&quot;</span>;</span><br><span class="line"><span class="built_in">int</span> a1 = Convert.ToInt32(a);</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>方法</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>Convert.ToInt32()</td><td>转换为整型(int)</td></tr><tr><td>Convert.ToChar()</td><td>转换为字符型(char)</td></tr><tr><td>Convert.ToString()</td><td>转换为字符串型(string)</td></tr><tr><td>Convert.ToDateTime()</td><td>转换为日期型(datetime)</td></tr><tr><td>Convert.ToDouble()</td><td>转换为双精度浮点型(double)</td></tr><tr><td>Conert.ToSingle()</td><td>转换为单精度浮点型(float)</td></tr></tbody></table><h2 id="自定义转换">自定义转换</h2><p>通过继承接口 <code>IConventible</code> 或者 <code>TypeConventer</code> 类，可以实现自定义转换。</p><h2 id="使用-as-运算符转换">使用 as 运算符转换</h2><p><code>as</code> 只能用于引用类型和可为空的类型。使用 <code>as</code> 有很多好处，当无法进行类型转换时，会将对象赋值为 <code>NULL</code> ，避免类型转换时报错或是抛出异常。C#抛出异常在进行捕获异常并进行处理是很消耗资源的，如果只是将对象赋值为 <code>NULL</code> 的话是几乎不消耗资源的(消耗很小的资源)。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">object</span> o = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> s = o <span class="keyword">as</span> <span class="built_in">string</span>; <span class="comment">//执行第一次类型兼容性检查，并返回结果</span></span><br><span class="line"><span class="keyword">if</span> (s != <span class="literal">null</span>)</span><br><span class="line">Console.WriteLine(<span class="string">&quot;转换成功！&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;转换失败！&quot;</span>);</span><br></pre></td></tr></table></figure><h1 id="装箱和拆箱">装箱和拆箱</h1><p>C#通过装箱和拆箱来实现值类型和引用类型的相互转换，使得任何 <code>value-type</code> 的值都可以转换为 <code>object</code> 类型的值，反之亦可。</p><h2 id="装箱">装箱</h2><p>装箱是指：将值类型的数据隐式地转换成一个对象类型(<code>object</code>)的数据。执行装箱操作时不可避免的要在堆上申请内存空间，并将堆栈上的值类型数据复制到申请的堆内存空间上，这是要消耗内存和cpu资源的。在执行装箱转换时，也可以使用显式转换。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">object</span> obj = i;   <span class="comment">//装箱：值类型转换为引用类型</span></span><br></pre></td></tr></table></figure><h2 id="拆箱">拆箱</h2><p>拆箱是指：将一个对象类型的数据显式地转换成一个值类型数据。拆箱过程是装箱的逆过程，是将存储在堆上的引用类型值转换为值类型并赋给值类型变量。</p><p>拆箱操作分为两步：</p><ol><li>检查对象实例，确保它是给定值类型的一个装箱值</li><li>将该值从实例复制到值类型变量中</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">object</span> obj = i;    <span class="comment">//装箱：值类型转换为引用类型</span></span><br><span class="line"><span class="built_in">int</span> j = (<span class="built_in">int</span>)obj;  <span class="comment">//拆箱：引用类型转换为值类型</span></span><br></pre></td></tr></table></figure><h2 id="注意">注意</h2><ul><li>装箱可以隐式进行，但拆箱必须显式</li><li>在装箱的时候，并不需要显式类型转换。但在拆箱时需要类型转换。因为在拆箱时对象可以被转换为任何类型</li><li>装什么拆什么，装箱就是要在托管堆重开辟空间，不但要装数值而且还要装类型。所以说装什么拆什么，也就是用什么值类型装箱，就要用什么值类型拆箱</li></ul><h1 id="运算符">运算符</h1><h2 id="三元运算符">三元运算符</h2><p><code>if/else</code> 的简化形式。首先判断一个条件，如果为真返回第一个值，为假返回后一个值。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">bool</span> result = a &gt; <span class="number">10</span> ? <span class="literal">true</span> : <span class="literal">false</span>; <span class="comment">//a&gt;10?如果大于返回true否则返回false</span></span><br></pre></td></tr></table></figure><h2 id="可空类型和运算符">可空类型和运算符</h2><p>在 <code>C# 2.0</code> 中出现了可空类型，允许值类型也可以为空 <code>null</code>，可空类型的实现基于 C#泛型。</p><p>注意：在程序中使用可空类型就必须考虑 <code>null</code> 值在各种运算符一起使用的影响，通常可空类型与一元或二元运算符一起使用时，如果一个操作数为 <code>null</code> 或两个操作数为 <code>null</code> ，结果就是 <code>null</code> 。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>? a = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">int</span>? c = a + <span class="number">4</span>; <span class="comment">//c=null</span></span><br></pre></td></tr></table></figure><h2 id="空合并运算符">空合并运算符</h2><p>空合并运算符 <code>??</code> 提供了快捷方式处理可空类型和引用类型时表示 <code>null</code> 可能的值。</p><p>注意： 只能针对引用类型处理，规则是：</p><ul><li>如果第一个操作数不是<code>null</code>，值就等于第一个操作数的值</li><li>如果第一个操作数是<code>null</code>，值就等于第二个操作数的值</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>? a = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">int</span> b;</span><br><span class="line">b = a ?? <span class="number">10</span>;<span class="comment">//第一个操作数是null，值为第二个操作数.10</span></span><br><span class="line">a = <span class="number">3</span>;</span><br><span class="line">b = a ?? <span class="number">10</span>;<span class="comment">//第一个操作数不是null，值为第一个操作数.3</span></span><br></pre></td></tr></table></figure><h2 id="checked-unchecked">checked/unchecked</h2><p>如果把代码块标记为 <code>checked</code> ， <code>CLR</code> 就会执行栈溢出检测，如果要禁止栈溢出，则可以把代码标记 <code>unchecked</code> 。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//byte类型最大取值255</span></span><br><span class="line"><span class="built_in">byte</span> a = <span class="number">255</span>;</span><br><span class="line">checked</span><br><span class="line">&#123;</span><br><span class="line">     a++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里如果不加checed.++后输出0(不会抛异常，但会丢失数据，溢出的位会被舍弃，所以值为0)，加上后会抛出栈溢出异常</span></span><br><span class="line">Console.WriteLine(a);</span><br></pre></td></tr></table></figure><h2 id="is">is</h2><p><code>is</code>  运算符可以检测对象是否与特定类型兼容，兼容表示对象是该类型或者派生自该类型。</p><p>转换规则如下：</p><ul><li>检查对象类型的兼容性，并返回结果 <code>true/false</code> 。</li><li>不会抛出异常</li><li>如果对象为<code>null</code>，刚返回<code>false</code></li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">object</span> o = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (o <span class="keyword">is</span> <span class="built_in">string</span>) <span class="comment">//执行第一次类型兼容性检查</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> s = (<span class="built_in">string</span>)o; <span class="comment">//执行第二次类型兼容性检查，并转换</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;转换成功！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;转换失败！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="as">as</h2><p>转换规则如下：</p><ul><li>检查对象类型的兼容性并返回转换结果，如果不兼容则返回<code>null</code></li><li>不会抛出异常</li><li>如果结果判断为空，则强制执行类型转换将抛出 <code>NullReferenceException</code> 异常</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">object</span> o = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> s = o <span class="keyword">as</span> <span class="built_in">string</span>; <span class="comment">//执行第一次类型兼容性检查，并返回结果</span></span><br><span class="line"><span class="keyword">if</span> (s != <span class="literal">null</span>)</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;转换成功！&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;转换失败！&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="sizeof">sizeof</h2><p><code>sizeof</code> 运算符可以确定栈中值类型需要的长度(单位为字节)。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(<span class="keyword">sizeof</span>(<span class="built_in">int</span>));<span class="comment">//4个字节</span></span><br><span class="line">Console.WriteLine(<span class="keyword">sizeof</span>(<span class="built_in">byte</span>));<span class="comment">//1个字节</span></span><br></pre></td></tr></table></figure><h2 id="typeof">typeof</h2><p>返回一个表示特定类型的 <code>System.Type</code> 对象。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(<span class="keyword">typeof</span>(<span class="built_in">int</span>));<span class="comment">//System.Int32</span></span><br><span class="line">Console.WriteLine(<span class="keyword">typeof</span>(<span class="built_in">byte</span>));<span class="comment">//System.Byte</span></span><br></pre></td></tr></table></figure><h1 id="关键字">关键字</h1><p><code>C#</code> 包含保留字，对编译器有特殊意义。这些保留字称为“关键字”。关键字不能用作变量，类，接口等的名称(标识符)，关键字不能用作标识符(变量名，类，接口等)。但是，它们可以与前缀“@”一起使用。例如，class 是保留关键字，因此不能用作标识符，但可以使用 <code>@class</code> 。</p><p>🎨 <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/index"><strong>关键字的更多信息，访问 MSDN</strong></a></p><h1 id="枚举">枚举</h1><p><code>enum</code> 是值类型数据类型。枚举用于声明命名整数常量的列表。可以直接在命名空间，类或结构中使用 <code>enum</code> 关键字定义。</p><ul><li>枚举用于为每个常量指定一个名称，以便可以使用其名称引用常量整数默认情况下，枚举的第一个成员的值为 0，每个连续的枚举成员的值增加 1</li><li>枚举可以包括数字数据类型的命名常量，例如 <code>byte</code>，<code>sbyte</code>，<code>short</code>，<code>ushort</code>，<code>int</code>，<code>uint</code>，<code>long</code> 或 <code>ulong</code></li><li>枚举不能与字符串类型一起使用</li></ul><p><code>Enum</code> 是一个抽象类，包含用于枚举的静态帮助器方法</p><table><thead><tr><th><strong>Enum method</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td><code>Format</code></td><td>将指定的枚举类型值转换为指定的字符串格式</td></tr><tr><td><code>GetName</code></td><td>返回指定枚举的指定值的常量的名称</td></tr><tr><td><code>GetNames</code></td><td>返回指定枚举的所有常量的字符串名称数组</td></tr><tr><td><code>GetValues</code></td><td>返回指定枚举的所有常量值的数组</td></tr><tr><td><code>object Parse(type, string)</code></td><td>将一个或多个枚举常量的名称或数值的字符串表示形式转换为等效的枚举对象</td></tr><tr><td><code>bool TryParse(string, out TEnum)</code></td><td>将一个或多个枚举常量的名称或数值的字符串表示形式转换为等效的枚举对象，返回值表示转换是否成功</td></tr></tbody></table><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Color</span><br><span class="line">&#123;</span><br><span class="line">    Red，</span><br><span class="line">    Green，</span><br><span class="line">    Blue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="预处理器指令">预处理器指令</h1><p><code>#region/#endregion</code> 指令用于把一段代码标记为有给定名称的一个块</p><p><code>define/#undef</code>   结合 <code>#if/#elif/endif</code>  实现条件编译</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug</span></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">CSharp.Study.Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> debug</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;debug&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">          Console.WriteLine(<span class="string">&quot;other&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/dotnet/1.4%E6%96%B9%E6%A1%88%E5%AE%9E%E8%B7%B5%E5%8F%8A%E9%9B%86%E6%88%90AzureDevops%E7%AE%A1%E9%81%93/"/>
      <url>/dotnet/1.4%E6%96%B9%E6%A1%88%E5%AE%9E%E8%B7%B5%E5%8F%8A%E9%9B%86%E6%88%90AzureDevops%E7%AE%A1%E9%81%93/</url>
      
        <content type="html"><![CDATA[<h1 id="CI-Pipeline">CI Pipeline</h1><p><img src="/images/2021-09-24-16-10-04.png" alt=""></p><p><img src="/images/2021-09-24-16-19-54.png" alt=""></p><p>CI Pipeline 设计并没有特别之处，重点在于 CD Pipeline设计。</p><h1 id="CD-Pipeline">CD Pipeline</h1><p><img src="/images/2021-09-24-16-12-03.png" alt=""></p><p>除了自身的CI源之前，添加生成密文控制台应用程序也作为源，以便于在CD过程中使用加密功能。</p><h1 id="Development">Development</h1><p><img src="/images/2021-09-24-16-13-03.png" alt=""><br>Development 开发环境是明文存储的，所以CD管道不做特殊处理。</p><h1 id="Sit">Sit</h1><p><img src="/images/2021-09-24-16-14-19.png" alt=""></p><p>SIT 环境的配置不同，在CD过程中会替换环境变量的值。</p><h2 id="环境变量设置">环境变量设置</h2><p><img src="/images/2021-09-24-16-15-25.png" alt=""></p><h2 id="Step1：下载安全文件">Step1：下载安全文件</h2><p>下载证书，证书存储在Devops中的库中，需要手动上传，如何生成证书自行查找资料。</p><p><img src="/images/2021-09-24-16-16-25.png" alt=""></p><h2 id="Step2：生成加密文件">Step2：生成加密文件</h2><p>依赖生成密文的程序生成秘钥文件以及 <code>secret.xml</code>。</p><p><img src="/images/2021-09-24-16-17-04.png" alt=""></p><h2 id="Step3：机密变量替换">Step3：机密变量替换</h2><p>使用 powershell 脚本解析 Step2 步骤中生成的 secret.xml 文件并替换环境变量的值。</p><p><img src="/images/2021-09-24-16-17-34.png" alt=""></p><h2 id="Step4：启用变量替换">Step4：启用变量替换</h2><p><img src="/images/2021-09-24-16-18-16.png" alt=""></p><h1 id="测试">测试</h1><p><img src="/images/2021-09-24-16-24-40.png" alt=""><br>Development<br><img src="/images/2021-09-24-16-25-07.png" alt=""><br>Sit<br><img src="/images/2021-09-24-16-25-28.png" alt=""></p><p><img src="/images/2021-09-24-16-25-45.png" alt=""></p><p>这里DataBase.DbConnection是null是因为DataBase并不是一个Option。</p><p><img src="/images/2021-09-24-16-26-20.png" alt=""></p><p>可以通过<code>dotnet</code>命令启动程序来查看是否解密成功</p><p>并未做到全自动化，还有很多不足，比如证书如何自动化安装，证书如果有密码如何处理，替换机密变量时Shell脚本的优化、UserSecret集成等。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/dotnet/1.2%E5%AE%9E%E8%B7%B5%E5%8F%8A%E5%A4%9A%E7%8E%AF%E5%A2%83%E8%B0%83%E8%AF%95/"/>
      <url>/dotnet/1.2%E5%AE%9E%E8%B7%B5%E5%8F%8A%E5%A4%9A%E7%8E%AF%E5%A2%83%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="新建-Web应用程序">新建 Web应用程序</h1><p><img src="/images/2021-09-24-15-52-30.png" alt=""></p><h1 id="Configuration-加载顺序">Configuration 加载顺序</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Microsoft.Extensions.Hosting</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 摘要:</span></span><br><span class="line">    <span class="comment">//     Provides convenience methods for creating instances of Microsoft.Extensions.Hosting.IHostBuilder</span></span><br><span class="line">    <span class="comment">//     with pre-configured defaults.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Host</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 摘要:</span></span><br><span class="line">        <span class="comment">//     Initializes a new instance of the Microsoft.Extensions.Hosting.HostBuilder class</span></span><br><span class="line">        <span class="comment">//     with pre-configured defaults.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 返回结果:</span></span><br><span class="line">        <span class="comment">//     The initialized Microsoft.Extensions.Hosting.IHostBuilder.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 言论：</span></span><br><span class="line">        <span class="comment">//     The following defaults are applied to the returned Microsoft.Extensions.Hosting.HostBuilder:</span></span><br><span class="line">        <span class="comment">//     • set the Microsoft.Extensions.Hosting.IHostEnvironment.ContentRootPath to the</span></span><br><span class="line">        <span class="comment">//     result of System.IO.Directory.GetCurrentDirectory</span></span><br><span class="line">        <span class="comment">//     • load host Microsoft.Extensions.Configuration.IConfiguration from &quot;DOTNET_&quot;</span></span><br><span class="line">        <span class="comment">//     prefixed environment variables</span></span><br><span class="line">        <span class="comment">//     • load app Microsoft.Extensions.Configuration.IConfiguration from &#x27;appsettings.json&#x27;</span></span><br><span class="line">        <span class="comment">//     and &#x27;appsettings.[Microsoft.Extensions.Hosting.IHostEnvironment.EnvironmentName].json&#x27;</span></span><br><span class="line">        <span class="comment">//     • load app Microsoft.Extensions.Configuration.IConfiguration from User Secrets</span></span><br><span class="line">        <span class="comment">//     when Microsoft.Extensions.Hosting.IHostEnvironment.EnvironmentName is &#x27;Development&#x27;</span></span><br><span class="line">        <span class="comment">//     using the entry assembly</span></span><br><span class="line">        <span class="comment">//     • load app Microsoft.Extensions.Configuration.IConfiguration from environment</span></span><br><span class="line">        <span class="comment">//     variables</span></span><br><span class="line">        <span class="comment">//     • configure the Microsoft.Extensions.Logging.ILoggerFactory to log to the console,</span></span><br><span class="line">        <span class="comment">//     debug, and event source output</span></span><br><span class="line">        <span class="comment">//     • enables scope validation on the dependency injection container when Microsoft.Extensions.Hosting.IHostEnvironment.EnvironmentName</span></span><br><span class="line">        <span class="comment">//     is &#x27;Development&#x27;</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IHostBuilder <span class="title">CreateDefaultBuilder</span>(<span class="params"></span>)</span>;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 摘要:</span></span><br><span class="line">        <span class="comment">//     Initializes a new instance of the Microsoft.Extensions.Hosting.HostBuilder class</span></span><br><span class="line">        <span class="comment">//     with pre-configured defaults.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 参数:</span></span><br><span class="line">        <span class="comment">//   args:</span></span><br><span class="line">        <span class="comment">//     The command line args.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 返回结果:</span></span><br><span class="line">        <span class="comment">//     The initialized Microsoft.Extensions.Hosting.IHostBuilder.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 言论：</span></span><br><span class="line">        <span class="comment">//     The following defaults are applied to the returned Microsoft.Extensions.Hosting.HostBuilder:</span></span><br><span class="line">        <span class="comment">//     • set the Microsoft.Extensions.Hosting.IHostEnvironment.ContentRootPath to the</span></span><br><span class="line">        <span class="comment">//     result of System.IO.Directory.GetCurrentDirectory</span></span><br><span class="line">        <span class="comment">//     • load host Microsoft.Extensions.Configuration.IConfiguration from &quot;DOTNET_&quot;</span></span><br><span class="line">        <span class="comment">//     prefixed environment variables</span></span><br><span class="line">        <span class="comment">//     • load host Microsoft.Extensions.Configuration.IConfiguration from supplied command</span></span><br><span class="line">        <span class="comment">//     line args</span></span><br><span class="line">        <span class="comment">//     • load app Microsoft.Extensions.Configuration.IConfiguration from &#x27;appsettings.json&#x27;</span></span><br><span class="line">        <span class="comment">//     and &#x27;appsettings.[Microsoft.Extensions.Hosting.IHostEnvironment.EnvironmentName].json&#x27;</span></span><br><span class="line">        <span class="comment">//     • load app Microsoft.Extensions.Configuration.IConfiguration from User Secrets</span></span><br><span class="line">        <span class="comment">//     when Microsoft.Extensions.Hosting.IHostEnvironment.EnvironmentName is &#x27;Development&#x27;</span></span><br><span class="line">        <span class="comment">//     using the entry assembly</span></span><br><span class="line">        <span class="comment">//     • load app Microsoft.Extensions.Configuration.IConfiguration from environment</span></span><br><span class="line">        <span class="comment">//     variables</span></span><br><span class="line">        <span class="comment">//     • load app Microsoft.Extensions.Configuration.IConfiguration from supplied command</span></span><br><span class="line">        <span class="comment">//     line args</span></span><br><span class="line">        <span class="comment">//     • configure the Microsoft.Extensions.Logging.ILoggerFactory to log to the console,</span></span><br><span class="line">        <span class="comment">//     debug, and event source output</span></span><br><span class="line">        <span class="comment">//     • enables scope validation on the dependency injection container when Microsoft.Extensions.Hosting.IHostEnvironment.EnvironmentName</span></span><br><span class="line">        <span class="comment">//     is &#x27;Development&#x27;</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IHostBuilder <span class="title">CreateDefaultBuilder</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这段注释：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//     • load app Microsoft.Extensions.Configuration.IConfiguration from &#x27;appsettings.json&#x27;</span><br><span class="line">//     and &#x27;appsettings.[Microsoft.Extensions.Hosting.IHostEnvironment.EnvironmentName].json&#x27;</span><br><span class="line">//     • load app Microsoft.Extensions.Configuration.IConfiguration from User Secrets</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            CreateHostBuilder(args).Build().Run();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IHostBuilder <span class="title">CreateHostBuilder</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> =&gt;</span><br><span class="line">            Host.CreateDefaultBuilder(args)</span><br><span class="line">                .ConfigureWebHostDefaults(webBuilder =&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    webBuilder.UseStartup&lt;Startup&gt;();</span><br><span class="line">                &#125;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这里意思是说：<code>Host.CreateDefaultBuilder()</code> 加载 <code>Configuration</code> 的顺序是：</p><ol><li><code>appsettings.json</code></li><li><code>appsettings.&#123;envName&#125;.json</code></li><li><code>usesecrets(secrets.json)</code></li></ol><blockquote><p>同一个节点信息如果在三个<code>.json</code>文件中都有定义，会依赖加载顺序，最后的会覆盖之前的</p></blockquote><h1 id="多环境配置">多环境配置</h1><p><img src="/images/2021-09-24-15-54-39.png" alt=""></p><p>这里的设计思路是将全局通用配置放在 <code>appsettings.json</code> 中，不同环境根据需求配置自己的节点，也可以使用相同名称来覆盖 <code>appsettings.json</code>。</p><p>appsettings.json</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;Logging&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;LogLevel&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;Default&quot;</span>: <span class="string">&quot;Information&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;AllowedHosts&quot;</span>: <span class="string">&quot;*&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>appsettings.Development.json</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;ConnectString&quot;</span>: <span class="string">&quot;Server=.;Database=WebApp01.Db.Dev;uid=sa;pwd=wpl19950815;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>appsettings.Sit.json</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;ConnectString&quot;</span>: <span class="string">&quot;Server=.;Database=WebApp01.Db.Sit;uid=sa;pwd=wpl19950815;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调试不同环境：</p><p><img src="/images/2021-09-24-15-55-42.png" alt=""></p><p>通过设置 <code>environmentVariables:ASPNETCORE_ENVIRONMENT</code> 环境名称来切换使用不同环境的配置文件，这里环境变量名称需要和 <code>appsetting.&#123;envName&#125;.json</code> 中 <code>&#123;envName&#125;</code> 保持一致。</p><p>在应用程序开发的过程中，有的时候需要在代码中保存一些机密的信息，比如加密密钥，字符串，或者是用户名密码等。通常的做法是保存到一个配置文件中，以前会保存到 <code>web.config</code> 中，但是 <a href="http://ASP.NET">ASP.NET</a> Core中，有更多多元化的方法可以更加优雅的的设置或者保存这些机密资料。</p><h1 id="用户机密简介">用户机密简介</h1><p>使用场景：</p><ul><li>需要保存一些和第三方网站对接的密钥，比如和 微信，微博站点使用的 appkey</li><li>给每个开发人员配置不用的用户名密码来访问一些资源</li><li>开发人员在开发过程中使用各自本机的数据库，如何配置数据库地址、账号和密码</li></ul><p><a href="http://ASP.NET">ASP.NET</a> Core 提供了一种很优雅简洁的方式 <code>User Secrets</code> 用来解决这个事情。</p><p>新建 Web 应用程序，在 Web 项目上右键,可以看到一个 <code>管理用户机密</code> 的菜单：</p><p><img src="/images/2021-09-24-15-59-28.png" alt=""></p><p><code>secrets.json</code><br><img src="/images/2021-09-24-16-00-19.png" alt=""></p><p><strong><code>secrets.json</code> 文件存储位置</strong>：</p><p>在非Windows系统中，它存储在</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/.microsoft/usersecrets/&lt;userSecretsId&gt;/secrets.json</span><br></pre></td></tr></table></figure><p>在Windows系统中，它存储在</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\用户名\AppData\Roaming\Microsoft\UserSecrets\aspnet-WebAppCore-e278c40f-15bd-4c19-9662-541514f02f3e</span><br></pre></td></tr></table></figure><p>可以看到，存储的上层文件夹就是 <code>project.json</code> 文件中的 <code>userSecretsId</code> 设定的值。</p><h1 id="应用程序中使用">应用程序中使用</h1><p>要在应用程序中访问配置的用户机密，需要保证 <code>project.json</code> 文件中存在依赖项：<code>Microsoft.Extensions.Configuration.UserSecrets</code> 并且<code>builder.AddUserSecrets()</code>。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/dotnet/1.3%E5%9F%BA%E4%BA%8EDataProtection%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BF%9D%E6%8A%A4%E6%96%B9%E6%A1%88/"/>
      <url>/dotnet/1.3%E5%9F%BA%E4%BA%8EDataProtection%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BF%9D%E6%8A%A4%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h1 id="准备工作">准备工作</h1><h2 id="DataProtectionOption">DataProtectionOption</h2><p>将使用数据保护需要的参数做成 <code>Option</code> ，方便配置调用。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ProtectionOption</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span>应用程序名称<span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;value&gt;</span>The name of the application.<span class="doctag">&lt;/value&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> ApplicationName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span>证书指纹<span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;value&gt;</span>The thumbprint.<span class="doctag">&lt;/value&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Thumbprint &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span>私钥存储路径<span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;value&gt;</span>The secret key path.<span class="doctag">&lt;/value&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> SecretKeyPath &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span>保护器名称<span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;value&gt;</span>The purpose.<span class="doctag">&lt;/value&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Purpose &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ProtectionOptionBase">ProtectionOptionBase</h2><p>真实项目中，不可能只对单个字符串进行加解密，大多数时候是对某个 <code>Option</code> 配置进行加解密，定义需要解密的 <code>Option</code> 需要继承的基类，Option上带有 <code>EncryptedAttribute</code>  标记的属性将会被解密。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span>使用数据保护的Option要继承的基类,带有EncryptedAttribute标记的将会被解密<span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">ProtectionOptionBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> Decrypted &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Decrypt</span>(<span class="params">IDataProtector protector</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Decrypted) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="function">PropertyInfo property <span class="keyword">in</span> <span class="title">GetType</span>(<span class="params"></span>).<span class="title">GetProperties</span>(<span class="params"></span>))</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (property.GetCustomAttribute&lt;EncryptedAttribute&gt;() != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">string</span> text = property.GetValue(<span class="keyword">this</span>).ToString();</span><br><span class="line">                property.SetValue(<span class="keyword">this</span>, protector.Unprotect(text));</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Decrypted = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CopyTo</span>(<span class="params">ProtectionOptionBase option</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="function">PropertyInfo property <span class="keyword">in</span> <span class="title">GetType</span>(<span class="params"></span>).<span class="title">GetProperties</span>(<span class="params"></span>))</span></span><br><span class="line">        &#123;</span><br><span class="line">            property.SetValue(option, property.GetValue(<span class="keyword">this</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="EncryptedAttribute">EncryptedAttribute</h2><p>定义特性，用于标识属性是否需要被解密。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EncryptedAttribute</span> : <span class="title">Attribute</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DataProtectionExtensions">DataProtectionExtensions</h2><p>基于数据保护服务添加扩展方法，提供注入服务并使用指定证书进行解密的能力。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">DataProtectionExtensions</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span>注册数据保护服务,使用x509证书加密<span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;services&quot;&gt;</span>The services.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;exception cref=&quot;Exception&quot;&gt;</span>not found X509Certificate<span class="doctag">&lt;/exception&gt;</span></span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IDataProtector <span class="title">AddDataProtectionWithX509</span>(<span class="params"><span class="keyword">this</span> IServiceCollection services</span>)</span></span><br><span class="line">       &#123;</span><br><span class="line">           ServiceProvider provider = services.BuildServiceProvider();</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 获取用户配置数据保护的Option</span></span><br><span class="line">           ProtectionOption protectionOption = provider</span><br><span class="line">               .GetRequiredService&lt;IOptions&lt;ProtectionOption&gt;&gt;().Value;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 获取证书</span></span><br><span class="line">           X509Certificate2 cert = GetCertificateFromStore(protectionOption.Thumbprint);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 注册服务</span></span><br><span class="line">           services.AddDataProtection()</span><br><span class="line">               <span class="comment">// 设置应用程序名称</span></span><br><span class="line">               .SetApplicationName(protectionOption.ApplicationName)</span><br><span class="line">               <span class="comment">// 设置秘钥存储路径</span></span><br><span class="line">               .PersistKeysToFileSystem(<span class="keyword">new</span> DirectoryInfo(protectionOption.SecretKeyPath))</span><br><span class="line">               <span class="comment">// 设置用于加密的证书</span></span><br><span class="line">               .UnprotectKeysWithAnyCertificate(cert);</span><br><span class="line"></span><br><span class="line">           provider = services.BuildServiceProvider();</span><br><span class="line"></span><br><span class="line">           IDataProtectionProvider protectionProvider = provider.GetRequiredService&lt;IDataProtectionProvider&gt;();</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 创建数据保护器</span></span><br><span class="line">           IDataProtector protector = protectionProvider.CreateProtector(protectionOption.Purpose);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 注册单例的数据保护器</span></span><br><span class="line">           services.AddSingleton&lt;IDataProtector&gt;(serviceProvider =&gt; protector);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">return</span> protector;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IServiceCollection <span class="title">ProtectedConfigure</span>&lt;<span class="title">TOptions</span>&gt;(<span class="params"><span class="keyword">this</span> IServiceCollection services</span></span></span><br><span class="line"><span class="params"><span class="function">           , IConfigurationSection section</span>)</span></span><br><span class="line"><span class="function">            <span class="keyword">where</span> TOptions : ProtectionOptionBase, <span class="keyword">new</span>(<span class="params"></span>)</span></span><br><span class="line">       &#123;</span><br><span class="line">           ServiceProvider provider = services.BuildServiceProvider();</span><br><span class="line">           IDataProtector protector = provider.GetRequiredService&lt;IDataProtector&gt;();</span><br><span class="line"></span><br><span class="line">           services.Configure&lt;TOptions&gt;(option =&gt;</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">var</span> config = section.Get&lt;TOptions&gt;();</span><br><span class="line">               config.Decrypt(protector);</span><br><span class="line">               config.CopyTo(option);</span><br><span class="line">           &#125;);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">return</span> services;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> Get the certifcate to use to encrypt the key</span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> CertSearchArea：StoreLocation.CurrentUser/StoreLocation.LocalMachine</span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;thumbprint&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> X509Certificate2 <span class="title">GetCertificateFromStore</span>(<span class="params"><span class="built_in">string</span> thumbprint</span>)</span></span><br><span class="line">       &#123;</span><br><span class="line">           X509Certificate2 signingCert =</span><br><span class="line">               GetCertificateFromStore(thumbprint, StoreLocation.CurrentUser);</span><br><span class="line">           <span class="keyword">if</span> (signingCert != <span class="literal">null</span>)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">return</span> signingCert;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">           &#123;</span><br><span class="line">               signingCert =</span><br><span class="line">                  GetCertificateFromStore(thumbprint, StoreLocation.LocalMachine);</span><br><span class="line">               <span class="keyword">if</span> (signingCert != <span class="literal">null</span>)</span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="keyword">return</span> signingCert;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> X509Certificate2Exception(<span class="string">&quot;本机和当前用户证书存储区都未找到对应证书&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span>Gets the certificate from store.<span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;thumbprint&quot;&gt;</span>The thumbprint.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;storeLocation&quot;&gt;</span>The store location.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> X509Certificate2 <span class="title">GetCertificateFromStore</span>(<span class="params"><span class="built_in">string</span> thumbprint, StoreLocation storeLocation</span>)</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="comment">// 获取本地机器证书存储</span></span><br><span class="line">           X509Store localMachineStore = <span class="keyword">new</span> X509Store(storeLocation);</span><br><span class="line">           <span class="keyword">try</span></span><br><span class="line">           &#123;</span><br><span class="line">               localMachineStore.Open(OpenFlags.ReadOnly);</span><br><span class="line">               X509Certificate2Collection certCollection = localMachineStore.Certificates;</span><br><span class="line">               X509Certificate2Collection localMachineCerts =</span><br><span class="line">                   certCollection.Find(X509FindType.FindByTimeValid, DateTime.Now, <span class="literal">false</span>);</span><br><span class="line">               X509Certificate2Collection signingCert =</span><br><span class="line">                   localMachineCerts.Find(X509FindType.FindByThumbprint, thumbprint, <span class="literal">false</span>);</span><br><span class="line">               <span class="keyword">if</span> (signingCert.Count == <span class="number">0</span>)</span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">return</span> signingCert[<span class="number">0</span>];</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">finally</span></span><br><span class="line">           &#123;</span><br><span class="line">               localMachineStore.Close();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="GeneratingCiphertext-Console">GeneratingCiphertext.Console</h2><p>依赖指定证书生成加密文件 <code>secret.xml</code> 以及对应 <code>&#123;key&#125;.xml</code>文件。</p><ul><li><code>&#123;key&#125;.xml</code>是生成的秘钥文件</li><li><code>secret.xml</code>在之后的管道集成中会使用到</li></ul><p><img src="/images/2021-09-24-16-06-37.png" alt=""></p><p>注意：在启动时必须提供必需的参数才可生成 <code>secret.xml</code> 及 <code>&#123;key&#125;.xml</code> 文件；在管道中使用命令行操作，在<code>Visual Studio</code>中可以使用如下方式设置：</p><p><img src="/images/2021-09-24-16-06-56.png" alt=""></p><p>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--cpath=<span class="string">&quot;C:\\Users\\WangPengLiang\\Desktop\\DataProtection\\dev.pfx&quot;</span>  --cpass=<span class="string">&quot;wpl19950815&quot;</span> --purpose=<span class="string">&quot;RedPI.Todo&quot;</span> --spath=<span class="string">&quot;C:\\Users\\WangPengLiang\\Desktop\\DataProtection\\app-keys&quot;</span> --appname=<span class="string">&quot;RedPI.Todo&quot;</span> --snodes=<span class="string">&quot;a:1, b:2&quot;</span>  --soutputpath=<span class="string">&quot;C:\Users\WangPengLiang\Desktop\DataProtection&quot;</span></span><br></pre></td></tr></table></figure><h1 id="项目应用">项目应用</h1><h2 id="appsettings-json">appsettings.json</h2><p>appsettings.json中包含了通用的Option的配置。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 数据保护相关配置;SecretKeyPath:固定目录</span></span><br><span class="line">  <span class="attr">&quot;ProtectionOption&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;Thumbprint&quot;</span>: <span class="string">&quot;CD Replace&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;ApplicationName&quot;</span>: <span class="string">&quot;CD Replace&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;SecretKeyPath&quot;</span>: <span class="string">&quot;DataProtection\\app-keys&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;Purpose&quot;</span>: <span class="string">&quot;CD Replace&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="appsettings-Development-json">appsettings.Development.json</h2><p>appsettings.Development.json 只包含针对当前环境的配置，直接明文存储。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 开发环境：明文存储</span></span><br><span class="line">  <span class="attr">&quot;TestOption&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;Test1&quot;</span>: <span class="string">&quot;dev-test1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;Test2&quot;</span>: <span class="string">&quot;dev-test2&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;DataBase&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;DbConnection&quot;</span>: <span class="string">&quot;Server=.;Database=WebApp01.Database;uid=sa;pwd=wpl19950815;&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="appsettings-Sit-json">appsettings.Sit.json</h2><p>appsettings.Sit.json 只包含针对当前环境的配置；<code>TestOption.Test2</code> 添加了 <code>Encrypted</code> 标记用于测试解密Option；<code>DataBase.DbConnection</code> 用于测试解密字符串。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">WebApp01.Options</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> WebApp01.CustomDataProtection;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestOption</span> : <span class="title">ProtectionOptionBase</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Test1 &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">Encrypted</span>]</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Test2 &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 数据保护相关配置;SecretKeyPath:固定目录</span></span><br><span class="line">  <span class="attr">&quot;ProtectionOption&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;Thumbprint&quot;</span>: <span class="string">&quot;CD Replace&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;ApplicationName&quot;</span>: <span class="string">&quot;CD Replace&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;SecretKeyPath&quot;</span>: <span class="string">&quot;DataProtection\\app-keys&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;Purpose&quot;</span>: <span class="string">&quot;CD Replace&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 测试Option解密</span></span><br><span class="line">  <span class="attr">&quot;TestOption&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;Test1&quot;</span>: <span class="string">&quot;sit-test1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;Test2&quot;</span>: <span class="string">&quot;CD Replace&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// Sit环境：需要加密的配置在CD时进行替换</span></span><br><span class="line">  <span class="attr">&quot;DataBase&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;DbConnection&quot;</span>: <span class="string">&quot;CD Replace&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Startup">Startup</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (Environment.IsDevelopment())</span><br><span class="line">    &#123;</span><br><span class="line">        services.Configure&lt;TestOption&gt;(Configuration.GetSection(<span class="string">&quot;TestOption&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 注入数据保护需要的Option</span></span><br><span class="line">        services.Configure&lt;ProtectionOption&gt;(Configuration.GetSection(<span class="string">&quot;ProtectionOption&quot;</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 注入数据保护服务（依赖指定证书）</span></span><br><span class="line">        IDataProtector dataProtector = services.AddDataProtectionWithX509();</span><br><span class="line">        <span class="comment">// 解密字符串</span></span><br><span class="line">        <span class="built_in">string</span> connStr = dataProtector.Unprotect(Configuration.GetSection(<span class="string">&quot;Database:ConnectString&quot;</span>).Value);</span><br><span class="line">        Console.WriteLine(connStr);</span><br><span class="line">        <span class="comment">// 解密Option;Option上带有EncryptedAttribute标记的属性将会被解密</span></span><br><span class="line">        services.ProtectedConfigure&lt;TestOption&gt;(Configuration.GetSection(<span class="string">&quot;TestOption&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    services.AddControllers();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="EnvironmentController">EnvironmentController</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">ApiController</span>]</span><br><span class="line">[<span class="meta">Route(<span class="meta-string">&quot;[controller]&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EnvironmentController</span> : <span class="title">ControllerBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IOptions&lt;TestOption&gt; testOption;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EnvironmentController</span>(<span class="params">IOptions&lt;TestOption&gt; testOption</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.testOption = testOption;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">HttpGet</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IActionResult <span class="title">GetEnvironmentVariables</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; dicts = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;();</span><br><span class="line">        ConfigurationBuilder builder = <span class="keyword">new</span> ConfigurationBuilder();</span><br><span class="line">        builder.AddJsonFile(<span class="string">&quot;appsettings.json&quot;</span>);</span><br><span class="line">        IConfigurationRoot configuration = builder.Build();</span><br><span class="line"></span><br><span class="line">        dicts.Add(<span class="string">&quot;ProtectionOption.Thumbprint&quot;</span>, configuration.GetSection(<span class="string">&quot;ProtectionOption:Thumbprint&quot;</span>).Value);</span><br><span class="line">        dicts.Add(<span class="string">&quot;ProtectionOption.ApplicationName&quot;</span>, configuration.GetSection(<span class="string">&quot;ProtectionOption:ApplicationName&quot;</span>).Value);</span><br><span class="line">        dicts.Add(<span class="string">&quot;ProtectionOption.SecretKeyPath&quot;</span>, configuration.GetSection(<span class="string">&quot;ProtectionOption:SecretKeyPath&quot;</span>).Value);</span><br><span class="line">        dicts.Add(<span class="string">&quot;ProtectionOption.Purpose&quot;</span>, configuration.GetSection(<span class="string">&quot;ProtectionOption:Purpose&quot;</span>).Value);</span><br><span class="line">        dicts.Add(<span class="string">&quot;TestOption.Test1&quot;</span>, testOption.Value.Test1);</span><br><span class="line">        dicts.Add(<span class="string">&quot;TestOption.Test2&quot;</span>, testOption.Value.Test2);</span><br><span class="line">        dicts.Add(<span class="string">&quot;DataBase.DbConnection&quot;</span>, configuration.GetSection(<span class="string">&quot;DataBase:DbConnection&quot;</span>).Value);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Ok(JsonConvert.SerializeObject(dicts));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/docker/1.8Dockerfile/"/>
      <url>/docker/1.8Dockerfile/</url>
      
        <content type="html"><![CDATA[<p>之前已经了解到镜像的定制实际上就是定制每一层所添加的配置、文件。如果可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，这就是Dockerfile。</p><p>之前已经了解到镜像的定制实际上就是定制每一层所添加的配置、文件。如果可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，这就是 <code>Dockerfile</code>。</p><span id="more"></span><h1 id="格式描述">格式描述</h1><p>Dockerfile 整体由两类语句组成</p><ul><li><code>Comment</code>  注释信息</li><li><code>Instruction arguments</code>  指令参数，一行一个指令</li></ul><p><strong>注意</strong></p><ul><li><code>Dockerfile</code> 文件名首字母必须大写</li><li><code>Dockerfile</code> 指令不区分大小写，但为方便和参数做区分，通常指令使用大写字母</li><li><code>Dockerfile</code> 指令按顺序从上至下依次执行</li><li><code>Dockerfile</code> 第一个非注释行必须是 <code>FROM</code> 指令，用来指定制作当前镜像依据的是哪个基础镜像</li><li><code>Dockerfile</code> 需要调用的文件必须跟 <code>Dockerfile</code> 文件在同一目录下，或者在其子目录下。父目录或者其它路径无效</li></ul><h1 id="FROM">FROM</h1><ul><li>功能为指定基础镜像，并且必须是第一条指令</li><li>如果不以任何镜像为基础写法为： <code>FROM scratch</code> ，意味着接下来所写的指令将作为镜像的第一层开始</li></ul><blockquote><p>注意：如果没有指定仓库，<code>docker build</code> 会先从本机查找是否有此基础镜像，如果没有默认去 <code>Docker Hub Registry</code> 上拉取，再找不到就会报错</p></blockquote><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> &lt;image&gt;</span><br><span class="line"><span class="keyword">FROM</span> &lt;image&gt;:&lt;tag&gt;</span><br><span class="line"><span class="keyword">FROM</span> &lt;image&gt;:&lt;digest&gt; </span><br><span class="line"><span class="comment"># 三种写法，其中&lt;tag&gt;和&lt;digest&gt; 是可选项，如果没有选择，那么默认值为latest</span></span><br></pre></td></tr></table></figure><h1 id="MAINTAINER（新版本过时）">MAINTAINER（新版本过时）</h1><ul><li><code>Dockerfile</code> 作者信息，一般格式是：姓名+邮箱地址</li><li>并不限制 <code>MAINTAINER</code> 指令的位置，但建议放在 <code>FROM</code> 指令之后</li><li>在较新的 <code>docker</code> 版本中，<code>MAINTAINER</code> 已经被 <code>LABEL</code> 替代</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MAINTAINER</span> <span class="string">&quot;merle@example.com&quot;</span></span><br></pre></td></tr></table></figure><h1 id="LABEL">LABEL</h1><p>为镜像指定各种元数据（键值对格式）: <code>LABEL</code> 会继承基础镜像中的 <code>LABEL</code> ，如遇 <code>key</code> 相同值将会被覆盖</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LABEL</span><span class="bash"> &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt;</span></span><br></pre></td></tr></table></figure><h1 id="COPY">COPY</h1><p>复制宿主机上的文件到目标镜像中，格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">COPY [--chown=:] &lt;源路径&gt;... &lt;目标路径&gt;</span><br><span class="line">COPY [--chown=:] [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</span><br></pre></td></tr></table></figure><p>和 <code>RUN</code>  指令一样，<code>COPY</code> 也有两种格式，一种类似于命令行，一种类似于函数调用。<code>COPY</code>  指令将从构建上下文目录中 <code>&lt;源路径&gt;</code>  的文件/目录复制到新的一层的镜像内的 <code>&lt;目标路径&gt;</code>  位置。比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY package.json /usr/src/app/</span><br></pre></td></tr></table></figure><p><code>&lt;源路径&gt;</code>  可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 <code>filepath.Match</code>  规则，比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">COPY hom* /mydir/</span><br><span class="line">COPY hom?.txt /mydir/</span><br></pre></td></tr></table></figure><p><code>&lt;目标路径&gt;</code>  可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 <code>WORKDIR</code>  指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先创建缺失目录。</p><blockquote><p>注意：使用 COPY 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候</p></blockquote><p>在使用该指令的时候还可以加上 <code>--chown=&lt;user&gt;:&lt;group&gt;</code>    选项来改变文件的所属用户及所属组</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">COPY --chown=55:mygroup files* /mydir/</span><br><span class="line">COPY --chown=bin files* /mydir/</span><br><span class="line">COPY --chown=1 files* /mydir/</span><br><span class="line">COPY --chown=10:11 files* /mydir/</span><br></pre></td></tr></table></figure><h1 id="ADD">ADD</h1><ul><li><code>ADD</code> 指令跟 <code>COPY</code> 类似，不过它支持使用 <code>tar</code> 文件和 <code>URL</code> 路径</li><li>当拷贝的源文件是 <code>tar</code> 文件时，会自动展开为一个目录并拷贝进新的镜像中。通过 <code>URL</code> 获取到的 <code>tar</code> 文件不会自动展开</li><li>主机可以联网的情况下， <code>docker build</code> 可以将网络上的某文件引用下载并打包到新的镜像中</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD</span><span class="bash"> &lt;src&gt;... &lt;dest&gt;</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> [<span class="string">&quot;&lt;src&gt;&quot;</span>,... <span class="string">&quot;&lt;dest&gt;&quot;</span>]</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：<code>ADD</code> 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。在 Docker 官方的 <a href="https://www.bookstack.cn/read/docker_practice-v1.1.0/appendix-best_practices.md">Dockerfile 最佳实践文档</a> 中要求，尽可能的使用 COPY，因为 COPY 的语义很明确，就是复制文件，而 ADD 则包含了更复杂的功能，其行为也不一定很清晰。最适合使用 ADD 的场合，就是所提及的需要自动解压缩的场合。因此在 <code>COPY</code> 和 <code>ADD</code> 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 <code>COPY</code> 指令，仅在需要自动解压缩的场合使用 <code>ADD</code></p></blockquote><p>在使用该指令的时候也可以加上 <code>--chown=&lt;user&gt;:&lt;group&gt;</code> 选项来改变文件的所属用户及所属组</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ADD --chown=55:mygroup files* /mydir/</span><br><span class="line">ADD --chown=bin files* /mydir/</span><br><span class="line">ADD --chown=1 files* /mydir/</span><br><span class="line">ADD --chown=10:11 files* /mydir/</span><br></pre></td></tr></table></figure><h1 id="WORKDIR">WORKDIR</h1><ul><li>同 <code>docker run -w</code></li><li>指定工作目录，可以指定多个，每个 <code>WORKDIR</code> 只影响它下面的指令，直到遇见下一个 <code>WORKDIR</code> 为止</li><li><code>WORKDIR</code> 可以调用由 <code>ENV</code> 指令定义的变量</li><li><code>WORKDIR</code> 相对路径或者绝对路径：相对路径是相对于上一个 <code>WORKDIR</code> 指令的路径，如果上面没有 <code>WORKDIR</code> 指令，那就是当前 <code>Dockerfile</code> 文件的目录</li></ul><h1 id="VOLUME">VOLUME</h1><ul><li>同 <code>docker run -v</code></li><li>用于在镜像中创建一个挂载点目录。之前提到 <code>Volume</code> 有两种类型：挂载主机目录和数据卷。在Dockerfile中只支持docker数据卷，也就是说只能指定容器内的路径，不能指定宿主机的路径</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">VOLUME</span><span class="bash"> &lt;mountpoint&gt;</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> [<span class="string">&quot;&lt;mountpoint&gt;&quot;</span>]</span></span><br></pre></td></tr></table></figure><h1 id="EXPOSE">EXPOSE</h1><ul><li>同 <code>docker run -expose</code> 指定容器中待暴露的端口。比如容器提供的是一个https服务且需要对外提供访问，那就需要指定待暴露443端口，然后在使用此镜像启动容器时搭配 <code>-P</code>  参数才能将待暴露的状态转换为真正暴露的状态，转换的同时443也会转换成一个随机端口，跟 <code>-p:443</code>一个意思</li><li><code>EXPOSE</code> 指令可以一次指定多个端口，例如： <code>EXPOSE 11111/udp 11112/tcp</code></li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPOSE</span> &lt;port&gt;[/&lt;protocol&gt;] [&lt;port&gt;[/&lt;protocol&gt;] ...]</span><br><span class="line">&lt;protocol&gt;用于指定协议类型，如果不指定，默认TCP协议</span><br></pre></td></tr></table></figure><h1 id="ENV">ENV</h1><ul><li>同 <code>docker run -e</code></li><li>为镜像定义所需的环境变量，并可被 <code>ENV</code> 指令后面的其它指令所调用。调用格式为 <code>$variable_name</code> 或者 <code>$&#123;variable_name&#125;</code></li><li>使用 <code>docker run</code> 启动容器的时候加上 <code>-e</code>  的参数为 <code>variable_name</code> 赋值，可以覆盖 <code>Dockerfile</code> 中 <code>ENV</code> 指令指定的环境变量值。但不会影响到 <code>Dockerfile</code> 中已经引用过此变量的文件</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> &lt;key&gt; &lt;value&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> &lt;key&gt;=&lt;value&gt; ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一种格式一次只能定义一个变量，&lt;key&gt;之后所有内容都会被视为&lt;value&gt;的组成部分</span></span><br><span class="line"><span class="comment"># 第二种格式一次可以定义多个变量，每个变量为一个&quot;=&quot;的键值对，如果&lt;value&gt;中包含空格，可以用反斜线 \ 进行转义，也可以为&lt;value&gt;加引号，另外参数过长时可用反斜线做续行。</span></span><br><span class="line"><span class="comment"># 定义多个变量时，建议使用第二种方式，因为Dockerfile中每一行都是一个镜像层，构建起来比较吃资源</span></span><br></pre></td></tr></table></figure><h1 id="RUN">RUN</h1><ul><li>用于指定 <code>docker build</code> 过程中运行的程序，可以是任何命令</li><li><code>RUN</code> 指令后所执行的命令必须在 <code>FROM</code> 指令后的基础镜像中存在才行</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> &lt;<span class="built_in">command</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> [<span class="string">&quot;executable&quot;</span>, <span class="string">&quot;param1&quot;</span>, <span class="string">&quot;param2&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>第一种后边直接跟 <code>shell</code> 命令</p><ul><li><code>linux</code> 上默认 <code>/bin/sh -c</code></li><li><code>windows</code> 上默认 <code>cmd /S /C</code></li></ul><p>第二种类似于函数调用，可将 <code>executable</code> 理解成为可执行文件，后面就是两个参数。</p><ul><li><code>RUN /bin/bash -c 'source $HOME/.bashrc; echo $HOME</code></li><li><code>RUN [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;echo hello&quot;]</code></li></ul><blockquote><p>注意：多行命令不要写多个RUN，原因是Dockerfile中每一个指令都会建立一层，多少个RUN就构建了多少层镜像，会造成镜像的臃肿、多层，不仅仅增加了构件部署的时间，还容易出错。RUN书写时的换行符是 <code>\</code></p></blockquote><h1 id="CMD">CMD</h1><ul><li>指定启动容器的默认要运行的程序，也就是 <code>PID</code> 为1的进程命令，且其运行结束后容器也会终止。如果不指定，默认是 <code>bash</code></li><li><code>CMD</code> 指令指定的默认程序会被 <code>docker run</code> 命令行指定的参数所覆盖</li><li><code>Dockerfile</code> 中可以存在多个 <code>CMD</code> 指令，但仅最后一个生效。因为一个 <code>docker</code> 容器只能运行一个 <code>PID</code> 为1的进程。</li><li><code>CMD</code> 类似于 <code>RUN</code> 指令，也可以运行任意命令或程序，但是两者的运行时间点不同（ <code>RUN</code> 指令运行在 <code>docker build</code> 的过程中，而 <code>CMD</code> 指令运行在基于新镜像启动容器也就是 <code>docker run</code> 时）</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="bash"> <span class="built_in">command</span> param1 param2</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;executable&quot;</span>,<span class="string">&quot;param1&quot;</span>,<span class="string">&quot;param2&quot;</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;param1&quot;</span>,<span class="string">&quot;param2&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>前两种语法格式同 <code>RUN</code> 指令。第一种用法对于CMD指令基本没有意义，因为它运行的程序PID不为1。<br>第三种则需要结合 <code>ENTRYPOINT</code> 指令使用，CMD指令后面的命令作为 <code>ENTRYPOINT</code> 指令的默认参数。如果 <code>docker run</code> 命令行结尾有参数指定，那 <code>CMD</code> 后面的参数不生效。</p><h1 id="ENTRYPOINT">ENTRYPOINT</h1><ul><li>类似 <code>CMD</code> 指令的功能，用于为容器指定默认运行程序</li><li><code>Dockerfile</code> 中可以存在多个 <code>ENTRYPOINT</code> 指令，但仅最后一个生效</li><li>与CMD区别在于：由 <code>ENTRYPOINT</code> 启动的程序不会被 <code>docker run</code> 命令行指定的参数所覆盖，而且这些命令行参数会被当做参数传递给 <code>ENTRYPOINT</code> 指令指定的程序</li><li><code>docker run</code> 的 <code>--entrypoint</code> 选项的参数可覆盖 <code>ENTRYPOINT</code> 指定的默认程序</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> <span class="built_in">command</span> param1 param2</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;executable&quot;</span>, <span class="string">&quot;param1&quot;</span>, <span class="string">&quot;param2&quot;</span>]</span></span><br></pre></td></tr></table></figure><h1 id="USER">USER</h1><ul><li>用于指定 <code>docker build</code> 过程中任何 <code>RUN</code> 、 <code>CMD</code> 等指令的用户名或者 <code>UID</code></li><li>默认情况下容器的运行用户为 <code>root</code></li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USER</span> &lt;<span class="keyword">user</span>&gt;[:&lt;group&gt;]</span><br><span class="line"></span><br><span class="line"><span class="keyword">USER</span> &lt;UID&gt;[:&lt;GID&gt;]</span><br></pre></td></tr></table></figure><blockquote><p>实践中UID需要是 <code>/etc/passwd</code> 中某用户的有效UID，否则docker run命令将运行失败</p></blockquote><h1 id="HEALTHCHECK">HEALTHCHECK</h1><p>顾名思义，健康检查。此指令的就是告诉 <code>docker </code>检查容器是否正常工作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HEALTHCHECK [OPTIONS] CMD <span class="built_in">command</span></span><br><span class="line">HEALTHCHECK NONE</span><br></pre></td></tr></table></figure><p>HEALTHCHECK 指令定义一个 <code>CMD</code> ，在CMD后面编写一条命令去判断服务运行是否正常。检查肯定不是一次性的，所以 <code>OPTIONS</code> 就是指定检查的频率等</p><ul><li><code>--interval=DURATION</code> （默认值：30s）：每隔多久检查一次，默认30s</li><li><code>--timeout=DURATION</code> （默认值：30s）：超时时长，默认30s</li><li><code>--start-period=DURATION</code> （默认值：0s）：启动健康检查的等待时间。因为容器启动成功时，进程不一定立马就启动成功，过早开始检查就会返回不健康</li><li><code>--retries=N</code> （默认值：3）：如果检查一次失败就返回不健康未免太武断，所以默认三次机会</li></ul><p>CMD 健康检测命令发出时，返回值有三种情况：</p><ul><li>0：成功</li><li>1：不健康</li><li>2：保留，无实际意义。</li></ul><p><code>HEALTHCHECK NONE</code> 就是不做健康检查</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">HEALTHCHECK</span><span class="bash"> --interval=5m --timeout=3s </span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> curl -f http://localhost/ || <span class="built_in">exit</span> 1</span></span><br></pre></td></tr></table></figure><h1 id="SHELL">SHELL</h1><p>用来指定运行程序默认要使用的 <code>shell</code> 类型，因为 <code>windows</code> 环境默认是 <code>powershell</code> 。此指令一般不会使用。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHELL</span><span class="bash"> [<span class="string">&quot;executable&quot;</span>, <span class="string">&quot;parameters&quot;</span>]</span></span><br></pre></td></tr></table></figure><h1 id="STOPSIGNAL">STOPSIGNAL</h1><p>指定发送使容器退出的系统调用信号。 <code>docker stop</code> 之所以能停止容器，就是发送了15的信号给容器内PID为1的进程。此指令一般不会使用。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">STOPSIGNAL</span> signal</span><br></pre></td></tr></table></figure><h1 id="ARG">ARG</h1><p><code>ARG</code> 命令同 <code>EVN</code> 类似，也是指定一个变量，但不同的是， <code>ENV</code> 指令配合 <code>-e</code> 参数可以在 <code>docker run</code> 过程中传参，而使用 <code>ARG</code> 指令配合 <code>--build-arg</code> 参数可以在 <code>docker build</code> 过程中传参，方便为不同场景构建不同镜像。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ARG</span> &lt;name&gt;[=&lt;default value&gt;]</span><br></pre></td></tr></table></figure><h1 id="ONBUILD">ONBUILD</h1><ul><li>用于在 <code>Dockerfile</code> 中定义一个触发器</li><li><code>ONBUILD</code> 后面指定的指令在 <code>docker build</code> 时是不会执行，构建完的镜像在被另一个 <code>Dockerfile</code> 文件中 <code>FROM</code> 指令所引用的时才会触发执行</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ONBUILD</span> [INSTRUCTION]</span><br></pre></td></tr></table></figure><ul><li>几乎任何指令都可以成为触发器指令，但 <code>ONBUILD</code> 不能自我嵌套，且不会触发 <code>FROM</code> 和 <code>MAINTAINER</code> 指令，多数情况是使用 <code>RUN</code> 或者 <code>ADD</code></li><li>在使用 <code>COPY</code> 指令时，应该注意后续引用该镜像的 <code>Dockerfile</code> 的同级目录下是否有被拷贝的文件</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/docker/2.0DockerMachine/"/>
      <url>/docker/2.0DockerMachine/</url>
      
        <content type="html"><![CDATA[<h1 id="概念">概念</h1><p>Docker Machine 是 Docker 官方编排（Orchestration）项目之一，负责在多种平台上快速安装 Docker 环境，基于 Go 语言实现。</p><span id="more"></span><h1 id="安装">安装</h1><p>Docker Machine 可以在多种操作系统平台上安装，包括 Linux、MacOS，以及 Windows。</p><h2 id="MacOS、Windows">MacOS、Windows</h2><p>Docker for Mac、Docker for Windows 自带 <code>docker-machine</code> 二进制包，安装之后即可使用。<br><strong>查看版本信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker-machine -v</span><br><span class="line">docker-machine version 0.13.0, build 9ba6da9</span><br></pre></td></tr></table></figure><h2 id="Linux">Linux</h2><p>在 Linux 上的安装十分简单，从 <a href="https://github.com/docker/machine/releases">官方 GitHub Release</a> 处直接下载编译好的二进制文件即可。<br>在 Linux 64 位系统上直接下载对应的二进制包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -L https://github.com/docker/machine/releases/download/v0.16.2/docker-machine-`uname -s`-`uname -m` &gt;/tmp/docker-machine &amp;&amp;</span><br><span class="line">    chmod +x /tmp/docker-machine &amp;&amp;</span><br><span class="line">    sudo cp /tmp/docker-machine /usr/<span class="built_in">local</span>/bin/docker-machine</span><br></pre></td></tr></table></figure><p>这里因为下载太慢选择翻墙直接下载 <code>releases</code> 版本后copy到主机 <code>/usr/local/bin/</code> 目录中。然后执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /usr/<span class="built_in">local</span>/bin/docker-machine</span><br></pre></td></tr></table></figure><p>完成后，查看版本信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang bin]<span class="comment"># docker-machine -v</span></span><br><span class="line">docker-machine version 0.16.2, build bd45ab13</span><br></pre></td></tr></table></figure><h1 id="使用">使用</h1><p>Docker Machine 支持多种后端驱动，包括虚拟机、本地主机和云平台等。</p><h2 id="创建本地主机实例">创建本地主机实例</h2><h3 id="Virtualbox-驱动">Virtualbox 驱动</h3><p>使用 <code>virtualbox</code> 类型的驱动，创建一台 Docker 主机，命名为 test。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine create -d virtualbox <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>也可以在创建时加上如下参数，来配置主机或者主机上的 Docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--engine-opt dns=114.114.114.114 配置 Docker 的默认 DNS</span><br><span class="line">--engine-registry-mirror https://registry.docker-cn.com 配置 Docker 的仓库镜像</span><br><span class="line">--virtualbox-memory 2048 配置主机内存</span><br><span class="line">--virtualbox-cpu-count 2 配置主机 CPU</span><br></pre></td></tr></table></figure><p>更多参数使用 <code>docker-machine create --driver virtualbox --help</code> 命令查看</p><h3 id="macOS-xhyve-驱动">macOS xhyve 驱动</h3><p><code>xhyve</code> 驱动 GitHub: <a href="https://github.com/zchee/docker-machine-driver-xhyve">https://github.com/zchee/docker-machine-driver-xhyve</a>，<a href="https://github.com/mist64/xhyve"><code>xhyve</code></a> 是 macOS 上轻量化的虚拟引擎，使用其创建的 Docker Machine 较 <code>VirtualBox</code> 驱动创建的运行效率要高。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">brew install docker-machine-driver-xhyve</span><br><span class="line">docker-machine create \</span><br><span class="line">      -d xhyve \</span><br><span class="line">      <span class="comment"># --xhyve-boot2docker-url ~/.docker/machine/cache/boot2docker.iso \</span></span><br><span class="line">      --engine-opt dns=114.114.114.114 \</span><br><span class="line">      --engine-registry-mirror https://registry.docker-cn.com \</span><br><span class="line">      --xhyve-memory-size 2048 \</span><br><span class="line">      --xhyve-rawdisk \</span><br><span class="line">      --xhyve-cpu-count 2 \</span><br><span class="line">      xhyve</span><br></pre></td></tr></table></figure><blockquote><p>注意：非首次创建时建议加上 <code>--xhyve-boot2docker-url ~/.docker/machine/cache/boot2docker.iso</code> 参数，避免每次创建时都从 GitHub 下载 ISO 镜像。</p></blockquote><p>更多参数请使用 <code>docker-machine create --driver xhyve --help</code> 命令查看。</p><h3 id="Windows-10">Windows 10</h3><p>Windows 10 安装 Docker for Windows 之后不能再安装 VirtualBox，也就不能使用 <code>virtualbox</code> 驱动来创建 Docker Machine，可以选择使用 <code>hyperv</code> 驱动。</p><blockquote><p>注意，必须事先在 <code>Hyper-V</code> 管理器中新建一个 <strong>外部虚拟交换机</strong> 执行下面的命令时，使用 <code>--hyperv-virtual-switch=MY_SWITCH</code> 指定虚拟交换机名称</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine create --driver hyperv --hyperv-virtual-switch=MY_SWITCH vm</span><br></pre></td></tr></table></figure><p>更多参数使用 <code>docker-machine create --driver hyperv --help</code> 命令查看。</p><h3 id="使用介绍">使用介绍</h3><p>创建好主机之后，查看主机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker-machine ls</span><br><span class="line">NAME      ACTIVE   DRIVER       STATE     URL                         SWARM   DOCKER       ERRORS</span><br><span class="line"><span class="built_in">test</span>      -        virtualbox   Running   tcp://192.168.99.187:2376           v17.10.0-ce</span><br></pre></td></tr></table></figure><p>创建主机成功后，可以通过 <code>env</code> 命令来让后续操作对象都是目标主机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine env <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>后续根据提示在命令行输入命令之后就可以操作 test 主机。也可以通过 <code>SSH</code> 登录到主机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker-machine ssh <span class="built_in">test</span></span><br><span class="line">docker@<span class="built_in">test</span>:~$ docker --version</span><br><span class="line">Docker version 17.10.0-ce, build f4ffd25</span><br></pre></td></tr></table></figure><p>连接到主机之后就可以在其上使用 Docker 了</p><h3 id="官方支持驱动">官方支持驱动</h3><p>通过 <code>-d</code> 选项可以选择支持的驱动类型。</p><ul><li>amazonec2</li><li>azure</li><li>digitalocean</li><li>exoscale</li><li>generic</li><li>google</li><li>hyperv</li><li>none</li><li>openstack</li><li>rackspace</li><li>softlayer</li><li>virtualbox</li><li>vmwarevcloudair</li><li>vmwarefusion</li><li>vmwarevsphere</li></ul><h3 id="第三方驱动">第三方驱动</h3><p>参考：<a href="https://github.com/docker/docker.github.io/blob/master/machine/AVAILABLE_DRIVER_PLUGINS.md">第三方驱动列表</a></p><h3 id="操作命令">操作命令</h3><ul><li><code>active</code> 查看活跃的 Docker 主机</li><li><code>config</code> 输出连接的配置信息</li><li><code>create</code> 创建一个 Docker 主机</li><li><code>env</code> 显示连接到某个主机需要的环境变量</li><li><code>inspect</code> 输出主机更多信息</li><li><code>ip</code> 获取主机地址</li><li><code>kill</code> 停止某个主机</li><li><code>ls</code> 列出所有管理的主机</li><li><code>provision</code> 重新设置一个已存在的主机</li><li><code>regenerate-certs</code> 为某个主机重新生成 TLS 认证信息</li><li><code>restart</code> 重启主机</li><li><code>rm</code> 删除某台主机</li><li><code>ssh</code> SSH 到主机上执行命令</li><li><code>scp</code> 在主机之间复制文件</li><li><code>mount</code> 挂载主机目录到本地</li><li><code>start</code> 启动一个主机</li><li><code>status</code> 查看主机状态</li><li><code>stop</code> 停止一个主机</li><li><code>upgrade</code> 更新主机 Docker 版本为最新</li><li><code>url</code> 获取主机的 URL</li><li><code>version</code> 输出 docker-machine 版本信息</li><li><code>help</code> 输出帮助信息</li></ul><p>每个命令，又带有不同的参数，可以通过<code>$ docker-machine COMMAND --help</code>查看具体用法</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/docker/2.1DockerSwarm/"/>
      <url>/docker/2.1DockerSwarm/</url>
      
        <content type="html"><![CDATA[<h1 id="背景介绍">背景介绍</h1><p><code>standalone</code> 部署模式故障转移机制：独立部署 <code>Redis</code> ，借助 <code>docker swarm</code> 故障转移机制做到基本HA，多节点的Redis通过 <code>NFS</code> 实现容器数据共享。</p><p>借助一个Redis实例来学习Docker Swarm，背景：<code>standalone</code> 部署模式故障转移机制：独立部署 <code>Redis</code> ，借助 <code>docker swarm</code> 故障转移机制做到基本HA，多节点的Redis通过 <code>NFS</code> 实现容器数据共享。</p><h1 id="环境准备-v2">环境准备</h1><p>独立的 <code>NFS</code> 服务器</p><table><thead><tr><th>192.168.158.143</th><th>部署NFS服务</th></tr></thead></table><p><code>Swarm</code> 集群由 <strong>管理节点</strong> 和 <strong>工作节点</strong> 组成。这里创建一个包含一个管理节点和两个工作节点的最小 <code>Swarm</code> 集群</p><table><thead><tr><th>IP</th><th>IsManager</th></tr></thead><tbody><tr><td>192.168.158.144</td><td>Yes</td></tr><tr><td>192.168.158.145</td><td>​</td></tr><tr><td>192.168.158.146</td><td></td></tr></tbody></table><h1 id="Docker-Swarm">Docker Swarm</h1><p>Docker Swarm 是 Docker 官方三剑客项目之一，提供 Docker 容器集群服务，是 Docker 官方对容器云生态进行支持的核心方案。使用它可以将多个 Docker 主机封装为单个大型的虚拟 Docker 主机，快速打造一套容器云平台。</p><blockquote><p>注意：Docker 1.12.0+ <a href="https://docs.docker.com/engine/swarm/">Swarm mode</a> 已经内嵌入 Docker 引擎，成为了 docker 子命令 <code>docker swarm</code>，Docker 引擎 API 已经删除 Docker Swarm</p></blockquote><p><code>Swarm mode</code> 内置 kv 存储功能，提供了众多新特性，比如：具有容错能力的去中心化设计、内置服务发现、负载均衡、路由网格、动态伸缩、滚动更新、安全传输等。<br>​</p><p><code>Swarm</code> 是使用 <code>[SwarmKit](https://github.com/docker/swarmkit/)</code> 构建的 Docker 引擎内置（原生）的集群管理和编排工具。使用 <code>Swarm</code> 集群之前需要了解以下几个概念。</p><h2 id="节点">节点</h2><p>运行 Docker 的主机可以主动初始化一个 <code>Swarm</code> 集群或者加入一个已存在的 <code>Swarm</code> 集群，这样这个运行 Docker 的主机就成为一个 <code>Swarm</code> 集群的节点 (<code>node</code>) 。节点分为管理 (<code>manager</code>) 节点和工作 (<code>worker</code>) 节点。管理节点用于 <code>Swarm</code> 集群的管理，<code>docker swarm</code> 命令基本只能在管理节点执行（节点退出集群命令 <code>docker swarm leave</code> 可以在工作节点执行）。一个 <code>Swarm</code> 集群可以有多个管理节点，但只有一个管理节点可以成为 <code>leader</code>，<code>leader</code> 通过 <code>raft</code> 协议实现。工作节点是任务执行节点，管理节点将服务 (<code>service</code>) 下发至工作节点执行。管理节点默认也作为工作节点。也可以通过配置让服务只运行在管理节点。</p><p><strong>集群中管理节点与工作节点的关系</strong></p><p><img src="/images/2021-09-09-16-46-11.png" alt=""></p><h2 id="服务和任务">服务和任务</h2><p>任务 （<code>Task</code>）是 <code>Swarm</code> 中的最小的调度单位，目前来说就是一个单一的容器。服务 （<code>Services</code>） 是指一组任务的集合，服务定义了任务的属性。服务有两种模式：</p><ul><li><code>replicated services</code> 按照一定规则在各个工作节点上运行指定个数的任务</li><li><code>global services</code> 每个工作节点上运行一个任务</li></ul><p>两种模式通过 <code>docker service create</code> 的 <code>--mode</code> 参数指定。</p><p><strong>容器/任务/服务的关系</strong></p><p><img src="/images/2021-09-09-16-46-39.png" alt=""></p><h1 id="NFS服务搭建">NFS服务搭建</h1><p><strong>服务端</strong>： <code>192.168.158.143</code>安装 <code>nfs-server</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yum -y install rpcbind nfs-utils</span><br><span class="line">systemctl start rpcbind</span><br><span class="line">systemctl <span class="built_in">enable</span> rpcbind</span><br><span class="line">systemctl start nfs-server　　//NFS依赖rpcbind进行通讯，所以要先启动rpcbind</span><br><span class="line">systemctl <span class="built_in">enable</span> nfs-server</span><br></pre></td></tr></table></figure><p><strong>客户端</strong> ：<code>192.168.158.145/192.168.158.146</code> 安装 <code>nfs-utils</code>，这里管理节点 <code>192.168.158.144</code> 并不打算部署服务故不需要安装<code>nfs-utils</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install nfs-utils</span><br></pre></td></tr></table></figure><p>创建共享目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//服务端</span><br><span class="line">[root@centos-01 /]<span class="comment"># mkdir -p /mnt/nfs_file/redis </span></span><br><span class="line">//客户端</span><br><span class="line">[root@centos-01 /]<span class="comment"># mkdir -p /mnt/nfs_file/redis </span></span><br></pre></td></tr></table></figure><h2 id="服务端NFS配置">服务端NFS配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/exports</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/mnt/nfs_file/ 192.168.158.143/24(rw,sync,no_root_squash)</span><br><span class="line"></span><br><span class="line">//ro只读权限</span><br><span class="line">//rw读写权限</span><br><span class="line">//sync同步写入内存与磁盘当中</span><br><span class="line">//no_all_squash保留共享文件的UID和GID（默认）</span><br><span class="line">//no_root_squash使得root用户具有根目录的完全访问权限</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-01 ~]<span class="comment"># vi /etc/exports</span></span><br><span class="line">[root@centos-01 ~]<span class="comment"># cat /etc/exports</span></span><br><span class="line">/mnt/nfs_file/ 192.168.57.0/24(rw,sync,no_root_squash)</span><br></pre></td></tr></table></figure><p>配置生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-01 ~]<span class="comment"># exportfs -rv</span></span><br><span class="line">exporting 192.168.158.143/24:/mnt/nfs_file</span><br></pre></td></tr></table></figure><h2 id="客户端NFS配置">客户端NFS配置</h2><p>关联服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -t nfs 192.168.158.143:/mnt/nfs_file /mnt/nfs_file</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//挂载测试</span><br><span class="line">[root@centos-01 ~]<span class="comment"># showmount -e 192.168.158.143</span></span><br><span class="line">Export list <span class="keyword">for</span> 192.168.158.143:</span><br><span class="line">/mnt/nfs_file 192.168.158.143/24</span><br></pre></td></tr></table></figure><p>备注：出现 <code>clnt_create:RPC:Port mapper failure - Unable to receive:error 113(NO route to host)</code> 报错时，需要关闭服务端与客户端之间的防火墙，或者开放NFS使用的2049端口。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld</span><br><span class="line"></span><br><span class="line">//添加规则(指定端口，--permanent永久生效，没有此参数重启后失效）</span><br><span class="line">//firewall-cmd --zone=public --add-port=2049/tcp --permanent</span><br></pre></td></tr></table></figure><h1 id="Docker集群搭建">Docker集群搭建</h1><h2 id="创建集群">创建集群</h2><p><strong>管理节点</strong>：<code>192.168.158.144</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-01 ~]<span class="comment"># docker swarm init</span></span><br><span class="line">Swarm initialized: current node (khtc8jboe8dy7wm73x1cacnqf) is now a manager.</span><br><span class="line"></span><br><span class="line">To add a worker to this swarm, run the following <span class="built_in">command</span>:</span><br><span class="line"></span><br><span class="line">    docker swarm join --token SWMTKN-1-4fixdycxiue0273gkral83cn9bgqvkct13r9fo1k01iy6oaadm-e3rd668t3ww1b2w3e0xfxi8yo 192.168.158.144:2377</span><br><span class="line"></span><br><span class="line">To add a manager to this swarm, run <span class="string">&#x27;docker swarm join-token manager&#x27;</span> and follow the instructions.</span><br></pre></td></tr></table></figure><p><strong>工作节点1</strong>：<code>192.168.158.145</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-01 ~]<span class="comment">#  docker swarm join --token SWMTKN-1-4fixdycxiue0273gkral83cn9bgqvkct13r9fo1k01iy6oaadm-e3rd668t3ww1b2w3e0xfxi8yo 192.168.158.144:2377</span></span><br><span class="line">This node joined a swarm as a worker.</span><br></pre></td></tr></table></figure><p><strong>工作节点2</strong>：<code>192.168.158.146</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-01 ~]<span class="comment"># docker swarm join --token SWMTKN-1-4fixdycxiue0273gkral83cn9bgqvkct13r9fo1k01iy6oaadm-e3rd668t3ww1b2w3e0xfxi8yo 192.168.158.144:2377</span></span><br><span class="line">This node joined a swarm as a worker.</span><br></pre></td></tr></table></figure><h2 id="更改节点可用性">更改节点可用性</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-<span class="number">01</span> ~]<span class="comment"># docker node ls</span></span><br><span class="line">ID                            HOSTNAME    STATUS    AVAILABILITY   MANAGER STATUS   ENGINE VERSION</span><br><span class="line"><span class="number">0</span>aw4rk8kwos84yi0ca57q5pcq     centos-<span class="number">01</span>   Ready     Active                          <span class="number">20.10</span>.<span class="number">6</span></span><br><span class="line"><span class="number">579</span>nqzz3p512aobe6mp4g93ep     centos-<span class="number">01</span>   Ready     Active                          <span class="number">20.10</span>.<span class="number">6</span></span><br><span class="line">khtc8jboe8dy7wm73x1cacnqf *   centos-<span class="number">01</span>   Ready     Active         Leader           <span class="number">20.10</span>.<span class="number">6</span></span><br><span class="line">[root@centos-<span class="number">01</span> ~]<span class="comment"># docker node update --availability drain khtc8jboe8dy7wm73x1cacnqf</span></span><br><span class="line">khtc8jboe8dy7wm73x1cacnqf</span><br><span class="line">[root@centos-<span class="number">01</span> ~]<span class="comment"># docker node ls</span></span><br><span class="line">ID                            HOSTNAME    STATUS    AVAILABILITY   MANAGER STATUS   ENGINE VERSION</span><br><span class="line"><span class="number">0</span>aw4rk8kwos84yi0ca57q5pcq     centos-<span class="number">01</span>   Ready     Active                          <span class="number">20.10</span>.<span class="number">6</span></span><br><span class="line"><span class="number">579</span>nqzz3p512aobe6mp4g93ep     centos-<span class="number">01</span>   Ready     Active                          <span class="number">20.10</span>.<span class="number">6</span></span><br><span class="line">khtc8jboe8dy7wm73x1cacnqf *   centos-<span class="number">01</span>   Ready     Drain          Leader           <span class="number">20.10</span>.<span class="number">6</span></span><br></pre></td></tr></table></figure><h2 id="查看集群状态">查看集群状态</h2><p><code>192.168.158.144</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-01 ~]<span class="comment"># docker node ls</span></span><br><span class="line">ID                            HOSTNAME    STATUS    AVAILABILITY   MANAGER STATUS   ENGINE VERSION</span><br><span class="line">0aw4rk8kwos84yi0ca57q5pcq     centos-01   Ready     Active                          20.10.6</span><br><span class="line">579nqzz3p512aobe6mp4g93ep     centos-01   Ready     Active                          20.10.6</span><br><span class="line">khtc8jboe8dy7wm73x1cacnqf *   centos-01   Ready     Active         Leader           20.10.6</span><br></pre></td></tr></table></figure><h2 id="解散集群">解散集群</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker swarm leave                       <span class="comment"># 工作节点：主动离开集群，让节点处于down状态，才能删除</span></span><br><span class="line">docker node rm g36lvv23ypjd8v7ovlst2n3yt <span class="comment"># 管理节点：删除指定节点</span></span><br><span class="line">docker swarm leave --force               <span class="comment"># 管理节点：解散集群</span></span><br></pre></td></tr></table></figure><h1 id="Redis部署">Redis部署</h1><p><code>standalone</code> 部署模式区别于传统 <code>Redis Cluster</code> 部署，首先需要借助 <code>NFS</code> 实现多主机 <code>Redis配置和持久化数据共享</code> 借助 <code>Docker Swarm</code> 的故障转移机制来达到 <code>基本的HA</code>。</p><h2 id="Redis配置共享">Redis配置共享</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-<span class="number">01</span> ~]<span class="comment"># cd /mnt/nfs_file/redis/</span></span><br><span class="line">[root@centos-<span class="number">01</span> redis]<span class="comment"># ls</span></span><br><span class="line">redis.conf</span><br></pre></td></tr></table></figure><blockquote><p>备注：<code>redis.conf</code> 需要关闭 <code>Cluster-Enable</code></p></blockquote><h2 id="Redis服务部署">Redis服务部署</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-<span class="number">01</span> ~]<span class="comment"># docker service create -p 6379:6379 --name redis --mount type=bind,src=/mnt/nfs_file/redis/redis.conf,dst=/etc/redis/redis.conf --mount type=bind,src=/mnt/nfs_file/redis,dst=/data redis redis-server /etc/redis/redis.conf --appendonly yes</span></span><br><span class="line">gc4q2nrqwp6qbimjwy3un0lmn</span><br><span class="line">overall progress: <span class="number">1</span> out of <span class="number">1</span> tasks </span><br><span class="line"><span class="number">1</span>/<span class="number">1</span>: running   [==================================================&gt;] </span><br><span class="line">verify: Service converged </span><br></pre></td></tr></table></figure><p><code>Docker Swarm</code> 会随机选择一个工作节点（这里是 <code>192.168.158.145</code> ）部署 一个<code>Redis</code>容器。</p><h1 id="查看运行服务">查看运行服务</h1><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-<span class="number">01</span> ~]<span class="comment"># docker service ls</span></span><br><span class="line">ID             NAME      MODE         REPLICAS   IMAGE          PORTS</span><br><span class="line">gc4q2nrqwp6q   redis     replicated   <span class="number">1</span>/<span class="number">1</span>        redis:latest   *:<span class="number">6379</span>-&gt;<span class="number">6379</span>/tcp</span><br></pre></td></tr></table></figure><h1 id="查看服务详情">查看服务详情</h1><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-<span class="number">01</span> ~]<span class="comment"># docker service  ps redis </span></span><br><span class="line">ID             NAME      IMAGE          NODE        DESIRED STATE   CURRENT STATE           ERROR     PORTS</span><br><span class="line">zf137g379xj6   redis.<span class="number">1</span>   redis:latest   centos-<span class="number">01</span>   Running         Running <span class="number">3</span> minutes ago  </span><br></pre></td></tr></table></figure><h1 id="查看服务日志">查看服务日志</h1><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-<span class="number">01</span> ~]<span class="comment"># docker service logs redis </span></span><br><span class="line">redis.<span class="number">1</span>.zf137g379xj6@centos-<span class="number">01</span>    | <span class="number">1</span>:C <span class="number">16</span> Jul <span class="number">2021</span> <span class="number">05</span>:<span class="number">46</span>:<span class="number">38.388</span> <span class="comment"># oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span></span><br><span class="line">redis.<span class="number">1</span>.zf137g379xj6@centos-<span class="number">01</span>    | <span class="number">1</span>:C <span class="number">16</span> Jul <span class="number">2021</span> <span class="number">05</span>:<span class="number">46</span>:<span class="number">38.388</span> <span class="comment"># Redis version=6.2.4, bits=64, commit=00000000, modified=0, pid=1, just started</span></span><br><span class="line">redis.<span class="number">1</span>.zf137g379xj6@centos-<span class="number">01</span>    | <span class="number">1</span>:C <span class="number">16</span> Jul <span class="number">2021</span> <span class="number">05</span>:<span class="number">46</span>:<span class="number">38.389</span> <span class="comment"># Configuration loaded</span></span><br><span class="line">redis.<span class="number">1</span>.zf137g379xj6@centos-<span class="number">01</span>    | <span class="number">1</span>:M <span class="number">16</span> Jul <span class="number">2021</span> <span class="number">05</span>:<span class="number">46</span>:<span class="number">38.389</span> * monotonic clock: POSIX clock_gettime</span><br><span class="line">redis.<span class="number">1</span>.zf137g379xj6@centos-<span class="number">01</span>    | <span class="number">1</span>:M <span class="number">16</span> Jul <span class="number">2021</span> <span class="number">05</span>:<span class="number">46</span>:<span class="number">38.391</span> <span class="comment"># Warning: Could not create server TCP listening socket ::1:6379: bind: Cannot assign requested address</span></span><br><span class="line">redis.<span class="number">1</span>.zf137g379xj6@centos-<span class="number">01</span>    | <span class="number">1</span>:M <span class="number">16</span> Jul <span class="number">2021</span> <span class="number">05</span>:<span class="number">46</span>:<span class="number">38.393</span> * Running mode=standalone, port=<span class="number">6379</span>.</span><br><span class="line">redis.<span class="number">1</span>.zf137g379xj6@centos-<span class="number">01</span>    | <span class="number">1</span>:M <span class="number">16</span> Jul <span class="number">2021</span> <span class="number">05</span>:<span class="number">46</span>:<span class="number">38.394</span> <span class="comment"># WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.</span></span><br><span class="line">redis.<span class="number">1</span>.zf137g379xj6@centos-<span class="number">01</span>    | <span class="number">1</span>:M <span class="number">16</span> Jul <span class="number">2021</span> <span class="number">05</span>:<span class="number">46</span>:<span class="number">38.394</span> <span class="comment"># Server initialized</span></span><br><span class="line">redis.<span class="number">1</span>.zf137g379xj6@centos-<span class="number">01</span>    | <span class="number">1</span>:M <span class="number">16</span> Jul <span class="number">2021</span> <span class="number">05</span>:<span class="number">46</span>:<span class="number">38.394</span> <span class="comment"># WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add &#x27;vm.overcommit_memory = 1&#x27; to /etc/sysctl.conf and then reboot or run the command &#x27;sysctl vm.overcommit_memory=1&#x27; for this to take effect.</span></span><br><span class="line">redis.<span class="number">1</span>.zf137g379xj6@centos-<span class="number">01</span>    | <span class="number">1</span>:M <span class="number">16</span> Jul <span class="number">2021</span> <span class="number">05</span>:<span class="number">46</span>:<span class="number">38.396</span> * Ready to accept connections</span><br></pre></td></tr></table></figure><p>这里保证只有一个 <code>Redis</code> 容器运行（<code>standalone</code> 部署）,所以不需要使用 <code>--replicas number</code> 。 关于<strong>服务动态伸缩</strong>/<strong>服务更新与回滚</strong>/<strong>滚动更新</strong>等相关知识参考：<a href="https://www.bookstack.cn/read/docker_practice-v1.1.0/swarm_mode-README.md%E3%80%82">https://www.bookstack.cn/read/docker_practice-v1.1.0/swarm_mode-README.md。</a></p><h1 id="删除服务">删除服务</h1><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service rm redis</span><br></pre></td></tr></table></figure><h1 id="测试">测试</h1><h2 id="基本功能测试">基本功能测试</h2><p>使用 <code>RedisClient</code> 连接Redis <code>192.168.158.146</code></p><p><img src="/images/2021-09-09-16-52-30.png" alt=""></p><h2 id="故障转移测试">故障转移测试</h2><p>这里手动将 <code>192.168.158.146</code> Redis容器停止，查看Swarm会怎么处理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-01 ~]<span class="comment"># docker ps -a</span></span><br><span class="line">CONTAINER ID   IMAGE          COMMAND                  CREATED         STATUS         PORTS      NAMES</span><br><span class="line">9855ebf35829   redis:latest   <span class="string">&quot;docker-entrypoint.s…&quot;</span>   4 minutes ago   Up 4 minutes   6379/tcp   redis.1.vys54q07u7egrmc64rnn2frj4</span><br><span class="line">[root@centos-01 ~]<span class="comment"># docker stop redis.1.vys54q07u7egrmc64rnn2frj4 </span></span><br><span class="line">redis.1.vys54q07u7egrmc64rnn2frj4</span><br><span class="line">[root@centos-01 ~]<span class="comment"># docker ps -a</span></span><br><span class="line">CONTAINER ID   IMAGE          COMMAND                  CREATED         STATUS                     PORTS     NAMES</span><br><span class="line">9855ebf35829   redis:latest   <span class="string">&quot;docker-entrypoint.s…&quot;</span>   4 minutes ago   Exited (0) 4 seconds ago             redis.1.vys54q07u7egrmc64rnn2frj4</span><br></pre></td></tr></table></figure><p>发现 <code>192.168.158.145</code> 上启动了一个新的Redis容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-01 ~]<span class="comment"># docker ps -a</span></span><br><span class="line">CONTAINER ID   IMAGE          COMMAND                  CREATED          STATUS         PORTS      NAMES</span><br><span class="line">ef95253a0d79   redis:latest   <span class="string">&quot;docker-entrypoint.s…&quot;</span>   16 seconds ago   Up 9 seconds   6379/tcp   redis.1.jb9b26y4ikj8vc1k04j2gj35w</span><br></pre></td></tr></table></figure><p>管理节点中查看服务运行情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-01 ~]<span class="comment"># docker service ps redis </span></span><br><span class="line">ID             NAME          IMAGE          NODE        DESIRED STATE   CURRENT STATE            ERROR     PORTS</span><br><span class="line">jb9b26y4ikj8   redis.1       redis:latest   centos-01   Running         Running 2 minutes ago              </span><br><span class="line">vys54q07u7eg    \_ redis.1   redis:latest   centos-01   Shutdown        Complete 2 minutes ago  </span><br></pre></td></tr></table></figure><p>发现 <code>Redis</code> 已经被转移到了<code>192.168.158.145</code> 使用 <code>RedisClient</code> 连接<code>192.168.158.145</code> 使用 <code>get name</code> 发现可以找到数据，说明Redis容器的数据共享是没问题的。一旦某个节点挂掉，Swarm会自动转移到其他可用的工作节点，结合NFS的文件共享就可以实现Redis独立部署但拥有基本的HA。</p><p><img src="/images/2021-09-09-16-53-04.png" alt=""></p><h1 id="Portainer可视化">Portainer可视化</h1><p>在 <code>192.168.158.1434</code> 管理节点上运行 Portainer 容器。</p><p><img src="/images/2021-09-09-16-53-29.png" alt=""></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/docker/2.2Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/docker/2.2Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>这里记录一下Docker中常用的命令</p><span id="more"></span><h1 id="docker-version">docker version</h1><p>显示docker版本信息。</p><h1 id="docker-info">docker info</h1><p>显示docker的系统信息，包括镜像和容器数量。</p><h1 id="docker-命令-help">docker 命令 --help</h1><p>帮助文档。</p><h1 id="docker-images">docker images</h1><p>查看所有本地主机上的镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY    TAG       IMAGE ID           CREATED             SIZE</span><br><span class="line">hello-world   latest    bf756fb1ae65         10 months ago         13.3kB</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>标签</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>TAG</td><td>镜像标签</td></tr><tr><td>IMAGE ID</td><td>镜像ID</td></tr><tr><td>CREATED</td><td>镜像创建时间</td></tr><tr><td>SIZE</td><td>镜像大小</td></tr><tr><td>REPOSITORY</td><td>镜像仓库源</td></tr></tbody></table><p><strong>可选项</strong><br><code>-a, --all</code>：列出所有镜像<br><code>-q, --quiet</code>：只显示镜像ID</p><h1 id="docker-search">docker search</h1><p>镜像搜索。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang ~]<span class="comment"># docker search mysql</span></span><br><span class="line">NAME      DESCRIPTION       STARS     OFFICIAL   AUTOMATED</span><br><span class="line">mysql     MySQL is a widely used, open-source relation…   10910     [OK]       </span><br><span class="line">mariadb    MariaDB Server is a high performing open sou…   4119      [OK]</span><br></pre></td></tr></table></figure><p><strong>可选项</strong></p><p><code>--filter STARS=3000</code>： 搜索Stars数大于3000镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@192 ~]<span class="comment"># docker search mysql --filter STARS=3000</span></span><br></pre></td></tr></table></figure><h1 id="docker-pull">docker pull</h1><p>下载镜像，默认下载最新版。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang ~]<span class="comment"># docker pull mysql </span></span><br><span class="line">Using default tag: latest    <span class="comment"># 如果不写tage，默认就是latest</span></span><br><span class="line">latest: Pulling from library/mysql </span><br><span class="line">bb79b6b2107f: Pull complete   <span class="comment"># 分层下载 docker iamge的核心 联合文件系统</span></span><br><span class="line">49e22f6fb9f7: Pull complete</span><br><span class="line">842b1255668c: Pull complete</span><br><span class="line">9f48d1f43000: Pull complete</span><br><span class="line">c693f0615bce: Pull complete</span><br><span class="line">8a621b9dbed2: Pull complete</span><br><span class="line">0807d32aef13: Pull complete</span><br><span class="line">a56aca0feb17: Pull complete</span><br><span class="line">de9d45fd0f07: Pull complete</span><br><span class="line">1d68a49161cc: Pull complete</span><br><span class="line">d16d318b774e: Pull complete</span><br><span class="line">49e112c55976: Pull complete</span><br><span class="line">Digest: sha256:8c17271df53ee3b843d6e16d46cff13f22c9c04d6982eb15a9a47bd5c9ac7e2d <span class="comment"># 签名 唯一表示</span></span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> mysql:latest  </span><br><span class="line">docker.io/library/mysql:latest <span class="comment"># 真实地址</span></span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql </span><br><span class="line">docker pull docker.io/library/mysql:latest</span><br></pre></td></tr></table></figure><h1 id="docker-pull-version">docker pull version</h1><p>指定版本下载。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@192 ~]<span class="comment">#  docker pull mysql:5.7</span></span><br></pre></td></tr></table></figure><h1 id="docker-rmi">docker rmi</h1><p>删除镜像。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang ~]# docker  rmi -f   根据镜像ID删除指定镜像</span><br><span class="line">[root@wangpengliang ~]# docker  rmi -f   根据镜像ID删除多个镜像</span><br><span class="line">[root@wangpengliang ~]# docker rmi -f $(docker images -qa) 删除所有镜像</span><br></pre></td></tr></table></figure><h1 id="docker-run-可选参数-image">docker run [可选参数] image</h1><p><strong>参数说明</strong></p><ul><li><code>--name</code>： 容器名 用来区分容器</li><li><code>-d</code> ：后台方式运行</li><li><code>-it  </code>：使用交互方式运行，进入容器查看内容</li><li><code>-p</code>：指定容器的端口 <code>-p  8080:8080</code></li><li><code>-P</code> ：随机指定端口（大写<code>-P</code>）</li></ul><p><strong>测试启动容器</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang ~]<span class="comment"># docker run -it centos /bin/bash</span></span><br><span class="line">[root@c1afa7ccf7d6 /]<span class="comment"># ls</span></span><br><span class="line">bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line"><span class="comment">#退回容器到主机</span></span><br><span class="line">[root@c1afa7ccf7d6 /]<span class="comment"># exit</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="docker-ps">docker -ps</h1><p>查看Docker当前运行的容器。</p><p><strong>参数说明</strong></p><ul><li><code>-a</code> ：列出当前在运行的容器+历史容器</li><li><code>-q</code> ：只显示容器编号</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@192 ~]<span class="comment"># docker ps -a</span></span><br></pre></td></tr></table></figure><h1 id="exit">exit</h1><p>退出容器。</p><h1 id="docker-rm-cId-cName">docker rm cId/cName</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker rm 容器Id                     <span class="comment"># 删除指定容器，不能删除在运行中的容器，如果要强制删除加-f</span></span><br><span class="line">docker rm -f $( docker  ps -aq)     <span class="comment"># 删除所有容器</span></span><br><span class="line">docker ps -a -q | xargs docker rm   <span class="comment"># 删除所有容器</span></span><br></pre></td></tr></table></figure><h1 id="docker-star-cId-cName">docker star cId/cName</h1><p>启动容器。</p><h1 id="docker-restart-cId-cName">docker restart  cId/cName</h1><p>重启容器。</p><h1 id="docker-stop-cId-cName">docker stop cId/cName</h1><p>停止当前正在运行的容器。</p><h1 id="docker-kill-cId-cName">docker kill cId/cName</h1><p>强制停止当前容器。</p><h1 id="docker-run-d-cId-cName">docker run -d cId/cName</h1><p>后台运行容器。</p><h1 id="docerk-logs-cId-cName">docerk logs cId/cName</h1><p>查看日志。</p><h1 id="docker-top-cId-cName">docker top cId/cName</h1><p>查看容器进程信息。</p><h1 id="docker-inspect-cId-cName">docker inspect cId/cName</h1><p>查看镜像的元数据新信息。</p><h1 id="docker-exec">docker exec</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang ~]<span class="comment"># docker exec -it 88c647580c /bin/bashh</span></span><br><span class="line">[root@88c647580c32 /]<span class="comment"># ls</span></span><br><span class="line">bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line">[root@88c647580c32 /]<span class="comment"># ps -ef</span></span><br><span class="line">[root@88c647580c32 /]<span class="comment"># exit</span></span><br></pre></td></tr></table></figure><h1 id="docker-attach">docker attach</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang ~]<span class="comment"># docker attach  88c647580c</span></span><br></pre></td></tr></table></figure><p><strong>attach 与 exec 区别</strong></p><ul><li><code>docker exec</code>： 进容器后开启一个新的后端，可以直接操作</li><li><code>docker attach</code>：进入容器正在执行终端，不会启动新的进程</li></ul><h1 id="docker-cp">docker cp</h1><p>文件拷贝，从docker内拷贝文件到宿主机。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#进入容器</span></span><br><span class="line">[root@88c647580c32 /]<span class="comment"># docker exec -it 88c647580c /bin/bash</span></span><br><span class="line">[root@88c647580c32 /]<span class="comment"># cd home/</span></span><br><span class="line"><span class="comment">#创建文件</span></span><br><span class="line">[root@88c647580c32 home]<span class="comment"># touch  test.txt</span></span><br><span class="line">[root@88c647580c32 home]<span class="comment"># exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"><span class="comment">#拷贝文件</span></span><br><span class="line">[root@88c647580c32 /]<span class="comment"># docker cp 88c647580c:/home/test.txt /home/</span></span><br><span class="line">[root@88c647580c32 /]<span class="comment"># ls /home/</span></span><br><span class="line">test.txt</span><br><span class="line">[root@88c647580c32 /]<span class="comment">#</span></span><br></pre></td></tr></table></figure><h1 id="apt-get-update-apt-get-install-iputils-ping">apt-get update &amp;&amp; apt-get install iputils-ping</h1><p>在容器内安装 <code>ping</code> 工具。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/docker/Portainer%E5%8F%AF%E8%A7%86%E5%8C%96%E9%9D%A2%E6%9D%BF/"/>
      <url>/docker/Portainer%E5%8F%AF%E8%A7%86%E5%8C%96%E9%9D%A2%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<p>Docker的可视化管理工具有DockerUI、Shipyard、Rancher、Portainer等，具体的功能差异查看<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.cnblogs.com%2Ffengli9998%2Fp%2F10386945.html">Docker的可视化管理工具对比</a>，Portainer是一个轻量级的docker环境管理UI，可以用来管理<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.kubernetes.org.cn%2Ftags%2Fdocker">docker</a>宿主机和docker swarm集群。</p><span id="more"></span><p><strong>Portainer主要功能</strong></p><ol><li>提供状态显示面板：显示主机或者swarm集群上有多少镜像，容器、网络、数据卷等</li><li>应用模板快速部署：可以使用预存的模板或者自己定制的模板快速部署</li><li>镜像网络数据卷管理：通过页面进行管理和操作，例如构建镜像，增删数据卷等</li><li>事件日志显示：对任何操作有记录，并且有页面可以显示审计日志</li><li>容器控制台操作：查看容器，启停容器，查看容器占用的性能(内存，cpu等)</li><li>Swarm集群管理：可以管理swarm集群，是最大的优点</li><li>登录用户管理：有完备的用户系统，权限控制（高级功能需付费）</li></ol><p><strong>部署Portiner容器</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 9000:9000 --name portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=<span class="literal">true</span> portainer/portainer</span><br></pre></td></tr></table></figure><ul><li><code>-v /var/run/docker.sock:/var/run/docker.sock</code>：挂载本地 /var/run/docker.socker与容器的/var/run/docker.socker连接</li><li><code>-v portainer_data:/data</code>：数据持久化</li></ul><p><img src="/images/2021-09-09-15-53-13.png" alt=""><br><strong>参考：</strong><br><a href="https://www.cnblogs.com/Yogile/p/12624404.html">https://www.cnblogs.com/Yogile/p/12624404.html</a><br><a href="https://www.cnblogs.com/hellxz/p/install_portainer.html">https://www.cnblogs.com/hellxz/p/install_portainer.html</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/dotnet/1.1DataProtection%E7%AE%80%E4%BB%8B/"/>
      <url>/dotnet/1.1DataProtection%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么需要数据保护">为什么需要数据保护</h1><p>Web应用程序中经常需要存储一些敏感数据（如用户密码），Windows系统为桌面程序提供了 <code>DPAPI</code>用来使用，但是并不适用于Web系统。<a href="http://ASP.NET">ASP.NET</a> Core提供了一套简单易用的API用来保护数据。</p><h1 id="简单示例">简单示例</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">readonly</span> IDataProtector protector;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span>(<span class="params">IDataProtectionProvider provider</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        protector = provider.CreateProtector(<span class="keyword">nameof</span>(MyClass));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RunSample</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> testStr = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加密</span></span><br><span class="line">        <span class="built_in">string</span> protectedPayload = protector.Protect(testStr);</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Protect returned: <span class="subst">&#123;protectedPayload&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;=========================================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解密</span></span><br><span class="line">        <span class="built_in">string</span> unprotectedPayload = protector.Unprotect(protectedPayload);</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Unprotect returned: <span class="subst">&#123;unprotectedPayload&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">TestMethod()</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Sample_01</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 添加数据保护到服务中</span></span><br><span class="line">    <span class="keyword">var</span> serviceCollection = <span class="keyword">new</span> ServiceCollection();</span><br><span class="line">    serviceCollection.AddDataProtection();</span><br><span class="line">    <span class="keyword">var</span> services = serviceCollection.BuildServiceProvider();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从DI中创建一个MyClass的实例 </span></span><br><span class="line">    <span class="keyword">var</span> instance = ActivatorUtilities.CreateInstance&lt;MyClass&gt;(services);</span><br><span class="line">    instance.RunSample();</span><br><span class="line">    Assert.IsTrue(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/2021-09-26-13-37-35.png" alt=""></p><p>在<code>CreateProtector(nameof(MyClass))</code>中，参数 <code>nameof(MyClass)</code> 可以理解为一个公钥或一个标识，表示当前Protector的用途。Data Protection 采用的是非对称加密，所以系统中应该还有一个私钥，此处的密钥由 <a href="http://ASP.NET">ASP.NET</a> Core 在系统内部维护，每一台机器都有一个自有的私钥。</p><h1 id="私钥存储">私钥存储</h1><ul><li>如果程序寄宿在<code>Microsoft Azure</code>下，存储在<code>%HOME%\ASP.NET\DataProtection-Keys</code>文件夹</li><li>如果程序寄宿在<code>IIS</code>下，它被保存在<code>HKLM</code>注册表的<code>ACLed</code>特殊注册表键，并且只有工作进程可以访问，使用<code>windows</code>的<code>DPAPI</code>加密</li><li>如果当前用户可用，即<code>win10</code>或者<code>win7</code>中，它存储在<code>%LOCALAPPDATA%\ASP.NET\DataProtection-Keys</code>文件夹，同样使用<code>windows</code>的<code>DPAPI</code>加密</li><li>如果这些都不符合，那么也就是私钥是没有被持久化的，也就是说当进程关闭的时候，生成的私钥就丢失了</li></ul><h1 id="私钥文件">私钥文件</h1><p><img src="/images/2021-09-26-13-38-17.png" alt=""></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span> <span class="attr">id</span>=<span class="string">&quot;bf2f4417-10fa-4d4d-ba61-b91c041029e0&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">creationDate</span>&gt;</span>2021-03-08T02:18:08.641323Z<span class="tag">&lt;/<span class="name">creationDate</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">activationDate</span>&gt;</span>2021-03-09T09:07:57.9935838Z<span class="tag">&lt;/<span class="name">activationDate</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">expirationDate</span>&gt;</span>2021-06-06T02:18:08.5176468Z<span class="tag">&lt;/<span class="name">expirationDate</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">descriptor</span> <span class="attr">deserializerType</span>=<span class="string">&quot;Microsoft.AspNetCore.DataProtection.AuthenticatedEncryption.ConfigurationModel.AuthenticatedEncryptorDescriptorDeserializer, Microsoft.AspNetCore.DataProtection, Version=2.1.1.0, Culture=neutral, PublicKeyToken=adb9793829ddae60&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">descriptor</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">encryption</span> <span class="attr">algorithm</span>=<span class="string">&quot;AES_256_CBC&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">validation</span> <span class="attr">algorithm</span>=<span class="string">&quot;HMACSHA256&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">encryptedSecret</span> <span class="attr">decryptorType</span>=<span class="string">&quot;Microsoft.AspNetCore.DataProtection.XmlEncryption.DpapiXmlDecryptor, Microsoft.AspNetCore.DataProtection, Version=2.1.1.0, Culture=neutral, PublicKeyToken=adb9793829ddae60&quot;</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://schemas.asp.net/2015/03/dataProtection&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encryptedKey</span> <span class="attr">xmlns</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!-- This key is encrypted with Windows DPAPI. --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">value</span>&gt;</span>AQAAANCMnd8BFdERjHoAwE/Cl+sBAAAAdzyZbq38yUupe39PhMdBEAAAAAACAAAAAAAQZgAAAAEAACAAAACYrALB9ricGU/5Y6iOanIlQjSCb548eBxAWafTbwxtLAAAAAAOgAAAAAIAACAAAADd6x5zXIP/VC6r1Y5ZAf74uL/+lc68ilrliN7T8dGhYVABAAD0qlvH4LDPjhr3R9WTjP+mOJZrrtt8clI91ULbNPDN2bgwM7ibkICFOLVr9AkwMpRzP+etArhuXbIhH6jzdv9aoAjAcQsQtg37LSlWBI3TFmTtz53nHzIxmfgUuPS23sLjHc7KTBo9+DPHy5BT3qm21y8EDoQ8ehj6WqqwvaEkThRXcG5Kst5HzBbIgeRXSrSprjIeja0uhJpFJOAzOr5ngeoRG4tKfs6VMZMIU9IMbukbuGSC/JoUMR5yzavT/Yi+Cr9x9eeIewDOKzRIaq3wIkYIybhOJxZm5MMgV3A4j4nKSSN0jcW6hXee5ksdywsPKquK5E5fz/jY6bVc9Sj1DV+A6IN6MAjstQzYpZ6CIjFJwgwD7OpD9G/JmlwRNhB/TnNWKAW+4duXYEgKADWA4ZVg2riaYYphPbEmz5RXnphN+C6OEDozguAsW60Z2DJAAAAAPxkE7aqhWgiAk2Fxf8w1yZ6ZMkBSXe/b655jsvfLl6asBUStynk08vPaw5YsD61VyRNp/s8lRjrfwyHpTGrxOw==<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encryptedKey</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">encryptedSecret</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">descriptor</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">descriptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br></pre></td></tr></table></figure><p>文件包含一个创建日期，一个过期日期。间隔为90天，90天之后密钥就会失效，系统将自动生成一个新的密钥并设置新的密钥作为活动的密钥。只要已过期的密钥还存在于系统上，仍然可以解密任何受保护的数据。</p><h1 id="Data-Protection">Data Protection</h1><p><code>ASP.NET Core Data Protection</code> 主要对开发人员提供了两个接口，<code>IDataProtectionProvider</code> 和 <code>IDataProtector</code>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Microsoft.AspNetCore.DataProtection</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 摘要:</span></span><br><span class="line">    <span class="comment">//     An interface that can provide data protection services.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IDataProtector</span> : <span class="title">IDataProtectionProvider</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">byte</span>[] <span class="title">Protect</span>(<span class="params"><span class="built_in">byte</span>[] plaintext</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">byte</span>[] <span class="title">Unprotect</span>(<span class="params"><span class="built_in">byte</span>[] protectedData</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>IDataProtector</code> 继承自 <code>IDataProtectionProvider</code> ，并且提供了两个方法 <code>Protect(加密)</code> 和 <code>Unprotect(解密)</code> 。</p><p><code>IDataProtectionProvider</code>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Microsoft.AspNetCore.DataProtection</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IDataProtectionProvider</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">IDataProtector <span class="title">CreateProtector</span>(<span class="params"><span class="built_in">string</span> purpose</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>IDataProtectionProvider</code> 提供了一个方法，通过传入一个 <code>purpose</code>字符串生成一个 <code>IDataProtector</code> 接口对象，方法签名中的 <code>purpose</code> 这个字符串，可以理解为一个标识，表示当前 Protector 的用途。</p><p>使用 <code>IDataProtector</code> 的时候，会发现它还有一些扩展方法位于<code>Microsoft.AspNetCore.DataProtection</code>命名空间下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">DataProtectionCommonExtensions</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IDataProtector <span class="title">CreateProtector</span>(<span class="params"><span class="keyword">this</span> IDataProtectionProvider provider, IEnumerable&lt;<span class="built_in">string</span>&gt; purposes</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IDataProtector <span class="title">CreateProtector</span>(<span class="params"><span class="keyword">this</span> IDataProtectionProvider provider, <span class="built_in">string</span> purpose, <span class="keyword">params</span> <span class="built_in">string</span>[] subPurposes</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IDataProtector <span class="title">GetDataProtector</span>(<span class="params"><span class="keyword">this</span> IServiceProvider services, IEnumerable&lt;<span class="built_in">string</span>&gt; purposes</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IDataProtector <span class="title">GetDataProtector</span>(<span class="params"><span class="keyword">this</span> IServiceProvider services, <span class="built_in">string</span> purpose, <span class="keyword">params</span> <span class="built_in">string</span>[] subPurposes</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">Protect</span>(<span class="params"><span class="keyword">this</span> IDataProtector protector, <span class="built_in">string</span> plaintext</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">Unprotect</span>(<span class="params"><span class="keyword">this</span> IDataProtector protector, <span class="built_in">string</span> protectedData</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>CreateProtector</code>还提供了可以传多个<code>purpose</code> 的方法（IEnumerable，params string[]），因为 <code>DataProtector</code> 是有层次结构的，再看一下<code>IDataProtector</code>接口，它自身也实现了<code>IDataProtectionProvider</code>接口，就是说<code>IDataProtector</code>自身也可以再创建<code>IDataProtector</code>。</p><h2 id="用户密码哈希">用户密码哈希</h2><p>在 <code>Microsoft.AspNetCore.Cryptography.KeyDerivation</code> 命名空间下提供了一个 <code>KeyDerivation.Pbkdf2</code> 方法用来对用户密码进行哈希。</p><h2 id="生命周期限制">生命周期限制</h2><p>有些时候，需要一些具有过期或者到期时间的加密字符串，比如用户在找回密码的时候，向用户的邮箱发送一封带有重置命令的一封邮件，这个重置命令就需要有一个过期时间了，超过这个过期时间后就失效，在以前可能需要向数据库存储一个时间来标记发送时间，然后再解密对比和数据库的时间差来验证。现在不用了，<a href="http://ASP.NET">ASP.NET</a> Core 默认提供了一个接口叫 <code>ITimeLimitedDataProtector</code>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CreateProtector(<span class="built_in">string</span> purpose) : ITimeLimitedDataProtector This API <span class="keyword">is</span> similar to the existing IDataProtectionProvider.CreateProtector <span class="keyword">in</span> that it can be used to create purpose chains <span class="keyword">from</span> a root time-limited protector.</span><br><span class="line">Protect(<span class="built_in">byte</span>[] plaintext, DateTimeOffset expiration) : <span class="function"><span class="built_in">byte</span>[]</span></span><br><span class="line"><span class="function"><span class="title">Protect</span>(<span class="params"><span class="built_in">byte</span>[] plaintext, TimeSpan lifetime</span>) : <span class="built_in">byte</span>[]</span></span><br><span class="line"><span class="function"><span class="title">Protect</span>(<span class="params"><span class="built_in">byte</span>[] plaintext</span>) : <span class="built_in">byte</span>[]</span></span><br><span class="line"><span class="function"><span class="title">Protect</span>(<span class="params"><span class="built_in">string</span> plaintext, DateTimeOffset expiration</span>) : <span class="built_in">string</span></span></span><br><span class="line"><span class="function"><span class="title">Protect</span>(<span class="params"><span class="built_in">string</span> plaintext, TimeSpan lifetime</span>) : <span class="built_in">string</span></span></span><br><span class="line"><span class="function"><span class="title">Protect</span>(<span class="params"><span class="built_in">string</span> plaintext</span>) : <span class="built_in">string</span></span></span><br></pre></td></tr></table></figure><p><code>ITimeLimitedDataProtector </code>提供了数个重载方法用来设定带有生命周期的加密方法，可以通过<code>Date TimeOffset</code>，<code>TimeSpan</code>等参数来设置时间。有对应的加密，就有相对应的解密方法，在这里就不详细介绍了。有兴趣的可以去看一下官方文档。</p><h2 id="配置数据保护">配置数据保护</h2><p><a href="http://ASP.NET">ASP.NET</a> Core 运行时，系统会基于当前机器的运行环境默认配置一些关于 <code>Data Protection</code> 的东西，但是有时可能需要对这些配置做一些改变。</p><h2 id="注册服务">注册服务</h2><p>通过以下方式来把 <code>Data Protection</code> 注册到服务中：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    services.AddDataProtection();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指定私钥存储位置">指定私钥存储位置</h2><p><code>AddDataProtection</code> 返回的是一个 <code>IDataProtectionBuilder</code> 接口，这个接口提供了一个扩展方法 <code>PersistKeysToFileSystem()</code>  来存储私钥。可以通过它传入一个路径来指定私钥存储的位置，比如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    services.AddDataProtection()</span><br><span class="line">        .PersistKeysToFileSystem(<span class="keyword">new</span> DirectoryInfo(<span class="string">@&quot;\\server\share\directory\&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用证书加密">使用证书加密</h2><p>可以传入一个共享文件夹，来存储私钥。这样在不同机器的私钥就可以保存到一个位置了。可以通过此种方式在分布式部署的时候，隔离开机器的差异化。如果觉得不安全，还可以配置一个<code>X.509</code>证书来进行加密，比如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  services.AddDataProtection()</span><br><span class="line">      .PersistKeysToFileSystem(<span class="keyword">new</span> DirectoryInfo(<span class="string">@&quot;\\server\share\directory\&quot;</span>))</span><br><span class="line">      .ProtectKeysWithCertificate(<span class="string">&quot;thumbprint&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="调整默认保存时间">调整默认保存时间</h2><p><code>Data Protection</code> 默认保存时间是90天，可以通过以下方式来修改默认的保存时间：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    services.AddDataProtection()</span><br><span class="line">        .SetDefaultKeyLifetime(TimeSpan.FromDays(<span class="number">14</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="应用程序隔离">应用程序隔离</h2><p>默认情况下，即使使用相同的物理密钥库，<code>Data Protection</code> 也会把不同的应用程序隔离开，因为这样可以防止从一个应用程序获取另外一个应用程序的密钥。所以如果是相同的应用程序，可以设置相同的应用程序名称，比如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    services.AddDataProtection()</span><br><span class="line">        .SetApplicationName(<span class="string">&quot;my application&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="禁止自动生成秘钥">禁止自动生成秘钥</h2><p>有时候需要禁用应用程序生成密钥，或者是说只有一个程序用来生成或者管理密钥，其他程序只是负责读的话，那么可以这样：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  services.AddDataProtection()</span><br><span class="line">      .DisableAutomaticKeyGeneration();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="修改加密算法"><strong>修改加密算法</strong></h2><p>可以使用 <code>UseCryptographicAlgorithms</code> 方法来修改 <code>ASP.NET Core Data Protection</code> 的默认加密算法，比如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">services.AddDataProtection()</span><br><span class="line">    .UseCryptographicAlgorithms(<span class="keyword">new</span> AuthenticatedEncryptionSettings()</span><br><span class="line">    &#123;</span><br><span class="line">        EncryptionAlgorithm = EncryptionAlgorithm.AES_256_CBC,</span><br><span class="line">        ValidationAlgorithm = ValidationAlgorithm.HMACSHA256</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/docker/1.9DockerCompose/"/>
      <url>/docker/1.9DockerCompose/</url>
      
        <content type="html"><![CDATA[<blockquote><p><code>Docker Compose</code> 是 Docker 官方编排（Orchestration）项目之一，负责实现对 Docker 容器集群的快速编排，快速的部署分布式应用。</p></blockquote><p>通过之前学习已经了解到使用一个 <code>Dockerfile</code> 模板文件，可以很方便的定义一个单独的应用容器。然而在日常工作中，经常碰到的情况是需要多个容器相互配合来完成某项任务的情况。例如要实现一个 Web 项目，除了 Web 服务容器本身，往往还需要再加上后端的数据库服务容器、负载均衡容器等等。<code>Compose</code> 就是用来处理这些事情的。它通过一个单独的 <code>docker-compose.yml</code> 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目<code>project</code>。</p><p><code>Compose</code> 中有两个重要的概念：</p><ul><li>服务 (<code>service</code>)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例</li><li>项目 (<code>project</code>)：由一组关联的应用容器组成的一个完整业务单元，在 <code>docker-compose.yml</code> 文件中定义</li></ul><p><code>Compose</code> 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理，<code>Compose</code> 项目由 Python 编写，实现上调用了 Docker 服务提供的 API 来对容器进行管理。因此只要所操作的平台支持 <code>Docker API</code> 就可以在其上利用 <code>Compose</code> 来进行编排管理。</p><span id="more"></span><h1 id="安装-v2">安装</h1><p><code>Compose</code>  支持 Linux、macOS、Windows 10 三大平台，安装方式：</p><ol><li>通过 Python 的包管理工具 <code>pip</code>  进行安装</li><li>直接下载编译好的二进制文件使用</li><li>直接在 Docker 容器中运行</li></ol><p>前两种方式是传统方式，适合本地环境下安装使用；最后一种方式则不破坏系统环境，更适合云计算场景，<code>Docker for Mac</code>  、 <code>Docker for Windows</code>  自带 <code>docker-compose</code>  二进制文件，安装 Docker 之后可以直接使用。</p><p><strong>查看本机是否安装</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang ~]<span class="comment"># docker-compose --version</span></span><br><span class="line">-bash: docker-compose: 未找到命令</span><br></pre></td></tr></table></figure><p><strong>Linux下安装 Compose</strong></p><p>在 Linux 上安装十分简单，从 官方 GitHub Release 处直接下载编译好的二进制文件即可。</p><p>例如，在 Linux 64 位系统上直接下载对应的二进制包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo curl -L https://github.com/docker/compose/releases/download/1.17.1/docker-compose-uname -s-uname -m &gt; /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line">$ sudo chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br></pre></td></tr></table></figure><p>查看本机架构</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang ~]<span class="comment"># uname -m</span></span><br><span class="line">x86_64</span><br></pre></td></tr></table></figure><p>这里选择使用二进制包下载安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang ~]<span class="comment"># curl -L https://github.com/docker/compose/releases/download/1.17.1/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose</span></span><br><span class="line">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">100   633  100   633    0     0     63      0  0:00:10  0:00:09  0:00:01   155</span><br><span class="line">100 8649k  100 8649k    0     0   292k      0  0:00:29  0:00:29 --:--:-- 1989k</span><br><span class="line">[root@wangpengliang ~]<span class="comment"># curl -L https://raw.githubusercontent.com/docker/compose/1.8.0/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose</span></span><br><span class="line">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">100 10554  100 10554    0     0   1435      0  0:00:07  0:00:07 --:--:--  2753</span><br><span class="line">[root@wangpengliang ~]<span class="comment"># chmod +x /usr/local/bin/docker-compose</span></span><br><span class="line">[root@wangpengliang ~]<span class="comment"># docker-compose --version</span></span><br><span class="line">docker-compose version 1.17.1, build 6d101fb</span><br></pre></td></tr></table></figure><p><strong>PIP 安装</strong></p><blockquote><p>注意： <code> x86_64</code>  架构的 Linux 建议按照上边的方法下载二进制包进行安装，如果计算机的架构是 <code>ARM</code>  (例如，树莓派)，再使用 pip 安装</p></blockquote><p>这种方式是将 Compose 当作一个 Python 应用来从 pip 源中安装</p><p>执行安装命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip install -U docker-compose</span><br></pre></td></tr></table></figure><p>看到类似如下输出，说明安装成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Collecting docker-compose</span><br><span class="line">Downloading docker-compose-1.17.1.tar.gz (149kB): 149kB downloaded</span><br><span class="line">...</span><br><span class="line">Successfully installed docker-compose cached-property requests texttable websocket-client docker-py dockerpty six enum34 backports.ssl-match-hostname ipaddress</span><br></pre></td></tr></table></figure><p>bash 补全命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -L https://raw.githubusercontent.com/docker/compose/1.8.0/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose</span><br></pre></td></tr></table></figure><p>容器中执行<br>Compose 既然是一个 Python 应用，自然也可以直接用容器来执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl -L https://github.com/docker/compose/releases/download/1.8.0/run.sh &gt; /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line">$ chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br></pre></td></tr></table></figure><p>查看下载的 <code>run.sh</code>  脚本内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> -e</span><br><span class="line">VERSION=<span class="string">&quot;1.8.0&quot;</span></span><br><span class="line">IMAGE=<span class="string">&quot;docker/compose:<span class="variable">$VERSION</span>&quot;</span></span><br><span class="line"><span class="comment"># Setup options for connecting to docker host</span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$DOCKER_HOST</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    DOCKER_HOST=<span class="string">&quot;/var/run/docker.sock&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ -S <span class="string">&quot;<span class="variable">$DOCKER_HOST</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    DOCKER_ADDR=<span class="string">&quot;-v <span class="variable">$DOCKER_HOST</span>:<span class="variable">$DOCKER_HOST</span> -e DOCKER_HOST&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    DOCKER_ADDR=<span class="string">&quot;-e DOCKER_HOST -e DOCKER_TLS_VERIFY -e DOCKER_CERT_PATH&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># Setup volume mounts for compose config and context</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="subst">$(pwd)</span>&quot;</span> != <span class="string">&#x27;/&#x27;</span> ]; <span class="keyword">then</span></span><br><span class="line">    VOLUMES=<span class="string">&quot;-v <span class="subst">$(pwd)</span>:<span class="subst">$(pwd)</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$COMPOSE_FILE</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    compose_dir=$(dirname <span class="variable">$COMPOSE_FILE</span>)</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># <span class="doctag">TODO:</span> also check --file argument</span></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$compose_dir</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    VOLUMES=<span class="string">&quot;<span class="variable">$VOLUMES</span> -v <span class="variable">$compose_dir</span>:<span class="variable">$compose_dir</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$HOME</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    VOLUMES=<span class="string">&quot;<span class="variable">$VOLUMES</span> -v <span class="variable">$HOME</span>:<span class="variable">$HOME</span> -v <span class="variable">$HOME</span>:/root&quot;</span> <span class="comment"># mount $HOME in /root to share docker.config</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># Only allocate tty if we detect one</span></span><br><span class="line"><span class="keyword">if</span> [ -t 1 ]; <span class="keyword">then</span></span><br><span class="line">    DOCKER_RUN_OPTIONS=<span class="string">&quot;-t&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ -t 0 ]; <span class="keyword">then</span></span><br><span class="line">    DOCKER_RUN_OPTIONS=<span class="string">&quot;<span class="variable">$DOCKER_RUN_OPTIONS</span> -i&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">exec</span> docker run --rm <span class="variable">$DOCKER_RUN_OPTIONS</span> <span class="variable">$DOCKER_ADDR</span> <span class="variable">$COMPOSE_OPTIONS</span> <span class="variable">$VOLUMES</span> -w <span class="string">&quot;<span class="subst">$(pwd)</span>&quot;</span> <span class="variable">$IMAGE</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br></pre></td></tr></table></figure><p>可以看到，其实是下载了 <code>docker/compose</code>  镜像并运行</p><h1 id="卸载-v2">卸载</h1><p>如果是二进制包方式安装的，删除二进制文件即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo rm /usr/<span class="built_in">local</span>/bin/docker-compose</span><br></pre></td></tr></table></figure><p>如果是通过 <code>pip</code>  安装的，则执行如下命令即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pip uninstall docker-compose</span><br></pre></td></tr></table></figure><h1 id="使用-v2">使用</h1><p>之前说到<code>Compose</code> 中有两个重要的概念：</p><ul><li>服务 (<code>service</code>)：一个应用容器，实际上可以运行多个相同镜像的实例</li><li>项目 (<code>project</code>)：由一组关联的应用容器组成的一个完整业务单元</li></ul><p>可见，一个项目可以由多个服务（容器）关联而成，<code>Compose</code> 面向项目进行管理。</p><p><strong>创建Web应用</strong></p><p>示例用 <code>Python</code> 创建一个能够记录页面访问次数的 web 网站。新建文件夹，在该目录中编写 <code>app.py</code> 文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> redis <span class="keyword">import</span> Redis</span><br><span class="line">app = Flask(__name__)</span><br><span class="line">redis = Redis(host=<span class="string">&#x27;redis&#x27;</span>, port=<span class="number">6379</span>)</span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>():</span></span><br><span class="line">    count = redis.incr(<span class="string">&#x27;hits&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello World! 该页面已被访问 &#123;&#125; 次。\n&#x27;</span>.<span class="built_in">format</span>(count)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(host=<span class="string">&quot;0.0.0.0&quot;</span>, debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p><strong>Dockerfile</strong></p><p>编写 <code>Dockerfile</code> 文件内容为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM python:<span class="number">3.6</span>-alpine</span><br><span class="line">ADD . /code</span><br><span class="line">WORKDIR /code</span><br><span class="line">RUN pip install redis flask</span><br><span class="line">CMD [<span class="string">&quot;python&quot;</span>, <span class="string">&quot;app.py&quot;</span>]</span><br></pre></td></tr></table></figure><p><strong>docker-compose.yml</strong></p><p>编写 <code>docker-compose.yml</code> 文件，这个是 Compose 使用的主模板文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&#x27;3&#x27;</span></span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    ports:</span><br><span class="line">     - <span class="string">&quot;5000:5000&quot;</span></span><br><span class="line">  redis:</span><br><span class="line">    image: <span class="string">&quot;redis:alpine&quot;</span></span><br></pre></td></tr></table></figure><p><strong>运行 compose</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up</span><br></pre></td></tr></table></figure><h1 id="HEAD-创建-pythontests-目录，创建-app-py-Dockerfile-docker-compose-yml-文件">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>**创建 <code>pythontests</code> 目录，创建 **<code>app.py</code> <code>Dockerfile</code> <code>docker-compose.yml</code> 文件</h1><p>创建 <code>pythontests</code> 目录，创建 <code>app.py</code> <code>Dockerfile</code> <code>docker-compose.yml</code> 文件</p><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>a155dac (init)</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang pythontests]<span class="comment"># ls</span></span><br><span class="line">app.py  docker-compose.yml  Dockerfile</span><br></pre></td></tr></table></figure><p><strong>运行 docker-compose</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang pythontests]<span class="comment"># docker-compose up</span></span><br><span class="line">Building web</span><br><span class="line">Step 1/5 : FROM python:3.6-alpine <span class="comment"># 下载基础镜像python:3.6-alpine</span></span><br><span class="line">3.6-alpine: Pulling from library/python</span><br><span class="line">540db60ca938: Pull complete</span><br><span class="line">a7ad1a75a999: Pull complete</span><br><span class="line">5545670c3922: Pull complete</span><br><span class="line">c89910f38943: Pull complete</span><br><span class="line">b6a40d090e87: Pull complete</span><br><span class="line">Digest: sha256:492bb540e9c9bc9f586d5d69467c66bc32072d9af48463b1f0054d4ff9b93709</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> python:3.6-alpine</span><br><span class="line"> ---&gt; ac438c122d19</span><br><span class="line">Step 2/5 : ADD . /code   <span class="comment"># 拷贝文件到/code目录</span></span><br><span class="line"> ---&gt; 68cbe5b2f598</span><br><span class="line">Step 3/5 : WORKDIR /code <span class="comment"># 设置/code目录为工作目录</span></span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 4fd09a1580a8</span><br><span class="line">Removing intermediate container 4fd09a1580a8 <span class="comment"># 拆卸中间容器：4fd09a1580a8</span></span><br><span class="line"> ---&gt; 2e4bbd31555d</span><br><span class="line">Step 4/5 : RUN pip install redis flask <span class="comment"># 运行pip安装redis、flask</span></span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> c12f4ece64f1</span><br><span class="line">Collecting redis</span><br><span class="line">  Downloading redis-3.5.3-py2.py3-none-any.whl (72 kB)</span><br><span class="line">Collecting flask</span><br><span class="line">  Downloading Flask-2.0.1-py3-none-any.whl (94 kB)</span><br><span class="line">Collecting click&gt;=7.1.2</span><br><span class="line">  Downloading click-8.0.1-py3-none-any.whl (97 kB)</span><br><span class="line">Collecting Werkzeug&gt;=2.0</span><br><span class="line">  Downloading Werkzeug-2.0.1-py3-none-any.whl (288 kB)</span><br><span class="line">Collecting itsdangerous&gt;=2.0</span><br><span class="line">  Downloading itsdangerous-2.0.1-py3-none-any.whl (18 kB)</span><br><span class="line">Collecting Jinja2&gt;=3.0</span><br><span class="line">  Downloading Jinja2-3.0.1-py3-none-any.whl (133 kB)</span><br><span class="line">Collecting importlib-metadata</span><br><span class="line">  Downloading importlib_metadata-4.5.0-py3-none-any.whl (17 kB)</span><br><span class="line">Collecting MarkupSafe&gt;=2.0</span><br><span class="line">  Downloading MarkupSafe-2.0.1.tar.gz (18 kB)</span><br><span class="line">Collecting dataclasses</span><br><span class="line">  Downloading dataclasses-0.8-py3-none-any.whl (19 kB)</span><br><span class="line">Collecting typing-extensions&gt;=3.6.4</span><br><span class="line">  Downloading typing_extensions-3.10.0.0-py3-none-any.whl (26 kB)</span><br><span class="line">Collecting zipp&gt;=0.5</span><br><span class="line">  Downloading zipp-3.4.1-py3-none-any.whl (5.2 kB)</span><br><span class="line">Building wheels <span class="keyword">for</span> collected packages: MarkupSafe</span><br><span class="line">  Building wheel <span class="keyword">for</span> MarkupSafe (setup.py): started</span><br><span class="line">  Building wheel <span class="keyword">for</span> MarkupSafe (setup.py): finished with status <span class="string">&#x27;done&#x27;</span></span><br><span class="line">  Created wheel <span class="keyword">for</span> MarkupSafe: filename=MarkupSafe-2.0.1-py3-none-any.whl size=9761 sha256=e2a25263f4c7babbdd0cdda87cad139e54eb972cf742f2f7b7893003e0ecfe97</span><br><span class="line">  Stored <span class="keyword">in</span> directory: /root/.cache/pip/wheels/05/46/9b/189d9acb1f643857fb8ad990ca04c02509c35d3ad6fac81794</span><br><span class="line">Successfully built MarkupSafe</span><br><span class="line">Installing collected packages: zipp, typing-extensions, MarkupSafe, importlib-metadata, dataclasses, Werkzeug, Jinja2, itsdangerous, click, redis, flask</span><br><span class="line">Successfully installed Jinja2-3.0.1 MarkupSafe-2.0.1 Werkzeug-2.0.1 click-8.0.1 dataclasses-0.8 flask-2.0.1 importlib-metadata-4.5.0 itsdangerous-2.0.1 redis-3.5.3 typing-extensions-3.10.0.0 zipp-3.4.1</span><br><span class="line">WARNING: Running pip as root will <span class="built_in">break</span> packages and permissions. You should install packages reliably by using venv: https://pip.pypa.io/warnings/venv</span><br><span class="line">Removing intermediate container c12f4ece64f1</span><br><span class="line"> ---&gt; 061f502fa95e</span><br><span class="line">Step 5/5 : CMD [<span class="string">&quot;python&quot;</span>, <span class="string">&quot;app.py&quot;</span>]</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> c6ac95ba9659</span><br><span class="line">Removing intermediate container c6ac95ba9659</span><br><span class="line"> ---&gt; aabe65a53ffd</span><br><span class="line">Successfully built aabe65a53ffd</span><br><span class="line">Successfully tagged pythontests_web:latest</span><br><span class="line">WARNING: Image <span class="keyword">for</span> service web was built because it did not already exist. To rebuild this image you must use `docker-compose build` or `docker-compose up --build`.</span><br><span class="line">Pulling redis (redis:alpine)...</span><br><span class="line">alpine: Pulling from library/redis</span><br><span class="line"></span><br><span class="line">29712d301e8c: Pull complete</span><br><span class="line">8173c12df40f: Pull complete</span><br><span class="line">8cc52074f78e: Pull complete</span><br><span class="line">aa7854465cce: Pull complete</span><br><span class="line">6ab1d05b4973: Pull complete</span><br><span class="line">Digest: sha256:eaaa58f8757d6f04b2e34ace57a71d79f8468053c198f5758fd2068ac235f303</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> redis:alpine</span><br><span class="line">Creating pythontests_web_1</span><br><span class="line">Creating pythontests_redis_1</span><br><span class="line">Attaching to pythontests_redis_1, pythontests_web_1</span><br><span class="line">redis_1  | 1:C 09 Jun 2021 03:16:24.588 <span class="comment"># oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span></span><br><span class="line">redis_1  | 1:C 09 Jun 2021 03:16:24.588 <span class="comment"># Redis version=6.2.4, bits=64, commit=00000000, modified=0, pid=1, just started</span></span><br><span class="line">redis_1  | 1:C 09 Jun 2021 03:16:24.588 <span class="comment"># Warning: no config file specified, using the default config. In order to specify a config file use redis-server /path/to/redis.conf</span></span><br><span class="line">redis_1  | 1:M 09 Jun 2021 03:16:24.588 * monotonic clock: POSIX clock_gettime</span><br><span class="line">redis_1  | 1:M 09 Jun 2021 03:16:24.590 * Running mode=standalone, port=6379.</span><br><span class="line">redis_1  | 1:M 09 Jun 2021 03:16:24.590 <span class="comment"># WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.</span></span><br><span class="line">redis_1  | 1:M 09 Jun 2021 03:16:24.590 <span class="comment"># Server initialized</span></span><br><span class="line">redis_1  | 1:M 09 Jun 2021 03:16:24.590 <span class="comment"># WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add &#x27;vm.overcommit_memory = 1&#x27; to /etc/sysctl.conf and then reboot or run the command &#x27;sysctl vm.overcommit_memory=1&#x27; for this to take effect.</span></span><br><span class="line">redis_1  | 1:M 09 Jun 2021 03:16:24.590 * Ready to accept connections</span><br><span class="line">web_1    |  * Serving Flask app <span class="string">&#x27;app&#x27;</span> (lazy loading)</span><br><span class="line">web_1    |  * Environment: production</span><br><span class="line">web_1    |    WARNING: This is a development server. Do not use it <span class="keyword">in</span> a production deployment.</span><br><span class="line">web_1    |    Use a production WSGI server instead.</span><br><span class="line">web_1    |  * Debug mode: on</span><br><span class="line">web_1    |  * Running on all addresses.</span><br><span class="line">web_1    |    WARNING: This is a development server. Do not use it <span class="keyword">in</span> a production deployment.</span><br><span class="line">web_1    |  * Running on http://172.19.0.2:5000/ (Press CTRL+C to quit)</span><br><span class="line">web_1    |  * Restarting with <span class="built_in">stat</span></span><br><span class="line">web_1    |  * Debugger is active!</span><br><span class="line">web_1    |  * Debugger PIN: 103-300-970</span><br><span class="line">web_1    | 172.19.0.1 - - [09/Jun/2021 03:17:00] <span class="string">&quot;GET / HTTP/1.1&quot;</span> 200 -</span><br></pre></td></tr></table></figure><p>测试结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang pythontests]<span class="comment"># curl 172.18.0.2:5000</span></span><br><span class="line">Hello World! 该页面已被访问 1 次。</span><br><span class="line">[root@wangpengliang pythontests]<span class="comment"># curl 172.18.0.2:5000</span></span><br><span class="line">Hello World! 该页面已被访问 2 次。</span><br><span class="line">[root@wangpengliang pythontests]<span class="comment"># curl 172.18.0.2:5000</span></span><br><span class="line">Hello World! 该页面已被访问 3 次。</span><br><span class="line">[root@wangpengliang pythontests]<span class="comment"># curl 172.18.0.2:5000</span></span><br><span class="line">Hello World! 该页面已被访问 4 次。</span><br><span class="line">[root@wangpengliang pythontests]<span class="comment"># curl 172.18.0.2:5000</span></span><br><span class="line">Hello World! 该页面已被访问 5 次。</span><br></pre></td></tr></table></figure><h1 id="命令对象与格式">命令对象与格式</h1><p>对于 Compose 来说，大部分命令的对象既可以是项目本身，也可以指定为项目中的服务或者容器。如果没有特别的说明，命令对象将是项目。这意味着项目中所有的服务都会受到命令影响。</p><p><strong>查看具体某个命令的使用格式：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker-compose [COMMAND] --<span class="built_in">help</span> </span><br><span class="line">或</span><br><span class="line">docker-compose <span class="built_in">help</span> [COMMAND]</span><br></pre></td></tr></table></figure><p><strong><code>docker-compose</code> 命令的基本使用格式：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose [-f=&lt;arg&gt;...] [options] [COMMAND] [ARGS...]</span><br></pre></td></tr></table></figure><h2 id="命令选项">命令选项</h2><ul><li><code>-f, --file FILE</code> 指定使用的 Compose 模板文件，默认为 <code>docker-compose.yml</code>，可以多次指定</li><li><code>-p, --project-name NAME</code> 指定项目名称，默认将使用所在目录名称作为项目名</li><li><code>--x-networking</code> 使用 Docker 的可拔插网络后端特性</li><li><code>--x-network-driver DRIVER</code> 指定网络后端的驱动，默认为 <code>bridge</code></li><li><code>--verbose</code> 输出更多调试信息</li><li><code>-v, --version</code> 打印版本并退出</li></ul><h2 id="命令使用说明">命令使用说明</h2><h3 id="build">build</h3><p>格式： <code>docker-compose build [options] [SERVICE...]</code></p><blockquote><p>构建（重新构建）项目中的服务容器。服务容器一旦构建后，将会带上一个标记名，例如对于 web 项目中的一个 db 容器，可能是 web_db。可以随时在项目目录下运行 <code>docker-compose build</code> 来重新构建服务</p></blockquote><p>选项：</p><ul><li><code>--force-rm</code> 删除构建过程中的临时容器</li><li><code>--no-cache</code> 构建镜像过程中不使用 cache（这将加长构建过程）</li><li><code>--pull</code> 始终尝试通过 pull 来获取更新版本的镜像</li></ul><h3 id="config">config</h3><p>验证 Compose 文件格式是否正确，若正确则显示配置，若格式错误显示错误原因。</p><h3 id="down">down</h3><p>此命令将会停止 <code>up</code> 命令所启动的容器，并移除网络。</p><h3 id="exec-v3">exec</h3><p>进入指定容器。</p><h3 id="help">help</h3><p>获得一个命令的帮助。</p><h3 id="images">images</h3><p>列出 Compose 文件中包含的镜像。</p><h3 id="kill">kill</h3><p>格式： <code>docker-compose kill [options] [SERVICE...]</code></p><blockquote><p>通过发送 <code>SIGKILL</code> 信号来强制停止服务容器。支持通过 <code>-s</code> 参数来指定发送的信号，例如通过如下指令发送 <code>SIGINT</code> 信号</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose <span class="built_in">kill</span> -s SIGINT</span><br></pre></td></tr></table></figure><h3 id="logs">logs</h3><p>格式： <code>docker-compose logs [options] [SERVICE...]</code></p><blockquote><p>查看服务容器的输出。默认情况下，docker-compose 将对不同的服务输出使用不同的颜色来区分。可以通过 <code>--no-color</code> 来关闭颜色。该命令在调试问题的时候经常使用</p></blockquote><h3 id="pause">pause</h3><p>格式：<code>docker-compose pause [SERVICE...]</code></p><blockquote><p>暂停一个服务容器</p></blockquote><h3 id="port">port</h3><p>格式： <code>docker-compose port [options] SERVICE PRIVATE_PORT</code></p><blockquote><p>打印某个容器端口所映射的公共端口</p></blockquote><p>选项：</p><ul><li><code>--protocol=proto</code> 指定端口协议，tcp（默认值）或者 udp</li><li><code>--index=index</code> 如果同一服务存在多个容器，指定命令对象容器的序号（默认为 1）</li></ul><h3 id="ps">ps</h3><p>格式： <code>docker-compose ps [options] [SERVICE...]</code></p><blockquote><p>列出项目中目前的所有容器。</p></blockquote><p>选项：</p><ul><li><code>-q</code> 只打印容器的 ID 信息</li></ul><h3 id="pull">pull</h3><p>格式： <code>docker-compose pull [options] [SERVICE...]</code></p><blockquote><p>拉取服务依赖的镜像</p></blockquote><p>选项：</p><ul><li><code>--ignore-pull-failures</code> 忽略拉取镜像过程中的错误</li></ul><h3 id="push">push</h3><blockquote><p>推送服务依赖的镜像到 Docker 镜像仓库</p></blockquote><h3 id="restart">restart</h3><p>格式：<code>docker-compose restart [options] [SERVICE...]</code></p><blockquote><p>重启项目中的服务</p></blockquote><p>选项：</p><ul><li><code>-t, --timeout TIMEOUT</code> 指定重启前停止容器的超时（默认10 秒）</li></ul><h3 id="rm">rm</h3><p>格式：<code>docker-compose rm [options] [SERVICE...]</code></p><blockquote><p>删除所有（停止状态的）服务容器。推荐先执行 <code>docker-compose stop</code> 命令来停止容器</p></blockquote><p>选项：</p><ul><li><code>-f, --force</code> 强制直接删除，包括非停止状态的容器。一般尽量不要使用该选项</li><li><code>-v</code> 删除容器所挂载的数据卷</li></ul><h3 id="run">run</h3><p>格式： <code>docker-compose run [options] [-p PORT...] [-e KEY=VAL...] SERVICE [COMMAND] [ARGS...]</code></p><blockquote><p>在指定服务上执行一个命令</p></blockquote><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose run ubuntu ping docker.com</span><br></pre></td></tr></table></figure><p>这将会启动一个 ubuntu 服务容器，并执行 <code>ping docker.com</code> 命令。默认情况下，如果存在关联，则所有关联的服务将会自动被启动，除非这些服务已经在运行中。该命令类似启动容器后运行指定的命令，相关卷、链接等等都将会按照配置自动创建。</p><p>两个不同点：</p><ul><li>给定命令将会覆盖原有的自动运行命令</li><li>不会自动创建端口，以避免冲突</li></ul><p>如果不希望自动启动关联的容器，可以使用 <code>--no-deps</code> 选项，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose run --no-deps web python manage.py shell</span><br></pre></td></tr></table></figure><p>将不会启动 web 容器所关联的其它容器。</p><p>选项：</p><ul><li><code>-d</code> 后台运行容器</li><li><code>--name NAME</code> 为容器指定一个名字</li><li><code>--entrypoint CMD</code> 覆盖默认的容器启动指令</li><li><code>-e KEY=VAL</code> 设置环境变量值，可多次使用选项来设置多个环境变量</li><li><code>-u, --user=&quot;&quot;</code> 指定运行容器的用户名或者 uid</li><li><code>--no-deps</code> 不自动启动关联的服务容器</li><li><code>--rm</code> 运行命令后自动删除容器，<code>d</code> 模式下将忽略</li><li><code>-p, --publish=[]</code> 映射容器端口到本地主机</li><li><code>--service-ports</code> 配置服务端口并映射到本地主机</li><li><code>-T</code> 不分配伪 tty，意味着依赖 tty 的指令将无法运行</li></ul><h3 id="scale">scale</h3><p>格式： <code>docker-compose scale [options] [SERVICE=NUM...]</code></p><blockquote><p>设置指定服务运行的容器个数。</p></blockquote><p>通过 <code>service=num</code> 的参数来设置数量。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose scale web=3 db=2</span><br></pre></td></tr></table></figure><p>这将启动 3 个容器运行 web 服务，2 个容器运行 db 服务。</p><p>一般的，当指定数目多于该服务当前实际运行容器，将新创建并启动容器；反之，将停止容器。</p><p>选项：</p><ul><li><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）。</li></ul><h3 id="start">start</h3><p>格式： <code>docker-compose start [SERVICE...]</code></p><blockquote><p>启动已经存在的服务容器</p></blockquote><h3 id="stop">stop</h3><p>格式： <code>docker-compose stop [options] [SERVICE...]</code></p><blockquote><p>停止已经处于运行状态的容器，但不删除它。通过 <code>docker-compose start</code> 可以再次启动这些容器</p></blockquote><p>选项：</p><ul><li><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）。</li></ul><h3 id="top">top</h3><blockquote><p>查看各个服务容器内运行的进程</p></blockquote><h3 id="unpause">unpause</h3><p>格式： <code>docker-compose unpause [SERVICE...]</code></p><blockquote><p>恢复处于暂停状态中的服务</p></blockquote><h3 id="up">up</h3><p>格式： <code>docker-compose up [options] [SERVICE...]</code></p><blockquote><p>该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。链接的服务都将会被自动启动，除非已经处于运行状态。大部分时候都可以直接通过该命令来启动一个项目。默认情况，<code>docker-compose up</code> 启动的容器都在前台，控制台将会同时打印所有容器的输出信息，可以很方便进行调试。</p></blockquote><p>当通过 <code>Ctrl-C</code> 停止命令时，所有容器将会停止。</p><p>如果使用 <code>docker-compose up -d</code>，将会在后台启动并运行所有的容器。一般推荐生产环境下使用该选项。</p><p>默认情况，如果服务容器已经存在，<code>docker-compose up</code> 将会尝试停止容器，然后重新创建（保持使用 <code>volumes-from</code> 挂载的卷），以保证新启动的服务匹配 <code>docker-compose.yml</code> 文件的最新内容。如果不希望容器被停止并重新创建，可以使用 <code>docker-compose up --no-recreate</code>。这样将只会启动处于停止状态的容器，而忽略已经运行的服务。如果只想重新部署某个服务，可以使用 <code>docker-compose up --no-deps -d &lt;SERVICE_NAME&gt;</code> 来重新创建服务并后台停止旧服务，启动新服务，并不会影响到其所依赖的服务。<br>选项：</p><ul><li><code>-d</code> 在后台运行服务容器。</li><li><code>--no-color</code> 不使用颜色来区分不同的服务的控制台输出。</li><li><code>--no-deps</code> 不启动服务所链接的容器。</li><li><code>--force-recreate</code> 强制重新创建容器，不能与 <code>--no-recreate</code> 同时使用。</li><li><code>--no-recreate</code> 如果容器已经存在了，则不重新创建，不能与 <code>--force-recreate</code> 同时使用。</li><li><code>--no-build</code> 不自动构建缺失的服务镜像。</li><li><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）。</li></ul><h3 id="version">version</h3><p>格式： <code>docker-compose version</code></p><blockquote><p>打印版本信息</p></blockquote><h1 id="Compose-模板文件">Compose 模板文件</h1><p>模板文件是使用 <code>Compose</code> 的核心，涉及到的指令关键字也大部分指令跟 <code>docker run</code> 相关参数的含义都是类似的。默认的模板文件名称为 <code>docker-compose.yml</code>，格式为 YAML 格式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&quot;3&quot;</span></span><br><span class="line">services:</span><br><span class="line">  webapp:</span><br><span class="line">    image: examples/web</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">&quot;80:80&quot;</span></span><br><span class="line">    volumes:</span><br><span class="line">      - <span class="string">&quot;/data&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：每个服务都必须通过 <code>image</code> 指令指定镜像或 <code>build</code> 指令（需要 Dockerfile）等来自动构建生成镜像</p></blockquote><p>如果使用 <code>build</code> 指令，在 <code>Dockerfile</code> 中设置的选项(例如：<code>CMD</code>, <code>EXPOSE</code>, <code>VOLUME</code>, <code>ENV</code> 等) 将会自动被获取，无需在 <code>docker-compose.yml</code> 中再次设置。</p><h2 id="build-v2">build</h2><p>指定 <code>Dockerfile</code> 所在文件夹的路径（可以是绝对路径，或者相对 docker-compose.yml 文件的路径）。 <code>Compose</code> 将会利用它自动构建这个镜像，然后使用这个镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&#x27;3&#x27;</span></span><br><span class="line">services:</span><br><span class="line">  webapp:</span><br><span class="line">    build: ./dir</span><br></pre></td></tr></table></figure><p>也可以使用 <code>context</code> 指令指定 <code>Dockerfile</code> 所在文件夹的路径。使用 <code>dockerfile</code> 指令指定 <code>Dockerfile</code> 文件名。<br>使用 <code>arg</code> 指令指定构建镜像时的变量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&#x27;3&#x27;</span></span><br><span class="line">services:</span><br><span class="line">  webapp:</span><br><span class="line">    build:</span><br><span class="line">      context: ./dir</span><br><span class="line">      dockerfile: Dockerfile-alternate</span><br><span class="line">      args:</span><br><span class="line">        buildno: 1</span><br></pre></td></tr></table></figure><p>使用 <code>cache_from</code> 指定构建镜像的缓存</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">build:</span><br><span class="line">  context: .</span><br><span class="line">  cache_from:</span><br><span class="line">    - alpine:latest</span><br><span class="line">    - corp/web_app:3.14</span><br></pre></td></tr></table></figure><h2 id="cap-add-cap-drop">cap_add, cap_drop</h2><p>指定容器的内核能力（capacity）分配。<br>例如，让容器拥有所有能力：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cap_add:</span><br><span class="line">  - ALL</span><br></pre></td></tr></table></figure><p>去掉 <code>NET_ADMIN</code>  能力：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cap_drop:</span><br><span class="line">  - NET_ADMIN</span><br></pre></td></tr></table></figure><h2 id="command">command</h2><p>覆盖容器启动后默认执行的命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span>: <span class="built_in">echo</span> <span class="string">&quot;hello world&quot;</span></span><br></pre></td></tr></table></figure><h2 id="cgroup-parent">cgroup_parent</h2><p>指定父 <code>cgroup</code> 组，意味着将继承该组的资源限制。<br>例如，创建了一个 cgroup 组名称为 <code>cgroups_1</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cgroup_parent: cgroups_1</span><br></pre></td></tr></table></figure><h2 id="container-name">container_name</h2><p>指定容器名称。默认将会使用 <code>项目名称_服务名称_序号</code> 这样的格式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">container_name: docker-web-container</span><br></pre></td></tr></table></figure><blockquote><p>注意: 指定容器名称后，该服务将无法进行扩展（scale），因为 Docker 不允许多个容器具有相同的名称</p></blockquote><h2 id="devices">devices</h2><p>指定设备映射关系。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">devices:</span><br><span class="line">  - <span class="string">&quot;/dev/ttyUSB1:/dev/ttyUSB0&quot;</span></span><br></pre></td></tr></table></figure><h2 id="depends-on">depends_on</h2><p>解决容器的依赖、启动先后的问题。以下例子中会先启动 <code>redis</code> <code>db</code> 再启动 <code>web。</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&#x27;3&#x27;</span></span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br><span class="line">      - redis</span><br><span class="line">  redis:</span><br><span class="line">    image: redis</span><br><span class="line">  db:</span><br><span class="line">    image: postgres</span><br></pre></td></tr></table></figure><blockquote><p>注意：<code>web</code> 服务不会等待 <code>redis</code> <code>db</code> 「完全启动」之后才启动</p></blockquote><h2 id="dns">dns</h2><p>自定义 <code>DNS</code> 服务器。可以是一个值，也可以是一个列表。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dns: 8.8.8.8</span><br><span class="line">dns:</span><br><span class="line">  - 8.8.8.8</span><br><span class="line">  - 114.114.114.114</span><br></pre></td></tr></table></figure><h2 id="dns-search">dns_search</h2><p>配置 <code>DNS</code> 搜索域。可以是一个值，也可以是一个列表。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dns_search: example.com</span><br><span class="line">dns_search:</span><br><span class="line">  - domain1.example.com</span><br><span class="line">  - domain2.example.com</span><br></pre></td></tr></table></figure><h2 id="tmpfs">tmpfs</h2><p>挂载一个 tmpfs 文件系统到容器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tmpfs: /run</span><br><span class="line">tmpfs:</span><br><span class="line">  - /run</span><br><span class="line">  - /tmp</span><br></pre></td></tr></table></figure><h2 id="env-file">env_file</h2><p>从文件中获取环境变量，可以为单独的文件路径或列表。如果通过 <code>docker-compose -f FILE</code> 方式来指定 Compose 模板文件，则 <code>env_file</code> 中变量的路径会基于模板文件路径。如果有变量名称与 <code>environment</code> 指令冲突，则按照惯例，以后者为准。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">env_file: .env</span><br><span class="line">env_file:</span><br><span class="line">  - ./common.env</span><br><span class="line">  - ./apps/web.env</span><br><span class="line">  - /opt/secrets.env</span><br></pre></td></tr></table></figure><p>环境变量文件中每一行必须符合格式，支持 <code>#</code> 开头的注释行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># common.env: Set development environment</span></span><br><span class="line">PROG_ENV=development</span><br></pre></td></tr></table></figure><h2 id="environment">environment</h2><p>设置环境变量。可以使用数组或字典两种格式。只给定名称的变量会自动获取运行 Compose 主机上对应变量的值，可以用来防止泄露不必要的数据。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">environment:</span><br><span class="line">  RACK_ENV: development</span><br><span class="line">  SESSION_SECRET:</span><br><span class="line">environment:</span><br><span class="line">  - RACK_ENV=development</span><br><span class="line">  - SESSION_SECRET</span><br></pre></td></tr></table></figure><p>如果变量名称或者值中用到 <code>true|false，yes|no</code> 等表达 <a href="http://yaml.org/type/bool.html">布尔</a> 含义的词汇，最好放到引号里，避免 YAML 自动解析某些内容为对应的布尔语义。这些特定词汇，包括</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y|Y|yes|Yes|YES|n|N|no|No|NO|<span class="literal">true</span>|True|TRUE|<span class="literal">false</span>|False|FALSE|on|On|ON|off|Off|OFF</span><br></pre></td></tr></table></figure><h2 id="expose">expose</h2><p>暴露端口，但不映射到宿主机，只被连接的服务访问。仅可以指定内部端口为参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">expose:</span><br><span class="line">  - <span class="string">&quot;3000&quot;</span></span><br><span class="line">  - <span class="string">&quot;8000&quot;</span></span><br></pre></td></tr></table></figure><h2 id="external-links">external_links</h2><p>链接到 <code>docker-compose.yml</code> 外部的容器，甚至并非 <code>Compose</code> 管理的外部容器。</p><blockquote><p>注意：不建议使用该指令</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">external_links:</span><br><span class="line"> - redis_1</span><br><span class="line"> - project_db_1:mysql</span><br><span class="line"> - project_db_1:postgresql</span><br></pre></td></tr></table></figure><h2 id="extra-hosts">extra_hosts</h2><p>类似 Docker 中的 <code>--add-host</code> 参数，指定额外的 host 名称映射信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">extra_hosts:</span><br><span class="line"> - <span class="string">&quot;googledns:8.8.8.8&quot;</span></span><br><span class="line"> - <span class="string">&quot;dockerhub:52.1.157.61&quot;</span></span><br></pre></td></tr></table></figure><p>会在启动后的服务容器中 <code>/etc/hosts</code> 文件中添加如下两条条目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8.8.8.8 googledns</span><br><span class="line">52.1.157.61 dockerhub</span><br></pre></td></tr></table></figure><h2 id="healthcheck">healthcheck</h2><p>通过命令检查容器是否健康运行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">healthcheck:</span><br><span class="line">  <span class="built_in">test</span>: [<span class="string">&quot;CMD&quot;</span>, <span class="string">&quot;curl&quot;</span>, <span class="string">&quot;-f&quot;</span>, <span class="string">&quot;http://localhost&quot;</span>]</span><br><span class="line">  interval: 1m30s</span><br><span class="line">  timeout: 10s</span><br><span class="line">  retries: 3</span><br></pre></td></tr></table></figure><h2 id="image">image</h2><p>指定为镜像名称或镜像 ID。如果镜像在本地不存在，<code>Compose</code> 将会尝试拉取这个镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">image: ubuntu</span><br><span class="line">image: orchardup/postgresql</span><br><span class="line">image: a4bc65fd</span><br></pre></td></tr></table></figure><h2 id="labels">labels</h2><p>为容器添加 Docker 元数据（metadata）信息。例如可以为容器添加辅助说明信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">labels:</span><br><span class="line">  com.startupteam.description: <span class="string">&quot;webapp for a startup team&quot;</span></span><br><span class="line">  com.startupteam.department: <span class="string">&quot;devops department&quot;</span></span><br><span class="line">  com.startupteam.release: <span class="string">&quot;rc3 for v1.0&quot;</span></span><br></pre></td></tr></table></figure><h2 id="links">links</h2><blockquote><p>注意：不推荐使用该指令</p></blockquote><h2 id="logging">logging</h2><p>配置日志选项。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">logging:</span><br><span class="line">  driver: syslog</span><br><span class="line">  options:</span><br><span class="line">    syslog-address: <span class="string">&quot;tcp://192.168.0.42:123&quot;</span></span><br></pre></td></tr></table></figure><p>目前支持三种日志驱动类型</p><ul><li><code>driver: &quot;json-file&quot;</code></li><li><code>driver: &quot;syslog&quot;</code></li><li><code>driver: &quot;none&quot;</code></li></ul><p><code>options</code> 配置日志驱动的相关参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">options:</span><br><span class="line">  max-size: <span class="string">&quot;200k&quot;</span></span><br><span class="line">  max-file: <span class="string">&quot;10&quot;</span></span><br></pre></td></tr></table></figure><h2 id="network-mode">network_mode</h2><p>设置网络模式。使用和 <code>docker run</code> 的 <code>--network</code> 参数一样的值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">network_mode: <span class="string">&quot;bridge&quot;</span></span><br><span class="line">network_mode: <span class="string">&quot;host&quot;</span></span><br><span class="line">network_mode: <span class="string">&quot;none&quot;</span></span><br><span class="line">network_mode: <span class="string">&quot;service:[service name]&quot;</span></span><br><span class="line">network_mode: <span class="string">&quot;container:[container name/id]&quot;</span></span><br></pre></td></tr></table></figure><h2 id="networks">networks</h2><p>配置容器连接的网络。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&quot;3&quot;</span></span><br><span class="line">services:</span><br><span class="line">  some-service:</span><br><span class="line">    networks:</span><br><span class="line">     - some-network</span><br><span class="line">     - other-network</span><br><span class="line">networks:</span><br><span class="line">  some-network:</span><br><span class="line">  other-network:</span><br></pre></td></tr></table></figure><h2 id="pid">pid</h2><p>跟主机系统共享进程命名空间。打开该选项的容器之间，以及容器和宿主机系统之间可以通过进程 ID 来相互访问和操作。<code>pid: &quot;host&quot;</code></p><h2 id="ports">ports</h2><p>暴露端口信息。使用宿主端口：容器端口 <code>(HOST:CONTAINER)</code> 格式，或者仅仅指定容器的端口（宿主将会随机选择端口）都可以。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ports:</span><br><span class="line"> - <span class="string">&quot;3000&quot;</span></span><br><span class="line"> - <span class="string">&quot;8000:8000&quot;</span></span><br><span class="line"> - <span class="string">&quot;49100:22&quot;</span></span><br><span class="line"> - <span class="string">&quot;127.0.0.1:8001:8001&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：当使用 <code>HOST:CONTAINER</code> 格式来映射端口时，如果使用的容器端口小于 60 并且没放到引号里，可能会得到错误结果，因为 <code>YAML</code> 会自动解析 <code>xx:yy</code> 这种数字格式为 60 进制。为避免出现这种问题，建议数字串都采用引号包括起来的字符串格式</p></blockquote><h2 id="secrets">secrets</h2><p>存储敏感数据，例如 <code>mysql</code> 服务密码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&quot;3.1&quot;</span></span><br><span class="line">services:</span><br><span class="line">mysql:</span><br><span class="line">  image: mysql</span><br><span class="line">  environment:</span><br><span class="line">    MYSQL_ROOT_PASSWORD_FILE: /run/secrets/db_root_password</span><br><span class="line">  secrets:</span><br><span class="line">    - db_root_password</span><br><span class="line">    - my_other_secret</span><br><span class="line">secrets:</span><br><span class="line">  my_secret:</span><br><span class="line">    file: ./my_secret.txt</span><br><span class="line">  my_other_secret:</span><br><span class="line">    external: <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="security-opt">security_opt</h2><p>指定容器模板标签（label）机制的默认属性（用户、角色、类型、级别等）。例如配置标签的用户名和角色名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">security_opt:</span><br><span class="line">    - label:user:USER</span><br><span class="line">    - label:role:ROLE</span><br></pre></td></tr></table></figure><h2 id="stop-signal">stop_signal</h2><p>设置另一个信号来停止容器。在默认情况下使用的是 SIGTERM 停止容器。<code>stop_signal: SIGUSR1</code></p><h2 id="sysctls">sysctls</h2><p>配置容器内核参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sysctls:</span><br><span class="line">  net.core.somaxconn: 1024</span><br><span class="line">  net.ipv4.tcp_syncookies: 0</span><br><span class="line">sysctls:</span><br><span class="line">  - net.core.somaxconn=1024</span><br><span class="line">  - net.ipv4.tcp_syncookies=0</span><br></pre></td></tr></table></figure><h2 id="ulimits">ulimits</h2><p>指定容器的 ulimits 限制值。例如，指定最大进程数为 65535，指定文件句柄数为 20000（软限制，应用可以随时修改，不能超过硬限制） 和 40000（系统硬限制，只能 root 用户提高）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ulimits:</span><br><span class="line">    nproc: 65535</span><br><span class="line">    nofile:</span><br><span class="line">      soft: 20000</span><br><span class="line">      hard: 40000</span><br></pre></td></tr></table></figure><h2 id="volumes">volumes</h2><p>数据卷所挂载路径设置。可以设置宿主机路径 （<code>HOST:CONTAINER</code>） 或加上访问模式 （<code>HOST:CONTAINER:ro</code>）。该指令中路径支持相对路径。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">volumes:</span><br><span class="line"> - /var/lib/mysql</span><br><span class="line"> - cache/:/tmp/cache</span><br><span class="line"> - ~/configs:/etc/configs/:ro</span><br></pre></td></tr></table></figure><h2 id="其它指令">其它指令</h2><p>此外，还有包括 <code>domainname, entrypoint, hostname, ipc, mac_address, privileged, read_only, shm_size, restart, stdin_open, tty, user, working_dir</code> 等指令，基本跟 <code>docker run</code> 中对应参数的功能一致。</p><p><strong>指定服务容器启动后执行的入口文件</strong></p><p><code>entrypoint: /code/entrypoint.sh</code></p><p><strong>指定容器中运行应用的用户名</strong><br><code>user: nginx</code></p><p><strong>指定容器中工作目录</strong><br><code>working_dir: /code</code></p><p><strong>指定容器中搜索域名、主机名、mac 地址等</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">domainname: your_website.com</span><br><span class="line">hostname: <span class="built_in">test</span></span><br><span class="line">mac_address: 08-00-27-00-0C-0A</span><br></pre></td></tr></table></figure><p><strong>允许容器中运行一些特权命令</strong><br><code>privileged: true</code></p><p><strong>指定容器退出后的重启策略为始终重启。该命令对保持服务始终运行十分有效，在生产环境中推荐配置为 <code>always</code> 或者 <code>unless-stopped</code></strong><br><code>restart: always</code></p><p><strong>以只读模式挂载容器的 root 文件系统，意味着不能对容器内容进行修改</strong><br><code>read_only: true</code></p><p><strong>打开标准输入，可以接受外部输入</strong><br><code>stdin_open: true</code></p><p><strong>模拟一个伪终端</strong><br><code>tty: true</code></p><h2 id="读取变量">读取变量</h2><p>Compose 模板文件支持动态读取主机的系统环境变量和当前目录下的 <code>.env</code> 文件中的变量。<br>例如，下面的 Compose 文件将从运行它的环境中读取变量 <code>$&#123;MONGO_VERSION&#125;</code> 的值，并写入执行的指令中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&quot;3&quot;</span></span><br><span class="line">services:</span><br><span class="line">db:</span><br><span class="line">  image: <span class="string">&quot;mongo:<span class="variable">$&#123;MONGO_VERSION&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><p>如果执行 <code>MONGO_VERSION=3.2 docker-compose up</code> 则会启动一个 <code>mongo:3.2</code> 镜像的容器；如果执行 <code>MONGO_VERSION=2.8 docker-compose up</code> 则会启动一个 <code>mongo:2.8</code> 镜像的容器。<br>若当前目录存在 <code>.env</code> 文件，执行 <code>docker-compose</code> 命令时将从该文件中读取变量。<br>在当前目录新建 <code>.env</code> 文件并写入以下内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 支持 # 号注释</span></span><br><span class="line">MONGO_VERSION=3.6</span><br></pre></td></tr></table></figure><p>执行 <code>docker-compose up</code> 则会启动一个 <code>mongo:3.6</code> 镜像的容器。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/docker/1.3Docker%E5%AE%B9%E5%99%A8/"/>
      <url>/docker/1.3Docker%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>容器是依赖于镜像生成，独立运行的一个或一组应用以及它们的运行环境。</p><h1 id="启动容器">启动容器</h1><p>启动容器有两种方式</p><ul><li>基于镜像新建容器并启动</li><li>将在终止状态（<code>stopped</code>）的容器重新启动</li></ul><h2 id="新建并启动容器">新建并启动容器</h2><p>比如下面的命令输出“hello world!”，之后终止容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang ~]# docker run ubuntu /bin/echo &#x27;hello world!&#x27;</span><br><span class="line">hello world!</span><br></pre></td></tr></table></figure><p>下面的命令则启动一个 bash 终端，允许用户进行交互：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang ~]# docker run -it ubuntu /bin/bash</span><br><span class="line">root@ef8fa7a1ffd6:/# </span><br></pre></td></tr></table></figure><ul><li><code>-t</code> 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上</li><li><code>-i</code> 让容器的标准输入保持打开</li></ul><p><code>-it</code> 是简写，在交互模式下可以通过所创建的终端来输入命令，比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang ~]# docker run -it ubuntu /bin/bash</span><br><span class="line">root@ef8fa7a1ffd6:/# pwd</span><br><span class="line">/</span><br><span class="line">root@ef8fa7a1ffd6:/# ls</span><br><span class="line">bin  boot  dev  etc  home  lib  lib32  lib64  libx32  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line">root@ef8fa7a1ffd6:/# </span><br></pre></td></tr></table></figure><p>使用 <code>docker run</code> 创建容器时，Docker 在后台运行的标准操作包括：</p><ol><li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li><li>利用镜像创建并启动一个容器</li><li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li><li>从地址池配置一个 ip 地址给容器</li><li>执行用户指定的应用程序</li><li>执行完毕后容器被终止</li></ol><h2 id="启动已终止容器">启动已终止容器</h2><p>可以利用 <code>docker container start</code> 命令，直接将一个已经终止的容器启动运行。可以在伪终端中利用 <code>ps</code> 或 <code>top</code> 来查看进程信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@ef8fa7a1ffd6:/# ps</span><br><span class="line">   PID TTY          TIME CMD</span><br><span class="line">     1 pts/0    00:00:00 bash</span><br><span class="line">    12 pts/0    00:00:00 ps</span><br></pre></td></tr></table></figure><h1 id="后台运行">后台运行</h1><p>更多的时候，需要让 Docker 在后台运行而不是直接把执行命令的结果输出在当前宿主机下。可以通过添加 <code>-d</code> 参数来实现。</p><p>不使用 <code>-d</code> 参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang ~]# docker run ubuntu /bin/sh -c &#x27;while true;do echo hello docker; sleep 1;done&#x27;</span><br><span class="line">hello docker</span><br><span class="line">hello docker</span><br><span class="line">hello docker</span><br><span class="line">hello docker</span><br></pre></td></tr></table></figure><p>容器会把输出的结果 (STDOUT) 打印到宿主机上1s打印一次&quot;hello docker&quot;。</p><hr><p>使用 <code>-d</code> 参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang ~]# docker run -d ubuntu /bin/sh -c &#x27;while true;do echo hello docker; sleep 1;done&#x27;</span><br><span class="line">3c443074634c5edd6272c62fd08d8439ac2b5f3b9677233aae06deb2724c917c</span><br></pre></td></tr></table></figure><p>此时容器会在后台运行并不会把输出结果 (STDOUT) 打印到宿主机上。</p><hr><p>可以使用 <code>docker logs</code> 查看输出结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang ~]# docker logs 3c443074634c</span><br><span class="line">hello docker</span><br><span class="line">hello docker</span><br><span class="line">hello docker</span><br></pre></td></tr></table></figure><p>使用 <code>-d</code>  参数启动后会返回一个唯一的 id，也可以通过 <code>docker container ls</code>  命令来查看容器信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang ~]# docker container ls</span><br><span class="line">CONTAINER ID   IMAGE       COMMAND                  CREATED         STATUS         PORTS                               NAMES</span><br><span class="line">3c443074634c   ubuntu      &quot;/bin/sh -c &#x27;while t…&quot;   2 minutes ago   Up 2 minutes                                       affectionate_agnesi</span><br><span class="line">a1ea64a6c039   nginx:3.0   &quot;/docker-entrypoint.…&quot;   17 hours ago    Up 17 hours    0.0.0.0:82-&gt;80/tcp, :::82-&gt;80/tcp   webserver3</span><br></pre></td></tr></table></figure><p>要获取容器的输出信息，可以按上面说的使用 <code>docker container logs</code>  命令，格式 <code>docker container logs [container ID or NAMES]</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang ~]# docker container logs  3c443074634c</span><br><span class="line">hello docker</span><br><span class="line">hello docker</span><br><span class="line">hello docker</span><br></pre></td></tr></table></figure><h1 id="终止容器">终止容器</h1><p>使用 <code>docker container stop</code>  来终止一个运行中的容器，此外当 Docker 容器中指定的应用终结时，容器也自动终止。比如对于上面只启动了一个终端的容器，通过 <code>exit</code>  命令或 <code>ctrl+d</code>   退出终端时，创建的容器立刻终止。</p><p>终止状态的容器可以用 <code>docker container ls -a</code>  命令看到：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang ~]# docker container ls -a</span><br><span class="line">CONTAINER ID   IMAGE       COMMAND                  CREATED        STATUS                      PORTS                               NAMES</span><br><span class="line">a1ea64a6c039   nginx:3.0   &quot;/docker-entrypoint.…&quot;   18 hours ago   Up 18 hours                 0.0.0.0:82-&gt;80/tcp, :::82-&gt;80/tcp   webserver3</span><br><span class="line">bab7ffb6e2e9   nginx:2.0   &quot;/docker-entrypoint.…&quot;   3 days ago     Exited (255) 18 hours ago   0.0.0.0:81-&gt;80/tcp, :::81-&gt;80/tcp   webserver2</span><br><span class="line">470e01aed950   nginx   </span><br></pre></td></tr></table></figure><p>处于终止状态的容器，可以通过 <code>docker container start</code>  命令来重新启动：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang ~]# docker container start webserver</span><br><span class="line">webserver</span><br><span class="line">[root@wangpengliang ~]# docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE       COMMAND                  CREATED        STATUS                      PORTS                               NAMES</span><br><span class="line">a1ea64a6c039   nginx:3.0   &quot;/docker-entrypoint.…&quot;   18 hours ago   Up 18 hours                 0.0.0.0:82-&gt;80/tcp, :::82-&gt;80/tcp   webserver3</span><br><span class="line">bab7ffb6e2e9   nginx:2.0   &quot;/docker-entrypoint.…&quot;   3 days ago     Exited (255) 18 hours ago   0.0.0.0:81-&gt;80/tcp, :::81-&gt;80/tcp   webserver2</span><br><span class="line">470e01aed950   nginx       &quot;/docker-entrypoint.…&quot;   3 days ago     Up 5 seconds                0.0.0.0:80-&gt;80/tcp, :::80-&gt;80/tcp   webserver</span><br></pre></td></tr></table></figure><p><code>docker container restart </code> 命令会将一个运行状态的容器终止，然后再重新启动：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang ~]# docker container restart webserver</span><br><span class="line">webserver</span><br></pre></td></tr></table></figure><h1 id="进入容器">进入容器</h1><p>使用 <code>-d</code>  参数时，容器启动后会进入后台，某些时候需要进入容器进行操作，包括使用 <code>docker attach</code> 或 <code>docker exec</code>  命令，推荐使用 <code>docker exec</code> 。</p><h2 id="attach">attach</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang ~]# docker run -dit ubuntu</span><br><span class="line">21498e13f12425718093684e74f342e30e7b9665e57b9b919f0a718d888f7b50</span><br><span class="line">[root@wangpengliang ~]# docker container ls</span><br><span class="line">CONTAINER ID   IMAGE       COMMAND                  CREATED         STATUS         PORTS                               NAMES</span><br><span class="line">21498e13f124   ubuntu      &quot;/bin/bash&quot;              9 seconds ago   Up 8 seconds                                       elated_chatelet</span><br><span class="line">a1ea64a6c039   nginx:3.0   &quot;/docker-entrypoint.…&quot;   18 hours ago    Up 18 hours    0.0.0.0:82-&gt;80/tcp, :::82-&gt;80/tcp   webserver3</span><br><span class="line">470e01aed950   nginx       &quot;/docker-entrypoint.…&quot;   3 days ago      Up 2 minutes   0.0.0.0:80-&gt;80/tcp, :::80-&gt;80/tcp   webserver</span><br><span class="line">[root@wangpengliang ~]# docker attach 21498e13f124</span><br><span class="line">root@21498e13f124:/# ls</span><br><span class="line">bin  boot  dev  etc  home  lib  lib32  lib64  libx32  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line">root@21498e13f124:/# exit </span><br><span class="line">exit</span><br><span class="line">[root@wangpengliang ~]# docker container ls</span><br><span class="line">CONTAINER ID   IMAGE       COMMAND                  CREATED        STATUS         PORTS                               NAMES</span><br><span class="line">a1ea64a6c039   nginx:3.0   &quot;/docker-entrypoint.…&quot;   18 hours ago   Up 18 hours    0.0.0.0:82-&gt;80/tcp, :::82-&gt;80/tcp   webserver3</span><br><span class="line">470e01aed950   nginx       &quot;/docker-entrypoint.…&quot;   3 days ago     Up 2 minutes   0.0.0.0:80-&gt;80/tcp, :::80-&gt;80/tcp   webserver</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>注意：如果从这个 stdin 中 exit，会导致容器的停止</p></blockquote><h2 id="exec">exec</h2><p><code>docker exec</code>  后边可以跟多个参数，这里主要说明 <code>-i -t</code>  参数</p><ul><li>只用 <code>-i</code>  参数时由于没有分配伪终端，界面没有熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回</li><li>当 <code>-i -t</code>  参数一起使用时，则可以看到熟悉的 Linux 命令提示符</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang ~]# docker exec -it 2687f43c0e42 bash</span><br><span class="line">root@2687f43c0e42:/# ls</span><br><span class="line">bin  boot  dev  etc  home  lib  lib32  lib64  libx32  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br></pre></td></tr></table></figure><p>如果从这个 stdin 中 exit，不会导致容器的停止。这就是为什么推荐使用 <code>docker exec</code> 的原因，更多参数说明使用 <code>docker exec --help</code>  查看。</p><h1 id="导出容器">导出容器</h1><p>如果要导出本地某个容器，可以使用 <code>docker export</code>  命令，这将导出容器快照到本地文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang ~]# docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE       COMMAND                  CREATED        STATUS                      PORTS                               NAMES</span><br><span class="line">2687f43c0e42   ubuntu      &quot;/bin/bash&quot;              2 hours ago    Up 2 minutes                                                    romantic_greider</span><br><span class="line">a1ea64a6c039   nginx:3.0   &quot;/docker-entrypoint.…&quot;   20 hours ago   Up 20 hours                 0.0.0.0:82-&gt;80/tcp, :::82-&gt;80/tcp   webserver3</span><br><span class="line">bab7ffb6e2e9   nginx:2.0   &quot;/docker-entrypoint.…&quot;   3 days ago     Exited (255) 20 hours ago   0.0.0.0:81-&gt;80/tcp, :::81-&gt;80/tcp   webserver2</span><br><span class="line">470e01aed950   nginx       &quot;/docker-entrypoint.…&quot;   3 days ago     Up 2 hours                  0.0.0.0:80-&gt;80/tcp, :::80-&gt;80/tcp   webserver</span><br><span class="line">[root@wangpengliang ~]# docker export 2687f43c0e42 &gt; ubuntu.tar</span><br></pre></td></tr></table></figure><h1 id="导入容器">导入容器</h1><p>可以使用 <code>docker import</code>  从容器快照文件中再导入为镜像。比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang ~]# docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE       COMMAND                  CREATED        STATUS                      PORTS                               NAMES</span><br><span class="line">2687f43c0e42   ubuntu      &quot;/bin/bash&quot;              2 hours ago    Up 2 minutes                                                    romantic_greider</span><br><span class="line">a1ea64a6c039   nginx:3.0   &quot;/docker-entrypoint.…&quot;   20 hours ago   Up 20 hours                 0.0.0.0:82-&gt;80/tcp, :::82-&gt;80/tcp   webserver3</span><br><span class="line">bab7ffb6e2e9   nginx:2.0   &quot;/docker-entrypoint.…&quot;   3 days ago     Exited (255) 20 hours ago   0.0.0.0:81-&gt;80/tcp, :::81-&gt;80/tcp   webserver2</span><br><span class="line">470e01aed950   nginx       &quot;/docker-entrypoint.…&quot;   3 days ago     Up 2 hours                  0.0.0.0:80-&gt;80/tcp, :::80-&gt;80/tcp   webserver</span><br><span class="line">[root@wangpengliang ~]# docker export 2687f43c0e42 &gt;ubuntu.tar</span><br><span class="line">[root@wangpengliang ~]# cat ubuntu.tar|docker import - test/ubuntu:v1.0</span><br><span class="line">sha256:557b6b4bfca63802c6b89bb4c8f1800a2af7954fdff345bd94adba2c770ad4d4</span><br><span class="line">[root@wangpengliang ~]# docker image ls</span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">test/ubuntu   v1.0      557b6b4bfca6   9 seconds ago   72.7MB</span><br><span class="line">nginx         3.0       f89693105193   20 hours ago    133MB</span><br><span class="line">nginx         2.0       546ad28bcf61   3 days ago      133MB</span><br><span class="line">redis         6.2.4     fad0ee7e917a   5 days ago      105MB</span><br><span class="line">redis         latest    fad0ee7e917a   5 days ago      105MB</span><br><span class="line">nginx         latest    d1a364dc548d   13 days ago     133MB</span><br><span class="line">ubuntu        latest    7e0aa2d69a15   6 weeks ago     72.7MB</span><br><span class="line">hello-world   latest    d1165f221234   3 months ago    13.3kB</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此外，也可以通过指定 URL 或者某个目录来导入，比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker import http://example.com/exampleimage.tgz example/imagerepo</span><br></pre></td></tr></table></figure><blockquote><p>注意：用户既可以使用 <code>docker load</code>  来导入镜像存储文件到本地镜像库，也可以使用 <code>docker import</code> 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息</p></blockquote><h1 id="删除容器">删除容器</h1><p>可以使用 <code>docker container rm</code>  来删除一个处于终止状态的容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang ~]# docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE       COMMAND                  CREATED        STATUS                      PORTS                               NAMES</span><br><span class="line">2687f43c0e42   ubuntu      &quot;/bin/bash&quot;              2 hours ago    Up 6 minutes                                                    romantic_greider</span><br><span class="line">a1ea64a6c039   nginx:3.0   &quot;/docker-entrypoint.…&quot;   20 hours ago   Up 20 hours                 0.0.0.0:82-&gt;80/tcp, :::82-&gt;80/tcp   webserver3</span><br><span class="line">bab7ffb6e2e9   nginx:2.0   &quot;/docker-entrypoint.…&quot;   3 days ago     Exited (255) 20 hours ago   0.0.0.0:81-&gt;80/tcp, :::81-&gt;80/tcp   webserver2</span><br><span class="line">470e01aed950   nginx       &quot;/docker-entrypoint.…&quot;   3 days ago     Up 2 hours                  0.0.0.0:80-&gt;80/tcp, :::80-&gt;80/tcp   webserver</span><br><span class="line"></span><br><span class="line">[root@wangpengliang ~]# docker container rm bab7ffb6e2e9</span><br><span class="line">bab7ffb6e2e9</span><br><span class="line"></span><br><span class="line">[root@wangpengliang ~]# docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE       COMMAND                  CREATED        STATUS         PORTS                               NAMES</span><br><span class="line">2687f43c0e42   ubuntu      &quot;/bin/bash&quot;              2 hours ago    Up 7 minutes                                       romantic_greider</span><br><span class="line">a1ea64a6c039   nginx:3.0   &quot;/docker-entrypoint.…&quot;   20 hours ago   Up 20 hours    0.0.0.0:82-&gt;80/tcp, :::82-&gt;80/tcp   webserver3</span><br><span class="line">470e01aed950   nginx       &quot;/docker-entrypoint.…&quot;   3 days ago     Up 2 hours     0.0.0.0:80-&gt;80/tcp, :::80-&gt;80/tcp   webserver</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果要删除一个运行中的容器，可以添加 <code>-f</code>  参数。Docker 会发送 <code>SIGKILL</code>  信号给容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang ~]# docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE       COMMAND                  CREATED        STATUS         PORTS                               NAMES</span><br><span class="line">2687f43c0e42   ubuntu      &quot;/bin/bash&quot;              2 hours ago    Up 8 minutes                                       romantic_greider</span><br><span class="line">a1ea64a6c039   nginx:3.0   &quot;/docker-entrypoint.…&quot;   20 hours ago   Up 20 hours    0.0.0.0:82-&gt;80/tcp, :::82-&gt;80/tcp   webserver3</span><br><span class="line">470e01aed950   nginx       &quot;/docker-entrypoint.…&quot;   3 days ago     Up 2 hours     0.0.0.0:80-&gt;80/tcp, :::80-&gt;80/tcp   webserver</span><br><span class="line"></span><br><span class="line">[root@wangpengliang ~]# docker container rm -f 2687f43c0e42</span><br><span class="line">2687f43c0e42</span><br><span class="line"></span><br><span class="line">[root@wangpengliang ~]# docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE       COMMAND                  CREATED        STATUS        PORTS                               NAMES</span><br><span class="line">a1ea64a6c039   nginx:3.0   &quot;/docker-entrypoint.…&quot;   20 hours ago   Up 20 hours   0.0.0.0:82-&gt;80/tcp, :::82-&gt;80/tcp   webserver3</span><br><span class="line">470e01aed950   nginx       &quot;/docker-entrypoint.…&quot;   3 days ago     Up 2 hours    0.0.0.0:80-&gt;80/tcp, :::80-&gt;80/tcp   webserver</span><br></pre></td></tr></table></figure><p>用 <code>docker container ls -a</code>  命令可以查看所有已经创建的包括终止状态的容器，如果数量太多一个个删除可能会很麻烦，用下面的命令可以清理掉所有处于终止状态的容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container prune</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/docker/1.5Docker%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86/"/>
      <url>/docker/1.5Docker%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>在容器中管理数据主要有两种方式：</p><ul><li>数据卷（ <code>Volumes</code> ）</li><li>挂载主机目录 ( <code>Bind Mounts</code> )</li></ul><p>关于使用：<code>-v</code> or <code>--mount</code>，新手推荐选择 <code>--mount</code> 参数，经验丰富的自由发挥。</p><span id="more"></span><h1 id="容器数据卷">容器数据卷</h1><p>数据卷（<code>Volumes</code>）是一个可供一个或多个容器使用的特殊目录它可以绕过 UFS，可以提供很多有用的特性：</p><ul><li>数据卷可以在容器之间共享和重用</li><li>对数据卷的修改会立马生效</li><li>对数据卷的更新不会影响镜像</li><li>数据卷默认会一直存在，即使容器被删除</li></ul><p>数据卷的使用，类似 Linux 下对目录或文件进行 mount，镜像中被指定为挂载点的目录中的文件会复制到数据卷中（仅数据卷为空时会复制）</p><p><strong>创建数据卷</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang ~]# docker volume create myredis</span><br><span class="line">myredis</span><br></pre></td></tr></table></figure><p><strong>查看所有数据卷</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang ~]# docker volume ls</span><br><span class="line">DRIVER    VOLUME NAME</span><br><span class="line">local     myredis</span><br></pre></td></tr></table></figure><p><strong>查看指定数据卷</strong>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">root@wangpengliang ~</span>]<span class="meta"># docker volume inspect myredis</span></span><br><span class="line">[<span class="meta"></span></span><br><span class="line"><span class="meta">    &#123;</span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;CreatedAt&quot;</span>: <span class="meta-string">&quot;2021-05-26T13:35:05+08:00&quot;</span>,</span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;Driver&quot;</span>: <span class="meta-string">&quot;local&quot;</span>,</span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;Labels&quot;</span>: &#123;&#125;,</span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;Mountpoint&quot;</span>: <span class="meta-string">&quot;/var/lib/docker/volumes/myredis/_data&quot;</span>,</span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;Name&quot;</span>: <span class="meta-string">&quot;myredis&quot;</span>,</span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;Options&quot;</span>: &#123;&#125;,</span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;Scope&quot;</span>: <span class="meta-string">&quot;local&quot;</span></span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line"><span class="meta"></span>]</span><br></pre></td></tr></table></figure><p><strong>启动一个挂载数据卷的容器</strong>：</p><h1 id="HEAD使用docker-run-命令时，使用-mount-标记来将数据卷挂载到容器里。在一次docker-run中可以挂载多个数据卷。">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>使用<code>docker run</code> 命令时，使用 <code>--mount</code> 标记来将数据卷挂载到容器里。在一次<code>docker run</code>中可以挂载多个数据卷。</h1><p>使用 <code>docker run</code> 命令时，使用 <code>--mount</code> 标记来将数据卷挂载到容器里。在一次 <code>docker run </code>中可以挂载多个数据卷。</p><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>a155dac (init)</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name redis -v myredis:/data redis redis-server --appendonly yes  </span><br><span class="line"><span class="meta">#</span><span class="bash"> or</span></span><br><span class="line">docker run -d --name redis --mount source=myredis,target=/data  redis redis-server --appendonly yes</span><br></pre></td></tr></table></figure><p><strong>查看数据卷具体信息</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker inspect redis</span></span><br></pre></td></tr></table></figure><p>数据卷信息在 <code>Mounts</code> Key 下面</p><p><img src="/images/2021-09-09-14-08-05.png" alt=""></p><h1 id="HEAD删除数据卷：">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>删除数据卷：</h1><p><strong>删除数据卷：</strong></p><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>a155dac (init)</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker volume rm myredis</span></span><br></pre></td></tr></table></figure><p>数据卷是用来持久化数据的，它的生命周期独立于容器，Docker 不会在容器被删除后自动删除数据卷，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的数据卷。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 <code>docker rm -v</code> 命令。</p><p>无主的数据卷可能会占据很多空间，要清理使用以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker volume prune</span></span><br></pre></td></tr></table></figure><h1 id="挂载主机目录">挂载主机目录</h1><p>挂载主机目录指挂载一个主机目录作为数据卷（<code>Bind Mounts</code>）。</p><p>使用 <code>--mount</code>  标记可以指定挂载一个本地主机的目录到容器中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name redis -v /data/docker/redis/data:/data redis redis-server --appendonly yes  </span><br><span class="line"><span class="meta">#</span><span class="bash"> or</span></span><br><span class="line">docker run -d --name redis --mount type=bind,source=/data/docker/redis/data,target=/data redis redis-server --appendonly yes</span><br></pre></td></tr></table></figure><p>上面命令加载宿主机的<code>/data/docker/redis/data</code> 目录到容器的 <code>/data</code>目录。</p><blockquote><p>注意：本地目录路径必须是绝对路径，使用 <code>-v</code> 参数时如果本地目录不存在 Docker 会自动创建一个目录，使用<code>--mount</code>参数时如果本地目录不存在，Docker 会报错</p></blockquote><p>Docker 挂载主机目录的默认权限是读写，也可以通过增加 <code>readonly</code> 指定为只读：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name redis -v /data/docker/redis/data:/data:ro redis redis-server --appendonly yes  </span><br><span class="line"><span class="meta">#</span><span class="bash"> or</span></span><br><span class="line">docker run -d --name redis6 --mount type=bind,source=/data/docker/redis/data,target=/data,ro redis redis-server --appendonly yes</span><br></pre></td></tr></table></figure><h1 id="HEAD加了readonly之后，就挂载为只读了。如果在容器内-bin-目录新建文件，会显示如下错误">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>加了<code>readonly</code>之后，就挂载为只读了。如果在容器内 <code>/bin</code> 目录新建文件，会显示如下错误</h1><p>加了 <code>readonly </code>之后，就挂载为只读了。如果在容器内 <code>/bin</code> 目录新建文件，会显示如下错误：</p><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>a155dac (init)</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Read-only file system</span><br></pre></td></tr></table></figure><p><strong>简拼</strong></p><ul><li><code>ro</code> ：ReadOnly</li><li><code>rw</code> ：ReadAndWrite</li></ul><h1 id="挂载方式判定">挂载方式判定</h1><ul><li><code>-v 容器内路径</code>  匿名挂载</li><li><code>-v 卷名:容器内路径</code> 具名挂载</li><li><code>-v /宿主机路径:容器内路径</code>   指定路径挂载</li></ul><h2 id="指定路径挂载">指定路径挂载</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v [本地路径]:[容器内路径]</span><br><span class="line">docker run -d --name redis  -v /data/docker/redis/data:/data redis redis-server /etc/redis/redis.conf --appendonly yes   </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看容器详细信息</span></span><br><span class="line">docker inspect redis</span><br></pre></td></tr></table></figure><p><img src="/images/2021-09-09-14-10-07.png" alt=""></p><h2 id="匿名挂载">匿名挂载</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name redis -v /data  redis redis-server --appendonly yes   </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看容器详细信息</span></span><br><span class="line">docker inspect redis</span><br></pre></td></tr></table></figure><p><img src="/images/2021-09-09-14-11-22.png" alt=""></p><h2 id="具名挂载">具名挂载</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name redis -v redis:/data redis redis-server --appendonly yes</span><br></pre></td></tr></table></figure><blockquote><p>推荐使用具名挂载因为方便后期查找或其他操作</p></blockquote><h1 id="数据卷容器">数据卷容器</h1><p>定义一个容器（挂载了数据卷的），其他容器通过挂载这个容器(父容器)实现数据共享，挂载数据卷的容器，称为数据卷容器（ <code>--volumes-from</code>）。通过数据卷容器可以实现容器间的数据共享。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it/ -d  -p 主机端口:容器端口 --name=容器名称 --volumes-from 数据卷容器ID/数据卷容器名称 生成数据卷容器的镜像ID/镜像名称[:版本号]</span><br></pre></td></tr></table></figure><blockquote><p>注：这里数据共享的方式：<strong>是拷贝不是共享</strong>，这就意味着哪怕父数据卷容器被停止，子容器数据还是存在的<br>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</p></blockquote><p>=======</p><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>a155dac (init)</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/docker/1.4Docker%E4%BB%93%E5%BA%93/"/>
      <url>/docker/1.4Docker%E4%BB%93%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>仓库是集中存放镜像的地方。注册服务器是管理仓库的具体服务器，每个服务器上可以有多个仓库，每个仓库下面有多个镜像。</p><h1 id="Docker-Hub">Docker Hub</h1><p>Docker 官方维护了一个公共仓库 Docker Hub，其中已经包括了数量超过 15,000 的镜像。大部分需求都可以通过在 Docker Hub 中直接下载镜像来实现。</p><h2 id="注册">注册</h2><p>在 <a href="https://hub.docker.com">Docker Hub</a> 免费注册一个 Docker 账号。</p><p><img src="/images/2021-09-09-13-57-25.png" alt=""></p><h2 id="登录">登录</h2><p>通过执行 <code>docker login</code>  命令交互式的输入用户名及密码来完成在命令行界面登录 Docker Hub，通过 <code>docker logout</code>  退出登录。</p><h2 id="拉取镜像">拉取镜像</h2><p>通过 <code>docker search</code> 命令查找官方仓库中的镜像，并利用 <code>docker pull</code>  命令来下载到本地，以 <code>centos</code>  为关键词为例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang ~]# docker search centos</span><br><span class="line">NAME                               DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">centos                             The official build of CentOS.                   6582      [OK]       </span><br><span class="line">ansible/centos7-ansible            Ansible on Centos7                              134                  [OK]</span><br><span class="line">consol/centos-xfce-vnc             Centos container with &quot;headless&quot; VNC session…   129                  [OK]</span><br><span class="line">jdeathe/centos-ssh                 OpenSSH / Supervisor / EPEL/IUS/SCL Repos - …   118                  [OK]</span><br><span class="line">centos/systemd                     systemd enabled base container.                 99                   [OK]</span><br><span class="line">imagine10255/centos6-lnmp-php56    centos6-lnmp-php56                              58                   [OK]</span><br><span class="line">tutum/centos                       Simple CentOS docker image with SSH access      48                   </span><br><span class="line">kinogmt/centos-ssh                 CentOS with SSH                                 29                   [OK]</span><br><span class="line">pivotaldata/centos-gpdb-dev        CentOS image for GPDB development. Tag names…   13                   </span><br><span class="line">guyton/centos6                     From official centos6 container with full up…   10                   [OK]</span><br><span class="line">centos/tools                       Docker image that has systems administration…   7                    [OK]</span><br><span class="line">drecom/centos-ruby                 centos ruby                                     6                    [OK]</span><br><span class="line">pivotaldata/centos                 Base centos, freshened up a little with a Do…   5                    </span><br><span class="line">mamohr/centos-java                 Oracle Java 8 Docker image based on Centos 7    3                    [OK]</span><br><span class="line">pivotaldata/centos-gcc-toolchain   CentOS with a toolchain, but unaffiliated wi…   3                    </span><br><span class="line">darksheer/centos                   Base Centos Image -- Updated hourly             3                    [OK]</span><br><span class="line">pivotaldata/centos-mingw           Using the mingw toolchain to cross-compile t…   3                    </span><br><span class="line">dokken/centos-7                    CentOS 7 image for kitchen-dokken               2                    </span><br><span class="line">indigo/centos-maven                Vanilla CentOS 7 with Oracle Java Developmen…   2                    [OK]</span><br><span class="line">amd64/centos                       The official build of CentOS.                   2                    </span><br><span class="line">pivotaldata/centos6.8-dev          CentosOS 6.8 image for GPDB development         1                    </span><br><span class="line">mcnaughton/centos-base             centos base image                               1                    [OK]</span><br><span class="line">blacklabelops/centos               CentOS Base Image! Built and Updates Daily!     1                    [OK]</span><br><span class="line">pivotaldata/centos7-dev            CentosOS 7 image for GPDB development           0                    </span><br><span class="line">smartentry/centos                  centos with smartentry                          0                    [OK]</span><br></pre></td></tr></table></figure><p>看到返回了很多包含关键字的镜像，其中包括镜像名字、描述、收藏数（表示该镜像的受关注程度）、是否官方创建（OFFICIAL）、是否自动构建。</p><p>根据是否是官方提供，可将镜像分为两类：</p><ul><li>类似 <code>centos</code>  这样的镜像，被称为基础镜像或根镜像。这些基础镜像由 Docker 公司创建、验证、支持、提供。这样的镜像往往使用单个单词作为名字。</li><li>还有一种类型，比如 <code>tianon/centos</code>  镜像，它是由 Docker Hub 的注册用户创建并维护的，往往带有用户名称前缀。可以通过前缀 <code>username/</code> 来指定使用某个用户提供的镜像，比如 tianon 用户</li></ul><blockquote><p>在查找的时候通过 <code>--filter=stars=N</code> 参数可以指定仅显示收藏数量为 N 以上的镜像</p></blockquote><h2 id="下载镜像">下载镜像</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang ~]# docker pull centos</span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/centos</span><br><span class="line">7a0437f04f83: Pull complete </span><br><span class="line">Digest: sha256:5528e8b1b1719d34604c87e11dcd1c0a20bedf46e83b5632cdeac91b8c04efc1</span><br><span class="line">Status: Downloaded newer image for centos:latest</span><br><span class="line">docker.io/library/centos:latest</span><br></pre></td></tr></table></figure><h2 id="推送镜像">推送镜像</h2><p>可以在登录后通过 <code>docker push</code>  命令来将自己的镜像推送到 <code>Docker Hub</code></p><blockquote><p>以下命令中的 username 替换为你的 Docker 账号用户名</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang ~]# docker image ls</span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED        SIZE</span><br><span class="line">nginx         2.0       546ad28bcf61   3 days ago     133MB</span><br><span class="line">redis         6.2.4     fad0ee7e917a   6 days ago     105MB</span><br><span class="line">redis         latest    fad0ee7e917a   6 days ago     105MB</span><br><span class="line">ubuntu        latest    7e0aa2d69a15   6 weeks ago    72.7MB</span><br><span class="line">hello-world   latest    d1165f221234   3 months ago   13.3kB</span><br><span class="line">centos        latest    300e315adb2f   6 months ago   209MB</span><br><span class="line"></span><br><span class="line">[root@wangpengliang ~]# docker login</span><br><span class="line">Login with your Docker ID to push and pull images from Docker Hub. If you dont have a Docker ID, head over to https://hub.docker.com to create one</span><br><span class="line">Username: wangpengliang</span><br><span class="line">Password: </span><br><span class="line">WARNING! Your password will be stored unencrypted in /root/.docker/config.json.</span><br><span class="line">Configure a credential helper to remove this warning. See</span><br><span class="line">https://docs.docker.com/engine/reference/commandline/login/#credentials-store</span><br><span class="line">Login Succeeded</span><br><span class="line"></span><br><span class="line">[root@wangpengliang ~]# docker tag nginx:2.0 wangpengliang/nginx:mytest</span><br><span class="line"></span><br><span class="line">[root@wangpengliang ~]# docker image ls</span><br><span class="line">REPOSITORY            TAG       IMAGE ID       CREATED        SIZE</span><br><span class="line">nginx                 2.0       546ad28bcf61   3 days ago     133MB</span><br><span class="line">wangpengliang/nginx   mytest    546ad28bcf61   3 days ago     133MB</span><br><span class="line">redis                 6.2.4     fad0ee7e917a   6 days ago     105MB</span><br><span class="line">redis                 latest    fad0ee7e917a   6 days ago     105MB</span><br><span class="line">ubuntu                latest    7e0aa2d69a15   6 weeks ago    72.7MB</span><br><span class="line">hello-world           latest    d1165f221234   3 months ago   13.3kB</span><br><span class="line">centos                latest    300e315adb2f   6 months ago   209MB</span><br><span class="line"></span><br><span class="line">[root@wangpengliang ~]# docker push wangpengliang/nginx:mytest </span><br><span class="line">The push refers to repository [docker.io/wangpengliang/nginx]</span><br><span class="line">8be9905423d3: Pushed </span><br><span class="line">075508cf8f04: Mounted from library/nginx </span><br><span class="line">5c865c78bc96: Mounted from library/nginx </span><br><span class="line">134e19b2fac5: Mounted from library/nginx </span><br><span class="line">83634f76e732: Mounted from library/nginx </span><br><span class="line">766fe2c3fc08: Mounted from library/nginx </span><br><span class="line">02c055ef67f5: Mounted from library/nginx </span><br><span class="line">mytest: digest: sha256:05cb206e7659009b6cfe41d4891078aecf1656e527c5a075af609b9cfcad74df size: 1778</span><br></pre></td></tr></table></figure><p><img src="/images/2021-09-09-13-58-30.png" alt=""></p><h2 id="自动构建">自动构建</h2><p>有时候构建了镜像，安装了某个软件，当软件发布新版本则需要手动更新镜像。而自动构建允许通过 Docker Hub 指定跟踪一个目标网站（支持 GitHub 或 BitBucket）上的项目，一旦项目发生新的提交 （commit）或者创建了新的标签（tag），Docker Hub 会自动构建镜像并推送到 Docker Hub 中。自动构建（Automated Builds）功能对于需要经常升级镜像内程序来说十分方便。</p><p>要配置自动构建，包括如下步骤</p><ol><li>登录 Docker Hub</li><li>在 Docker Hub 点击右上角头像，在账号设置（Account Settings）中关联（Linked Accounts）目标网站</li><li>在 Docker Hub 中新建或选择已有的仓库，在 Builds 选项卡中选择 Configure Automated Builds</li><li>选取一个目标网站中的项目（需要含 Dockerfile）和分支</li><li>指定 Dockerfile 的位置并保存之后，可以在 Docker Hub 的仓库页面的 Timeline 选项卡中查看每次构建的状态</li></ol><h1 id="私有仓库">私有仓库</h1><p>创建Docker私有仓库的目的在于私密性，适用于团体内部，如公司部门，企业内部等需要在团体成员中共享Docker相关资源的场景。<a href="https://docs.docker.com/registry/">docker-registry</a> 是官方提供的工具，可以用于构建私有的镜像仓库。</p><h2 id="下载镜像-v2">下载镜像</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-01 ~]# docker pull registry</span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/registry</span><br><span class="line">ddad3d7c1e96: Pull complete </span><br><span class="line">6eda6749503f: Pull complete </span><br><span class="line">363ab70c2143: Pull complete </span><br><span class="line">5b94580856e6: Pull complete </span><br><span class="line">12008541203a: Pull complete </span><br><span class="line">Digest: sha256:bac2d7050dc4826516650267fe7dc6627e9e11ad653daca0641437abdf18df27</span><br><span class="line">Status: Downloaded newer image for registry:latest</span><br><span class="line">docker.io/library/registry:latest</span><br></pre></td></tr></table></figure><h2 id="启动容器并开放端口">启动容器并开放端口</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-01 ~]# docker run -d -p 5000:5000 --restart=always --name registry registry</span><br><span class="line">63411fb8a1475200da83a72aed4c584d329f2d02a6d473a09a00be06cce189a2</span><br></pre></td></tr></table></figure><p>这里使用官方的 <code>registry</code> 镜像来启动私有仓库。默认情况下，仓库会被创建在容器的 <code>/var/lib/registry</code> 目录下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-01 ~]# docker run -d -p 5000:5000 --restart=always --name registry registry</span><br><span class="line">63411fb8a1475200da83a72aed4c584d329f2d02a6d473a09a00be06cce189a2</span><br><span class="line">[root@centos-01 ~]# ls</span><br><span class="line">anaconda-ks.cfg</span><br><span class="line">[root@centos-01 ~]# cd /</span><br><span class="line">[root@centos-01 /]# ls</span><br><span class="line">bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line">[root@centos-01 /]# docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE      COMMAND                  CREATED              STATUS              PORTS                                       NAMES</span><br><span class="line">63411fb8a147   registry   &quot;/entrypoint.sh /etc…&quot;   About a minute ago   Up About a minute   0.0.0.0:5000-&gt;5000/tcp, :::5000-&gt;5000/tcp   registry</span><br><span class="line"></span><br><span class="line">[root@centos-01 /]# docker exec -it 63411fb8a147 /bin/sh</span><br><span class="line">/ # ls</span><br><span class="line">bin            entrypoint.sh  home           media          opt            root           sbin           sys            usr</span><br><span class="line">dev            etc            lib            mnt            proc           run            srv            tmp            var</span><br><span class="line">/ # cd /var/lib/registry/</span><br><span class="line">/var/lib/registry # ls</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以通过 <code>-v</code> 参数将镜像文件存储在本地的指定路径。例如下面的例子将上传的镜像放到本地的 <code>/opt/data/registry</code> 目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run -d \</span></span><br><span class="line"><span class="bash">    -p 5000:5000 \</span></span><br><span class="line"><span class="bash">    -v /opt/data/registry:/var/lib/registry \</span></span><br><span class="line"><span class="bash">    registry</span></span><br></pre></td></tr></table></figure><h2 id="上传-搜索-下载镜像">上传/搜索/下载镜像</h2><p>创建好私有仓库后，就可以使用 <code>docker tag</code> 来标记一个镜像，然后推送到仓库。这里私有仓库地址为 <code>192.168.31.32:5000</code> ，查看本机已有镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-01 /]# docker image ls</span><br><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED       SIZE</span><br><span class="line">nginx        latest    d1a364dc548d   2 weeks ago   133MB</span><br><span class="line">registry     latest    1fd8e1b0bb7e   8 weeks ago   26.2MB</span><br></pre></td></tr></table></figure><p>使用 <code>docker tag </code>将 <code>nginx:latest</code> 这个镜像标记为 <code>192.168.31.32:5000/nginx:latest</code>，格式为 :</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag IMAGE[:TAG] [REGISTRY_HOST[:REGISTRY_PORT]/]REPOSITORY[:TAG]</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-01 /]# docker tag nginx:latest 192.168.31.32:5000/nginx:latest</span><br><span class="line"></span><br><span class="line">[root@centos-01 /]# docker image ls</span><br><span class="line">REPOSITORY                 TAG       IMAGE ID       CREATED       SIZE</span><br><span class="line">192.168.31.32:5000/nginx   latest    d1a364dc548d   2 weeks ago   133MB</span><br><span class="line">nginx                      latest    d1a364dc548d   2 weeks ago   133MB</span><br><span class="line">registry                   latest    1fd8e1b0bb7e   8 weeks ago   26.2MB</span><br></pre></td></tr></table></figure><p>使用 <code>docker push</code> 上传标记的镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-01 /]# docker push 192.168.31.32:5000/nginx</span><br><span class="line">Using default tag: latest</span><br><span class="line">The push refers to repository [192.168.31.32:5000/nginx]</span><br><span class="line">Get https://192.168.31.32:5000/v2/: http: server gave HTTP response to HTTPS client</span><br></pre></td></tr></table></figure><p>这里发现无法成功推送镜像，原因是因为：Docker 默认不允许以非 <code>HTTPS</code> 方式推送镜像。可以通过 Docker 的配置选项来取消这个限制。对于使用 <code>systemd</code> 的系统，请在 <code>/etc/docker/daemon.json</code> 中写入如下内容（如果文件不存在需要手动创建该文件）</p><h2 id="daemon-json">daemon.json</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;registry-mirror&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;https://registry.docker-cn.com&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;insecure-registries&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;192.168.31.32:5000&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：该文件必须符合 <code>json</code> 规范，否则 Docker 将不能启动</p></blockquote><p>增加配置文件后，重启docker服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload </span><br><span class="line">service docker restart</span><br></pre></td></tr></table></figure><p>再次测试 <code>docker push</code> :</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-01 docker]<span class="comment"># docker push 192.168.31.32:5000/nginx</span></span><br><span class="line">Using default tag: latest</span><br><span class="line">The push refers to repository [192.168.31.32:5000/nginx]</span><br><span class="line">075508cf8f04: Pushed </span><br><span class="line">5c865c78bc96: Pushed </span><br><span class="line">134e19b2fac5: Pushed </span><br><span class="line">83634f76e732: Pushed </span><br><span class="line">766fe2c3fc08: Pushed </span><br><span class="line">02c055ef67f5: Pushed </span><br><span class="line">latest: digest: sha256:61191087790c31e43eb37caa10de1135b002f10c09fdda7fa8a5989db74033aa size: 1570</span><br></pre></td></tr></table></figure><p><code>curl</code>查看仓库中的镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-01 docker]<span class="comment"># curl 192.168.31.32:5000/v2/_catalog</span></span><br><span class="line">&#123;<span class="string">&quot;repositories&quot;</span>:[<span class="string">&quot;nginx&quot;</span>]&#125;</span><br></pre></td></tr></table></figure><p>看到 <code>&#123;&quot;repositories&quot;:[&quot;nginx&quot;]&#125;</code>，说明镜像成功上传。</p><p>下面演示先删除已有镜像，再尝试从私有仓库中下载这个镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-01 docker]<span class="comment"># docker image ls</span></span><br><span class="line">REPOSITORY                 TAG       IMAGE ID       CREATED       SIZE</span><br><span class="line">nginx                      latest    d1a364dc548d   2 weeks ago   133MB</span><br><span class="line">192.168.31.32:5000/nginx   latest    d1a364dc548d   2 weeks ago   133MB</span><br><span class="line">registry                   latest    1fd8e1b0bb7e   8 weeks ago   26.2MB</span><br><span class="line"></span><br><span class="line">[root@centos-01 docker]<span class="comment"># docker rmi nginx:latest</span></span><br><span class="line">Untagged: nginx:latest</span><br><span class="line">Untagged: nginx@sha256:6d75c99af15565a301e48297fa2d121e15d80ad526f8369c526324f0f7ccb750</span><br><span class="line"></span><br><span class="line">[root@centos-01 docker]<span class="comment"># docker image ls</span></span><br><span class="line">REPOSITORY                 TAG       IMAGE ID       CREATED       SIZE</span><br><span class="line">192.168.31.32:5000/nginx   latest    d1a364dc548d   2 weeks ago   133MB</span><br><span class="line">registry                   latest    1fd8e1b0bb7e   8 weeks ago   26.2MB</span><br><span class="line"></span><br><span class="line">[root@centos-01 docker]<span class="comment"># docker rmi 192.168.31.32:5000/nginx:latest </span></span><br><span class="line">Untagged: 192.168.31.32:5000/nginx:latest</span><br><span class="line">Untagged: 192.168.31.32:5000/nginx@sha256:61191087790c31e43eb37caa10de1135b002f10c09fdda7fa8a5989db74033aa</span><br><span class="line">Deleted: sha256:d1a364dc548d5357f0da3268c888e1971bbdb957ee3f028fe7194f1d61c6fdee</span><br><span class="line">Deleted: sha256:fcc8faba78fe8a1f75025781c8fa1841079b75b54fce8408d039f73a48b7a81b</span><br><span class="line">Deleted: sha256:a476b265974ace4c857e3d88b358e848f126297a8249840c72d5f5ea1954a4bf</span><br><span class="line">Deleted: sha256:56722ee1ee7e73a5c6f96ea2959fa442fb4db9f044399bcd939bb0a6eb7919dc</span><br><span class="line">Deleted: sha256:c657df997c75f6c1a9c5cc683e8e34c6f29e5b4c1dee60b632d3477fd5fdd644</span><br><span class="line">Deleted: sha256:e9e1f772d2a8dbbeb6a4a4dcb4f0d07ff1c432bf94fac7a2db2216837bf9ec5b</span><br><span class="line">Deleted: sha256:02c055ef67f5904019f43a41ea5f099996d8e7633749b6e606c400526b2c4b33</span><br><span class="line"></span><br><span class="line">[root@centos-01 docker]<span class="comment"># docker image ls</span></span><br><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED       SIZE</span><br><span class="line">registry     latest    1fd8e1b0bb7e   8 weeks ago   26.2MB</span><br><span class="line"></span><br><span class="line">[root@centos-01 docker]<span class="comment"># docker pull  192.168.31.32:5000/nginx:latest</span></span><br><span class="line">latest: Pulling from nginx</span><br><span class="line">69692152171a: Pull complete </span><br><span class="line">30afc0b18f67: Pull complete </span><br><span class="line">596b1d696923: Pull complete </span><br><span class="line">febe5bd23e98: Pull complete </span><br><span class="line">8283eee92e2f: Pull complete </span><br><span class="line">351ad75a6cfa: Pull complete </span><br><span class="line">Digest: sha256:61191087790c31e43eb37caa10de1135b002f10c09fdda7fa8a5989db74033aa</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> 192.168.31.32:5000/nginx:latest</span><br><span class="line">192.168.31.32:5000/nginx:latest</span><br><span class="line"></span><br><span class="line">[root@centos-01 docker]<span class="comment"># docker image ls</span></span><br><span class="line">REPOSITORY                 TAG       IMAGE ID       CREATED       SIZE</span><br><span class="line">192.168.31.32:5000/nginx   latest    d1a364dc548d   2 weeks ago   133MB</span><br><span class="line">registry                   latest    1fd8e1b0bb7e   8 weeks ago   26.2MB</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="私有仓库高级配置">私有仓库高级配置</h2><p>参考：<a href="https://www.bookstack.cn/read/docker_practice-v1.1.0/repository-registry_auth.md">https://www.bookstack.cn/read/docker_practice-v1.1.0/repository-registry_auth.md</a></p><h1 id="Nexus-3">Nexus 3</h1><p>参考：<a href="https://www.bookstack.cn/read/docker_practice-v1.1.0/repository-nexus3_registry.md">https://www.bookstack.cn/read/docker_practice-v1.1.0/repository-nexus3_registry.md</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/docker/1.6Docker%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F/"/>
      <url>/docker/1.6Docker%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>安装Docker时会自动创建三个网络。可以使用 <code>docker network ls</code> 命令列出网络：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-01 ~]<span class="comment"># docker network ls</span></span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">cdda3ae8795a   bridge    bridge    <span class="built_in">local</span></span><br><span class="line">ed7ffc7437dd   host      host      <span class="built_in">local</span></span><br><span class="line">fa66bc1a17f4   none      null      <span class="built_in">local</span></span><br></pre></td></tr></table></figure><span id="more"></span><h1 id="四种网络模式">四种网络模式</h1><p>在使用 <code>docker run</code> 创建容器时，可以用 <code>--network</code>  指定容器的网络模式，Docker有以下四种网络模式：</p><ul><li><code>--net=host</code> ：容器和宿主机共享 Network namespace</li><li><code>--net=none</code> ：容器有独立的 Network namespace，但并没有对其进行任何网络设置，如分配 <code> veth pair</code> 和网桥连接、配置IP等</li><li><code>--net=bridge</code>：默认设置</li><li><code>--net=container:name_Or_id </code> ：容器和另外一个容器共享 <code>Network namespace</code></li></ul><h2 id="Bridge">Bridge</h2><p>该模式是在启动docker服务后默认的网络模式，Docker 启动时，Docker使用Linux桥接（参考<a href="https://www.jianshu.com/p/f86d4b88777d">《Linux虚拟网络技术》</a>），在宿主机虚拟一个Docker容器网桥 <code>docker0</code>，Docker启动一个容器时会根据Docker网桥的网段分配给容器一个IP地址，称为 <code>Container-IP</code> ，同时Docker网桥是每个容器的默认网关。因为在同一宿主机内的容器都接入同一个网桥，这样容器之间就能够通过容器的 <code>Container-IP</code> 互相通信。</p><p>当创建一个 <code>Docker</code> 容器时，同时会创建一个 <code>veth pair</code>  接口（当数据包发送到一个接口时，另外一个接口也可以接收相同的数据包）。这对接口一端在容器内，即 <code>eth0</code> ；另一端在本地并被挂载到 <code>docker0</code>  网桥，名称以 <code>veth</code>  开头。通过这种方式主机可以跟容器通信，容器之间也可以相互通信。Docker就创建了在主机和所有容器之间的一个虚拟共享网络。</p><p>在安装和启动docker服务之后即可查看到这个 <code>docker0</code> 的虚拟网桥设备：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-01 ~]<span class="comment"># ip addr</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">       </span><br><span class="line">2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000</span><br><span class="line">    link/ether 00:0c:29:50:75:ae brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.126.143/24 brd 192.168.126.255 scope global noprefixroute ens33</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 2409:8900:2b86:13cc:a958:4c6e:c162:309d/64 scope global noprefixroute dynamic </span><br><span class="line">       valid_lft 3569sec preferred_lft 3569sec</span><br><span class="line">    inet6 fe80::1f3a:afc1:82f6:3f66/64 scope link noprefixroute </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">       </span><br><span class="line">3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default </span><br><span class="line">    link/ether 02:42:cb:f1:35:ea brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure><blockquote><p><code>docker0</code> 网桥是宿主机虚拟出来的，并不是真实存在的网络设备，外部网络是无法通过ip地址直接寻址的，需要通过其他方式来使外部网络可以访问容器，一般会通过 <strong>访问宿主机ip结合容器的端口（端口映射）进行容器的访问</strong></p></blockquote><p><img src="/images/2021-09-09-14-29-16.png" alt=""></p><p><strong>实现步骤</strong></p><ol><li><code>Docker Daemon</code> 利用 <code>veth pair</code>  技术，在宿主机上创建两个虚拟网络接口设备，假设为 <code>veth0</code>  和 <code>veth1</code> 。 <code>veth pair</code> 技术的特性可以保证无论哪一个 <code>veth</code>  接收到网络报文，都会将报文传输给另一方</li><li><code>Docker Daemon</code>  将 <code>veth0</code>  附加到 <code>Docker Daemon</code> 创建的 <code>docker0</code> 网桥上。保证宿主机的网络报文可以发往 <code>veth0</code></li><li><code>Docker Daemon</code>  将 <code>veth1</code>  添加到 <code>Docker Container</code> 所属的 <code>namespace</code>  下，并被改名为 <code>eth0</code> 。保证宿主机的网络报文若发往 <code>veth0</code> 则立即会被 <code>eth0</code> 接收，实现宿主机到<code>Docker Container</code>网络的联通，同时也保证容器单独使用 <code>eth0</code>，实现容器网络环境的隔离</li></ol><p><strong>缺陷</strong></p><ol><li>该模式下容器不具有公有IP ，就是说和宿主机的 <code>eth0</code> 不处于同一个网段。导致的结果是：在宿主机以外不能直接和容器进行通信</li><li>虽然经过中间处理（NAT模式） 可以解决公有IP的问题，但是NAT模式仍然存在问题与不便，比如：容器都需要在宿主机上竞争端口，容器内部服务的访问者需要使用服务发现获知服务的外部端口等</li><li>另外由于NAT模式是在三层网络上的实现手段，会影响网络传输效率</li></ol><p><strong>测试</strong></p><p>1)：查看本机网络</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-01 ~]<span class="comment"># ip addr</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">       </span><br><span class="line">2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000</span><br><span class="line">    link/ether 00:0c:29:50:75:ae brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.126.143/24 brd 192.168.126.255 scope global noprefixroute ens33</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 2409:8900:2b86:13cc:a958:4c6e:c162:309d/64 scope global noprefixroute dynamic </span><br><span class="line">       valid_lft 3569sec preferred_lft 3569sec</span><br><span class="line">    inet6 fe80::1f3a:afc1:82f6:3f66/64 scope link noprefixroute </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">       </span><br><span class="line">3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default </span><br><span class="line">    link/ether 02:42:cb:f1:35:ea brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure><p>2)：创建容器并查看IP</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-01 ~]<span class="comment"># docker run -d  --name nginx  nginx</span></span><br><span class="line">8afe1080ba992614f96b6868dbbcab463e37c98f8d3fa729245d48c2e6a1e3fe</span><br><span class="line"></span><br><span class="line">[root@centos-01 ~]<span class="comment"># docker ps -a</span></span><br><span class="line">CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS     NAMES</span><br><span class="line">8afe1080ba99   nginx     <span class="string">&quot;/docker-entrypoint.…&quot;</span>   3 seconds ago   Up 2 seconds   80/tcp    nginx</span><br><span class="line"></span><br><span class="line">[root@centos-01 ~]<span class="comment"># docker inspect nginx</span></span><br></pre></td></tr></table></figure><p><img src="/images/2021-09-09-14-34-08.png" alt=""></p><p>发现其ip为 <code>172.17.0.2</code> ,当容器桥接 <code>docker0</code> 后，会自动分配 <code>ip</code> 地址，之后的IP地址递增。</p><p>3)：查看网桥和端口连接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-01 ~]<span class="comment"># brctl show</span></span><br><span class="line">bridge namebridge idSTP enabledinterfaces</span><br><span class="line">docker08000.0242cbf135eanoveth3a98010</span><br></pre></td></tr></table></figure><p>一个新的网络接口  <code>veth3a98010</code>  被挂到了 <code>docker0</code> 上， <code>veth3a98010</code> 就是新创建容器的虚拟网卡。</p><p>4)：查看<code>veth pair</code> 配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-01 ~]<span class="comment"># ip addr</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">       </span><br><span class="line">2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000</span><br><span class="line">    link/ether 00:0c:29:50:75:ae brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.126.143/24 brd 192.168.126.255 scope global noprefixroute ens33</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 2409:8900:2b86:13cc:a958:4c6e:c162:309d/64 scope global noprefixroute dynamic </span><br><span class="line">       valid_lft 3520sec preferred_lft 3520sec</span><br><span class="line">    inet6 fe80::1f3a:afc1:82f6:3f66/64 scope link noprefixroute </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">       </span><br><span class="line">3: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default </span><br><span class="line">    link/ether 02:42:cb:f1:35:ea brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::42:cbff:fef1:35ea/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">       </span><br><span class="line">21: veth3a98010@if20: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP group default </span><br><span class="line">    link/ether 16:ea:7d:ca:a3:07 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet6 fe80::14ea:7dff:feca:a307/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">       </span><br><span class="line">[root@centos-01 ~]<span class="comment"># brctl show</span></span><br><span class="line">bridge namebridge idSTP enabledinterfaces</span><br><span class="line">docker08000.0242cbf135eanoveth3a98010</span><br><span class="line"></span><br><span class="line">[root@centos-01 ~]<span class="comment"># docker exec  -it nginx /bin/bash</span></span><br><span class="line">root@8afe1080ba99:/<span class="comment"># cat /sys/class/net/eth0/iflink </span></span><br><span class="line">21</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：<code>veth</code>  设备是成双成对出现的，一端在容器内部名为 <code>eth0</code>，一端加入到网桥名为 <code>vethxxx</code> （通常命名为veth），它们组成一个数据传输通道，一端进一端出，veth设备连接了两个网络设备并实现了数据通信；在bridge模式下，连在同一网桥上的容器可以相互通信。若出于安全考虑，也可以禁止它们之间通信，方法是在 <code>DOCKER_OPTS</code> 变量中设置 <code>–icc=false</code>，这样只有使用 <code>–link</code> 才能使两个容器通信。</p><h2 id="Host">Host</h2><p>如果启动容器时使用的是host模式，那么容器将不会获得一个独立的 <code>Network Namespace（网络命名空间）</code> ，而是和宿主机系统共用一个。这意味着：容器不会虚拟出自己的网卡以及配置自己的ip等，而是使用宿主机的ip以及端口。不过在其他方面例如文件系统、进程列表等还是与之隔离的。使用host模式的容器可以直接使用宿主机的IP地址与外界通信，容器内部的服务端口也可以使用宿主机的端口，不需要进行 <code>NAT</code> ，Host最大的优势就是网络性能比较好，但是已经被使用的端口就不能再用了。</p><p><img src="/images/2021-09-09-14-36-38.png" alt=""></p><p><strong>介绍</strong></p><ul><li>host 网络模式需要在容器创建时指定 <code>--network=host</code></li><li>host 模式可以直接使用宿主机的IP地址与外界进行通信，若宿主机的 <code>eth0</code>  是一个公有 IP，那么容器也拥有这个公有IP。同时容器内服务的端口也可以使用宿主机的端口，无需额外进行 <code>NAT</code>  转换</li><li>host模式可以让容器共享宿主机网络栈，这样的好处是外部主机与容器直接通信，但是容器的网络缺少隔离性</li></ul><p><strong>缺陷</strong></p><ul><li>容器网络环境隔离性的弱化。即容器不再拥有隔离、独立的网络栈</li><li>使用 host 模式的容器虽然可以让容器内部的服务和传统情况无差别、无改造的使用，但是由于网络隔离性的弱化，该容器会与宿主机竞争网络栈的使用</li><li>容器内部将不再拥有所有的端口资源，原因是部分端口资源已经被宿主机本身的服务占用，还有部分端口已经用以 <code>bridge</code>  网络模式容器的端口映射</li></ul><p><strong>测试</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-01 ~]# docker run -d --network=host --name nginx  nginx</span><br><span class="line">ba0eb1c89ab6b505619db9b6789074db397a9f729ce18aeb82543986971b83d1</span><br><span class="line"></span><br><span class="line">[root@centos-01 ~]# docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS     NAMES</span><br><span class="line">ba0eb1c89ab6   nginx     &quot;/docker-entrypoint.…&quot;   3 seconds ago   Up 2 seconds             nginx</span><br></pre></td></tr></table></figure><p>注意</p><ol><li>不需要添加 <code>-p</code> 参数，因为它使用的就是主机的IP和端口，添加 <code>-p</code> 参数后，反而会出现警告：   <code> WARNING: Published ports are discarded when using host network mode</code></li><li>宿主机的ip路由转发功能一定要打开，否则所创建的容器无法联网。<code>echo 1 &gt; /proc/sys/net/ipv4/ip_forward</code></li></ol><blockquote><p>host端口占用模式是容器占用主机上当前所监听的端口(官网描述为publish)。比如这里nginx占用80端口，那么用host模式启动的时候，主机上的80端口会被nginx占用，这时其他的容器就不能再指定80端口，但可以指定其他端口，所以说一台主机上可以运行多个host模式的容器，只要彼此监听的端口不一样即可</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-01 ~]# curl 192.168.126.143:80</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Welcome to nginx!&lt;/title&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    body &#123;</span><br><span class="line">        width: 35em;</span><br><span class="line">        margin: 0 auto;</span><br><span class="line">        font-family: Tahoma, Verdana, Arial, sans-serif;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;If you see this page, the nginx web server is successfully installed and</span><br><span class="line">working. Further configuration is required.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;For online documentation and support please refer to</span><br><span class="line">&lt;a href=&quot;http://nginx.org/&quot;&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;</span><br><span class="line">Commercial support is available at</span><br><span class="line">&lt;a href=&quot;http://nginx.com/&quot;&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="Container">Container</h2><p><code>Container模式</code> 与 <code>Host模式</code> 类似，指定新创建的容器和已经存在的一个容器共享一个 <code>Network Namespace</code> 。这意味着：新建的容器不会创建自己的网卡等相关操作，而是和与指定的容器共享这些资源。除了网络方面，其文件系统、进程列表等都是隔离的。</p><p><img src="/images/2021-09-09-14-40-14.png" alt=""></p><blockquote><p>注：它并没有改善容器与宿主机以外世界通信的情况（和桥接模式一样，不能连接宿主机以外的其他设备）</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-01 ~]# docker run -d --name nginx --network=container:ba0eb1c89ab6b50 nginx</span><br></pre></td></tr></table></figure><h2 id="None">None</h2><p>Docker容器拥有自己的 <code>Network Namespace</code> ，但不会对容器进行任何的网络配置。这意味着：这个容器没有网卡、IP、路由等信息。需要自己为Docker容器添加网卡、配置IP等。这种方式网络的隔离性最为彻底，即表明关闭了容器的网络功能，也无法访问这个容器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-01 ~]<span class="comment"># docker run -d --name nginx --network=none nginx</span></span><br></pre></td></tr></table></figure><h1 id="参考">参考</h1><ul><li><a href="https://www.w3cschool.cn/docker/docker-command-manual.html">https://www.w3cschool.cn/docker/docker-command-manual.html</a></li><li><a href="https://docs.docker.com/reference/">https://docs.docker.com/reference/</a></li><li><a href="https://www.runoob.com/docker/docker-command-manual.html">https://www.runoob.com/docker/docker-command-manual.html</a></li><li><a href="https://blog.csdn.net/qq_43791724/article/details/109758108">https://blog.csdn.net/qq_43791724/article/details/109758108</a></li><li><a href="https://zhuanlan.zhihu.com/p/83041422">https://zhuanlan.zhihu.com/p/83041422</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/docker/1.7Docker%E9%AB%98%E7%BA%A7%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"/>
      <url>/docker/1.7Docker%E9%AB%98%E7%BA%A7%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>除了自动创建的网络，还可以创建自定义网络。Docker提供三种自定义网络驱动： <code>bridge</code> /<code>overlay</code> / <code>macvlan</code> ，其中 <code>overlay</code>  和 <code>macvlan</code> 用于创建跨主机的网络。</p><blockquote><p>注意：建议使用自定义的网络来控制哪些容器可以相互通信，可以自动DNS解析容器名称到IP地址</p></blockquote><span id="more"></span><p>除了自动创建的网络还可以创建自定义网络。Docker提供三种自定义网络驱动：</p><ul><li><code>bridge</code></li><li><code>overlay</code></li><li><code>macvlan</code></li></ul><p>其中 <code>overlay</code>  和 <code>macvlan</code> 用于创建跨主机的网络。</p><blockquote><p>注意：建议使用自定义的网络来控制哪些容器可以相互通信，可以自动DNS解析容器名称到IP地址</p></blockquote><h1 id="自定义创建bridge网络">自定义创建bridge网络</h1><p>通过 bridge 驱动创建类似于默认的 bridge 网络（自定义网桥中会自己分配ip地址和网关地址）。</p><p><strong>创建自定义网桥</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-01 ~]# docker network create --driver bridge my-net</span><br><span class="line">c62a2e3d6ad5dece71a470cde488ad9c41c24fac9380689f43905ffbd70d4389</span><br><span class="line"></span><br><span class="line">[root@centos-01 ~]# brctl show</span><br><span class="line">bridge namebridge idSTP enabledinterfaces</span><br><span class="line">br-c62a2e3d6ad58000.0242ae4b8680no</span><br><span class="line">docker08000.0242cbf135eano</span><br><span class="line"></span><br><span class="line">[root@centos-01 ~]# docker network ls</span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">f6524186651f   bridge    bridge    local</span><br><span class="line">ed7ffc7437dd   host      host      local</span><br><span class="line">c62a2e3d6ad5   my-net    bridge    local</span><br><span class="line">fa66bc1a17f4   none      null      local</span><br></pre></td></tr></table></figure><p>看到新增网桥 <code>br-c62a2e3d6ad5</code>， <code>c62a2e3d6ad5</code>  是新建网桥 <code>my-net</code> 的短id，<code>docker network inspect</code>   看下 <code>my-net</code> 的配置信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-01 ~]<span class="comment"># docker network inspect my-net </span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;my-net&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Id&quot;</span>: <span class="string">&quot;c62a2e3d6ad5dece71a470cde488ad9c41c24fac9380689f43905ffbd70d4389&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Created&quot;</span>: <span class="string">&quot;2021-06-18T11:16:55.17530733+08:00&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Scope&quot;</span>: <span class="string">&quot;local&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;bridge&quot;</span>,</span><br><span class="line">        <span class="string">&quot;EnableIPv6&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;IPAM&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Options&quot;</span>: &#123;&#125;,</span><br><span class="line">            <span class="string">&quot;Config&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">&quot;Subnet&quot;</span>: <span class="string">&quot;172.19.0.0/16&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;Gateway&quot;</span>: <span class="string">&quot;172.19.0.1&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;Internal&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;Attachable&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;Ingress&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;ConfigFrom&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;Network&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;ConfigOnly&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;Containers&quot;</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">&quot;Options&quot;</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">&quot;Labels&quot;</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里 <code>172.19.0.0/16</code> 是 <code>Docker</code> 自动分配的IP网段，网关为 <code>172.19.0.1</code> ,在 <code>my-net</code> 对应的网桥<code>br-c62a2e3d6ad5</code>上</p><p>如果想要指定IP网段。只需在创建网段时指定 <code>--subnet</code>  和 <code>-gateway</code> 参数即可，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create --driver bridge --subnet 172.22.16.0/24 --gateway 172.22.16.1 my-net</span><br></pre></td></tr></table></figure><p>容器要使用新的网络，需要在启动时通过 <code>--network</code> 指定：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-01 ~]# docker run -d --network=my-net --name nginx  nginx</span><br><span class="line">2104ba150f62d9ea552d09b05ccb0b376db10ce054b50908d16361a639826b84</span><br></pre></td></tr></table></figure><p>查看容器配置：</p><p><img src="/images/2021-09-09-14-45-27.png" alt=""></p><p>容器分配到的IP为 <code>172.19.0.2</code> 到目前为止，这里的IP是docker自动从 <code>subnet</code> 中分配的，如果想要指定一个静态IP可以通过 <code>--ip</code> 指定。</p><p>这里有个问题需要注意：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-01 ~]# docker run -d --network=my-net --ip 172.19.0.110 --name nginx  nginx</span><br><span class="line">5506e7ca82c8252727d8e7e4ae2c25ae1e3e5276fcf031112a17702ac4194e77</span><br><span class="line">docker: Error response from daemon: user specified IP address is supported only when connecting to networks with user configured subnets.</span><br></pre></td></tr></table></figure><p>Docker中只有使用 <code>--subnet</code> 创建的网络才能指定静态IP。因此在使用 <code>docker-compose</code> 或者 <code>docker run</code> 命令创建容器时，如果需要指定可以使用 ：</p><ul><li><code>–subnet</code>   指定 IP 段</li><li><code>–gateway</code> 指定网关</li><li><code>my-net</code>     指定网桥名称</li></ul><h1 id="同网桥下容器通信">同网桥下容器通信</h1><p><strong>nginx1</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-01 ~]# docker run -d --name nginx1 --network=my-net nginx</span><br><span class="line">96a448f4c29fef3038abdd91410d7f9264ef3620cb1a80974bcb63694e61953c</span><br></pre></td></tr></table></figure><p><img src="/images/2021-09-09-14-46-48.png" alt=""></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-01 ~]# docker exec -it nginx1 /bin/bash</span><br><span class="line">root@96a448f4c29f:/# ping 172.19.0.3</span><br><span class="line">PING 172.19.0.3 (172.19.0.3) 56(84) bytes of data.</span><br><span class="line">64 bytes from 172.19.0.3: icmp_seq=1 ttl=64 time=0.175 ms</span><br><span class="line">64 bytes from 172.19.0.3: icmp_seq=2 ttl=64 time=0.052 ms</span><br><span class="line">64 bytes from 172.19.0.3: icmp_seq=3 ttl=64 time=0.044 ms</span><br></pre></td></tr></table></figure><p><strong>nginx2</strong>:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-01 ~]# docker run -d --name nginx2 --network=my-net nginx</span><br><span class="line">8d47f51c8138e0ef935f3e8a7447c16a655ce21f18e87a0af0bc6e5ea2daaa21</span><br></pre></td></tr></table></figure><p><img src="/images/2021-09-09-14-47-06.png" alt=""></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-01 ~]# docker exec -it nginx2 /bin/bash</span><br><span class="line">root@8d47f51c8138:/# ping 172.19.0.2</span><br><span class="line">PING 172.19.0.2 (172.19.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from 172.19.0.2: icmp_seq=1 ttl=64 time=0.043 ms</span><br><span class="line">64 bytes from 172.19.0.2: icmp_seq=2 ttl=64 time=0.064 ms</span><br><span class="line">64 bytes from 172.19.0.2: icmp_seq=3 ttl=64 time=0.049 ms</span><br></pre></td></tr></table></figure><p>结果可知：同一网络中的容器、网关之间都是可以通信的。</p><h1 id="容器跨网桥通信">容器跨网桥通信</h1><p>这里有个问题是 <code>my-net</code> 与默认的 <code>bridge</code> 网络是否可以通信，正常来说两个网络属于不同的网桥应该不能通信，测试一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-01 ~]<span class="comment"># docker ps -a</span></span><br><span class="line">1CONTAINER ID   IMAGE     COMMAND                  CREATED          STATUS          PORTS     NAMES</span><br><span class="line">8d47f51c8138   nginx     <span class="string">&quot;/docker-entrypoint.…&quot;</span>   32 minutes ago   Up 32 minutes   80/tcp    nginx2</span><br><span class="line">96a448f4c29f   nginx     <span class="string">&quot;/docker-entrypoint.…&quot;</span>   32 minutes ago   Up 32 minutes   80/tcp    nginx1</span><br><span class="line"></span><br><span class="line">[root@centos-01 ~]<span class="comment"># docker run -d --name nginx3 nginx</span></span><br><span class="line">220cc3010771f7a3b0c778d4d5668baa860e969e8d5a6cde830290b31dad89fd</span><br><span class="line"></span><br><span class="line">[root@centos-01 ~]<span class="comment"># docker ps -a</span></span><br><span class="line">CONTAINER ID   IMAGE     COMMAND                  CREATED          STATUS          PORTS     NAMES</span><br><span class="line">220cc3010771   nginx     <span class="string">&quot;/docker-entrypoint.…&quot;</span>   3 seconds ago    Up 2 seconds    80/tcp    nginx3</span><br><span class="line">8d47f51c8138   nginx     <span class="string">&quot;/docker-entrypoint.…&quot;</span>   32 minutes ago   Up 32 minutes   80/tcp    nginx2</span><br><span class="line">96a448f4c29f   nginx     <span class="string">&quot;/docker-entrypoint.…&quot;</span>   32 minutes ago   Up 32 minutes   80/tcp    nginx1</span><br><span class="line"></span><br><span class="line">[root@centos-01 ~]<span class="comment"># brctl show</span></span><br><span class="line">bridge namebridge idSTP enabledinterfaces</span><br><span class="line">br-c62a2e3d6ad58000.0242ae4b8680noveth0a1e1ba</span><br><span class="line">                            veth1069d0c</span><br><span class="line">docker08000.0242cbf135eanoveth3147348</span><br><span class="line"></span><br><span class="line">[root@centos-01 ~]<span class="comment"># docker inspect nginx3</span></span><br></pre></td></tr></table></figure><p><img src="/images/2021-09-09-14-48-08.png" alt=""></p><p>新建容器 <code>nginx3</code> 但不指定网桥所以会使用默认的 <code>bridge</code> 网络，结果显示 <code>br-c62a2e3d6ad5</code> 上绑定了两个虚拟网卡 <code>veth0a1e1ba</code> 和 <code>veth1069d0c</code> 对应 <code>nginx1</code> 和 <code>nginx2</code> , <code>docker0</code> 上绑定了 <code>veth3147348</code> ，对应 <code>ngnix3</code> ，分配的IP地址是 <code>172.17.0.2</code> 也可以看出来不在一个网段。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-01 ~]<span class="comment"># docker exec -it nginx1 /bin/bash</span></span><br><span class="line">root@96a448f4c29f:/<span class="comment"># ping 172.17.0.2</span></span><br><span class="line">PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data.</span><br></pre></td></tr></table></figure><p>结果可知：不同网段的确是 <code>ping</code> 不通的。</p><p>思考：“不同的网络如果加上路由是否可以通信”，如果host上对每个网络都有一条路由，同时操作系统上打开了 <code>ip forwarding</code> ，host就成了一个路由器，挂接在不同网桥上的网络就能够相互通信。试试看。</p><p>查看路由表：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-01 ~]<span class="comment"># ip r</span></span><br><span class="line">default via 192.168.126.67 dev ens33 proto static metric 100 </span><br><span class="line">172.17.0.0/16 dev docker0 proto kernel scope link src 172.17.0.1 </span><br><span class="line">172.19.0.0/16 dev br-c62a2e3d6ad5 proto kernel scope link src 172.19.0.1 </span><br><span class="line">192.168.126.0/24 dev ens33 proto kernel scope link src 192.168.126.143 metric 100 </span><br></pre></td></tr></table></figure><p><img src="/images/2021-09-09-14-49-20.png" alt=""><br><code>172.17.0.0/16</code> 和 <code>172..16.0/24</code> 两个网络的路由都定义好了。再看看 <code>ip forwarding</code> ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-01 ~]<span class="comment"># sysctl net.ipv4.ip_forward</span></span><br><span class="line">net.ipv4.ip_forward = 1</span><br></pre></td></tr></table></figure><p>这里看到路由转发也是开启的，条件都满足的情况下为什么还不行呢，再看看 <code>iptables</code></p><p><img src="/images/2021-09-09-14-49-47.png" alt=""></p><p>这里看到原因是因为： <code>iptables</code> DROP掉了网桥 <code>dockero</code> 与 <code>br-c62a2e3d6ad5</code> 之间双向的流量。从规则命名 <code>DOCKER-ISOLATION</code> 可知 <code>docker</code> 在设计上就是要隔离不同的 <code>netwrok</code>, 这里可以通过使用 <code>docker network connect</code> 命令添加一块网卡来实现不同网桥容器通信：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-01 ~]# docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND                  CREATED        STATUS        PORTS     NAMES</span><br><span class="line">220cc3010771   nginx     &quot;/docker-entrypoint.…&quot;   34 hours ago   Up 34 hours   80/tcp    nginx3</span><br><span class="line">8d47f51c8138   nginx     &quot;/docker-entrypoint.…&quot;   34 hours ago   Up 34 hours   80/tcp    nginx2</span><br><span class="line">96a448f4c29f   nginx     &quot;/docker-entrypoint.…&quot;   34 hours ago   Up 34 hours   80/tcp    nginx1</span><br><span class="line"></span><br><span class="line">[root@centos-01 ~]# docker network connect my-net 220cc3010771 #将nginx3连接到my-net中</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-01 ~]# docker exec -it nginx1 /bin/bash</span><br><span class="line">root@96a448f4c29f:/# ping 172.19.0.4</span><br><span class="line">PING 172.19.0.4 (172.19.0.4) 56(84) bytes of data.</span><br><span class="line">64 bytes from 172.19.0.4: icmp_seq=1 ttl=64 time=0.130 ms</span><br><span class="line">64 bytes from 172.19.0.4: icmp_seq=2 ttl=64 time=0.046 ms</span><br><span class="line">64 bytes from 172.19.0.4: icmp_seq=3 ttl=64 time=0.060 ms</span><br></pre></td></tr></table></figure><p>此时发现 <code>nginx1</code> 已经可以访问到 <code>nginx3</code> 了。</p><h1 id="端口映射">端口映射</h1><p>容器访问外网是通过 <code>iptables</code> 的 <code>SNAT</code> 实现的，docker容器在启动的时候，如果不指定端口映射参数，容器外部无法通过网络访问容器内的网络应用和服务。需要设置端口映射，也可以使用 <code>Dockerfile</code> 文件中的 <code>EXPOSE</code> 指令来配置。</p><p>端口映射使用 <code>-p</code> 、 <code>-P</code> 来实现</p><ul><li><code>-p</code> 容器内部端口绑定到指定的主机端口</li><li><code>-P</code> 容器内部端口随机映射到主机的高端口</li></ul><p><strong>格式</strong>：<code>指定ip:指定宿主机端口:指定容器端口</code>/<code>IP:HOSTPORT:CONTAINERPORT</code></p><p>这适用于将容器端口映射到指定地址的指定端口：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang ~]# docker run -it -d -p 127.0.0.1:5000:5000 --name redis redis #将容器的5000端口映射到指定地址127.0.0.1的5000端口上</span><br><span class="line">c2179a906b05e210c42eb6561cf76285f3391e703d5db249a154e06d4d025f28</span><br><span class="line">[root@wangpengliang ~]# docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND                  CREATED          STATUS          PORTS                                NAMES</span><br><span class="line">4927cb5dfe67   redis     &quot;docker-entrypoint.s…&quot;   49 seconds ago   Up 48 seconds   127.0.0.1:5000-&gt;5000/tcp, 6379/tcp   redis</span><br></pre></td></tr></table></figure><p><strong>格式</strong>：<code>指定ip、宿主机随机端口、指定容器端口</code> /<code>IP::CONTAINERPORT</code></p><p>这适用于将容器端口映射到指定地址的任意端口：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang ~]# docker run -it -d -p 127.0.0.1::5000 --name redis redis   #将容器的5000端口映射到指定地址127.0.0.1的任意端口上</span><br><span class="line">c19e6b8f249db67b2f50455d35159f718a1d68e6efd02c106f0148bae14ba496</span><br><span class="line">[root@wangpengliang ~]# docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS                                 NAMES</span><br><span class="line">c19e6b8f249d   redis     &quot;docker-entrypoint.s…&quot;   2 seconds ago   Up 2 seconds   6379/tcp, 127.0.0.1:49153-&gt;5000/tcp   redis</span><br></pre></td></tr></table></figure><p><strong>格式</strong>：<code>不指定ip、指定宿主机端口、指定容器端口</code>/<code>HOSTPORT:CONTAINERPORT</code></p><p>这适用于将容器指定端口映射到宿主机的指定端口：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang ~]<span class="comment"># docker run -it -d -p 80:8000 --name redis redis          #将容器的8000端口映射到宿主机的80端口上</span></span><br><span class="line">3ad63ffd90665413e644cd16f2eb7d404fcb14bb509eee05f67e0db8f1c067a4</span><br><span class="line">[root@wangpengliang ~]<span class="comment"># docker ps -a</span></span><br><span class="line">CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS                                             NAMES</span><br><span class="line">3ad63ffd9066   redis     <span class="string">&quot;docker-entrypoint.s…&quot;</span>   5 seconds ago   Up 4 seconds   6379/tcp, 0.0.0.0:80-&gt;8000/tcp, :::80-&gt;8000/tcp   redis</span><br></pre></td></tr></table></figure><h2 id="绑定-UDP-端口">绑定 UDP 端口</h2><p>默认情况下 <code>-p</code> 和 <code>-P</code> 绑定的都是 <code>tcp</code> 协议端口，如果要绑定 <code>udp</code> 协议端口，只能使用 <code>-p</code> 参数，且在最后添加 <code>/udp</code> 字符串。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang ~]<span class="comment"># docker run -d -p 127.0.0.1:5553:5000/udp jcdemo/flaskapp</span></span><br><span class="line">6aa30aa070a6e77f0d3f8653df69c654edf6e8bb68cea475aefbc68f6f7f9572</span><br></pre></td></tr></table></figure><h2 id="绑定多个端口">绑定多个端口</h2><p>多次使用 <code>-p</code> 参数可以映射多个端口。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang ~]<span class="comment"># docker run -d -p 5552:5000  -p 5551:5001 jcdemo/flaskapp</span></span><br><span class="line">fa116ae4f5c19d82d9d4f40560c3219c85540a21d88f7fa999b60382ab57524a</span><br></pre></td></tr></table></figure><h1 id="查看映射端口">查看映射端口</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker port container_ID <span class="comment">#容器ID</span></span><br><span class="line"><span class="comment">#结果输出</span></span><br><span class="line">80/tcp -&gt; 0.0.0.0:800</span><br></pre></td></tr></table></figure><h1 id="跨主机网络解决方案">跨主机网络解决方案</h1><p>TODO</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/docker/1.1Docker%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%89%E8%A3%85/"/>
      <url>/docker/1.1Docker%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>软件开发最大的麻烦事之一就是环境配置。计算机的环境都不相同，为了保证软件能在不同的机器上正常运行必须保证两件事：</p><ul><li>操作系统的设置</li><li>各种库和组件的安装</li></ul><p>比如安装一个dotnet core 应用，计算机必须有dotnet SDK，还必须有各种依赖，可能还要配置环境变量。而且换一台机器就要重新配置一遍。能不能做到软件可以带环境安装？也就是说安装的时候，把原始环境一模一样地复制过来。</p><h1 id="虚拟机">虚拟机</h1><p>虚拟机（virtual machine）就是带环境安装的一种解决方案。它可以在一种操作系统里面运行另一种操作系统，比如在 Windows 系统里面运行 Linux 系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件不需要了就删掉，对其他部分毫无影响。</p><p>虽然可以通过虚拟机还原软件的原始环境。但是这个方案有几个缺点：</p><ul><li><strong>资源占用多</strong>：虚拟机会独占一部分内存和硬盘空间。它运行的时候其他程序就不能使用这些资源了。哪怕虚拟机里面的应用程序，真正使用的内存只有1MB，虚拟机依然需要几百MB的内存才能运行</li><li><strong>冗余步骤多</strong>：虚拟机是完整的操作系统，一些系统级别的操作步骤，往往无法跳过，比如用户登录</li><li><strong>启动慢</strong>：启动操作系统需要多久，启动虚拟机就需要多久。可能要等几分钟，应用程序才能真正运行</li></ul><h1 id="Linux-容器">Linux 容器</h1><p>由于虚拟机存在这些缺点，Linux 发展出了另一种虚拟化技术：Linux 容器（ <code>Linux Containers</code> 缩写为 <code>LXC</code> ）Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。或者说，在正常进程的外面套了一个<a href="https://opensource.com/article/18/1/history-low-level-container-runtimes">保护层</a>。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。</p><p>由于容器是进程级别的，相比虚拟机有很多优势：</p><ul><li><strong>启动快</strong>：容器里面的应用，直接就是底层系统的一个进程而不是虚拟机内部的进程。所以启动容器相当于启动本机的一个进程，而不是启动一个操作系统，速度就快很多</li><li><strong>资源占用少</strong>：容器只占用需要的资源，不占用没有用到的资源；虚拟机由于是完整的操作系统，不可避免要占用所有资源。另外，多个容器可以共享资源，虚拟机都是独享资源</li><li><strong>体积小</strong>：容器只要包含用到的组件即可，而虚拟机是整个操作系统的打包，所以容器文件比虚拟机文件要小很多</li></ul><blockquote><p>总之，容器有点像轻量级的虚拟机，能够提供虚拟化的环境，但是成本开销小得多</p></blockquote><p>下图比较了Docker和传统虚拟化方式的不同之处。传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程。</p><p><img src="/images/2021-09-09-13-28-12.png" alt=""></p><p>容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</p><p><img src="/images/2021-09-09-13-28-29.png" alt=""></p><h1 id="Docker概念">Docker概念</h1><blockquote><p>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。它是目前最流行的 Linux 容器解决方案</p></blockquote><p>Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker就不用再担心环境问题。</p><p>Docker 使用 <code>Google</code> 公司推出的 <a href="https://golang.google.cn/">Go 语言</a> 进行开发实现，基于 <code>Linux</code> 内核的 <a href="https://zh.wikipedia.org/wiki/Cgroups">cgroup</a>，<a href="https://en.wikipedia.org/wiki/Linux_namespaces">namespace</a>，以及 <a href="https://docs.docker.com/storage/storagedriver/overlayfs-driver/">OverlayFS</a> 类的 <a href="https://en.wikipedia.org/wiki/Union_mount">Union FS</a> 等技术，对进程进行封装隔离，属于 <a href="https://en.wikipedia.org/wiki/Operating-system-level_virtualization">操作系统层面的虚拟化技术</a>。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。最初实现是基于 <a href="https://linuxcontainers.org/lxc/introduction/">LXC</a>，从 <code>0.7</code> 版本以后开始去除 <code>LXC</code>，转而使用自行开发的 <a href="https://github.com/docker/libcontainer">libcontainer</a>，从 <code>1.11</code> 版本开始，则进一步演进为用 <a href="https://github.com/opencontainers/runc">runC</a> 和 <a href="https://github.com/containerd/containerd">containerd</a> 。</p><h1 id="Docker优点">Docker优点</h1><p>作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势：</p><ul><li><strong>更高效的利用系统资源</strong>：由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用</li><li><strong>更快速的启动</strong>：传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker 容器应用由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间</li><li><strong>一致的运行环境</strong>：开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 <em>「这段代码在我机器上没问题」</em> 这类问题</li><li><strong>持续交付和部署</strong>：对开发和运维（<a href="https://zh.wikipedia.org/wiki/DevOps">DevOps</a>）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 <a href="https://www.bookstack.cn/read/docker_practice-v1.1.0/$image-dockerfile">Dockerfile</a> 来进行镜像构建，并结合 <a href="https://en.wikipedia.org/wiki/Continuous_integration">持续集成(Continuous Integration)</a> 系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 <a href="https://en.wikipedia.org/wiki/Continuous_delivery">持续部署(Continuous Delivery/Deployment)</a> 系统进行自动部署。而且使用 <code>Dockerfile</code> 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像</li><li><strong>更轻松的迁移</strong>：由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云其运行结果是一致的。因此可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况</li><li><strong>更轻松的维护和扩展</strong>：Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外Docker 团队同各个开源项目团队一起维护了一大批高质量的 <a href="https://hub.docker.com/search/?type=image&amp;image_filter=official">官方镜像</a>，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本</li></ul><p><strong>Docker对比传统虚拟机总结</strong></p><table><thead><tr><th>特性</th><th>容器</th><th>虚拟机</th></tr></thead><tbody><tr><td>启动</td><td>秒级</td><td>分钟级</td></tr><tr><td>硬盘使用</td><td>一般为 <code>MB</code></td><td>一般为 <code>GB</code></td></tr><tr><td>性能</td><td>接近原生</td><td>弱于</td></tr><tr><td>系统支持量</td><td>单机支持上千个容器</td><td>一般几十个</td></tr></tbody></table><h1 id="Docker组成">Docker组成</h1><p>Docker 使用客户端-服务器 (C/S) 架构模式 使用远程API来管理和创建Docker容器。Docker 容器（Container）通过 Docker 镜像（Image）来创建，二者之间的关系类似于面向对象中的对象与类。</p><p>Docker由三个基本概念组成</p><ul><li><strong>仓库（Repository）</strong>：Docker用于存放镜像文件的仓库</li><li><strong>镜像（Image）</strong>：Image是构建容器的源代码，是一个只读的模板。由一层一层的文件系统组成的类似于虚拟机的镜像</li><li><strong>容器(Container）</strong>：Container是由Docker镜像创建的运行实例，类似于虚拟机。容器之间是相互隔离的，包含特定的应用及其所需的依赖文件</li></ul><blockquote><p>✨ Docker Hub是Docker公司提供的一个注册服务器（Register）来保存多个仓库，每个仓库又可以包含多个具备不同tag的镜像</p></blockquote><h1 id="Docker安装（Centos）">Docker安装（Centos）</h1><p>Docker 是一个开源的商业产品，有两个版本：社区版（Community Edition，缩写为 CE）和企业版（Enterprise Edition，缩写为 EE）。企业版包含了一些收费服务，个人开发者一般用不到。</p><h2 id="环境准备">环境准备</h2><p>官方建议 <code>Centos7 Linux</code> 内核需要<code>3.10</code>以上</p><blockquote><p>注意：使用 <code>root</code> 用户登录执行命令前无需加<code>sudo</code>，非 <code>root</code> 的所有命令前面要加 <code>sudo</code></p></blockquote><h2 id="查看内核版本">查看内核版本</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang ~]<span class="comment"># uname -r</span></span><br><span class="line">3.10.0-1160.25.1.el7.x86_64</span><br></pre></td></tr></table></figure><h2 id="卸载旧版本">卸载旧版本</h2><blockquote><p>如果之前安装过才需要</p></blockquote><p><strong>1)：查看当前docker状态，如果是运行状态则停掉</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl status docker</span><br><span class="line">systemctl stop docker</span><br></pre></td></tr></table></figure><p><strong>2)：查看yum安装的docker文件包</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list installed |grep docker</span><br></pre></td></tr></table></figure><p><strong>3)：查看docker相关的rpm源文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa |grep docker</span><br></pre></td></tr></table></figure><p><strong>4)：删除所有安装的docker文件包</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y remove docker.x86_64</span><br></pre></td></tr></table></figure><p><strong>其他docker相关的安装包同样删除，删完之后再查看下docker rpm源</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa |grep docker</span><br></pre></td></tr></table></figure><p><strong>5)：删除docker的镜像文件，默认在</strong><code>**/var/lib/docker**</code><strong>目录下</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /var/lib/docker</span><br></pre></td></tr></table></figure><h2 id="Yum安装">Yum安装</h2><ol><li>更新 yum 包。可选项：如之后出现不兼容的情况的话就必须执行</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y update</span><br></pre></td></tr></table></figure><ol start="2"><li>​安装必要系统工具。<code>yum-util</code> 提供 <code>yum-config-manager</code> 功能，另外两个是 <code>devicemapper</code> 驱动依赖的</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure><ol start="3"><li>设置 yum 源。下面两个都可用</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --add-repo http:<span class="comment">//download.docker.com/linux/centos/docker-ce.repo</span></span><br><span class="line">yum-config-manager --add-repo http:<span class="comment">//mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span></span><br></pre></td></tr></table></figure><ol start="4"><li>查看可用版本</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang ~]<span class="comment"># yum list docker-ce --showduplicates | sort -r</span></span><br><span class="line">已加载插件：fastestmirror</span><br><span class="line">可安装的软件包</span><br><span class="line"> * updates: mirrors.163.com</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line"> * extras: mirrors.163.com</span><br><span class="line">docker-ce.x86_64            3:20.10.6-3.el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64            3:20.10.5-3.el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64            3:20.10.4-3.el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64            3:20.10.3-3.el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64            3:20.10.2-3.el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64            3:20.10.1-3.el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64            3:20.10.0-3.el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64            3:19.03.9-3.el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64            3:19.03.8-3.el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64            3:19.03.7-3.el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64            3:19.03.6-3.el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64            3:19.03.5-3.el7                     docker-ce-stable</span><br><span class="line"> * centos-sclo-sclo: mirrors.163.com</span><br><span class="line"> * centos-sclo-rh: mirrors.163.com</span><br><span class="line"> * base: mirrors.163.com</span><br></pre></td></tr></table></figure><ol start="5"><li>选择版本并安装</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">格式：yum install docker-ce-版本号</span><br><span class="line">yum -y install docker-ce-20.10.6</span><br></pre></td></tr></table></figure><p><img src="/images/2021-09-09-13-32-36.png" alt=""><br>6. 启动并设置开机自启</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker &amp;&amp; systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure><p>查看安装版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang ~]<span class="comment"># docker version</span></span><br><span class="line">Client: Docker Engine - Community</span><br><span class="line"> Version:           20.10.6</span><br><span class="line"> API version:       1.41</span><br><span class="line"> Go version:        go1.13.15</span><br><span class="line"> Git commit:        370c289</span><br><span class="line"> Built:             Fri Apr  9 22:45:33 2021</span><br><span class="line"> OS/Arch:           linux/amd64</span><br><span class="line"> Context:           default</span><br><span class="line"> Experimental:      <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">Server: Docker Engine - Community</span><br><span class="line"> Engine:</span><br><span class="line">  Version:          20.10.6</span><br><span class="line">  API version:      1.41 (minimum version 1.12)</span><br><span class="line">  Go version:       go1.13.15</span><br><span class="line">  Git commit:       8728dd2</span><br><span class="line">  Built:            Fri Apr  9 22:43:57 2021</span><br><span class="line">  OS/Arch:          linux/amd64</span><br><span class="line">  Experimental:     <span class="literal">false</span></span><br><span class="line"> containerd:</span><br><span class="line">  Version:          1.4.4</span><br><span class="line">  GitCommit:        05f951a3781f4f2c1911b05e61c160e9c30eaa8e</span><br><span class="line"> runc:</span><br><span class="line">  Version:          1.0.0-rc93</span><br><span class="line">  GitCommit:        12644e614e25b05da6fd08a38ffa0cfe1903fdec</span><br><span class="line"> docker-init:</span><br><span class="line">  Version:          0.19.0</span><br><span class="line">  GitCommit:        de40ad0</span><br></pre></td></tr></table></figure><ol start="7"><li>测试运行</li></ol><blockquote><p>由于本地没有 hello-world 这个镜像，正常情况下会下载一个 hello-world 的镜像并在容器内运行</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><h2 id="脚本安装">脚本安装</h2><p><strong>必备条件</strong></p><ul><li><p>使用 sudo 或 root 权限登录 Centos</p></li><li><p>确保 yum 包更新到最新</p></li></ul><ol><li>执行安装脚本</li></ol><blockquote><p>执行脚本会添加 docker.repo 源并安装 Docker</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com -o get-docker.sh</span><br><span class="line">sh get-docker.sh</span><br></pre></td></tr></table></figure><ol start="2"><li>启动进程</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><ol start="3"><li>测试运行</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run hello-world</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/docker/1.2Docker%E9%95%9C%E5%83%8F/"/>
      <url>/docker/1.2Docker%E9%95%9C%E5%83%8F/</url>
      
        <content type="html"><![CDATA[<p>镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，包含运行软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件，Docker 运行容器前需要本地存在对应的镜像，如果本地不存在会从镜像仓库下载该镜像。</p><blockquote><p>操作系统分为内核和用户空间。对于 Linux 而言，内核启动后，会挂载 <code>root</code> 文件系统为其提供用户空间支持。而 Docker 镜像就相当于是一个 root 文件系统。比如官方镜像 ubuntu:18.04 就包含了完整的一套 Ubuntu 18.04 最小系统的 root 文件系统</p></blockquote><h1 id="镜像来源">镜像来源</h1><ul><li>远程仓库下载</li><li>拷贝</li><li>自己制作镜像( <code>Dockerfile</code> )</li></ul><h1 id="获取镜像">获取镜像</h1><p><a href="https://hub.docker.com/explore/">Docker Hub</a> 上有大量高质量的镜像可以用，获取镜像的命令是 <code>docker pull</code>，格式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</span><br></pre></td></tr></table></figure><p>具体选项可以通过 <code>docker pull --help</code> 命令看到，镜像名称格式如下：</p><ul><li>Docker 镜像仓库地址：地址格式一般是 <code>&lt;域名/IP&gt;[:端口号]</code>。默认地址是 Docker Hub</li><li>仓库名：这里的仓库名是两段式名称，即 <code>&lt;用户名&gt;/&lt;软件名&gt;</code>。对于 Docker Hub，如果不给出用户名，则默认为 <code>library</code>，也就是官方镜像</li></ul><p>比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang ~]<span class="comment"># docker pull redis:6.2.4</span></span><br><span class="line">6.2.4: Pulling from library/redis</span><br><span class="line">69692152171a: Pull complete </span><br><span class="line">a4a46f2fd7e0: Pull complete </span><br><span class="line">bcdf6fddc3bd: Pull complete </span><br><span class="line">2902e41faefa: Pull complete </span><br><span class="line">df3e1d63cdb1: Pull complete </span><br><span class="line">fa57f005a60d: Pull complete </span><br><span class="line">Digest: sha256:7e2c6181ad5c425443b56c7c73a9cd6df24a122345847d1ea9bb86a5afc76325</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> redis:6.2.4</span><br><span class="line">docker.io/library/redis:6.2.4</span><br></pre></td></tr></table></figure><p>上面的命令中没有给出 Docker 镜像仓库地址，因此将会从 Docker Hub 获取镜像。而镜像名称是 <code>redis:6.2.4</code>，因此将会获取官方镜像 <code>library/redis</code>仓库中标签为 <code>6.2.4</code>  的镜像。</p><p>从下载过程中可以看到分层存储的概念，镜像是由多层存储所构成。下载也是一层层的去下载，并非单一文件下载。过程中给出了每一层的 ID 的前 12 位。下载结束后，给出该镜像完整的 <code>sha256</code> 的摘要以确保下载一致性。</p><h1 id="镜像列表">镜像列表</h1><p>镜像下载完成后可以使用 <code>docker image ls</code> 查看本地镜像列表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang ~]<span class="comment"># docker image ls</span></span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED        SIZE</span><br><span class="line">redis         6.2.4     fad0ee7e917a   2 days ago     105MB</span><br><span class="line">redis         latest    fad0ee7e917a   2 days ago     105MB</span><br><span class="line">hello-world   latest    d1165f221234   3 months ago   13.3kB</span><br></pre></td></tr></table></figure><p>列表包含了 仓库名、标签、镜像 ID、创建时间以及所占用的空间，镜像 ID 是镜像的唯一标识，一个镜像可以对应多个标签。</p><h1 id="镜像体积">镜像体积</h1><p>仔细观察会注意到上面标识的所占用空间和在 Docker Hub 上看到的镜像大小不同。比如，<code>redis:6.2.4</code> 镜像大小，在这里是 <code>105 MB</code>，但是在 <a href="https://hub.docker.com/r/library/ubuntu/tags/">Docker Hub</a> 显示的却是 <code>37 MB</code>。这是因为 Docker Hub 中显示的体积是压缩后的体积。在镜像下载和上传过程中镜像是保持着压缩状态的，因此 Docker Hub 所显示的大小是网络传输中更关心的流量大小。而 <code>docker image ls</code> 显示的是镜像下载到本地后，展开的大小。准确说，是展开后的各层所占空间的总和，因为镜像到本地查看空间的时候，更关心的是本地磁盘空间占用的大小。</p><p>另外一个需要注意的问题是，<code>docker image ls</code> 列表中的镜像体积总和并非是所有镜像实际硬盘消耗。由于 Docker 镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。由于 Docker 使用 <a href="https://www.jianshu.com/p/3ba255463047">UNION FS</a>，相同的层只需要保存一份即可。因此实际镜像硬盘占用空间很可能要比这个列表镜像大小的总和要小。</p><p>通过以下命令可以查看镜像、容器、数据卷所占用的空间：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang ~]<span class="comment"># docker system df</span></span><br><span class="line">TYPE            TOTAL     ACTIVE    SIZE      RECLAIMABLE</span><br><span class="line">Images          2         1         105.4MB   13.34kB (0%)</span><br><span class="line">Containers      1         1         26B       0B (0%)</span><br><span class="line">Local Volumes   1         1         0B        0B</span><br><span class="line">Build Cache     0         0         0B        0B</span><br></pre></td></tr></table></figure><h1 id="虚悬镜像">虚悬镜像</h1><p>有时候可以看到这种特殊的镜像，仓库名和标签均为 <code>&lt;none&gt;</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;none&gt;               &lt;none&gt;              00285df0df87        5 days ago          342 MB</span><br></pre></td></tr></table></figure><p>这个镜像原本是有镜像名和标签的，比如原来为 <code>mongo:3.2</code>，随着官方镜像维护，发布了新版本后，重新 <code>docker pull mongo:3.2</code> 时，<code>mongo:3.2</code> 这个镜像名被转移到了新下载的镜像身上，而旧的镜像上的这个名称则被取消，从而成为了 <code>&lt;none&gt;</code>。除了 <code>docker pull</code> 可能导致这种情况，<code>docker build</code> 也同样可以导致这种现象。由于新旧镜像同名，旧镜像名称被取消，从而出现仓库名、标签均为 <code>&lt;none&gt;</code> 的镜像。这类无标签镜像也被称为 <strong>虚悬镜像(dangling image)</strong> 。</p><p>通过以下命令可以查看这类镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker image ls -f dangling=true</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">&lt;none&gt;              &lt;none&gt;              00285df0df87        5 days ago          342 MB</span><br></pre></td></tr></table></figure><p>一般来说虚悬镜像已经失去了存在的价值，是可以随意删除的。可以通过以下命令删除：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image prune</span><br></pre></td></tr></table></figure><h1 id="中间层镜像">中间层镜像</h1><p>为了加速镜像构建、重复利用资源，Docker 会利用 中间层镜像。所以在使用一段时间后，可能会看到一些依赖的中间层镜像。默认的 <code>docker image ls</code> 列表中只会显示顶层镜像，如果希望显示包括中间层镜像在内的所有镜像的话，需要加 <code>-a</code> 参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image ls -a</span><br></pre></td></tr></table></figure><p>这样会看到很多无标签的镜像，这些无标签的镜像很多都是中间层镜像，是其它镜像所依赖的镜像。这些无标签镜像不应该删除，否则会导致上层镜像因为依赖丢失而出错。实际上，这些镜像也没必要删除，因为之前说过，相同的层只会存一遍，而这些镜像是别的镜像的依赖，因此并不会因为它们被列出来而多存了一份，只要删除依赖它们的镜像后，这些被依赖的中间层镜像也会被连带删除。</p><h1 id="列出部分镜像">列出部分镜像</h1><p>不加任何参数的情况下，<code>docker image ls</code> 会列出所有顶层镜像，但有时候只希望列出部分镜像。<code>docker image ls</code> 有几个参数可以帮助做到</p><p>根据仓库名列出镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang ~]<span class="comment"># docker image ls redis</span></span><br><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED      SIZE</span><br><span class="line">redis        6.2.4     fad0ee7e917a   2 days ago   105MB</span><br><span class="line">redis        latest    fad0ee7e917a   2 days ago   105MB</span><br></pre></td></tr></table></figure><hr><p>指定仓库名和标签：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang ~]<span class="comment"># docker image ls redis:6.2.4</span></span><br><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED      SIZE</span><br><span class="line">redis        6.2.4     fad0ee7e917a   2 days ago   105MB</span><br></pre></td></tr></table></figure><p>除此以外，<code>docker image ls</code> 还支持过滤器参数 <code>--filter</code>或者简写 <code>-f</code>。</p><hr><p>只显示镜像ID <code>-q</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang ~]<span class="comment"># docker image ls -q</span></span><br><span class="line">fad0ee7e917a</span><br><span class="line">fad0ee7e917a</span><br><span class="line">d1165f221234</span><br></pre></td></tr></table></figure><hr><p>格式化显示镜像结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang ~]<span class="comment"># docker image ls --format &quot;&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Repository&#125;&#125;&quot;</span></span><br><span class="line">fad0ee7e917a: redis</span><br><span class="line">fad0ee7e917a: redis</span><br><span class="line">d1165f221234: hello-world</span><br><span class="line"><span class="comment"># 以表格等距显示（需要自己定义列）</span></span><br><span class="line">[root@wangpengliang ~]<span class="comment"># docker image ls --format &quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Repository&#125;&#125;\t&#123;&#123;.Tag&#125;&#125;&quot;</span></span><br><span class="line">IMAGE ID       REPOSITORY    TAG</span><br><span class="line">fad0ee7e917a   redis         6.2.4</span><br><span class="line">fad0ee7e917a   redis         latest</span><br><span class="line">d1165f221234   hello-world   latest</span><br></pre></td></tr></table></figure><p>只包含镜像ID和仓库名。</p><hr><h1 id="删除镜像">删除镜像</h1><p>如果要删除本地镜像，可以使用 <code>docker image rm</code> 命令，格式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...] <span class="comment">#&lt;镜像&gt; 可以是 镜像短 ID、镜像长 ID、镜像名 或者 镜像摘要</span></span><br></pre></td></tr></table></figure><p>或者使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dcoker rmi &lt;镜像&gt;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang ~]<span class="comment"># docker image ls</span></span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED        SIZE</span><br><span class="line">redis         6.2.4     fad0ee7e917a   2 days ago     105MB</span><br><span class="line">redis         latest    fad0ee7e917a   2 days ago     105MB</span><br><span class="line">hello-world   latest    d1165f221234   3 months ago   13.3kB</span><br><span class="line"></span><br><span class="line">[root@wangpengliang ~]<span class="comment"># docker rmi redis:latest</span></span><br><span class="line">Untagged: redis:latest</span><br><span class="line"></span><br><span class="line">[root@wangpengliang ~]<span class="comment"># docker image ls</span></span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED        SIZE</span><br><span class="line">redis         6.2.4     fad0ee7e917a   2 days ago     105MB</span><br><span class="line">hello-world   latest    d1165f221234   3 months ago   13.3kB</span><br></pre></td></tr></table></figure><h1 id="运行容器">运行容器</h1><p>上面了解了关于镜像的一些基础知识，有了镜像就能够以这个镜像为基础启动并运行一个容器。以 <code>redis</code> 为例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang ~]<span class="comment"># docker run -it --name redis -d redis:6.2.4</span></span><br><span class="line">68b9ad2b60fc7fd2a546e764448798195c86f5f22bfce200cd7e583d60df8096</span><br><span class="line"></span><br><span class="line">[root@wangpengliang ~]<span class="comment"># docker ps -a</span></span><br><span class="line">CONTAINER ID   IMAGE         COMMAND                  CREATED         STATUS         PORTS      NAMES</span><br><span class="line">68b9ad2b60fc   redis:6.2.4   <span class="string">&quot;docker-entrypoint.s…&quot;</span>   4 seconds ago   Up 3 seconds   6379/tcp   redis</span><br><span class="line"></span><br><span class="line">[root@wangpengliang ~]<span class="comment"># docker exec -it redis /bin/bash</span></span><br><span class="line">root@68b9ad2b60fc:/data<span class="comment"># cat /etc/os-release </span></span><br><span class="line">PRETTY_NAME=<span class="string">&quot;Debian GNU/Linux 10 (buster)&quot;</span></span><br><span class="line">NAME=<span class="string">&quot;Debian GNU/Linux&quot;</span></span><br><span class="line">VERSION_ID=<span class="string">&quot;10&quot;</span></span><br><span class="line">VERSION=<span class="string">&quot;10 (buster)&quot;</span></span><br><span class="line">VERSION_CODENAME=buster</span><br><span class="line">ID=debian</span><br><span class="line">HOME_URL=<span class="string">&quot;https://www.debian.org/&quot;</span></span><br><span class="line">SUPPORT_URL=<span class="string">&quot;https://www.debian.org/support&quot;</span></span><br><span class="line">BUG_REPORT_URL=<span class="string">&quot;https://bugs.debian.org/&quot;</span></span><br></pre></td></tr></table></figure><h1 id="UnionFS">UnionFS</h1><ul><li>联合文件系统是一种分层、轻量级并且高性能的文件系统，支持对文件系统的修改，作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下（unite directories into a single virtual filesystem）</li><li>UnionFS是Docker镜像的基础，镜像可以通过分层来继承，基于基础镜像（没有父镜像的镜像），可以制作各种具体的应用镜像</li><li>特性一次同时加载多个文件系统，但从外面看起来只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录</li><li>Docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统叫 UnionFS</li><li>BootFS（Boot file system）主要包含 bootloader 和 kernel，bootloader 主要是引导加载 kernel，Linux 刚启动时会加载 BootFS文件系统，在 Docker 镜像的最底层是 BootFS。这一层与典型的 Linux/Unix 系统是一样的，包含 boot 加载器和内核。当 boot 加载完成之后整个内核就都在内存中了，此时内存的使用权已由 BootFS 转交给内核，此时系统也会卸载 BootFS</li><li>RootFS（Root File System），在 BootFS 之上，包含的就是典型 Linux 系统中的 /dev，/proc，/bin，/etc 等标准目录和文件。RootFS就是各种不同的操作系统发行版，比如 Ubuntu CentOS 等</li></ul><blockquote><p>比如：mysql 和 tomcat 都需要 centos 环境，先安装 mysql 就有了 centos 的环境，再安装 tomcat 时就可以共用这一层 centos ，不需要再下载 centos</p></blockquote><h1 id="Commit镜像">Commit镜像</h1><p>镜像是容器的基础，每次执行 <code>docker run</code> 的时候都会指定哪个镜像作为容器运行的基础。之前例子中一直使用来自于 Docker Hub 的镜像。直接使用这些镜像是可以满足一定的需求，而当这些镜像无法直接满足需求时，就需要定制镜像。</p><p>镜像是多层存储，每一层是在前一层的基础上进行的修改。容器同样也是多层存储，以镜像为基础层，在其基础上加一层作为容器运行时的存储层。</p><p>以定制一个 Web 服务器为例，来了解镜像是如何构建的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name webserver -d -p 80:80 nginx</span><br></pre></td></tr></table></figure><p>使用 nginx 镜像启动一个容器，命名为 <code>webserver </code>并且映射 <code>80</code> 端口，然后浏览器去访问这个服务器会看到默认的 nginx 欢迎页面。</p><p><img src="/images/2021-09-09-13-42-21.png" alt=""></p><p>现在将&quot;Welcome to nginx!&quot;  改成 “Welcome to Docker!”，通过 <code>docker cp</code> 将容器内文件拷贝出来修改后再放回去。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang home]# docker cp 470e01aed950:/usr/share/nginx/html/index.html /home/</span><br></pre></td></tr></table></figure><blockquote><p>这里也可以使用 docker exec 进入到容器内进行修改，不过因为容器内并没安装 <code>vi</code> ，还需额外安装就懒得折腾了</p></blockquote><p>现在刷新浏览器的话，会发现内容改变了。<br><img src="/images/2021-09-09-13-43-16.png" alt=""><br>上面修改了容器的文件，也就是改动了容器的存储层。可以通过 <code>docker diff</code> 命令看到具体的改动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang home]# docker diff webserver </span><br><span class="line">C /etc</span><br><span class="line">C /etc/nginx</span><br><span class="line">C /etc/nginx/conf.d</span><br><span class="line">C /etc/nginx/conf.d/default.conf</span><br><span class="line">C /run</span><br><span class="line">A /run/nginx.pid</span><br><span class="line">C /usr</span><br><span class="line">C /usr/share</span><br><span class="line">C /usr/share/nginx</span><br><span class="line">C /usr/share/nginx/html</span><br><span class="line">C /usr/share/nginx/html/index.html</span><br><span class="line">C /var</span><br><span class="line">C /var/cache</span><br><span class="line">C /var/cache/nginx</span><br><span class="line">A /var/cache/nginx/fastcgi_temp</span><br><span class="line">A /var/cache/nginx/proxy_temp</span><br><span class="line">A /var/cache/nginx/scgi_temp</span><br><span class="line">A /var/cache/nginx/uwsgi_temp</span><br><span class="line">A /var/cache/nginx/client_temp</span><br><span class="line">C /root</span><br><span class="line">A /root/.bash_history</span><br></pre></td></tr></table></figure><p>当运行一个容器时（如果不使用卷），做的任何文件修改都会被记录于容器存储层里。而 Docker 提供了一个 <code>docker commit</code> 命令，可以将容器的存储层保存下来成为镜像。换句话说就是在原有镜像的基础上再叠加上容器的存储层，并构成新的镜像。以后运行这个新镜像时，就会拥有原有容器最后的文件变化。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]]</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit -m=&quot;提交的描述信息&quot; -a=&quot;作者&quot; 容器id 目标镜像名[tag]</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang ~]# docker commit -m=&#x27;nginx2.0&#x27; -a=&#x27;wangpengliang&#x27; 470e01aed950 nginx:2.0</span><br><span class="line">sha256:546ad28bcf61aeedd04de8c255efa508ee65eeff0b2a4529d17d3df835aa6bb2</span><br><span class="line">[root@wangpengliang ~]# docker image ls</span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">nginx         2.0       546ad28bcf61   5 seconds ago   133MB</span><br><span class="line">redis         6.2.4     fad0ee7e917a   2 days ago      105MB</span><br><span class="line">nginx         latest    d1a364dc548d   9 days ago      133MB</span><br><span class="line">hello-world   latest    d1165f221234   3 months ago    13.3kB</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用 <code>docker history</code> 可以具体查看镜像内的历史记录，如果比较 <code>nginx:latest</code> 的历史记录，会发现新增了刚刚提交的这一层：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang ~]# docker history nginx:2.0</span><br><span class="line">IMAGE          CREATED              CREATED BY                                      SIZE      COMMENT</span><br><span class="line">546ad28bcf61   About a minute ago   nginx -g daemon off;                            2.03kB    nginx2.0</span><br><span class="line">d1a364dc548d   9 days ago           /bin/sh -c #(nop)  CMD [&quot;nginx&quot; &quot;-g&quot; &quot;daemon…   0B        </span><br><span class="line">&lt;missing&gt;      9 days ago           /bin/sh -c #(nop)  STOPSIGNAL SIGQUIT           0B        </span><br><span class="line">&lt;missing&gt;      9 days ago           /bin/sh -c #(nop)  EXPOSE 80                    0B        </span><br><span class="line">&lt;missing&gt;      9 days ago           /bin/sh -c #(nop)  ENTRYPOINT [&quot;/docker-entr…   0B        </span><br><span class="line">&lt;missing&gt;      9 days ago           /bin/sh -c #(nop) COPY file:09a214a3e07c919a…   4.61kB    </span><br><span class="line">&lt;missing&gt;      9 days ago           /bin/sh -c #(nop) COPY file:0fd5fca330dcd6a7…   1.04kB    </span><br><span class="line">&lt;missing&gt;      9 days ago           /bin/sh -c #(nop) COPY file:0b866ff3fc1ef5b0…   1.96kB    </span><br><span class="line">&lt;missing&gt;      9 days ago           /bin/sh -c #(nop) COPY file:65504f71f5855ca0…   1.2kB     </span><br><span class="line">&lt;missing&gt;      9 days ago           /bin/sh -c set -x     &amp;&amp; addgroup --system -…   63.9MB    </span><br><span class="line">&lt;missing&gt;      9 days ago           /bin/sh -c #(nop)  ENV PKG_RELEASE=1~buster     0B        </span><br><span class="line">&lt;missing&gt;      9 days ago           /bin/sh -c #(nop)  ENV NJS_VERSION=0.5.3        0B        </span><br><span class="line">&lt;missing&gt;      9 days ago           /bin/sh -c #(nop)  ENV NGINX_VERSION=1.21.0     0B        </span><br><span class="line">&lt;missing&gt;      3 weeks ago          /bin/sh -c #(nop)  LABEL maintainer=NGINX Do…   0B        </span><br><span class="line">&lt;missing&gt;      3 weeks ago          /bin/sh -c #(nop)  CMD [&quot;bash&quot;]                 0B        </span><br><span class="line">&lt;missing&gt;      3 weeks ago          /bin/sh -c #(nop) ADD file:7362e0e50f30ff454…   69.3MB</span><br></pre></td></tr></table></figure><p>新的镜像定制好后，运行这个镜像。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name webserver2 -d -p 81:80 nginx:2.0</span><br></pre></td></tr></table></figure><p>这里命名为新的服务为 <code>webserver2</code> ，并且映射到 <code>81</code> 端口。看到结果内容和之前修改后的 <code>webserver</code> 一样</p><p><img src="/images/2021-09-09-13-46-31.png" alt=""></p><h1 id="慎用Commit镜像">慎用Commit镜像</h1><p><code>docker commit</code> 命令虽然可以比较直观的帮助理解镜像分层存储的概念，但是实际环境中并不推荐这么用，原因有如下几点：</p><p><strong>问题一：</strong></p><p>仔细观察之前的 <code>docker diff webserver</code> 的结果，会发现除了真正想要修改的 <code>/usr/share/nginx/html/index.html</code> 文件外，由于命令的执行还有很多文件被改动或添加了。这还仅仅是最简单的操作，如果是安装软件包、编译构建那会有大量的无关内容被添加进来。如果不清理干净，将导致镜像极为臃肿。</p><p><strong>问题二：</strong></p><p>使用 <code>docker commit</code> 意味着所有对镜像的操作都是黑箱操作，生成的镜像也被称为黑箱镜像，除了制作镜像的人知道执行过什么命令、怎么生成的镜像，别人根本无从得知。而且，即使是这个制作镜像的人，过一段时间后也无法记清具体操作。虽然 <code>docker diff</code> 或许可以得到一些线索，但是远远不到可以确保生成一致镜像的地步。这种黑箱镜像将导致维护工作非常痛苦。</p><p><strong>问题三：</strong></p><p>镜像所使用的分层存储的概念是除当前层外，之前的每一层都是不会发生改变的，换句话说，任何修改的结果仅仅是在当前层进行标记、添加、修改，而不会改动上一层。如果使用 <code>docker commit</code> 制作镜像以及后期修改的话，每一次修改都会让镜像更加臃肿一次，所删除的上一层的东西并不会丢失，会一直如影随形的跟着这个镜像，即使根本无法访问到。这也会让镜像更加臃肿。</p><h1 id="DockerFile示例">DockerFile示例</h1><p>根据之前的 <code>docker commit</code> 了解到镜像的定制实际上就是定制每一层所添加的配置、文件。如果可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是<code>Dockerfile</code> 。</p><p>Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。了解了 Dockerfile 如何构建镜像后，以 nginx 举例来构建这个镜像。</p><p>在空白目录中建立文件命名为 <code>Dockerfile</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir mynginx</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> mynginx</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> touch Dockerfile</span></span><br></pre></td></tr></table></figure><p>编写内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line">RUN echo &#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27; &gt; /usr/share/nginx/html/index.html</span><br></pre></td></tr></table></figure><p>使用 <code>docker build</code> 命令依赖 <code>Dockerfile</code>文件生成镜像：（注意：最后有个<code>.</code> 这是必须的）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang ~]# docker build -t nginx:3.0 .</span><br></pre></td></tr></table></figure><p>查看构建好的镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@wangpengliang ~]# docker image ls</span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">nginx         3.0       f89693105193   7 minutes ago   133MB</span><br><span class="line">nginx         2.0       546ad28bcf61   3 days ago      133MB</span><br><span class="line">redis         6.2.4     fad0ee7e917a   5 days ago      105MB</span><br><span class="line">nginx         latest    d1a364dc548d   12 days ago     133MB</span><br><span class="line">hello-world   latest    d1165f221234   3 months ago    13.3kB</span><br></pre></td></tr></table></figure><p>运行 <code>nginx:3.0</code> 镜像测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name webserver3 -d -p 82:80 nginx:3.0</span><br></pre></td></tr></table></figure><p><img src="/images/2021-09-09-13-49-52.png" alt=""></p><h1 id="其他-Docker-Build-用法">其他 <code>Docker Build</code> 用法</h1><h2 id="Git-repo-构建">Git repo 构建</h2><p><code>docker build</code> 支持从 <code>URL</code>  构建，比如可以直接从 Git repo 中构建：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker build https://github.com/twang2218/gitlab-ce-zh.git<span class="comment">#:11.1</span></span><br><span class="line">Sending build context to Docker daemon 2.048 kB</span><br><span class="line">Step1: FROM gitlab/gitlab-ce:11.1.0-ce.0</span><br><span class="line">11.1.0-ce.0:Pulling from gitlab/gitlab-ce</span><br><span class="line">aed15891ba52:Already exists</span><br><span class="line">773ae8583d14:Already exists</span><br></pre></td></tr></table></figure><p>这里指定了构建所需的 <code>git repo</code> ，并且指定默认的 <code>master</code> 分支，构建目录为 <code>/11.1/</code>，然后 Docker 就会去 <code>git clone</code> 这个项目、切换到指定分支、并进入到指定目录后开始构建。</p><h2 id="tar-压缩包构建">tar 压缩包构建</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build http://server/context.tar.gz</span><br></pre></td></tr></table></figure><p>如果给出的 <code>URL</code>  不是个 <code>Git repo</code> ，而是个 <code>tar</code> 压缩包，那么 Docker 引擎会下载这个包，并自动解压缩，以其作为上下文，开始构建。</p><h2 id="读取-Dockerfile-构建">读取 Dockerfile 构建</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker build -&lt;Dockerfile</span><br><span class="line">或</span><br><span class="line">cat Dockerfile| docker build -</span><br></pre></td></tr></table></figure><p>如果标准输入传入的是文本文件，则将其视为 <code>Dockerfile</code>，并开始构建。这种形式由于直接从标准输入中读取 Dockerfile 的内容，它没有上下文，因此不可以像其他方法那样可以将本地文件 <code>COPY</code> 到镜像之类的事情。</p><h2 id="读取上下文压缩包构建">读取上下文压缩包构建</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -&lt; context.tar.gz</span><br></pre></td></tr></table></figure><p>如果发现标准输入的文件格式是 <code>gzip</code>、<code>bzip2</code> 以及 <code>xz</code> 的话，将会使其为上下文压缩包，直接将其展开，将里面视为上下文，并开始构建。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
