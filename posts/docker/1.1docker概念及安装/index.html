<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="软件开发最大的麻烦事之一就是环境配置。计算机的环境都不相同，为了保证软件能在不同的机器上正常运行必须保证两件事：
操作系统的设置 各种库和组件的安装 比如安装一个dotnet core 应用，计算机必须有dotnet SDK，还必须有各种依赖，可能还要配置环境变量。而且换一台机器就要重新配置一遍。能不能做到软件可以带环境安装？也就是说安装的时候，把原始环境一模一样地复制过来。
虚拟机# 虚拟机（virtual machine）就是带环境安装的一种解决方案。它可以在一种操作系统里面运行另一种操作系统，比如在 Windows 系统里面运行 Linux 系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件不需要了就删掉，对其他部分毫无影响。
虽然可以通过虚拟机还原软件的原始环境。但是这个方案有几个缺点：
资源占用多：虚拟机会独占一部分内存和硬盘空间。它运行的时候其他程序就不能使用这些资源了。哪怕虚拟机里面的应用程序，真正使用的内存只有1MB，虚拟机依然需要几百MB的内存才能运行 冗余步骤多：虚拟机是完整的操作系统，一些系统级别的操作步骤，往往无法跳过，比如用户登录 启动慢：启动操作系统需要多久，启动虚拟机就需要多久。可能要等几分钟，应用程序才能真正运行 Linux 容器# 由于虚拟机存在这些缺点，Linux 发展出了另一种虚拟化技术：Linux 容器（ Linux Containers 缩写为 LXC ）Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。或者说，在正常进程的外面套了一个保护层。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。
由于容器是进程级别的，相比虚拟机有很多优势：
启动快：容器里面的应用，直接就是底层系统的一个进程而不是虚拟机内部的进程。所以启动容器相当于启动本机的一个进程，而不是启动一个操作系统，速度就快很多 资源占用少：容器只占用需要的资源，不占用没有用到的资源；虚拟机由于是完整的操作系统，不可避免要占用所有资源。另外，多个容器可以共享资源，虚拟机都是独享资源 体积小：容器只要包含用到的组件即可，而虚拟机是整个操作系统的打包，所以容器文件比虚拟机文件要小很多 总之，容器有点像轻量级的虚拟机，能够提供虚拟化的环境，但是成本开销小得多
下图比较了Docker和传统虚拟化方式的不同之处。传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程。
容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。
Docker概念# Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。它是目前最流行的 Linux 容器解决方案
Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker就不用再担心环境问题。
Docker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 OverlayFS 类的 Union FS 等技术，对进程进行封装隔离，属于 操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。最初实现是基于 LXC，从 0.7 版本以后开始去除 LXC，转而使用自行开发的 libcontainer，从 1.11 版本开始，则进一步演进为用 runC 和 containerd 。
Docker优点# 作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势：
">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:url" content="http://localhost:1313/posts/docker/1.1docker%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%89%E8%A3%85/">
  <meta property="og:site_name" content="CODE&#39;NOTE">
  <meta property="og:title" content="CODE&#39;NOTE">
  <meta property="og:description" content="软件开发最大的麻烦事之一就是环境配置。计算机的环境都不相同，为了保证软件能在不同的机器上正常运行必须保证两件事：
操作系统的设置 各种库和组件的安装 比如安装一个dotnet core 应用，计算机必须有dotnet SDK，还必须有各种依赖，可能还要配置环境变量。而且换一台机器就要重新配置一遍。能不能做到软件可以带环境安装？也就是说安装的时候，把原始环境一模一样地复制过来。
虚拟机# 虚拟机（virtual machine）就是带环境安装的一种解决方案。它可以在一种操作系统里面运行另一种操作系统，比如在 Windows 系统里面运行 Linux 系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件不需要了就删掉，对其他部分毫无影响。
虽然可以通过虚拟机还原软件的原始环境。但是这个方案有几个缺点：
资源占用多：虚拟机会独占一部分内存和硬盘空间。它运行的时候其他程序就不能使用这些资源了。哪怕虚拟机里面的应用程序，真正使用的内存只有1MB，虚拟机依然需要几百MB的内存才能运行 冗余步骤多：虚拟机是完整的操作系统，一些系统级别的操作步骤，往往无法跳过，比如用户登录 启动慢：启动操作系统需要多久，启动虚拟机就需要多久。可能要等几分钟，应用程序才能真正运行 Linux 容器# 由于虚拟机存在这些缺点，Linux 发展出了另一种虚拟化技术：Linux 容器（ Linux Containers 缩写为 LXC ）Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。或者说，在正常进程的外面套了一个保护层。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。
由于容器是进程级别的，相比虚拟机有很多优势：
启动快：容器里面的应用，直接就是底层系统的一个进程而不是虚拟机内部的进程。所以启动容器相当于启动本机的一个进程，而不是启动一个操作系统，速度就快很多 资源占用少：容器只占用需要的资源，不占用没有用到的资源；虚拟机由于是完整的操作系统，不可避免要占用所有资源。另外，多个容器可以共享资源，虚拟机都是独享资源 体积小：容器只要包含用到的组件即可，而虚拟机是整个操作系统的打包，所以容器文件比虚拟机文件要小很多 总之，容器有点像轻量级的虚拟机，能够提供虚拟化的环境，但是成本开销小得多
下图比较了Docker和传统虚拟化方式的不同之处。传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程。
容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。
Docker概念# Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。它是目前最流行的 Linux 容器解决方案
Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker就不用再担心环境问题。
Docker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 OverlayFS 类的 Union FS 等技术，对进程进行封装隔离，属于 操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。最初实现是基于 LXC，从 0.7 版本以后开始去除 LXC，转而使用自行开发的 libcontainer，从 1.11 版本开始，则进一步演进为用 runC 和 containerd 。
Docker优点# 作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势：">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">


  <meta itemprop="name" content="CODE&#39;NOTE">
  <meta itemprop="description" content="软件开发最大的麻烦事之一就是环境配置。计算机的环境都不相同，为了保证软件能在不同的机器上正常运行必须保证两件事：
操作系统的设置 各种库和组件的安装 比如安装一个dotnet core 应用，计算机必须有dotnet SDK，还必须有各种依赖，可能还要配置环境变量。而且换一台机器就要重新配置一遍。能不能做到软件可以带环境安装？也就是说安装的时候，把原始环境一模一样地复制过来。
虚拟机# 虚拟机（virtual machine）就是带环境安装的一种解决方案。它可以在一种操作系统里面运行另一种操作系统，比如在 Windows 系统里面运行 Linux 系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件不需要了就删掉，对其他部分毫无影响。
虽然可以通过虚拟机还原软件的原始环境。但是这个方案有几个缺点：
资源占用多：虚拟机会独占一部分内存和硬盘空间。它运行的时候其他程序就不能使用这些资源了。哪怕虚拟机里面的应用程序，真正使用的内存只有1MB，虚拟机依然需要几百MB的内存才能运行 冗余步骤多：虚拟机是完整的操作系统，一些系统级别的操作步骤，往往无法跳过，比如用户登录 启动慢：启动操作系统需要多久，启动虚拟机就需要多久。可能要等几分钟，应用程序才能真正运行 Linux 容器# 由于虚拟机存在这些缺点，Linux 发展出了另一种虚拟化技术：Linux 容器（ Linux Containers 缩写为 LXC ）Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。或者说，在正常进程的外面套了一个保护层。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。
由于容器是进程级别的，相比虚拟机有很多优势：
启动快：容器里面的应用，直接就是底层系统的一个进程而不是虚拟机内部的进程。所以启动容器相当于启动本机的一个进程，而不是启动一个操作系统，速度就快很多 资源占用少：容器只占用需要的资源，不占用没有用到的资源；虚拟机由于是完整的操作系统，不可避免要占用所有资源。另外，多个容器可以共享资源，虚拟机都是独享资源 体积小：容器只要包含用到的组件即可，而虚拟机是整个操作系统的打包，所以容器文件比虚拟机文件要小很多 总之，容器有点像轻量级的虚拟机，能够提供虚拟化的环境，但是成本开销小得多
下图比较了Docker和传统虚拟化方式的不同之处。传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程。
容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。
Docker概念# Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。它是目前最流行的 Linux 容器解决方案
Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker就不用再担心环境问题。
Docker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 OverlayFS 类的 Union FS 等技术，对进程进行封装隔离，属于 操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。最初实现是基于 LXC，从 0.7 版本以后开始去除 LXC，转而使用自行开发的 libcontainer，从 1.11 版本开始，则进一步演进为用 runC 和 containerd 。
Docker优点# 作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势：">
  <meta itemprop="wordCount" content="427">

<title>1.1 Docker概念及安装 | CODE&#39;NOTE</title>
<link rel="icon" href="/favicon.png" >
<link rel="manifest" href="/manifest.json">
<link rel="canonical" href="http://localhost:1313/posts/docker/1.1docker%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%89%E8%A3%85/">
<link rel="stylesheet" href="/book.min.6970156cec683193d93c9c4edaf0d56574e4361df2e0c1be4f697ae81c3ba55f.css" integrity="sha256-aXAVbOxoMZPZPJxO2vDVZXTkNh3y4MG&#43;T2l66Bw7pV8=" crossorigin="anonymous">


  <script defer src="/fuse.min.js"></script>
  <script defer src="/en.search.min.3ed9c79c605914c45e19db90edfda0ca8d87c63064c1d6252862250c4e917346.js" integrity="sha256-PtnHnGBZFMReGduQ7f2gyo2HxjBkwdYlKGIlDE6Rc0Y=" crossorigin="anonymous"></script>



  
</head>
<body dir="ltr" class="book-kind-page book-type-posts">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    
<aside class="book-menu">
  <div class="book-menu-content">
    
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><span>CODE&#39;NOTE</span>
  </a>
</h2>


<div class="book-search hidden">
  <input id="book-search-input" type="text" 
    placeholder="Search"
    aria-label="Search"
    maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>
<script>document.querySelector(".book-search").classList.remove("hidden")</script>
























</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>



  </div>
</aside>
 

    <div class="book-page">
      <header class="book-header hidden">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/icons/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <h3>1.1 Docker概念及安装</h3>

  <label for="toc-control">
    
    <img src="/icons/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#环境准备">环境准备</a></li>
    <li><a href="#查看内核版本">查看内核版本</a></li>
    <li><a href="#yum安装">Yum安装</a></li>
    <li><a href="#脚本安装">脚本安装</a></li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
<article class="markdown book-post">
  <h1>
    1.1 Docker概念及安装
  </h1>
  


  

  


  <div class="book-post-content markdown-inner"><p>软件开发最大的麻烦事之一就是环境配置。计算机的环境都不相同，为了保证软件能在不同的机器上正常运行必须保证两件事：</p>
<ul>
<li>操作系统的设置</li>
<li>各种库和组件的安装</li>
</ul>
<p>比如安装一个dotnet core 应用，计算机必须有dotnet SDK，还必须有各种依赖，可能还要配置环境变量。而且换一台机器就要重新配置一遍。能不能做到软件可以带环境安装？也就是说安装的时候，把原始环境一模一样地复制过来。</p>
<h1 id="虚拟机">虚拟机<a class="anchor" href="#%e8%99%9a%e6%8b%9f%e6%9c%ba">#</a></h1>
<p>虚拟机（virtual machine）就是带环境安装的一种解决方案。它可以在一种操作系统里面运行另一种操作系统，比如在 Windows 系统里面运行 Linux 系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件不需要了就删掉，对其他部分毫无影响。</p>
<p>虽然可以通过虚拟机还原软件的原始环境。但是这个方案有几个缺点：</p>
<ul>
<li><strong>资源占用多</strong>：虚拟机会独占一部分内存和硬盘空间。它运行的时候其他程序就不能使用这些资源了。哪怕虚拟机里面的应用程序，真正使用的内存只有1MB，虚拟机依然需要几百MB的内存才能运行</li>
<li><strong>冗余步骤多</strong>：虚拟机是完整的操作系统，一些系统级别的操作步骤，往往无法跳过，比如用户登录</li>
<li><strong>启动慢</strong>：启动操作系统需要多久，启动虚拟机就需要多久。可能要等几分钟，应用程序才能真正运行</li>
</ul>
<h1 id="linux-容器">Linux 容器<a class="anchor" href="#linux-%e5%ae%b9%e5%99%a8">#</a></h1>
<p>由于虚拟机存在这些缺点，Linux 发展出了另一种虚拟化技术：Linux 容器（ <code>Linux Containers</code> 缩写为 <code>LXC</code> ）Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。或者说，在正常进程的外面套了一个<a href="https://opensource.com/article/18/1/history-low-level-container-runtimes">保护层</a>。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。</p>
<p>由于容器是进程级别的，相比虚拟机有很多优势：</p>
<ul>
<li><strong>启动快</strong>：容器里面的应用，直接就是底层系统的一个进程而不是虚拟机内部的进程。所以启动容器相当于启动本机的一个进程，而不是启动一个操作系统，速度就快很多</li>
<li><strong>资源占用少</strong>：容器只占用需要的资源，不占用没有用到的资源；虚拟机由于是完整的操作系统，不可避免要占用所有资源。另外，多个容器可以共享资源，虚拟机都是独享资源</li>
<li><strong>体积小</strong>：容器只要包含用到的组件即可，而虚拟机是整个操作系统的打包，所以容器文件比虚拟机文件要小很多</li>
</ul>
<blockquote class='book-hint '>
<p>总之，容器有点像轻量级的虚拟机，能够提供虚拟化的环境，但是成本开销小得多</p>
</blockquote><p>下图比较了Docker和传统虚拟化方式的不同之处。传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程。</p>
<p><img src="/images/2021-09-09-13-28-12.png" alt="" /></p>
<p>容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</p>
<p><img src="/images/2021-09-09-13-28-29.png" alt="" /></p>
<h1 id="docker概念">Docker概念<a class="anchor" href="#docker%e6%a6%82%e5%bf%b5">#</a></h1>
<blockquote class='book-hint '>
<p>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。它是目前最流行的 Linux 容器解决方案</p>
</blockquote><p>Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker就不用再担心环境问题。</p>
<p>Docker 使用 <code>Google</code> 公司推出的 <a href="https://golang.google.cn/">Go 语言</a> 进行开发实现，基于 <code>Linux</code> 内核的 <a href="https://zh.wikipedia.org/wiki/Cgroups">cgroup</a>，<a href="https://en.wikipedia.org/wiki/Linux_namespaces">namespace</a>，以及 <a href="https://docs.docker.com/storage/storagedriver/overlayfs-driver/">OverlayFS</a> 类的 <a href="https://en.wikipedia.org/wiki/Union_mount">Union FS</a> 等技术，对进程进行封装隔离，属于 <a href="https://en.wikipedia.org/wiki/Operating-system-level_virtualization">操作系统层面的虚拟化技术</a>。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。最初实现是基于 <a href="https://linuxcontainers.org/lxc/introduction/">LXC</a>，从 <code>0.7</code> 版本以后开始去除 <code>LXC</code>，转而使用自行开发的 <a href="https://github.com/docker/libcontainer">libcontainer</a>，从 <code>1.11</code> 版本开始，则进一步演进为用 <a href="https://github.com/opencontainers/runc">runC</a> 和 <a href="https://github.com/containerd/containerd">containerd</a> 。</p>
<h1 id="docker优点">Docker优点<a class="anchor" href="#docker%e4%bc%98%e7%82%b9">#</a></h1>
<p>作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势：</p>
<ul>
<li><strong>更高效的利用系统资源</strong>：由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用</li>
<li><strong>更快速的启动</strong>：传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker 容器应用由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间</li>
<li><strong>一致的运行环境</strong>：开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 <em>「这段代码在我机器上没问题」</em> 这类问题</li>
<li><strong>持续交付和部署</strong>：对开发和运维（<a href="https://zh.wikipedia.org/wiki/DevOps">DevOps</a>）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 <a href="https://www.bookstack.cn/read/docker_practice-v1.1.0/$image-dockerfile">Dockerfile</a> 来进行镜像构建，并结合 <a href="https://en.wikipedia.org/wiki/Continuous_integration">持续集成(Continuous Integration)</a> 系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 <a href="https://en.wikipedia.org/wiki/Continuous_delivery">持续部署(Continuous Delivery/Deployment)</a> 系统进行自动部署。而且使用 <code>Dockerfile</code> 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像</li>
<li><strong>更轻松的迁移</strong>：由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云其运行结果是一致的。因此可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况</li>
<li><strong>更轻松的维护和扩展</strong>：Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外Docker 团队同各个开源项目团队一起维护了一大批高质量的 <a href="https://hub.docker.com/search/?type=image&amp;image_filter=official">官方镜像</a>，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本</li>
</ul>
<p><strong>Docker对比传统虚拟机总结</strong></p>
<table>
  <thead>
      <tr>
          <th>特性</th>
          <th>容器</th>
          <th>虚拟机</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>启动</td>
          <td>秒级</td>
          <td>分钟级</td>
      </tr>
      <tr>
          <td>硬盘使用</td>
          <td>一般为 <code>MB</code></td>
          <td>一般为 <code>GB</code></td>
      </tr>
      <tr>
          <td>性能</td>
          <td>接近原生</td>
          <td>弱于</td>
      </tr>
      <tr>
          <td>系统支持量</td>
          <td>单机支持上千个容器</td>
          <td>一般几十个</td>
      </tr>
  </tbody>
</table>
<h1 id="docker组成">Docker组成<a class="anchor" href="#docker%e7%bb%84%e6%88%90">#</a></h1>
<p>Docker 使用客户端-服务器 (C/S) 架构模式 使用远程API来管理和创建Docker容器。Docker 容器（Container）通过 Docker 镜像（Image）来创建，二者之间的关系类似于面向对象中的对象与类。</p>
<p>Docker由三个基本概念组成</p>
<ul>
<li><strong>仓库（Repository）</strong>：Docker用于存放镜像文件的仓库</li>
<li><strong>镜像（Image）</strong>：Image是构建容器的源代码，是一个只读的模板。由一层一层的文件系统组成的类似于虚拟机的镜像</li>
<li><strong>容器(Container）</strong>：Container是由Docker镜像创建的运行实例，类似于虚拟机。容器之间是相互隔离的，包含特定的应用及其所需的依赖文件</li>
</ul>
<blockquote class='book-hint '>
<p>✨ Docker Hub是Docker公司提供的一个注册服务器（Register）来保存多个仓库，每个仓库又可以包含多个具备不同tag的镜像</p>
</blockquote><h1 id="docker安装">Docker安装<a class="anchor" href="#docker%e5%ae%89%e8%a3%85">#</a></h1>
<p>Docker 是一个开源的商业产品，有两个版本：社区版（Community Edition，缩写为 CE）和企业版（Enterprise Edition，缩写为 EE）。企业版包含了一些收费服务，个人开发者一般用不到。</p>
<h2 id="环境准备">环境准备<a class="anchor" href="#%e7%8e%af%e5%a2%83%e5%87%86%e5%a4%87">#</a></h2>
<p>官方建议 <code>Centos7 Linux</code> 内核需要<code>3.10</code>以上</p>
<blockquote class='book-hint '>
<p>注意：使用 <code>root</code> 用户登录执行命令前无需加<code>sudo</code>，非 <code>root</code> 的所有命令前面要加 <code>sudo</code></p>
</blockquote><h2 id="查看内核版本">查看内核版本<a class="anchor" href="#%e6%9f%a5%e7%9c%8b%e5%86%85%e6%a0%b8%e7%89%88%e6%9c%ac">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#f92672">[</span>root@wangpengliang ~<span style="color:#f92672">]</span><span style="color:#75715e"># uname -r</span>
</span></span><span style="display:flex;"><span>3.10.0-1160.25.1.el7.x86_64</span></span></code></pre></div><h2 id="yum安装">Yum安装<a class="anchor" href="#yum%e5%ae%89%e8%a3%85">#</a></h2>
<ol>
<li>更新 yum 包。可选项：如之后出现不兼容的情况的话就必须执行</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>yum -y update</span></span></code></pre></div><ol start="2">
<li>​	安装必要系统工具。<code>yum-util</code> 提供 <code>yum-config-manager</code> 功能，另外两个是 <code>devicemapper</code> 驱动依赖的</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>yum install -y yum-utils device-mapper-persistent-data lvm2</span></span></code></pre></div><ol start="3">
<li>设置 yum 源。下面两个都可用</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#a6e22e">yum</span><span style="color:#f92672">-</span><span style="color:#a6e22e">config</span><span style="color:#f92672">-</span><span style="color:#a6e22e">manager</span> <span style="color:#f92672">--</span><span style="color:#a6e22e">add</span><span style="color:#f92672">-</span><span style="color:#a6e22e">repo</span> <span style="color:#a6e22e">http</span><span style="color:#f92672">:</span><span style="color:#75715e">//download.docker.com/linux/centos/docker-ce.repo
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">yum</span><span style="color:#f92672">-</span><span style="color:#a6e22e">config</span><span style="color:#f92672">-</span><span style="color:#a6e22e">manager</span> <span style="color:#f92672">--</span><span style="color:#a6e22e">add</span><span style="color:#f92672">-</span><span style="color:#a6e22e">repo</span> <span style="color:#a6e22e">http</span><span style="color:#f92672">:</span><span style="color:#75715e">//mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
</span></span></span></code></pre></div><ol start="4">
<li>查看可用版本</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#f92672">[</span>root@wangpengliang ~<span style="color:#f92672">]</span><span style="color:#75715e"># yum list docker-ce --showduplicates | sort -r</span>
</span></span><span style="display:flex;"><span>已加载插件：fastestmirror
</span></span><span style="display:flex;"><span>可安装的软件包
</span></span><span style="display:flex;"><span> * updates: mirrors.163.com
</span></span><span style="display:flex;"><span>Loading mirror speeds from cached hostfile
</span></span><span style="display:flex;"><span> * extras: mirrors.163.com
</span></span><span style="display:flex;"><span>docker-ce.x86_64            3:20.10.6-3.el7                     docker-ce-stable
</span></span><span style="display:flex;"><span>docker-ce.x86_64            3:20.10.5-3.el7                     docker-ce-stable
</span></span><span style="display:flex;"><span>docker-ce.x86_64            3:20.10.4-3.el7                     docker-ce-stable
</span></span><span style="display:flex;"><span>docker-ce.x86_64            3:20.10.3-3.el7                     docker-ce-stable
</span></span><span style="display:flex;"><span>docker-ce.x86_64            3:20.10.2-3.el7                     docker-ce-stable
</span></span><span style="display:flex;"><span>docker-ce.x86_64            3:20.10.1-3.el7                     docker-ce-stable
</span></span><span style="display:flex;"><span>docker-ce.x86_64            3:20.10.0-3.el7                     docker-ce-stable
</span></span><span style="display:flex;"><span>docker-ce.x86_64            3:19.03.9-3.el7                     docker-ce-stable
</span></span><span style="display:flex;"><span>docker-ce.x86_64            3:19.03.8-3.el7                     docker-ce-stable
</span></span><span style="display:flex;"><span>docker-ce.x86_64            3:19.03.7-3.el7                     docker-ce-stable
</span></span><span style="display:flex;"><span>docker-ce.x86_64            3:19.03.6-3.el7                     docker-ce-stable
</span></span><span style="display:flex;"><span>docker-ce.x86_64            3:19.03.5-3.el7                     docker-ce-stable
</span></span><span style="display:flex;"><span> * centos-sclo-sclo: mirrors.163.com
</span></span><span style="display:flex;"><span> * centos-sclo-rh: mirrors.163.com
</span></span><span style="display:flex;"><span> * base: mirrors.163.com</span></span></code></pre></div><ol start="5">
<li>选择版本并安装</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>格式：yum install docker-ce-版本号
</span></span><span style="display:flex;"><span>yum -y install docker-ce-20.10.6</span></span></code></pre></div><p><img src="/images/2021-09-09-13-32-36.png" alt="" />
6. 启动并设置开机自启</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>systemctl start docker <span style="color:#f92672">&amp;&amp;</span> systemctl enable docker</span></span></code></pre></div><p>查看安装版本</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#f92672">[</span>root@wangpengliang ~<span style="color:#f92672">]</span><span style="color:#75715e"># docker version</span>
</span></span><span style="display:flex;"><span>Client: Docker Engine - Community
</span></span><span style="display:flex;"><span> Version:           20.10.6
</span></span><span style="display:flex;"><span> API version:       1.41
</span></span><span style="display:flex;"><span> Go version:        go1.13.15
</span></span><span style="display:flex;"><span> Git commit:        370c289
</span></span><span style="display:flex;"><span> Built:             Fri Apr  <span style="color:#ae81ff">9</span> 22:45:33 <span style="color:#ae81ff">2021</span>
</span></span><span style="display:flex;"><span> OS/Arch:           linux/amd64
</span></span><span style="display:flex;"><span> Context:           default
</span></span><span style="display:flex;"><span> Experimental:      true
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Server: Docker Engine - Community
</span></span><span style="display:flex;"><span> Engine:
</span></span><span style="display:flex;"><span>  Version:          20.10.6
</span></span><span style="display:flex;"><span>  API version:      1.41 <span style="color:#f92672">(</span>minimum version 1.12<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>  Go version:       go1.13.15
</span></span><span style="display:flex;"><span>  Git commit:       8728dd2
</span></span><span style="display:flex;"><span>  Built:            Fri Apr  <span style="color:#ae81ff">9</span> 22:43:57 <span style="color:#ae81ff">2021</span>
</span></span><span style="display:flex;"><span>  OS/Arch:          linux/amd64
</span></span><span style="display:flex;"><span>  Experimental:     false
</span></span><span style="display:flex;"><span> containerd:
</span></span><span style="display:flex;"><span>  Version:          1.4.4
</span></span><span style="display:flex;"><span>  GitCommit:        05f951a3781f4f2c1911b05e61c160e9c30eaa8e
</span></span><span style="display:flex;"><span> runc:
</span></span><span style="display:flex;"><span>  Version:          1.0.0-rc93
</span></span><span style="display:flex;"><span>  GitCommit:        12644e614e25b05da6fd08a38ffa0cfe1903fdec
</span></span><span style="display:flex;"><span> docker-init:
</span></span><span style="display:flex;"><span>  Version:          0.19.0
</span></span><span style="display:flex;"><span>  GitCommit:        de40ad0</span></span></code></pre></div><ol start="7">
<li>测试运行</li>
</ol>
<blockquote class='book-hint '>
<p>由于本地没有 hello-world 这个镜像，正常情况下会下载一个 hello-world 的镜像并在容器内运行</p>
</blockquote><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker run hello-world</span></span></code></pre></div><h2 id="脚本安装">脚本安装<a class="anchor" href="#%e8%84%9a%e6%9c%ac%e5%ae%89%e8%a3%85">#</a></h2>
<p><strong>必备条件</strong></p>
<ul>
<li>
<p>使用 sudo 或 root 权限登录 Centos</p>
</li>
<li>
<p>确保 yum 包更新到最新</p>
</li>
</ul>
<ol>
<li>执行安装脚本</li>
</ol>
<blockquote class='book-hint '>
<p>执行脚本会添加 docker.repo 源并安装 Docker</p>
</blockquote><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>curl -fsSL https://get.docker.com -o get-docker.sh
</span></span><span style="display:flex;"><span>sh get-docker.sh</span></span></code></pre></div><ol start="2">
<li>启动进程</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>systemctl start docker</span></span></code></pre></div><ol start="3">
<li>测试运行</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo docker run hello-world</span></span></code></pre></div><h1 id="docker-卸载">Docker 卸载<a class="anchor" href="#docker-%e5%8d%b8%e8%bd%bd">#</a></h1>
<p><strong>1)：查看当前docker状态，如果是运行状态则停掉</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>systemctl status docker
</span></span><span style="display:flex;"><span>systemctl stop docker</span></span></code></pre></div><p><strong>2)：查看yum安装的docker文件包</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span> yum list installed |grep docker</span></span></code></pre></div><p><strong>3)：查看docker相关的rpm源文件</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>rpm -qa |grep docker</span></span></code></pre></div><p><strong>4)：删除所有安装的docker文件包</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span> yum -y remove docker.x86_64</span></span></code></pre></div><p><strong>其他docker相关的安装包同样删除，删完之后再查看下docker rpm源</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>rpm -qa |grep docker</span></span></code></pre></div><p><strong>5)：删除docker的镜像文件，默认在</strong><code>**/var/lib/docker**</code><strong>目录下</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>rm -rf /var/lib/docker</span></span></code></pre></div></div>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">
  <div>
  
    <a href="/posts/devops/nugetserver%E6%90%AD%E5%BB%BA/" class="flex align-center">
      <img src="/icons/backward.svg" class="book-icon" alt="Backward" />
      <span>Nuget Server搭建</span>
    </a>
  
  </div>
  <div>
  
    <a href="/posts/docker/1.2docker%E9%95%9C%E5%83%8F/" class="flex align-center">
      <span>1.2 Docker镜像</span>
      <img src="/icons/forward.svg" class="book-icon" alt="Forward" />
    </a>
  
  </div>
</div>
 
        
  
 
        
        
  
 
        
  
  
    <script>(function(){document.querySelectorAll("pre:has(code)").forEach(e=>{e.addEventListener("click",e.focus),e.addEventListener("copy",function(t){if(t.preventDefault(),navigator.clipboard){const t=window.getSelection().toString()||e.textContent;navigator.clipboard.writeText(t)}})})})()</script>
  

      </footer>

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
  
  <aside class="book-toc">
    <div class="book-toc-content">
      
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#环境准备">环境准备</a></li>
    <li><a href="#查看内核版本">查看内核版本</a></li>
    <li><a href="#yum安装">Yum安装</a></li>
    <li><a href="#脚本安装">脚本安装</a></li>
  </ul>
</nav>



    </div>
  </aside>
  
 
  </main>

  
</body>
</html>




















