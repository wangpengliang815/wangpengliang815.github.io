<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="切片定义# func sliceDeclar() { var s1 []int // 定义存放int类型的切片 var s2 []string // 定义存放string类型的切片 fmt.Println(s1, s2) fmt.Println(s1 == nil, s2 == nil) }创建切片和创建数组非常相似，如果在 [] 指定了值，那么创建的是一个数组，反之就是一个切片
创建空切片# 空切片在底层数组包含 0 个元素，也没有分配任何存储空间。一般用于表示空集合。
func createEmptySlice() { slice1 := []int{} slice2 := make([]int, 0) fmt.Println(slice1, slice2) fmt.Println(slice1 == nil, slice2 == nil) }基于数组得到切片# func createSliceByArray() { arr := [...]int{1, 2, 3, 4, 5, 6, 7, 8, 9} fmt.Println(arr) fmt.Println(arr[0:4]) // =&gt;[1 2 3 4] 基于数组得到切片,从0开始到第4个结束（不包含4）.原则：左包含右不包含 fmt.Println(arr[:4]) // =&gt;[1 2 3 4] 省略第一个参数，默认从0开始 fmt.Println(arr[3:]) // =&gt;[4 5 6 7 8 9] 省略第二个参数，默认到len(a1)结束 fmt.Println(arr[:]) // =&gt;[1 2 3 4 5 6 7 8 9] 两个参数都省略，默认从0开始到len(a1-1)结束 }输出：
[1 2 3 4 5 6 7 8 9] [1 2 3 4] [1 2 3 4] [4 5 6 7 8 9] [1 2 3 4 5 6 7 8 9]基于切片得到切片# func createSliceBySlice() { arr := [...]int{1, 2, 3, 4, 5, 6, 7, 8, 9} arr1 := arr[0:4] fmt.Println(arr1) fmt.Printf(&#34;len(s5):%d cap(s5):%d \n&#34;, len(arr1), cap(arr1)) //由切片得到切片 arr2 := arr1[2:4] fmt.Println(arr2) fmt.Printf(&#34;len(s5):%d cap(s5):%d \n&#34;, len(arr2), cap(arr2)) }输出：
">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:url" content="http://localhost:1313/posts/go/06%E5%88%87%E7%89%87/">
  <meta property="og:site_name" content="CODE&#39;NOTE">
  <meta property="og:title" content="CODE&#39;NOTE">
  <meta property="og:description" content="切片定义# func sliceDeclar() { var s1 []int // 定义存放int类型的切片 var s2 []string // 定义存放string类型的切片 fmt.Println(s1, s2) fmt.Println(s1 == nil, s2 == nil) }创建切片和创建数组非常相似，如果在 [] 指定了值，那么创建的是一个数组，反之就是一个切片
创建空切片# 空切片在底层数组包含 0 个元素，也没有分配任何存储空间。一般用于表示空集合。
func createEmptySlice() { slice1 := []int{} slice2 := make([]int, 0) fmt.Println(slice1, slice2) fmt.Println(slice1 == nil, slice2 == nil) }基于数组得到切片# func createSliceByArray() { arr := [...]int{1, 2, 3, 4, 5, 6, 7, 8, 9} fmt.Println(arr) fmt.Println(arr[0:4]) // =&gt;[1 2 3 4] 基于数组得到切片,从0开始到第4个结束（不包含4）.原则：左包含右不包含 fmt.Println(arr[:4]) // =&gt;[1 2 3 4] 省略第一个参数，默认从0开始 fmt.Println(arr[3:]) // =&gt;[4 5 6 7 8 9] 省略第二个参数，默认到len(a1)结束 fmt.Println(arr[:]) // =&gt;[1 2 3 4 5 6 7 8 9] 两个参数都省略，默认从0开始到len(a1-1)结束 }输出：
[1 2 3 4 5 6 7 8 9] [1 2 3 4] [1 2 3 4] [4 5 6 7 8 9] [1 2 3 4 5 6 7 8 9]基于切片得到切片# func createSliceBySlice() { arr := [...]int{1, 2, 3, 4, 5, 6, 7, 8, 9} arr1 := arr[0:4] fmt.Println(arr1) fmt.Printf(&#34;len(s5):%d cap(s5):%d \n&#34;, len(arr1), cap(arr1)) //由切片得到切片 arr2 := arr1[2:4] fmt.Println(arr2) fmt.Printf(&#34;len(s5):%d cap(s5):%d \n&#34;, len(arr2), cap(arr2)) }输出：">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">


  <meta itemprop="name" content="CODE&#39;NOTE">
  <meta itemprop="description" content="切片定义# func sliceDeclar() { var s1 []int // 定义存放int类型的切片 var s2 []string // 定义存放string类型的切片 fmt.Println(s1, s2) fmt.Println(s1 == nil, s2 == nil) }创建切片和创建数组非常相似，如果在 [] 指定了值，那么创建的是一个数组，反之就是一个切片
创建空切片# 空切片在底层数组包含 0 个元素，也没有分配任何存储空间。一般用于表示空集合。
func createEmptySlice() { slice1 := []int{} slice2 := make([]int, 0) fmt.Println(slice1, slice2) fmt.Println(slice1 == nil, slice2 == nil) }基于数组得到切片# func createSliceByArray() { arr := [...]int{1, 2, 3, 4, 5, 6, 7, 8, 9} fmt.Println(arr) fmt.Println(arr[0:4]) // =&gt;[1 2 3 4] 基于数组得到切片,从0开始到第4个结束（不包含4）.原则：左包含右不包含 fmt.Println(arr[:4]) // =&gt;[1 2 3 4] 省略第一个参数，默认从0开始 fmt.Println(arr[3:]) // =&gt;[4 5 6 7 8 9] 省略第二个参数，默认到len(a1)结束 fmt.Println(arr[:]) // =&gt;[1 2 3 4 5 6 7 8 9] 两个参数都省略，默认从0开始到len(a1-1)结束 }输出：
[1 2 3 4 5 6 7 8 9] [1 2 3 4] [1 2 3 4] [4 5 6 7 8 9] [1 2 3 4 5 6 7 8 9]基于切片得到切片# func createSliceBySlice() { arr := [...]int{1, 2, 3, 4, 5, 6, 7, 8, 9} arr1 := arr[0:4] fmt.Println(arr1) fmt.Printf(&#34;len(s5):%d cap(s5):%d \n&#34;, len(arr1), cap(arr1)) //由切片得到切片 arr2 := arr1[2:4] fmt.Println(arr2) fmt.Printf(&#34;len(s5):%d cap(s5):%d \n&#34;, len(arr2), cap(arr2)) }输出：">
  <meta itemprop="wordCount" content="975">

<title>06切片 | CODE&#39;NOTE</title>
<link rel="icon" href="/favicon.png" >
<link rel="manifest" href="/manifest.json">
<link rel="canonical" href="http://localhost:1313/posts/go/06%E5%88%87%E7%89%87/">
<link rel="stylesheet" href="/book.min.6970156cec683193d93c9c4edaf0d56574e4361df2e0c1be4f697ae81c3ba55f.css" integrity="sha256-aXAVbOxoMZPZPJxO2vDVZXTkNh3y4MG&#43;T2l66Bw7pV8=" crossorigin="anonymous">


  <script defer src="/fuse.min.js"></script>
  <script defer src="/en.search.min.3ed9c79c605914c45e19db90edfda0ca8d87c63064c1d6252862250c4e917346.js" integrity="sha256-PtnHnGBZFMReGduQ7f2gyo2HxjBkwdYlKGIlDE6Rc0Y=" crossorigin="anonymous"></script>



  
</head>
<body dir="ltr" class="book-kind-page book-type-posts">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    
<aside class="book-menu">
  <div class="book-menu-content">
    
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><span>CODE&#39;NOTE</span>
  </a>
</h2>


<div class="book-search hidden">
  <input id="book-search-input" type="text" 
    placeholder="Search"
    aria-label="Search"
    maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>
<script>document.querySelector(".book-search").classList.remove("hidden")</script>
























</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>



  </div>
</aside>
 

    <div class="book-page">
      <header class="book-header hidden">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/icons/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <h3>06切片</h3>

  <label for="toc-control">
    
  </label>
</div>


  
 
      </header>

      
      
<article class="markdown book-post">
  <h1>
    06切片
  </h1>
  


  

  


  <div class="book-post-content markdown-inner"><h1 id="切片定义">切片定义<a class="anchor" href="#%e5%88%87%e7%89%87%e5%ae%9a%e4%b9%89">#</a></h1>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sliceDeclar</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">s1</span> []<span style="color:#66d9ef">int</span>    <span style="color:#75715e">// 定义存放int类型的切片</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">s2</span> []<span style="color:#66d9ef">string</span> <span style="color:#75715e">// 定义存放string类型的切片</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s1</span>, <span style="color:#a6e22e">s2</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s1</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">s2</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span>)
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>创建切片和创建数组非常相似，如果在 <code>[]</code> 指定了值，那么创建的是一个数组，反之就是一个切片</p>
<h1 id="创建空切片">创建空切片<a class="anchor" href="#%e5%88%9b%e5%bb%ba%e7%a9%ba%e5%88%87%e7%89%87">#</a></h1>
<p>空切片在底层数组包含 0 个元素，也没有分配任何存储空间。一般用于表示空集合。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">createEmptySlice</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">slice1</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">slice2</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">slice1</span>, <span style="color:#a6e22e">slice2</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">slice1</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">slice2</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span>)
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><h1 id="基于数组得到切片">基于数组得到切片<a class="anchor" href="#%e5%9f%ba%e4%ba%8e%e6%95%b0%e7%bb%84%e5%be%97%e5%88%b0%e5%88%87%e7%89%87">#</a></h1>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">createSliceByArray</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">arr</span> <span style="color:#f92672">:=</span> [<span style="color:#f92672">...</span>]<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">9</span>}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">arr</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">arr</span>[<span style="color:#ae81ff">0</span>:<span style="color:#ae81ff">4</span>]) <span style="color:#75715e">// =&gt;[1 2 3 4] 基于数组得到切片,从0开始到第4个结束（不包含4）.原则：左包含右不包含</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">arr</span>[:<span style="color:#ae81ff">4</span>])  <span style="color:#75715e">// =&gt;[1 2 3 4] 省略第一个参数，默认从0开始</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">arr</span>[<span style="color:#ae81ff">3</span>:])  <span style="color:#75715e">// =&gt;[4 5 6 7 8 9] 省略第二个参数，默认到len(a1)结束</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">arr</span>[:])   <span style="color:#75715e">// =&gt;[1 2 3 4 5 6 7 8 9] 两个参数都省略，默认从0开始到len(a1-1)结束</span>
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>输出：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#f92672">[</span><span style="color:#ae81ff">1</span> <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">4</span> <span style="color:#ae81ff">5</span> <span style="color:#ae81ff">6</span> <span style="color:#ae81ff">7</span> <span style="color:#ae81ff">8</span> 9<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span><span style="color:#ae81ff">1</span> <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">3</span> 4<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span><span style="color:#ae81ff">1</span> <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">3</span> 4<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span><span style="color:#ae81ff">4</span> <span style="color:#ae81ff">5</span> <span style="color:#ae81ff">6</span> <span style="color:#ae81ff">7</span> <span style="color:#ae81ff">8</span> 9<span style="color:#f92672">]</span>      
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span><span style="color:#ae81ff">1</span> <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">4</span> <span style="color:#ae81ff">5</span> <span style="color:#ae81ff">6</span> <span style="color:#ae81ff">7</span> <span style="color:#ae81ff">8</span> 9<span style="color:#f92672">]</span></span></span></code></pre></div><h1 id="基于切片得到切片">基于切片得到切片<a class="anchor" href="#%e5%9f%ba%e4%ba%8e%e5%88%87%e7%89%87%e5%be%97%e5%88%b0%e5%88%87%e7%89%87">#</a></h1>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">createSliceBySlice</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">arr</span> <span style="color:#f92672">:=</span> [<span style="color:#f92672">...</span>]<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">9</span>}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">arr1</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">arr</span>[<span style="color:#ae81ff">0</span>:<span style="color:#ae81ff">4</span>]
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">arr1</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;len(s5):%d cap(s5):%d \n&#34;</span>, len(<span style="color:#a6e22e">arr1</span>), cap(<span style="color:#a6e22e">arr1</span>))
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//由切片得到切片</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">arr2</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">arr1</span>[<span style="color:#ae81ff">2</span>:<span style="color:#ae81ff">4</span>]
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">arr2</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;len(s5):%d cap(s5):%d \n&#34;</span>, len(<span style="color:#a6e22e">arr2</span>), cap(<span style="color:#a6e22e">arr2</span>))
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>输出：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#f92672">[</span><span style="color:#ae81ff">1</span> <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">3</span> 4<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>len<span style="color:#f92672">(</span>s5<span style="color:#f92672">)</span>:4 cap<span style="color:#f92672">(</span>s5<span style="color:#f92672">)</span>:9 
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span><span style="color:#ae81ff">3</span> 4<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>len<span style="color:#f92672">(</span>s5<span style="color:#f92672">)</span>:2 cap<span style="color:#f92672">(</span>s5<span style="color:#f92672">)</span>:7 </span></span></code></pre></div><h1 id="直接创建并初始化">直接创建并初始化<a class="anchor" href="#%e7%9b%b4%e6%8e%a5%e5%88%9b%e5%bb%ba%e5%b9%b6%e5%88%9d%e5%a7%8b%e5%8c%96">#</a></h1>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">createSlice</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">s1</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">67</span>, <span style="color:#ae81ff">88</span>}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">s2</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">string</span>{<span style="color:#e6db74">&#34;北京&#34;</span>, <span style="color:#e6db74">&#34;上海&#34;</span>, <span style="color:#e6db74">&#34;山西&#34;</span>}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s1</span>, <span style="color:#a6e22e">s2</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s1</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">s2</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;len(s1):%d cap(s1):%d \n&#34;</span>, len(<span style="color:#a6e22e">s1</span>), cap(<span style="color:#a6e22e">s1</span>))
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;len(s2):%d cap(s2):%d \n&#34;</span>, len(<span style="color:#a6e22e">s2</span>), cap(<span style="color:#a6e22e">s2</span>))
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><h1 id="使用-make-创建切片">使用 make 创建切片<a class="anchor" href="#%e4%bd%bf%e7%94%a8-make-%e5%88%9b%e5%bb%ba%e5%88%87%e7%89%87">#</a></h1>
<p>以上大部分都是基于数组来创建切片，如果需要动态的创建一个切片，可以使用内置的<code>make()</code>函数，格式如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>make<span style="color:#f92672">([]</span>T, size, cap<span style="color:#f92672">)</span></span></span></code></pre></div><p>其中：</p>
<ul>
<li><code>T</code>:切片的元素类型</li>
<li><code>size</code>:切片中元素的数量</li>
<li><code>cap</code>:切片的容量</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">createSliceByMake</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">slice1</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">string</span>, <span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 使用make创建一个长度5，容量为10的切片</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">slice2</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">string</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">10</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">slice1</span>, <span style="color:#a6e22e">slice2</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// fmt.Println(slice2[6]) // 虽然创建的切片对应底层数组的大小为 10，但是不能访问索引值 5 以后的元素,其实相当于底层数组长度是10但是切片只覆盖到了0~5</span>
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>需要说明的是，切片对应的底层数组的大小为指定的容量。比如对于上面的例子，指定了 <code>slice2</code> 的容量为 10，那么 <code>slice2</code> 对应的底层数组的大小就是 10。虽然创建的切片对应底层数组的大小为 10，但是不能访问索引值 5 以后的元素，比如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span> 	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">slice2</span>[<span style="color:#ae81ff">6</span>])</span></span></code></pre></div><p>输出：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>	panic: runtime error: index out of range <span style="color:#f92672">[</span>6<span style="color:#f92672">]</span> with length <span style="color:#ae81ff">5</span></span></span></code></pre></div><p>虽然创建的切片对应底层数组的大小为 10，但是不能访问索引值 5 以后的元素，其实相当于：底层数组长度是10但是切片 <code>slice2</code> 只覆盖到了 <code>0~5</code>。</p>
<h1 id="切片的长度和容量">切片的长度和容量<a class="anchor" href="#%e5%88%87%e7%89%87%e7%9a%84%e9%95%bf%e5%ba%a6%e5%92%8c%e5%ae%b9%e9%87%8f">#</a></h1>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>    <span style="color:#a6e22e">arr</span> <span style="color:#f92672">:=</span> [<span style="color:#f92672">...</span>]<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">9</span>}</span></span></code></pre></div><p>示例一：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>	<span style="color:#a6e22e">s1</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">arr</span>[<span style="color:#ae81ff">3</span>:] <span style="color:#75715e">// [4 5 6 7 8 9]</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s1</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 切片的长度是元素的个数,切片的容量是底层数组从切片的第一个元素到最后一个元素,</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;len(s1):%d cap(s1):%d \n&#34;</span>, len(<span style="color:#a6e22e">s1</span>), cap(<span style="color:#a6e22e">s1</span>))</span></span></code></pre></div><p>输出：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#f92672">[</span><span style="color:#ae81ff">4</span> <span style="color:#ae81ff">5</span> <span style="color:#ae81ff">6</span> <span style="color:#ae81ff">7</span> <span style="color:#ae81ff">8</span> 9<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>len<span style="color:#f92672">(</span>s1<span style="color:#f92672">)</span>:6 cap<span style="color:#f92672">(</span>s1<span style="color:#f92672">)</span>:6 </span></span></code></pre></div><p>示例二：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>	<span style="color:#a6e22e">s2</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">arr</span>[<span style="color:#ae81ff">4</span>:<span style="color:#ae81ff">8</span>] <span style="color:#75715e">// [5 6 7 8]</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s2</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 切片的长度是元素的个数,所以len=4,切片的容量是底层数组从切片的第一个元素到最后一个元素,所以这里就是从4到9</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;len(s2):%d cap(s2):%d \n&#34;</span>, len(<span style="color:#a6e22e">s2</span>), cap(<span style="color:#a6e22e">s2</span>))</span></span></code></pre></div><p>输出：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#f92672">[</span><span style="color:#ae81ff">5</span> <span style="color:#ae81ff">6</span> <span style="color:#ae81ff">7</span> 8<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>len<span style="color:#f92672">(</span>s2<span style="color:#f92672">)</span>:4 cap<span style="color:#f92672">(</span>s2<span style="color:#f92672">)</span>:5 </span></span></code></pre></div><h1 id="切片的本质">切片的本质<a class="anchor" href="#%e5%88%87%e7%89%87%e7%9a%84%e6%9c%ac%e8%b4%a8">#</a></h1>
<p>切片的本质就是对底层数组的封装，它包含了三个信息：底层数组的指针、切片的长度 <code>len</code> 和切片的容量 <code>cap</code>。参考自：  <a href="https://www.liwenzhou.com/posts/Go/06_slice/">李文周的博客</a></p>
<p>举个例子，现在有一个数组<code>a := [8]int{0, 1, 2, 3, 4, 5, 6, 7}</code>，切片<code>s1 := a[:5]</code>，示意图如下：</p>
<p><img src="https://www.liwenzhou.com/images/Go/slice/slice_01.png" alt="" /></p>
<p>切片<code>s2 := a[3:6]</code>，示意图如下：</p>
<p><img src="https://www.liwenzhou.com/images/Go/slice/slice_02.png" alt="" /></p>
<p><strong>注意</strong>：现在两个切片共享同一个底层数组，因为切片的本质就是对底层数组的封装，所以如果一个切片修改了该底层数组的共享部分，另一个切片也能感知到</p>
<h1 id="切片判断是否为空">切片判断是否为空<a class="anchor" href="#%e5%88%87%e7%89%87%e5%88%a4%e6%96%ad%e6%98%af%e5%90%a6%e4%b8%ba%e7%a9%ba">#</a></h1>
<p>切片之间是不能比较的，不能使用<code>==</code>操作符来判断两个切片是否含有全部相等元素。 切片唯一合法的比较操作是和 <code>nil</code> 比较。 一个 <code>nil</code> 值的切片并没有底层数组，一个 <code>nil</code> 值的切片的长度和容量都是0。但是不能说一个长度和容量都是0的切片一定是 <code>nil</code> ，例如下面的示例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">compareSlice</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">q1</span> []<span style="color:#66d9ef">int</span> <span style="color:#75715e">// len(q1)=0;cap(q1)=0;q1==nil; 没有被初始化所以q1==nil is true</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;len(q1):%d cap(q1):%d q1==nil:%t \n&#34;</span>, len(<span style="color:#a6e22e">q1</span>), cap(<span style="color:#a6e22e">q1</span>), <span style="color:#a6e22e">q1</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">q2</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{} <span style="color:#75715e">// len(q2)=0;cap(q2)=0;q2!=nil; 这里是定义了元素为空的数组,所以q2==nil is false</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;len(q2):%d cap(q2):%d q2==nil:%t \n&#34;</span>, len(<span style="color:#a6e22e">q2</span>), cap(<span style="color:#a6e22e">q2</span>), <span style="color:#a6e22e">q2</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">q3</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">0</span>) <span style="color:#75715e">// len(q3)=0;cap(q3)=0; q3!=nil; 这里使用了make所以十分分配内存的只不过cap和len都为0而已,所以q3==nil is false</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;len(q3):%d cap(q3):%d q3==nil:%t \n&#34;</span>, len(<span style="color:#a6e22e">q3</span>), cap(<span style="color:#a6e22e">q3</span>), <span style="color:#a6e22e">q3</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span>)
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>所以要判断一个切片是否是空的，要是用<code>len(s) == 0</code>来判断，不应该使用<code>s == nil</code>来判断。</p>
<h1 id="切片的赋值拷贝">切片的赋值拷贝<a class="anchor" href="#%e5%88%87%e7%89%87%e7%9a%84%e8%b5%8b%e5%80%bc%e6%8b%b7%e8%b4%9d">#</a></h1>
<p>下面代码演示了拷贝前后两个变量共享底层数组，之前也说过：对一个切片的修改会影响另一个切片的内容，这点需要特别注意。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">shareArraySlice</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">w1</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">3</span>) <span style="color:#75715e">// [0 0 0]</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">w2</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">w1</span>             <span style="color:#75715e">// 将w1直接赋值给w2，w1和w2共用一个底层数组</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">w2</span>[<span style="color:#ae81ff">0</span>] = <span style="color:#ae81ff">100</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">w1</span>) <span style="color:#75715e">// [100 0 0]</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">w2</span>) <span style="color:#75715e">// [100 0 0]</span>
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><h1 id="切片遍历">切片遍历<a class="anchor" href="#%e5%88%87%e7%89%87%e9%81%8d%e5%8e%86">#</a></h1>
<p>切片的遍历方式和数组是一致的，支持索引遍历和<code>for range</code>遍历。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">traversalSlice</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">slice</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">3</span>) <span style="color:#75715e">// [0 0 0]</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; len(<span style="color:#a6e22e">slice</span>); <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">slice</span>[<span style="color:#a6e22e">i</span>])
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">index</span>, <span style="color:#a6e22e">value</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">slice</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">index</span>, <span style="color:#a6e22e">value</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><h1 id="append">append<a class="anchor" href="#append">#</a></h1>
<p>Go语言的内建函数 <code>append()</code> 可以为切片动态添加元素。 可以一次添加一个元素，可以添加多个元素，也可以添加另一个切片中的元素（后面加<code>…</code>）。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">appendSlice</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">slice</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">3</span>)              <span style="color:#75715e">// 创建切片：[0 0 0]</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">slice</span> = append(<span style="color:#a6e22e">slice</span>, <span style="color:#ae81ff">1</span>)             <span style="color:#75715e">// 切片中添加第一个元素 1</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">slice</span> = append(<span style="color:#a6e22e">slice</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>) <span style="color:#75715e">// 继续添加元素 2,3,4,5,6</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">slice2</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">9</span>}             <span style="color:#75715e">// 创建新的切片</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">slice</span> = append(<span style="color:#a6e22e">slice</span>, <span style="color:#a6e22e">slice2</span><span style="color:#f92672">...</span>)     <span style="color:#75715e">// 将新的切片中的元素都放到w3中,这里...代表将slice2中的元素拆分</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">slice</span>)                   <span style="color:#75715e">// 输出：[0 0 0 1 2 3 4 5 6 7 8 9]</span>
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>**注意：**如果使用 <code>append()</code> 切片可以不被初始化,会自动扩容并添加元素。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">s</span> []<span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">s</span> = append(<span style="color:#a6e22e">s</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>)</span></span></code></pre></div><p>每个切片会指向一个底层数组，这个数组的容量够用就添加新增元素。当底层数组不能容纳新增的元素时，切片就会自动按照一定的策略进行“扩容”，此时该切片指向的底层数组就会更换。“扩容”操作往往发生在 <code>append()</code> 函数调用时，所以我们通常都需要用原变量接收append函数的返回值。</p>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">appendDilatationSlice</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">numSlice</span> []<span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">10</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">numSlice</span> = append(<span style="color:#a6e22e">numSlice</span>, <span style="color:#a6e22e">i</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%v  len:%d  cap:%d  ptr:%p\n&#34;</span>, <span style="color:#a6e22e">numSlice</span>, len(<span style="color:#a6e22e">numSlice</span>), cap(<span style="color:#a6e22e">numSlice</span>), <span style="color:#a6e22e">numSlice</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>输出：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#f92672">[</span>0<span style="color:#f92672">]</span>  len:1  cap:1  ptr:0xc000012088
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span><span style="color:#ae81ff">0</span> 1<span style="color:#f92672">]</span>  len:2  cap:2  ptr:0xc0000120d0        
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span><span style="color:#ae81ff">0</span> <span style="color:#ae81ff">1</span> 2<span style="color:#f92672">]</span>  len:3  cap:4  ptr:0xc000010200      
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span><span style="color:#ae81ff">0</span> <span style="color:#ae81ff">1</span> <span style="color:#ae81ff">2</span> 3<span style="color:#f92672">]</span>  len:4  cap:4  ptr:0xc000010200    
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span><span style="color:#ae81ff">0</span> <span style="color:#ae81ff">1</span> <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">3</span> 4<span style="color:#f92672">]</span>  len:5  cap:8  ptr:0xc00000c340  
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span><span style="color:#ae81ff">0</span> <span style="color:#ae81ff">1</span> <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">4</span> 5<span style="color:#f92672">]</span>  len:6  cap:8  ptr:0xc00000c340
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span><span style="color:#ae81ff">0</span> <span style="color:#ae81ff">1</span> <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">4</span> <span style="color:#ae81ff">5</span> 6<span style="color:#f92672">]</span>  len:7  cap:8  ptr:0xc00000c340
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span><span style="color:#ae81ff">0</span> <span style="color:#ae81ff">1</span> <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">4</span> <span style="color:#ae81ff">5</span> <span style="color:#ae81ff">6</span> 7<span style="color:#f92672">]</span>  len:8  cap:8  ptr:0xc00000c340
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span><span style="color:#ae81ff">0</span> <span style="color:#ae81ff">1</span> <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">4</span> <span style="color:#ae81ff">5</span> <span style="color:#ae81ff">6</span> <span style="color:#ae81ff">7</span> 8<span style="color:#f92672">]</span>  len:9  cap:16  ptr:0xc00010e080
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span><span style="color:#ae81ff">0</span> <span style="color:#ae81ff">1</span> <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">4</span> <span style="color:#ae81ff">5</span> <span style="color:#ae81ff">6</span> <span style="color:#ae81ff">7</span> <span style="color:#ae81ff">8</span> 9<span style="color:#f92672">]</span>  len:10  cap:16  ptr:0xc00010e080</span></span></code></pre></div><p>从上面的结果可以看出：</p>
<ol>
<li><code>append()</code>函数将元素追加到切片的最后并返回该切片</li>
<li>切片 <code>numSlice</code> 的容量按照1，2，4，8，16这样的规则自动进行扩容，每次扩容后都是扩容前的2倍</li>
</ol>
<h1 id="切片的扩容策略">切片的扩容策略<a class="anchor" href="#%e5%88%87%e7%89%87%e7%9a%84%e6%89%a9%e5%ae%b9%e7%ad%96%e7%95%a5">#</a></h1>
<p>可以通过查看 <code>$GOROOT/src/runtime/slice.go</code> 源码，其中扩容相关代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">newcap</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">old</span>.<span style="color:#a6e22e">cap</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">doublecap</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">newcap</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">newcap</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 1.首先判断如果新申请容量(cap)大于2倍的旧容量(old.cap):那么最终容量等于新申请的容量(cap)</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#a6e22e">cap</span> &gt; <span style="color:#a6e22e">doublecap</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">newcap</span> = <span style="color:#a6e22e">cap</span>
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 2.否则判断如果旧切片的长度小于1024，则最终容量等于旧容量(old.cap)x2</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">old</span>.<span style="color:#a6e22e">len</span> &lt; <span style="color:#ae81ff">1024</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">newcap</span> = <span style="color:#a6e22e">doublecap</span>
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 3. 否则判断如果旧切片长度大于等于1024 ，则最终容量从旧容量（old.cap）开始循环增加原来的1/4，即 newcap=old.cap,for {newcap += newcap/4} 直到最终容量大于等于新申请的容量cap，即newcap &gt;= cap</span>
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Check 0 &lt; newcap to detect overflow</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// and prevent an infinite loop.</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> <span style="color:#ae81ff">0</span> &lt; <span style="color:#a6e22e">newcap</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">newcap</span> &lt; <span style="color:#a6e22e">cap</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">newcap</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">newcap</span> <span style="color:#f92672">/</span> <span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Set newcap to the requested cap when</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// the newcap calculation overflowed.</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">newcap</span> <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">newcap</span> = <span style="color:#a6e22e">cap</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>从上面的代码可以看出以下内容：</p>
<ol>
<li>
<p>首先判断如果新申请容量  <code>cap</code> 大于2倍的旧容量  <code>old.cap</code>，最终容量  <code>newcap</code> 等于新申请的容量  <code>cap</code></p>
</li>
<li>
<p>否则判断如果旧切片的长度小于 <code>1024</code> ，则最终容量 <code>newcap </code> 等于旧容量  <code>old.cap</code> 的两倍</p>
</li>
<li>
<p>否则判断如果旧切片长度大于等于 <code>1024</code> ，则最终容量 <code>newcap</code> 从旧容量 <code>old.cap</code> 开始循环增加原来的<code>1/4</code>，即 <code>newcap=old.cap,for {newcap += newcap/4} </code>直到最终容量 <code>newcap</code> 大于等于新申请的容量<code>cap</code>，即 <code>newcap &gt;= cap</code></p>
</li>
<li>
<p>如果最终容量  <code>cap</code> 计算值溢出，则最终容量 <code>cap</code>  就是新申请容量 <code>cap</code></p>
</li>
</ol>
<p>需要注意：切片扩容会根据切片中元素的类型不同而做不同的处理，比如 <code>int</code> 和 <code>string</code> 类型的处理方式就不一样。</p>
<h1 id="copy">copy<a class="anchor" href="#copy">#</a></h1>
<p>首先来看一个问题：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>	<span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">a</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">a</span>) <span style="color:#75715e">// [1 2 3 4 5]</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">b</span>) <span style="color:#75715e">// [1 2 3 4 5]</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">b</span>[<span style="color:#ae81ff">0</span>] = <span style="color:#ae81ff">1000</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">a</span>) <span style="color:#75715e">// [1000 2 3 4 5]</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">b</span>) <span style="color:#75715e">// [1000 2 3 4 5]</span></span></span></code></pre></div><p>由于切片是引用类型，所以 <code>a</code> 和 <code>b</code> 其实都指向了同一块内存地址。修改 <code>b</code> 的同时 <code>a</code> 的值也会发生变化。</p>
<p><code>copy()</code>函数可以迅速地将一个切片的数据复制到另外一个切片空间中，使用格式如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>copy(<span style="color:#a6e22e">destSlice</span>, <span style="color:#a6e22e">srcSlice</span> []<span style="color:#a6e22e">T</span>)</span></span></code></pre></div><p>其中：</p>
<ul>
<li><code>srcSlice</code>: 数据来源切片</li>
<li><code>destSlice</code>: 目标切片</li>
</ul>
<p>举个例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>	<span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">d</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>	copy(<span style="color:#a6e22e">d</span>, <span style="color:#a6e22e">c</span>)     <span style="color:#75715e">// 使用copy()函数将切片c1中的元素复制到切片c2</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">c</span>) <span style="color:#75715e">// [1 2 3 4 5]</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">d</span>) <span style="color:#75715e">// [1 2 3 4 5]</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">c</span>[<span style="color:#ae81ff">0</span>] = <span style="color:#ae81ff">1000</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">c</span>) <span style="color:#75715e">// [1000 2 3 4 5]</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">d</span>) <span style="color:#75715e">// [1 2 3 4 5]</span></span></span></code></pre></div><h1 id="从切片中删除元素">从切片中删除元素<a class="anchor" href="#%e4%bb%8e%e5%88%87%e7%89%87%e4%b8%ad%e5%88%a0%e9%99%a4%e5%85%83%e7%b4%a0">#</a></h1>
<p>Go语言中并没有删除切片元素的专用方法，我们可以使用切片本身的特性来删除元素。 代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>	<span style="color:#75715e">// 从切片中删除元素</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">c3</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">30</span>, <span style="color:#ae81ff">31</span>, <span style="color:#ae81ff">32</span>, <span style="color:#ae81ff">33</span>, <span style="color:#ae81ff">34</span>, <span style="color:#ae81ff">35</span>, <span style="color:#ae81ff">36</span>, <span style="color:#ae81ff">37</span>}
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 要删除索引为2的元素32</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">c3</span> = append(<span style="color:#a6e22e">c3</span>[:<span style="color:#ae81ff">2</span>], <span style="color:#a6e22e">c3</span>[<span style="color:#ae81ff">3</span>:]<span style="color:#f92672">...</span>) <span style="color:#75715e">// 其实这就是利用append的特性修改了切片内容再返回</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">c3</span>)                <span style="color:#75715e">// [30 31 33 34 35 36 37]</span></span></span></code></pre></div><p>总结：要从切片c3中删除索引为 <code>index</code> 的元素，操作方法是 <code>c3 = append(c3[:index], c3[index+1:]...)</code></p>
</div>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">
  <div>
  
    <a href="/posts/go/05%E6%95%B0%E7%BB%84/" class="flex align-center">
      <img src="/icons/backward.svg" class="book-icon" alt="Backward" />
      <span>05数组</span>
    </a>
  
  </div>
  <div>
  
    <a href="/posts/go/07map/" class="flex align-center">
      <span>07map</span>
      <img src="/icons/forward.svg" class="book-icon" alt="Forward" />
    </a>
  
  </div>
</div>
 
        
  
 
        
        
  
 
        
  
  
    <script>(function(){document.querySelectorAll("pre:has(code)").forEach(e=>{e.addEventListener("click",e.focus),e.addEventListener("copy",function(t){if(t.preventDefault(),navigator.clipboard){const t=window.getSelection().toString()||e.textContent;navigator.clipboard.writeText(t)}})})})()</script>
  

      </footer>

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
  
 
  </main>

  
</body>
</html>




















