<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="简介# Prometheus 是一个开源的完整监控解决方案，基于中央化的规则计算、统一分析和告警的新模型。 相比于传统监控系统具有以下优点：
易于管理# Prometheus 核心部分只有一个单独的二进制文件，不存在任何的第三方依赖(数据库，缓存等等)。唯一需要的就是本地磁盘，因此不会有潜在级联故障的风险。
Prometheus 基于 Pull 模型的架构方式，可以在任何地方（本地电脑，开发环境，测试环境）搭建监控系统。对于一些复杂的情况，还可以使用服务发现( Service Discovery )的能力动态管理监控目标。
监控服务内部状态# Pometheus 鼓励用户监控服务的内部状态，基于 Prometheus 丰富的 Client 库，可以轻松的在应用程序中添加对 Prometheus 的支持，从而可以获取服务和应用内部真正的运行状态。
强大的数据模型# 所有采集的监控数据均以指标 metric 的形式保存在内置的时间序列数据库当中( TSDB )。所有样本除了基本的指标名称以外，还包含一组用于描述该样本特征的标签。如下所示：
http_request_status{code=&#39;200&#39;,content_path=&#39;/api/path&#39;, environment=&#39;produment&#39;} =&gt; [value1@timestamp1,value2@timestamp2...] http_request_status{code=&#39;200&#39;,content_path=&#39;/api/path2&#39;, environment=&#39;produment&#39;} =&gt; [value1@timestamp1,value2@timestamp2...]每一条时间序列由指标名称( Metrics Name )以及一组标签( Labels )唯一标识。每条时间序列按照时间的先后顺序存储一系列的样本值。
表示维度的标签可能来源于监控对象的状态，比如 code=404 或者 content_path=/api/path 。也可能来源于的环境定义，比如 environment=produment 。基于这些 Labels 可以方便地对监控数据进行聚合，过滤，裁剪。
PromQL 查询# Prometheus 内置了一个强大的数据查询语言 PromQL 。 通过 PromQL 可以实现对监控数据的查询、聚合。同时PromQL 也被应用于数据可视化(如Grafana)以及告警当中。
通过 PromQL 可以轻松回答类似于以下问题：
过去一段时间中95%应用延迟时间的分布范围？ 预测在4小时后，磁盘空间占用大致会是什么情况？ CPU占用率前5位的服务有哪些？(过滤) 高效# 对于监控系统而言，大量的监控任务必然导致有大量的数据产生。而 Prometheus 可以高效地处理这些数据，对于单个 Prometheus Server 实例而言它可以处理：
">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:url" content="http://localhost:1313/posts/prometheus/1.1prometheus%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%AE%89%E8%A3%85/">
  <meta property="og:site_name" content="CODE&#39;NOTE">
  <meta property="og:title" content="CODE&#39;NOTE">
  <meta property="og:description" content="简介# Prometheus 是一个开源的完整监控解决方案，基于中央化的规则计算、统一分析和告警的新模型。 相比于传统监控系统具有以下优点：
易于管理# Prometheus 核心部分只有一个单独的二进制文件，不存在任何的第三方依赖(数据库，缓存等等)。唯一需要的就是本地磁盘，因此不会有潜在级联故障的风险。
Prometheus 基于 Pull 模型的架构方式，可以在任何地方（本地电脑，开发环境，测试环境）搭建监控系统。对于一些复杂的情况，还可以使用服务发现( Service Discovery )的能力动态管理监控目标。
监控服务内部状态# Pometheus 鼓励用户监控服务的内部状态，基于 Prometheus 丰富的 Client 库，可以轻松的在应用程序中添加对 Prometheus 的支持，从而可以获取服务和应用内部真正的运行状态。
强大的数据模型# 所有采集的监控数据均以指标 metric 的形式保存在内置的时间序列数据库当中( TSDB )。所有样本除了基本的指标名称以外，还包含一组用于描述该样本特征的标签。如下所示：
http_request_status{code=&#39;200&#39;,content_path=&#39;/api/path&#39;, environment=&#39;produment&#39;} =&gt; [value1@timestamp1,value2@timestamp2...] http_request_status{code=&#39;200&#39;,content_path=&#39;/api/path2&#39;, environment=&#39;produment&#39;} =&gt; [value1@timestamp1,value2@timestamp2...]每一条时间序列由指标名称( Metrics Name )以及一组标签( Labels )唯一标识。每条时间序列按照时间的先后顺序存储一系列的样本值。
表示维度的标签可能来源于监控对象的状态，比如 code=404 或者 content_path=/api/path 。也可能来源于的环境定义，比如 environment=produment 。基于这些 Labels 可以方便地对监控数据进行聚合，过滤，裁剪。
PromQL 查询# Prometheus 内置了一个强大的数据查询语言 PromQL 。 通过 PromQL 可以实现对监控数据的查询、聚合。同时PromQL 也被应用于数据可视化(如Grafana)以及告警当中。
通过 PromQL 可以轻松回答类似于以下问题：
过去一段时间中95%应用延迟时间的分布范围？ 预测在4小时后，磁盘空间占用大致会是什么情况？ CPU占用率前5位的服务有哪些？(过滤) 高效# 对于监控系统而言，大量的监控任务必然导致有大量的数据产生。而 Prometheus 可以高效地处理这些数据，对于单个 Prometheus Server 实例而言它可以处理：">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">


  <meta itemprop="name" content="CODE&#39;NOTE">
  <meta itemprop="description" content="简介# Prometheus 是一个开源的完整监控解决方案，基于中央化的规则计算、统一分析和告警的新模型。 相比于传统监控系统具有以下优点：
易于管理# Prometheus 核心部分只有一个单独的二进制文件，不存在任何的第三方依赖(数据库，缓存等等)。唯一需要的就是本地磁盘，因此不会有潜在级联故障的风险。
Prometheus 基于 Pull 模型的架构方式，可以在任何地方（本地电脑，开发环境，测试环境）搭建监控系统。对于一些复杂的情况，还可以使用服务发现( Service Discovery )的能力动态管理监控目标。
监控服务内部状态# Pometheus 鼓励用户监控服务的内部状态，基于 Prometheus 丰富的 Client 库，可以轻松的在应用程序中添加对 Prometheus 的支持，从而可以获取服务和应用内部真正的运行状态。
强大的数据模型# 所有采集的监控数据均以指标 metric 的形式保存在内置的时间序列数据库当中( TSDB )。所有样本除了基本的指标名称以外，还包含一组用于描述该样本特征的标签。如下所示：
http_request_status{code=&#39;200&#39;,content_path=&#39;/api/path&#39;, environment=&#39;produment&#39;} =&gt; [value1@timestamp1,value2@timestamp2...] http_request_status{code=&#39;200&#39;,content_path=&#39;/api/path2&#39;, environment=&#39;produment&#39;} =&gt; [value1@timestamp1,value2@timestamp2...]每一条时间序列由指标名称( Metrics Name )以及一组标签( Labels )唯一标识。每条时间序列按照时间的先后顺序存储一系列的样本值。
表示维度的标签可能来源于监控对象的状态，比如 code=404 或者 content_path=/api/path 。也可能来源于的环境定义，比如 environment=produment 。基于这些 Labels 可以方便地对监控数据进行聚合，过滤，裁剪。
PromQL 查询# Prometheus 内置了一个强大的数据查询语言 PromQL 。 通过 PromQL 可以实现对监控数据的查询、聚合。同时PromQL 也被应用于数据可视化(如Grafana)以及告警当中。
通过 PromQL 可以轻松回答类似于以下问题：
过去一段时间中95%应用延迟时间的分布范围？ 预测在4小时后，磁盘空间占用大致会是什么情况？ CPU占用率前5位的服务有哪些？(过滤) 高效# 对于监控系统而言，大量的监控任务必然导致有大量的数据产生。而 Prometheus 可以高效地处理这些数据，对于单个 Prometheus Server 实例而言它可以处理：">
  <meta itemprop="wordCount" content="680">

<title>1.1 Prometheus简介及安装 | CODE&#39;NOTE</title>
<link rel="icon" href="/favicon.png" >
<link rel="manifest" href="/manifest.json">
<link rel="canonical" href="http://localhost:1313/posts/prometheus/1.1prometheus%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%AE%89%E8%A3%85/">
<link rel="stylesheet" href="/book.min.6970156cec683193d93c9c4edaf0d56574e4361df2e0c1be4f697ae81c3ba55f.css" integrity="sha256-aXAVbOxoMZPZPJxO2vDVZXTkNh3y4MG&#43;T2l66Bw7pV8=" crossorigin="anonymous">


  <script defer src="/fuse.min.js"></script>
  <script defer src="/en.search.min.3ed9c79c605914c45e19db90edfda0ca8d87c63064c1d6252862250c4e917346.js" integrity="sha256-PtnHnGBZFMReGduQ7f2gyo2HxjBkwdYlKGIlDE6Rc0Y=" crossorigin="anonymous"></script>



  
</head>
<body dir="ltr" class="book-kind-page book-type-posts">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    
<aside class="book-menu">
  <div class="book-menu-content">
    
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><span>CODE&#39;NOTE</span>
  </a>
</h2>


<div class="book-search hidden">
  <input id="book-search-input" type="text" 
    placeholder="Search"
    aria-label="Search"
    maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>
<script>document.querySelector(".book-search").classList.remove("hidden")</script>
























</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>



  </div>
</aside>
 

    <div class="book-page">
      <header class="book-header hidden">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/icons/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <h3>1.1 Prometheus简介及安装</h3>

  <label for="toc-control">
    
    <img src="/icons/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#prometheus-server">Prometheus Server</a></li>
    <li><a href="#exporters">Exporters</a></li>
    <li><a href="#alertmanager">AlertManager</a></li>
    <li><a href="#pushgateway">PushGateway</a></li>
  </ul>

  <ul>
    <li><a href="#二进制包安装">二进制包安装</a></li>
    <li><a href="#容器安装">容器安装</a></li>
    <li><a href="#浏览器访问">浏览器访问</a></li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
<article class="markdown book-post">
  <h1>
    1.1 Prometheus简介及安装
  </h1>
  


  

  


  <div class="book-post-content markdown-inner"><h1 id="简介">简介<a class="anchor" href="#%e7%ae%80%e4%bb%8b">#</a></h1>
<p>Prometheus 是一个开源的完整监控解决方案，基于中央化的规则计算、统一分析和告警的新模型。 相比于传统监控系统具有以下优点：</p>
<h1 id="易于管理">易于管理<a class="anchor" href="#%e6%98%93%e4%ba%8e%e7%ae%a1%e7%90%86">#</a></h1>
<p>Prometheus 核心部分只有一个单独的二进制文件，不存在任何的第三方依赖(数据库，缓存等等)。唯一需要的就是本地磁盘，因此不会有潜在级联故障的风险。</p>
<p><strong>Prometheus 基于 <code>Pull</code> 模型的架构方式，可以在任何地方（本地电脑，开发环境，测试环境）搭建监控系统</strong>。对于一些复杂的情况，还可以使用服务发现( <code>Service Discovery</code> )的能力动态管理监控目标。</p>
<h1 id="监控服务内部状态">监控服务内部状态<a class="anchor" href="#%e7%9b%91%e6%8e%a7%e6%9c%8d%e5%8a%a1%e5%86%85%e9%83%a8%e7%8a%b6%e6%80%81">#</a></h1>
<p>Pometheus 鼓励用户监控服务的内部状态，基于 Prometheus 丰富的 Client 库，可以轻松的在应用程序中添加对 Prometheus 的支持，从而可以获取服务和应用内部真正的运行状态。</p>
<p><img src="https://www.prometheus.wang/quickstart/static/monitor-internal.png" alt="监控服务内部运行状态" /></p>
<h1 id="强大的数据模型">强大的数据模型<a class="anchor" href="#%e5%bc%ba%e5%a4%a7%e7%9a%84%e6%95%b0%e6%8d%ae%e6%a8%a1%e5%9e%8b">#</a></h1>
<p>所有采集的监控数据均以指标 <code>metric</code> 的形式保存在内置的时间序列数据库当中( <code>TSDB</code> )。所有样本除了基本的指标名称以外，还包含一组用于描述该样本特征的标签。如下所示：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>http_request_status<span style="color:#f92672">{</span>code<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;200&#39;</span>,content_path<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;/api/path&#39;</span>, environment<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;produment&#39;</span><span style="color:#f92672">}</span> <span style="color:#f92672">=</span>&gt; <span style="color:#f92672">[</span>value1@timestamp1,value2@timestamp2...<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>http_request_status<span style="color:#f92672">{</span>code<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;200&#39;</span>,content_path<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;/api/path2&#39;</span>, environment<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;produment&#39;</span><span style="color:#f92672">}</span> <span style="color:#f92672">=</span>&gt; <span style="color:#f92672">[</span>value1@timestamp1,value2@timestamp2...<span style="color:#f92672">]</span></span></span></code></pre></div><p>每一条时间序列由指标名称( <code>Metrics Name</code> )以及一组标签( <code>Labels</code> )唯一标识。每条时间序列按照时间的先后顺序存储一系列的样本值。</p>
<p>表示维度的标签可能来源于监控对象的状态，比如 <code>code=404</code> 或者 <code>content_path=/api/path</code> 。也可能来源于的环境定义，比如 <code>environment=produment</code> 。基于这些 <code>Labels</code> 可以方便地对监控数据进行聚合，过滤，裁剪。</p>
<h1 id="promql-查询">PromQL 查询<a class="anchor" href="#promql-%e6%9f%a5%e8%af%a2">#</a></h1>
<p>Prometheus 内置了一个强大的数据查询语言 <code>PromQL</code> 。 通过 PromQL 可以实现对监控数据的查询、聚合。同时PromQL 也被应用于数据可视化(如Grafana)以及告警当中。</p>
<p>通过 PromQL 可以轻松回答类似于以下问题：</p>
<ul>
<li>过去一段时间中95%应用延迟时间的分布范围？</li>
<li>预测在4小时后，磁盘空间占用大致会是什么情况？</li>
<li>CPU占用率前5位的服务有哪些？(过滤)</li>
</ul>
<h1 id="高效">高效<a class="anchor" href="#%e9%ab%98%e6%95%88">#</a></h1>
<p>对于监控系统而言，大量的监控任务必然导致有大量的数据产生。而 Prometheus 可以高效地处理这些数据，对于单个 Prometheus Server 实例而言它可以处理：</p>
<ul>
<li>数以百万的监控指标</li>
<li>每秒处理数十万的数据点</li>
</ul>
<h1 id="可扩展">可扩展<a class="anchor" href="#%e5%8f%af%e6%89%a9%e5%b1%95">#</a></h1>
<p>Prometheus 非常简单，因此可以在每个数据中心、每个团队运行独立的 Prometheus Sevrer。Prometheus 对于联邦集群的支持，可以让多个 Prometheus 实例产生一个逻辑集群，当单实例 Prometheus Server 处理的任务量过大时，通过使用功能分区( sharding )+联邦集群( federation )对其进行扩展。</p>
<h1 id="易于集成">易于集成<a class="anchor" href="#%e6%98%93%e4%ba%8e%e9%9b%86%e6%88%90">#</a></h1>
<p>使用 Prometheus 可以快速搭建监控服务，并且可以非常方便地在应用程序中进行集成。目前支持： <code>Java</code>， <code>JMX</code>， <code>Python</code>， <code>Go</code>，<code>Ruby</code>， <code>.Net</code>， <code>Node.js</code> 等语言的客户端SDK，基于这些SDK可以快速让应用程序纳入到 Prometheus 的监控当中，或者开发自己的监控数据收集程序。同时这些客户端收集的监控数据，不仅仅支持Prometheus，还能支持 Graphite 这些其他的监控工具。</p>
<blockquote class='book-hint '>
<p>Prometheus还支持与其他的监控系统进行集成：Graphite， Statsd， Collected， Scollector， muini， Nagios 等。</p>
</blockquote><p>Prometheus 社区还提供了大量第三方实现的监控数据采集支持：JMX， CloudWatch， EC2， MySQL， PostgresSQL， Haskell， Bash， SNMP， Consul， Haproxy， Mesos， Bind， CouchDB， Django， Memcached， RabbitMQ， Redis， RethinkDB， Rsyslog 等等。</p>
<h1 id="可视化">可视化<a class="anchor" href="#%e5%8f%af%e8%a7%86%e5%8c%96">#</a></h1>
<p>Prometheus Server 中自带了一个 <code>Prometheus UI</code> ，通过这个UI可以方便地直接对数据进行查询，并且支持直接以图形化的形式展示数据。同时 Prometheus 还提供了一个独立的基于 <code>Ruby On Rails</code> 的 Dashboard 解决方案<code>Promdash</code>。最新的 <code>Grafana</code> 可视化工具也已经提供了完整的 Prometheus 支持，基于 Grafana 可以创建更加精美的监控图标。基于 Prometheus 提供的API还可以实现自己的监控可视化UI。r</p>
<h1 id="开放性">开放性<a class="anchor" href="#%e5%bc%80%e6%94%be%e6%80%a7">#</a></h1>
<p>通常来说当需要监控一个应用程序时，一般需要该应用程序提供对相应监控系统协议的支持。因此应用程序会与所选择的监控系统进行绑定。为了减少这种绑定所带来的限制。对于决策者而言要么直接在应用中集成该监控系统的支持，要么就在外部创建单独的服务来适配不同的监控系统。</p>
<p>而对于 Prometheus 来说，使用 Prometheus 的 client library 的输出格式不止支持 Prometheus 的格式化数据，也可以输出支持其它监控系统的格式化数据，比如Graphite。</p>
<blockquote class='book-hint '>
<p>甚至可以在不使用 Prometheus 的情况下，采用Prometheus的 client library 来让应用程序支持监控数据采集</p>
</blockquote><h1 id="prometheus-架构">Prometheus 架构<a class="anchor" href="#prometheus-%e6%9e%b6%e6%9e%84">#</a></h1>
<p>这里从 Prometheus 的架构角度了解一下 Prometheus 生态中的各个组件，下图展示 Prometheus 的基本架构：</p>
<p><img src="/images/2022-07-04-16-38-34.png" alt="" /></p>
<h2 id="prometheus-server">Prometheus Server<a class="anchor" href="#prometheus-server">#</a></h2>
<p>Prometheus Server 是 Prometheus 组件中的核心部分，负责实现对监控数据的获取，存储以及查询。</p>
<p>Prometheus Server 可以通过静态配置管理监控目标，也可以配合使用 <code>Service Discovery</code> 的方式动态管理监控目标，并从这些监控目标中获取数据。</p>
<p>Prometheus Server 需要对采集到的监控数据进行存储，Prometheus Server 本身就是一个时序数据库，将采集到的监控数据按照时间序列的方式存储在本地磁盘当中。</p>
<p>Prometheus Server 对外提供了自定义的 <code>PromQL</code> 语言，实现对数据的查询以及分析。 内置的 <code>Express Browser UI</code>，通过这个UI可以直接通过 PromQL 实现数据的查询以及可视化。</p>
<p>Prometheus Server 的联邦集群能力可以使其从其他的 Prometheus Server 实例中获取数据，因此在大规模监控的情况下，可以通过联邦集群以及功能分区的方式对 Prometheus Server 进行扩展。</p>
<h2 id="exporters">Exporters<a class="anchor" href="#exporters">#</a></h2>
<p>Exporter 将监控数据采集的端点通过HTTP服务的形式暴露给 Prometheus Server，Prometheus Server 通过访问该Exporter 提供的 Endpoint 端点，即可获取到需要采集的监控数据。</p>
<p>一般可以将 Exporter 分为两类：</p>
<ul>
<li>直接采集：这一类 Exporter 直接内置了对 Prometheus 监控的支持，比如 <code>cAdvisor</code>，<code>Kubernetes</code>，<code>Etcd</code>，<code>Gokit</code>等，都直接内置了用于向 Prometheus 暴露监控数据的端点</li>
<li>间接采集：原有监控目标并不直接支持 Prometheus，需要通过 Prometheus 提供的 <code>Client Library</code> 编写该监控目标的监控采集程序。例如： <code>Mysql Exporter</code>，<code>JMX Exporter</code>，<code>Consul Exporter</code> 等</li>
</ul>
<h2 id="alertmanager">AlertManager<a class="anchor" href="#alertmanager">#</a></h2>
<p>在 Prometheus Server 中支持基于 <code>PromQL</code> 创建告警规则，如果满足 PromQL 定义的规则，则会产生一条告警，而告警的后续处理流程则由 <code>AlertManager</code> 进行管理。在 AlertManager 中可以与邮件，Slack等等内置的通知方式进行集成，也可以通过 <code>Webhook</code> 自定义告警处理方式。AlertManager 是 Prometheus 体系中的告警处理中心。</p>
<h2 id="pushgateway">PushGateway<a class="anchor" href="#pushgateway">#</a></h2>
<p>由于 Prometheus 数据采集基于 <code>Pull</code> 模型进行设计，因此在网络环境的配置上必须要让 Prometheus Server 能够直接与 Exporter 进行通信。 当这种网络需求无法直接满足时，就可以利用 <code>PushGateway</code> 来进行中转。通过 PushGateway 将内部网络的监控数据主动 <code>Push</code> 到 Gateway 当中。而 Prometheus Server 同样采用 Pull 的方式从 PushGateway 中获取到监控数据。</p>
<h1 id="prometheus--安装">Prometheus  安装<a class="anchor" href="#prometheus--%e5%ae%89%e8%a3%85">#</a></h1>
<p>Prometheus 基于 <code>Golang</code> 编写，编译后的软件包，不依赖于任何的第三方依赖。用户只需要下载对应平台的二进制包，解压并且添加基本的配置即可正常启动 Prometheus Server。</p>
<h2 id="二进制包安装">二进制包安装<a class="anchor" href="#%e4%ba%8c%e8%bf%9b%e5%88%b6%e5%8c%85%e5%ae%89%e8%a3%85">#</a></h2>
<p>对于非 Docker 用户，可以从 <a href="https://prometheus.io/download/">https://prometheus.io/download/</a> 找到最新版本的 Prometheus Sevrer 软件包：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>curl -LO https://github.com/prometheus/prometheus/releases/download/v2.36.2/prometheus-2.36.2.linux-amd64.tar.gz</span></span></code></pre></div><p>解压，并将 Prometheus 相关的命令，添加到系统环境变量路径即可：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>tar -xzf prometheus-2.36.2.linux-amd64.tar.gz
</span></span><span style="display:flex;"><span>cd prometheus-2.36.2.linux-amd64</span></span></code></pre></div><p>解压后当前目录会包含默认的 Prometheus 配置文件 <code>promethes.yml</code></p>
<pre tabindex="0"><code># my global config
global:
  scrape_interval:     15s # Set the scrape interval to every 15 seconds. Default is every 1 minute.
  evaluation_interval: 15s # Evaluate rules every 15 seconds. The default is every 1 minute.
  # scrape_timeout is set to the global default (10s).

# Alertmanager configuration
alerting:
  alertmanagers:
  - static_configs:
    - targets:
      # - alertmanager:9093

# Load rules once and periodically evaluate them according to the global &#39;evaluation_interval&#39;.
rule_files:
  # - &#34;first_rules.yml&#34;
  # - &#34;second_rules.yml&#34;

# A scrape configuration containing exactly one endpoint to scrape:
# Here it&#39;s Prometheus itself.
scrape_configs:
  # The job name is added as a label `job=&lt;job_name&gt;` to any timeseries scraped from this config.
  - job_name: &#39;prometheus&#39;

    # metrics_path defaults to &#39;/metrics&#39;
    # scheme defaults to &#39;http&#39;.

    static_configs:
    - targets: [&#39;localhost:9090&#39;]</code></pre><p>Promtheus 作为一个时间序列数据库，其采集的数据会以文件的形似存储在本地中，默认的存储路径为 <code>data/</code>，因此需要先手动创建该目录：</p>
<pre tabindex="0"><code>mkdir -p data</code></pre><p>也可以通过参数 <code>--storage.tsdb.path=&quot;data/&quot;</code> 修改本地数据存储的路径。</p>
<p>启动 Prometheus 服务，其会默认加载当前路径下的 <code>prometheus.yaml</code> 文件：</p>
<pre tabindex="0"><code>./prometheus</code></pre><p>正常的情况下，可以看到以下输出内容：</p>
<pre tabindex="0"><code>level=info ts=2018-10-23T14:55:14.499484Z caller=main.go:554 msg=&#34;Starting TSDB ...&#34;
level=info ts=2018-10-23T14:55:14.499531Z caller=web.go:397 component=web msg=&#34;Start listening for connections&#34; address=0.0.0.0:9090
level=info ts=2018-10-23T14:55:14.507999Z caller=main.go:564 msg=&#34;TSDB started&#34;
level=info ts=2018-10-23T14:55:14.508068Z caller=main.go:624 msg=&#34;Loading configuration file&#34; filename=prometheus.yml
level=info ts=2018-10-23T14:55:14.509509Z caller=main.go:650 msg=&#34;Completed loading of configuration file&#34; filename=prometheus.yml
level=info ts=2018-10-23T14:55:14.509537Z caller=main.go:523 msg=&#34;Server is ready to receive web requests.&#34;</code></pre><h2 id="容器安装">容器安装<a class="anchor" href="#%e5%ae%b9%e5%99%a8%e5%ae%89%e8%a3%85">#</a></h2>
<p>对于 Docker 用户，直接使用 Prometheus 的镜像即可启动Prometheus Server：</p>
<p>在 <code>etc</code> 下创建目录 <code>prometheus</code> ：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#f92672">[</span>root@wangpengliang100ecs ~<span style="color:#f92672">]</span><span style="color:#75715e"># cd /etc/</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>root@wangpengliang100ecs etc<span style="color:#f92672">]</span><span style="color:#75715e"># mkdir prometheus</span></span></span></code></pre></div><p>设置权限目录：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>chown -R root:root /etc/prometheus</span></span></code></pre></div><p>手动创建 <code>prometheus.yml</code>配置文件，内容如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yml" data-lang="yml"><span style="display:flex;"><span><span style="color:#75715e"># my global config</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">global</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">scrape_interval</span>:     <span style="color:#ae81ff">15s</span> <span style="color:#75715e"># Set the scrape interval to every 15 seconds. Default is every 1 minute.</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">evaluation_interval</span>: <span style="color:#ae81ff">15s</span> <span style="color:#75715e"># Evaluate rules every 15 seconds. The default is every 1 minute.</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># scrape_timeout is set to the global default (10s).</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Alertmanager configuration</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">alerting</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">alertmanagers</span>:
</span></span><span style="display:flex;"><span>  - <span style="color:#f92672">static_configs</span>:
</span></span><span style="display:flex;"><span>    - <span style="color:#f92672">targets</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#75715e"># - alertmanager:9093</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Load rules once and periodically evaluate them according to the global &#39;evaluation_interval&#39;.</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">rule_files</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># - &#34;first_rules.yml&#34;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># - &#34;second_rules.yml&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># A scrape configuration containing exactly one endpoint to scrape:</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Here it&#39;s Prometheus itself.</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">scrape_configs</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># The job name is added as a label `job=&lt;job_name&gt;` to any timeseries scraped from this config.</span>
</span></span><span style="display:flex;"><span>  - <span style="color:#f92672">job_name</span>: <span style="color:#e6db74">&#39;prometheus&#39;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># metrics_path defaults to &#39;/metrics&#39;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># scheme defaults to &#39;http&#39;.</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">static_configs</span>:
</span></span><span style="display:flex;"><span>    - <span style="color:#f92672">targets</span>: [<span style="color:#e6db74">&#39;localhost:9090&#39;</span>]</span></span></code></pre></div><p>启动容器：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker run -d --name prometheus -p 9090:9090 -v /etc/prometheus/prometheus.yml:/etc/prometheus/prometheus.yml prom/prometheus</span></span></code></pre></div><h2 id="浏览器访问">浏览器访问<a class="anchor" href="#%e6%b5%8f%e8%a7%88%e5%99%a8%e8%ae%bf%e9%97%ae">#</a></h2>
<p>启动完成后，可以通过 http://ipaddress:9090 访问 Prometheus 的UI界面：</p>
<p><img src="/images/2022-07-04-19-49-09.png" alt="" /></p>
</div>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">
  <div>
  
    <a href="/posts/microservice/consul%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0/" class="flex align-center">
      <img src="/icons/backward.svg" class="book-icon" alt="Backward" />
      <span>Consul服务注册发现</span>
    </a>
  
  </div>
  <div>
  
    <a href="/posts/prometheus/1.2exporter%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86/" class="flex align-center">
      <span>1.2 Exporter数据采集</span>
      <img src="/icons/forward.svg" class="book-icon" alt="Forward" />
    </a>
  
  </div>
</div>
 
        
  
 
        
        
  
 
        
  
  
    <script>(function(){document.querySelectorAll("pre:has(code)").forEach(e=>{e.addEventListener("click",e.focus),e.addEventListener("copy",function(t){if(t.preventDefault(),navigator.clipboard){const t=window.getSelection().toString()||e.textContent;navigator.clipboard.writeText(t)}})})})()</script>
  

      </footer>

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
  
  <aside class="book-toc">
    <div class="book-toc-content">
      
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#prometheus-server">Prometheus Server</a></li>
    <li><a href="#exporters">Exporters</a></li>
    <li><a href="#alertmanager">AlertManager</a></li>
    <li><a href="#pushgateway">PushGateway</a></li>
  </ul>

  <ul>
    <li><a href="#二进制包安装">二进制包安装</a></li>
    <li><a href="#容器安装">容器安装</a></li>
    <li><a href="#浏览器访问">浏览器访问</a></li>
  </ul>
</nav>



    </div>
  </aside>
  
 
  </main>

  
</body>
</html>




















