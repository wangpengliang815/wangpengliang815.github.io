<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">

    
      <link rel="icon" href="/favicon.png" />
    

    <title>
        
          Wang’Notes’
        
    </title>

    <!-- Spectre.css framework -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/spectre.css/0.5.9/spectre.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/spectre.css/0.5.9/spectre-exp.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/spectre.css/0.5.9/spectre-icons.min.css">

    <!-- theme css & js -->
    
<link rel="stylesheet" href="/css/book.css">

    
<script src="/js/book.js"></script>


    <!-- tocbot -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css">
    
    <!-- katex -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">

    
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/zooming/2.1.1/zooming.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    const zooming = new Zooming()
    zooming.listen('.book-content img')
})
</script>

<meta name="generator" content="Hexo 5.4.0"></head>

  <body>

    <div class="book-container">
      <div class="book-sidebar">
        <div class="book-brand">
  <a href="/">
    <img src="/favicon.png">
    <span>WANG’NOTES’</span>
  </a>
</div>
          <div id="menu" class="book-menu hide">
  <ul>
<li><a href="/index">Home</a></li>
</ul>
<h2 id="DotNET">DotNET</h2>
<ul>
<li><a href="/dotnet/%E5%9F%BA%E7%A1%80%E5%90%88%E9%9B%86">基础合集</a></li>
<li><a href="/dotnet/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">数据结构</a></li>
<li><a href="/dotnet/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1">类和对象</a></li>
<li><a href="/dotnet/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1">面向对象</a></li>
<li><a href="/dotnet/%E6%B3%9B%E5%9E%8B%E6%8A%80%E6%9C%AF">泛型技术</a></li>
<li><a href="/dotnet/%E5%8F%8D%E5%B0%84%E6%8A%80%E6%9C%AF%E5%AE%9E%E8%B7%B5">反射技术实践</a></li>
<li><a href="/dotnet/%E5%A7%94%E6%89%98%E5%92%8C%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3">委托和事件详解</a></li>
<li><a href="/dotnet/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91">多线程开发</a></li>
<li><a href="/dotnet/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%8A%80%E6%9C%AF">多线程之线程同步技术</a></li>
<li><a href="/dotnet/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B">异步编程async/await</a></li>
<li><a href="/dotnet/%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D">值类型和引用类型的内存分配</a></li>
<li><a href="/dotnet/%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B">并行编程</a></li>
</ul>
<h2 id="DotNET-Core">DotNET Core</h2>
<ul>
<li><a href="/%E5%9F%BA%E7%A1%80/1">分布式事务</a></li>
<li><a href="/%E5%9F%BA%E7%A1%80/1">分布式锁</a></li>
</ul>
<h2 id="Asp-Net-Mvc"><a target="_blank" rel="noopener" href="http://Asp.Net">Asp.Net</a> Mvc</h2>
<ul>
<li><a href="/%E5%9F%BA%E7%A1%80/1">分布式事务</a></li>
<li><a href="/%E5%9F%BA%E7%A1%80/1">分布式锁</a></li>
</ul>
<h2 id="DataProtection">DataProtection</h2>
<ul>
<li><a href="">1.1 DataProtection简介</a></li>
<li><a href="">1.2 DataProtection方法介绍</a></li>
<li><a href="">1.3 落地实践及多环境调试</a></li>
<li><a href="">1.4 UserSecrets</a></li>
<li><a href="">1.5 基于DataProtection的数据保护方案</a></li>
<li><a href="">1.6 方案实践及集成AzureDevops管道</a></li>
</ul>
<h2 id="Linux">Linux</h2>
<ul>
<li><a href="/linux/Centos%E5%AE%89%E8%A3%85">Centos安装</a></li>
<li><a href="/linux/Centos%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE">Centos网络配置</a></li>
<li><a href="/linux/Centos7%E5%8D%87%E7%BA%A7gcc%E7%89%88%E6%9C%AC">Centos7升级gcc版本</a></li>
<li><a href="/linux/Linux%E7%9B%AE%E5%BD%95%E8%AF%B4%E6%98%8E">Linux目录说明</a></li>
<li><a href="/linux/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4">Linux常用命令</a></li>
</ul>
<h2 id="Redis">Redis</h2>
<ul>
<li><a href="/redis/1.1NoSql%E6%A6%82%E8%BF%B0">1.1 NoSql概述</a></li>
<li><a href="/redis/1.2Redis%E5%AE%89%E8%A3%85">1.2 Redis安装</a></li>
<li><a href="/redis/1.3Redis%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">1.3 Redis基本数据类型</a></li>
<li><a href="/redis/1.4Redis%E7%89%B9%E6%AE%8A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">1.4 Redis特殊数据类型</a></li>
<li><a href="/redis/1.5Redis%E4%BA%8B%E5%8A%A1%E6%93%8D%E4%BD%9C">1.5 Redis事务操作</a></li>
<li><a href="/redis/1.6Redis%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3">1.6 Redis配置文件详解</a></li>
<li><a href="/redis/1.7Redis%E6%8C%81%E4%B9%85%E5%8C%96">1.7 Redis持久化</a></li>
<li><a href="/redis/1.8Redis%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85">1.8 Redis发布订阅</a></li>
<li><a href="/redis/1.9Redis%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88">1.9 Redis集群方案</a></li>
<li><a href="/redis/1.10Redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98">1.10 Redis常见问题</a></li>
<li><a href="/redis/%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9E%E6%8E%A5Redis">客户端连接Redis</a></li>
<li><a href="/redis/%E4%BD%BF%E7%94%A8Docker%E6%90%AD%E5%BB%BARedis%E9%9B%86%E7%BE%A4">使用Docker搭建Redis集群</a></li>
</ul>
<h2 id="RabbitMQ">RabbitMQ</h2>
<ul>
<li><a href="/rabbitMq/1.1RabbitMQ%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%89%E8%A3%85">1.1 RabbitMQ概念及安装</a></li>
<li><a href="/rabbitMq/1.2%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D">1.2 工作模式介绍</a></li>
<li><a href="/rabbitMq/1.3%E6%B6%88%E6%81%AF%E7%A1%AE%E8%AE%A4%E5%8F%8A%E6%8C%81%E4%B9%85%E5%8C%96">1.3 消息确认及持久化</a></li>
<li><a href="/rabbitMq/1.4%E4%B8%A4%E7%A7%8D%E6%B6%88%E8%B4%B9%E6%A8%A1%E5%BC%8F%E5%92%8CQOS%E7%9A%84%E5%AE%9E%E7%8E%B0">1.4 两种消费模式和QOS的实现</a></li>
<li><a href="/rabbitMq/1.5Channel%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95">1.5 Channel常见方法</a></li>
<li><a href="/rabbitMq/1.6RabbitMQ%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4">1.6 RabbitMQ常用命令</a></li>
<li><a href="/rabbitMq/1.7RabbitMQ%E5%B8%B8%E8%A7%81%E7%AD%96%E7%95%A5">1.7 RabbitMQ常见策略</a></li>
<li><a href="/rabbitMq/1.8RabbitMQ%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98">1.8 RabbitMQ常见问题</a></li>
<li><a href="/rabbitMq/1.9RabbitMQ%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88">1.9 RabbitMQ集群方案</a></li>
<li><a href="/rabbitMq/%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9E%E6%8E%A5RabbitMQ">客户端连接RabbitMQ</a></li>
</ul>
<h2 id="Docker">Docker</h2>
<ul>
<li><a href="/docker/1.1Docker%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%89%E8%A3%85">1.1 Docker概念及安装</a></li>
<li><a href="/docker/1.2Docker%E9%95%9C%E5%83%8F(Image)">1.2 Docker镜像(Image)</a></li>
<li><a href="/docker/1.3Docker%E5%AE%B9%E5%99%A8(Container)">1.3 Docker容器(Container)</a></li>
<li><a href="/docker/1.4Docker%E4%BB%93%E5%BA%93(Repository)">1.4 Docker仓库(Repository)</a></li>
<li><a href="/docker/1.5Docker%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86">1.5 Docker数据管理</a></li>
<li><a href="/docker/1.6Docker%E5%AE%B9%E5%99%A8%E5%9B%9B%E7%A7%8D%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F">1.6 Docker容器四种网络模式</a></li>
<li><a href="/docker/1.7Docker%E9%AB%98%E7%BA%A7%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE">1.7 Docker高级网络配置</a></li>
<li><a href="/docker/1.8Dockerfile">1.8 Dockerfile</a></li>
<li><a href="/docker/1.9Docker%E4%B8%89%E5%89%91%E5%AE%A2%E4%B9%8BDockerCompose">1.9 Docker三剑客之DockerCompose</a></li>
<li><a href="/docker/2.0Docker%E4%B8%89%E5%89%91%E5%AE%A2%E4%B9%8BDockerMachine">2.0 Docker三剑客之DockerMachine</a></li>
<li><a href="/docker/2.1Docker%E4%B8%89%E5%89%91%E5%AE%A2%E4%B9%8BDockerSwarm">2.1 Docker三剑客之DockerSwarm</a></li>
<li><a href="/docker/2.2Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4">2.2 Docker常用命令</a></li>
<li><a href="/docker/Portainer%E5%8F%AF%E8%A7%86%E5%8C%96%E9%9D%A2%E6%9D%BF">Portainer可视化面板</a></li>
</ul>
<h2 id="分布式相关">分布式相关</h2>
<ul>
<li><a href="/%E5%9F%BA%E7%A1%80/1">分布式事务</a></li>
<li><a href="/%E5%9F%BA%E7%A1%80/1">分布式锁</a></li>
<li><a href="/%E5%9F%BA%E7%A1%80/1">分布式缓存</a></li>
<li><a href="/distributed/Consul%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E8%AE%B0%E5%BD%95">Consul 相关知识记录</a></li>
</ul>
<h2 id="UnitTest">UnitTest</h2>
<ul>
<li><a href="/%E5%9F%BA%E7%A1%80/1">Categories</a></li>
</ul>
<h2 id="23种设计模式">23种设计模式</h2>
<ul>
<li><a href="/%E5%9F%BA%E7%A1%80/1">Categories</a></li>
</ul>
<h2 id="SonarQube-代码质量把控">SonarQube 代码质量把控</h2>
<ul>
<li><a href="/%E5%9F%BA%E7%A1%80/1">Categories</a></li>
</ul>
<h2 id="Devops工具-AzureDevops">Devops工具 AzureDevops</h2>
<ul>
<li><a href="/%E5%9F%BA%E7%A1%80/1">Categories</a></li>
</ul>
<h2 id="Devops工具-Jenkins">Devops工具 Jenkins</h2>
<ul>
<li><a href="/%E5%9F%BA%E7%A1%80/1">Categories</a></li>
</ul>
<h2 id="Devops工具-Jenkins-v2">Devops工具 Jenkins</h2>
<ul>
<li><a href="/%E5%9F%BA%E7%A1%80/1">Categories</a></li>
</ul>
<h2 id="示例项目：Microservice-Sample">示例项目：Microservice.Sample</h2>
<ul>
<li><a href="/sample/microservice/1.1%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8%E4%B9%8B%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA">1.1 微服务入门：项目搭建</a></li>
<li><a href="/sample/microservice/1.2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8%E4%B9%8B%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0">1.2 微服务入门：服务注册与发现（Consul）</a></li>
<li><a href="/sample/microservice/1.3%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8%E4%B9%8B%E7%BD%91%E5%85%B3">1.3 微服务入门：网关（Ocelot）</a></li>
<li><a href="/sample/microservice/1.4%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8%E4%B9%8B%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF">1.4 微服务入门：事件总线（CAP）</a></li>
<li><a href="/sample/microservice/1.5%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8%E4%B9%8BDockerCompose">1.5 微服务入门：DockerCompose</a></li>
</ul>

</div>


<script src="/js/book-menu.js"></script>

      </div>

      <div class="sidebar-toggle" onclick="sidebar_toggle()" onmouseover="add_inner()" onmouseleave="remove_inner()">
  <div class="sidebar-toggle-inner"></div>
</div>

<script>
function add_inner() {
  let inner = document.querySelector('.sidebar-toggle-inner')
  inner.classList.add('show')  
}

function remove_inner() {
  let inner = document.querySelector('.sidebar-toggle-inner')
  inner.classList.remove('show')
}

function sidebar_toggle() {
    let sidebar_toggle = document.querySelector('.sidebar-toggle')
    let sidebar = document.querySelector('.book-sidebar')
    let content = document.querySelector('.off-canvas-content')
    if (sidebar_toggle.classList.contains('extend')) { // show
        sidebar_toggle.classList.remove('extend')
        sidebar.classList.remove('hide')
        content.classList.remove('extend')
    }
    else { // hide
        sidebar_toggle.classList.add('extend')
        sidebar.classList.add('hide')
        content.classList.add('extend')
    }
}
</script>

        <div class="off-canvas-content">
          <div class="columns">
            <div class="column col-10 col-lg-12">
              <div class="book-navbar">
                <!-- For Responsive Layout -->

<header class="navbar">
  <section class="navbar-section">
    <a onclick="open_sidebar()">
      <i class="icon icon-menu"></i>
    </a>
  </section>
</header>

              </div>
              <div class="book-content">
                
<article id="page">
  <h1></h1>
  <p>对于多线程，经常使用的是<code>Thread</code>。在了解<code>Task</code>之前，如果要使用多核的功能可能就会自己来开线程，然而这种线程模型在<code>.net 4.0</code>之后被一种称为<code>基于“任务的编程模型”</code>所冲击，这就是<code>Task</code>。</p>
<p><code>Task</code>会比<code>Thread</code>具有更小的性能开销，<code>Task</code>是架构在<code>Thread</code>之上的就是说<code>Task</code>最终还是会抛给线程去做，并且任务跟线程不是一对一的关系，比如开 10 个任务并不是说会开 10 个线程，这一点任务有点类似线程池，但是任务相比线程池有很小的开销和精确的控制。<code>Task</code>类的表示单个操作不返回一个值，通常以异步方式执行，<code>Task</code> 对象是<code>&quot;基于任务的异步模式&quot;</code>首次引入<code>.NET Framework 4</code> 中。</p>
<p>因为由执行工作 <code>Task</code>对象通常以异步方式执行在线程池线程上而不是以同步方式在主应用程序线程，可以使用<code>Status</code>属性，以及 <code>IsCanceled</code>,<code>IsCompleted</code>, 和 <code>IsFaulted</code>属性，以确定任务的状态</p>
<h1 id="相关概念理解">相关概念理解</h1>
<ul>
<li>同步（Synchronous）</li>
<li>异步 (Asynchronous)</li>
<li>阻塞 (Blocking)</li>
<li>非阻塞(Nonblocking)</li>
</ul>
<p>同步/异步指的是在客户端</p>
<blockquote>
<p>同步意味着：客户端提出了一个请求以后，在回应之前只能等待<br>
异步意味着：客户端提出一个请求以后，还可以继续提其他请求</p>
</blockquote>
<p>阻塞/非阻塞指的是服务器端</p>
<blockquote>
<p>阻塞意味着：服务器接受一个请求后，在返回结果以前不能接受其他请求<br>
非阻塞意味着：服务器接受一个请求后，尽管没有返回结果，还是可以继续接受其他请求</p>
</blockquote>
<h1 id="同步与异步">同步与异步</h1>
<p>同步和异步关注的是消息通信机制 (synchronous communication/ asynchronous communication)</p>
<p>所谓同步，就是在发出一个<strong>调用</strong>时，在没有得到结果之前，该<strong>调用</strong>就不返回。但是一旦调用返回，就得到返回值了。换句话说，就是由<strong>调用者</strong>主动等待这个<strong>调用</strong>的结果。</p>
<p>而异步则是相反，<strong>调用</strong>在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果,而是在<strong>调用</strong>发出后，<strong>被调用者</strong>通过状态、通知来通知调用者，或通过回调函数处理这个调用。(典型的异步编程模型比如Node.js)</p>
<p><strong>同步通信机制</strong></p>
<blockquote>
<p>你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，“我查一下”，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）</p>
</blockquote>
<p><strong>异步通信机制</strong></p>
<blockquote>
<p>书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过&quot;回电&quot;这种方式来回调</p>
</blockquote>
<h1 id="阻塞与非阻塞">阻塞与非阻塞</h1>
<p>阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态，阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程</p>
<p>Example</p>
<blockquote>
<p>你打电话问书店老板有没有《分布式系统》这本书，如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果，在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关</p>
</blockquote>
<h1 id="模型图例">模型图例</h1>
<h2 id="单线程同步模型">单线程同步模型</h2>
<p><img src="../images/2021-09-02-22-35-08.png" alt=""></p>
<h2 id="多线程模型">多线程模型</h2>
<p><img src="../images/2021-09-02-22-35-45.png" alt=""></p>
<h2 id="异步模型">异步模型</h2>
<p><img src="../images/2021-09-02-22-36-14.png" alt=""></p>
<h1 id="基础">基础</h1>
<h2 id="创建任务">创建任务</h2>
<h3 id="new-TaskFactory">new TaskFactory()</h3>
<p>使用实例化的TaskFactory类</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t1 = <span class="keyword">new</span> TaskFactory().StartNew(() =&gt; Console.WriteLine(<span class="string">&quot;new TaskFactory().StartNew&quot;</span>));</span><br></pre></td></tr></table></figure>
<h3 id="Task-Factory">Task.Factory</h3>
<p>使用Task静态属性Factory</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t2 = Task.Factory.StartNew(() =&gt; Console.WriteLine(<span class="string">&quot;Task.Factory&quot;</span>));</span><br></pre></td></tr></table></figure>
<h3 id="new-Task">new Task()</h3>
<p>使用<code>Task</code>的构造函数, 实例化<code>Task</code>对象时，任务不会立即执行，而是指定<code>Created</code>状态，通过<code>Task.Start()</code>方法启动</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t3 = <span class="keyword">new</span> Task(() =&gt; Console.WriteLine(<span class="string">&quot;Task Constructor&quot;</span>));</span><br><span class="line">	t3.Start();</span><br></pre></td></tr></table></figure>
<h3 id="Task-Run">Task.Run</h3>
<p>.Net4.5 新增功能使用<code>Task</code>类的<code>Run</code>方法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var t4 = Task.Run(() =&gt; Console.WriteLine(<span class="string">&quot;Task.Run&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>注意：使用<code>Task.Run/Task.Factory.StartNew/new TaskFactory().StartNew()</code>方法运行的任务会立即开始工作，无需显式调用这些任务的<code>Start</code>方法</p>
<h2 id="同步任务">同步任务</h2>
<p>任务不一定要使用线程池中的线程，也可以使用其他线程，任务也可以同步进行，以相同的线程作为主调线程</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> t1 = <span class="keyword">new</span> Task(() =&gt; TaskMethod(<span class="string">&quot;t1&quot;</span>));</span><br><span class="line">            t1.Start();</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;主线程调用结束&quot;</span>);</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">TaskMethod</span>(<span class="params"><span class="built_in">string</span> taskName</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Task &#123;0&#125; 运行在线程id为&#123;1&#125;的线程上。是否是线程池中线程？:&#123;2&#125;&quot;</span>,</span><br><span class="line">taskName, Thread.CurrentThread.ManagedThreadId, Thread.CurrentThread.IsThreadPoolThread);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t1 = <span class="keyword">new</span> Task(() =&gt; TaskMethod(<span class="string">&quot;t1&quot;</span>));</span><br><span class="line">    t1.RunSynchronously();</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;主线程调用结束&quot;</span>);</span><br><span class="line">    Console.ReadKey();</span><br></pre></td></tr></table></figure>
<h2 id="使用单独线程的任务">使用单独线程的任务</h2>
<p>如果任务的代码需要长时间运行，应该使用<code>TaskCreationOptions.LongRuning</code>告诉任务调度器创建一个新线程，而不是使用线程池中的线程。此时线程可以不受线程池管理</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t1 = <span class="keyword">new</span> Task(TaskMethod, TaskCreationOptions.LongRunning);</span><br><span class="line">t1.Start();</span><br></pre></td></tr></table></figure>
<h2 id="Task生命周期">Task生命周期</h2>
<table>
<thead>
<tr>
<th style="text-align:left">状态</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Created</td>
<td style="text-align:left">该任务已初始化，但尚未被计划</td>
</tr>
<tr>
<td style="text-align:left">WaitingForActivation</td>
<td style="text-align:left">该任务正在等待 .NET Framework 基础结构在内部将其激活并进行计划</td>
</tr>
<tr>
<td style="text-align:left">WaitingToRun</td>
<td style="text-align:left">该任务已被计划执行，但尚未开始执行</td>
</tr>
<tr>
<td style="text-align:left">Running</td>
<td style="text-align:left">该任务正在运行，但尚未完成</td>
</tr>
<tr>
<td style="text-align:left">WaitingForChildrenToComplete</td>
<td style="text-align:left">该任务已完成执行，正在隐式等待附加的子任务完成</td>
</tr>
<tr>
<td style="text-align:left">RanToCompletion</td>
<td style="text-align:left">已成功完成执行的任务</td>
</tr>
<tr>
<td style="text-align:left">Canceled</td>
<td style="text-align:left">该任务已通过对其自身的 CancellationToken 引发 OperationCanceledException 对取消进行了确认，此时该标记处于已发送信号状态；或者在该任务开始执行之前，已向该任务的 CancellationToken 发出了信号</td>
</tr>
<tr>
<td style="text-align:left">Faulted</td>
<td style="text-align:left">由于未处理异常的原因而完成的任务</td>
</tr>
</tbody>
</table>
<h2 id="Task任务控制">Task任务控制</h2>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Task.Wait</td>
<td style="text-align:left">task1.Wait();就是等待任务执行完成，task 的状态变为 Completed</td>
</tr>
<tr>
<td style="text-align:left">Task.WaitAll</td>
<td style="text-align:left">待所有的任务都执行完成</td>
</tr>
<tr>
<td style="text-align:left">Task.WaitAny</td>
<td style="text-align:left">等待任何一个任务完成就继续向下执行</td>
</tr>
<tr>
<td style="text-align:left">Task.ContinueWith</td>
<td style="text-align:left">第一个 Task 完成后自动启动下一个 Task，实现 Task 的延续 CancellationTokenSource</td>
</tr>
<tr>
<td style="text-align:left">CancellationTokenSource</td>
<td style="text-align:left">通过 cancellation 的 tokens 来取消一个 Task</td>
</tr>
</tbody>
</table>
<h2 id="Task返回类型">Task返回类型</h2>
<h3 id="void">void</h3>
<p>不关心结果，返回 void 类型</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[TestMethod]</span><br><span class="line">public void <span class="function"><span class="title">Task_Result_Void</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine($<span class="string">&quot;不关心结果,返回Void,--Start,线程Id:&#123;Thread.CurrentThread.ManagedThreadId&#125;&quot;</span>);</span><br><span class="line">    Print();</span><br><span class="line">    Console.WriteLine($<span class="string">&quot;不关心结果,返回Void,--End,线程Id:&#123;Thread.CurrentThread.ManagedThreadId&#125;&quot;</span>);</span><br><span class="line">    Assert.IsTrue(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    static async void <span class="function"><span class="title">Print</span></span>()</span><br><span class="line">    &#123;</span><br><span class="line">        await Task.Run(() =&gt;</span><br><span class="line">       &#123;</span><br><span class="line">           Console.WriteLine($<span class="string">&quot;Hello, 线程Id:&#123; Thread.CurrentThread.ManagedThreadId&#125;&quot;</span>);</span><br><span class="line">       &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Task">Task</h3>
<p>关心是否完成，返回 Task 类型</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public void <span class="function"><span class="title">Task_Result_Task</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine($<span class="string">&quot;看电视中...,线程Id:&#123;Thread.CurrentThread.ManagedThreadId&#125;&quot;</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;突然停电，看下是不是跳闸了&quot;</span>);</span><br><span class="line">    var task = OpenMainsSwitch();</span><br><span class="line">    Console.WriteLine($<span class="string">&quot;没电了先玩会儿手机吧，线程Id为：&#123;Thread.CurrentThread.ManagedThreadId&#125;&quot;</span>);</span><br><span class="line">    Thread.Sleep(100);</span><br><span class="line">    // 等着电源开关被打开</span><br><span class="line">    task.Wait();</span><br><span class="line">    Console.WriteLine($<span class="string">&quot;又有电了,继续看电视...,线程Id:&#123;Thread.CurrentThread.ManagedThreadId&#125;&quot;</span>);</span><br><span class="line">    Assert.IsTrue(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    static async Task <span class="function"><span class="title">OpenMainsSwitch</span></span>()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine($<span class="string">&quot;准备打开电源开关，线程Id：&#123; Thread.CurrentThread.ManagedThreadId&#125;&quot;</span>);</span><br><span class="line">        await Task.Run(() =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine($<span class="string">&quot;打开电源开关, 线程Id:&#123; Thread.CurrentThread.ManagedThreadId&#125;&quot;</span>);</span><br><span class="line">            Thread.Sleep(2000);</span><br><span class="line">        &#125;);</span><br><span class="line">        Console.WriteLine($<span class="string">&quot;电源开关打开了，线程Id：&#123; Thread.CurrentThread.ManagedThreadId&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Task-T"><code>Task&lt;T&gt;</code></h3>
<p>调用方法要从调用中获取一个<code>T</code>类型的值，异步方法的返回类型就必须是<code>Task&lt;T&gt;</code>。调用方法从<code>Task</code>的<code>Result</code>属性获取的就是<code>T</code>类型的值</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">Task_Result_TaskTAsync</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> message = <span class="string">$&quot;Today is <span class="subst">&#123;DateTime.Today:D&#125;</span>\n&quot;</span> + <span class="string">&quot;Today&#x27;s hours of leisure: &quot;</span> + <span class="string">$&quot;<span class="subst">&#123;<span class="keyword">await</span> GetLeisureHoursAsync()&#125;</span>&quot;</span>;</span><br><span class="line">    Console.WriteLine(message);</span><br><span class="line">    Assert.IsTrue(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task&lt;<span class="built_in">int</span>&gt; <span class="title">GetLeisureHoursAsync</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        DayOfWeek today = <span class="keyword">await</span> Task.FromResult(DateTime.Now.DayOfWeek);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> leisureHours =</span><br><span class="line">            today <span class="keyword">is</span> DayOfWeek.Saturday || today <span class="keyword">is</span> DayOfWeek.Sunday</span><br><span class="line">            ? <span class="number">16</span> : <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> leisureHours;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="连续任务">连续任务</h2>
<p>在指定任务完成后调用另一个指定任务</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Task_ContinueWith_Example</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Task&lt;<span class="built_in">string</span>&gt; t1 = <span class="keyword">new</span> Task&lt;<span class="built_in">string</span>&gt;(</span><br><span class="line">        () =&gt; TaskMethod1(<span class="string">&quot;t1&quot;</span>));</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Task1-创建,状态为:&#123;0&#125;&quot;</span>, t1.Status);</span><br><span class="line">    t1.Start();</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Task1-启动,状态为:&#123;0&#125;&quot;</span>, t1.Status);</span><br><span class="line">    Console.WriteLine(t1.Result);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Task1-完成,状态为:&#123;0&#125;&quot;</span>, t1.Status);</span><br><span class="line">    Task t2 = t1.ContinueWith(TaskMethod2);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Task2,状态为:&#123;0&#125;&quot;</span>, t2.Status);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">string</span> <span class="title">TaskMethod1</span>(<span class="params"><span class="built_in">string</span> taskName</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> result = <span class="built_in">string</span>.Format(<span class="string">$&quot;Task:<span class="subst">&#123;taskName&#125;</span> 运行在线程id:<span class="subst">&#123; Thread.CurrentThread.ManagedThreadId&#125;</span>的线程上,&quot;</span> +</span><br><span class="line">            <span class="string">$&quot;是否是线程池中线程？:<span class="subst">&#123;Thread.CurrentThread.IsThreadPoolThread&#125;</span>&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">TaskMethod2</span>(<span class="params">Task t</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;TaskID:<span class="subst">&#123; t.Id&#125;</span> 运行在线程id:<span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>的线程上。是否是线程池中线程？:<span class="subst">&#123;Thread.CurrentThread.IsThreadPoolThread&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    Assert.IsTrue(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>TaskContinuationOptions</code>枚举的值可以指定连续任务只有在起始任务成功或失败结束时启动</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Task t2 = t1.ContinueWith(TaskMethod2, TaskContinuationOptions.NotOnCanceled);</span><br></pre></td></tr></table></figure>
<h2 id="嵌套Task">嵌套Task</h2>
<h3 id="关联嵌套">关联嵌套</h3>
<p>在创建<code>cTask</code>时，加入了参数<code>TaskCreationOptions.AttachedToParent</code>，这个时候，<code>cTask</code>和<code>pTask</code>就会建立关联，<code>cTask</code>就会成为<code>pTask</code>的一部分</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">TestMethod</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Task_Relevance_Example</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> pTask = Task.Factory.StartNew(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">var</span> cTask= Task.Factory.StartNew(() =&gt;</span><br><span class="line">         &#123;</span><br><span class="line">             Console.WriteLine(<span class="string">&quot;Childen task finished!&quot;</span>);</span><br><span class="line">         &#125;, TaskCreationOptions.AttachedToParent);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Parent task finished!&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    pTask.Wait();</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Flag&quot;</span>);</span><br><span class="line">    Assert.IsTrue(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="非关联嵌套">非关联嵌套</h3>
<p>外层的<code>pTask</code>运行完后，并不会等待内层的<code>cTask</code>，直接向下走先输出了<code>Flag</code>。这种嵌套有时候相当于创建两个Task，但是嵌套在一起的话，在Task比较多时会方便查找和管理，并且还可以在一个Task中途加入多个Task，让进度并行前进</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">TestMethod</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Task_NoRelevance_Example</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> pTask = Task.Factory.StartNew(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Task.Factory.StartNew(() =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Childen task finished!&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Parent task finished!&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    pTask.Wait();</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Flag&quot;</span>);</span><br><span class="line">    Assert.IsTrue(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>Task</code>内部创建<code>Task</code>，如果父任务在子任务之前结束，父任务状态就显示为<code>WaitingForChilderenToComplete</code>。所有的子任务也结束时，父任务的状态就改为<code>RanToCompletion</code>，如果使用<code>TaskContinuationOptions</code>枚举值创建子任务时会有不同结果，取消父任务也会取消子任务</p>
<h2 id="Task取消">Task取消</h2>
<h3 id="单个任务">单个任务</h3>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">TestMethod</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Task_CancellationToken_SingleTask_Example</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    CancellationTokenSource cts = <span class="keyword">new</span> CancellationTokenSource();</span><br><span class="line">    Task t1 = Task.Run(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (cts.Token.IsCancellationRequested)</span><br><span class="line">            &#123;</span><br><span class="line">                cts.Token.ThrowIfCancellationRequested();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Thread.Sleep(<span class="number">500</span>);</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;任务t1,共执行30次,当前第&#123;0&#125;次&quot;</span>, i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, cts.Token);</span><br><span class="line">    Thread.Sleep(<span class="number">2000</span>);</span><br><span class="line">    <span class="comment">// 传达取消请求</span></span><br><span class="line">    cts.Cancel();</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;已停止,Status<span class="subst">&#123;t1.Status&#125;</span>&quot;</span>);</span><br><span class="line">    Assert.IsTrue(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多个任务">多个任务</h3>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">TestMethod</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Task_CancellationToken_MultiTask_Example</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    CancellationTokenSource cts1 = <span class="keyword">new</span> CancellationTokenSource();</span><br><span class="line">    CancellationTokenSource cts2 = <span class="keyword">new</span> CancellationTokenSource();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 任何Task处于取消状态时其余也将取消</span></span><br><span class="line">    CancellationTokenSource ctsCombine =</span><br><span class="line">         CancellationTokenSource.CreateLinkedTokenSource(cts1.Token, cts2.Token);</span><br><span class="line">    Task t1 = Task.Run(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!ctsCombine.IsCancellationRequested)</span><br><span class="line">            &#123;</span><br><span class="line">                Thread.Sleep(<span class="number">500</span>);</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;任务t1,共执行30次,当前第&#123;0&#125;次&quot;</span>, i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, ctsCombine.Token);</span><br><span class="line"></span><br><span class="line">    Task t2 = Task.Run(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!ctsCombine.IsCancellationRequested)</span><br><span class="line">            &#123;</span><br><span class="line">                Thread.Sleep(<span class="number">500</span>);</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;任务t2,共执行30次,当前第&#123;0&#125;次&quot;</span>, i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, ctsCombine.Token);</span><br><span class="line">    Thread.Sleep(<span class="number">2000</span>);</span><br><span class="line">    cts1.Cancel();</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;t1:Status_<span class="subst">&#123;t1.Status&#125;</span>,t2:Status_<span class="subst">&#123;t2.Status&#125;</span>&quot;</span>);</span><br><span class="line">    Assert.IsTrue(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="定时取消">定时取消</h3>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    CancellationTokenSource cts = <span class="keyword">new</span> CancellationTokenSource();</span><br><span class="line">    cts.CancelAfter(<span class="number">8000</span>);</span><br><span class="line">    Task t1 = Task.Run(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (cts.Token.IsCancellationRequested)</span><br><span class="line">            &#123;</span><br><span class="line">                cts.Token.ThrowIfCancellationRequested();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Thread.Sleep(<span class="number">500</span>);</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;任务t1,共执行30次,当前第&#123;0&#125;次&quot;</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, cts.Token);</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        t1.Wait();</span><br><span class="line">    &#125;</span><br><span class="line">    catch (AggregateException e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> e.InnerExceptions)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Console.ReadKey();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>工作原理</strong><br>
程序运行主线程创建-&gt;创建<code>CancellationTokenSource</code>对象-&gt;设置<code>task</code>在指定毫秒数后取消(这里是 8000)-&gt;创建<code>task</code>并传入<code>CancellationTokenSource</code>对象生成的<code>token</code>，循环打印 1~30，取消标记为<code>true</code>则抛出异常中止任务，<code>false</code>则正常输出。在输出前等待 500 毫秒(避免 8000 毫秒还没到任务就已经执行完成)-&gt;使用<code>try/catch</code>包裹<code>t1.Wait()</code>等待任务执行完成语句，并捕获处理异常。这里任务在执行完 15 次的时候被取消</p>
<h2 id="取消时回调">取消时回调</h2>
<p><code>CancellationTokenSource.Token.Register()</code>，使用<code>Register</code>，向取消标记登记一个回调方法。应用程序调用<code>CancellationTokenSource</code> 对象的 <code>Cancel</code> 方法时，这个回调就会运行。但是不能保证这个方法在什么时候执行,可能在任务执行完自己的取消处理之前或之后,也可能在那个过程之中</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">TestMethod</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Task_CancellationToken_Register_Example</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    CancellationTokenSource cts = <span class="keyword">new</span> CancellationTokenSource();</span><br><span class="line">    <span class="keyword">var</span> token = cts.Token;</span><br><span class="line">    cts.CancelAfter(<span class="number">8000</span>);</span><br><span class="line">    token.Register(Callback);</span><br><span class="line">    Task t1 = Task.Run(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (token.IsCancellationRequested)</span><br><span class="line">            &#123;</span><br><span class="line">                token.ThrowIfCancellationRequested();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Thread.Sleep(<span class="number">500</span>);</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;任务t1,共执行30次,当前第&#123;0&#125;次&quot;</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, token);</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        t1.Wait();</span><br><span class="line">    &#125;</span><br><span class="line">    catch (AggregateException e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> e.InnerExceptions)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Callback</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Register登记的任务取消回调函数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Assert.IsTrue(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="问题记录">问题记录</h1>
<h2 id="async-await并不能提升性能">async/await并不能提升性能?</h2>
<p>问题描述：所谓的异步操作就是A线程在执行任务的时候，执行到一半再把任务交给B线程，然后A线程开始等待B的执行完成了，这不还是同步的吗?</p>
<blockquote>
<p>异步编程不能提高性能。异步编程只是提供一种简单的编程模型来提高系统的响应能力，比如，如果在UI线程上执行长时间IO操作，在操作完成之前界面就处在无法操作的状态。<br>
可以提高性能的是并行技术，比如任务并行库（TPL，Task Parallel Library）、并行LINQ（PLINQ）等，这些技术可以充分利用CPU来提高计算性能。一般来说，耗时的IO操作使用异步简化代码，耗时的计算操作使用并行来提高性能</p>
</blockquote>
<blockquote>
<p>比如服务端最大处理请求是100个线程，那么同步模式下，150个请求过来，就有50个请求需要等待执行。async/await 模式下，正在执行的100个线程 可以空闲出来 处理后来的50个请求，前面100个请求异步完成后，再通过上下文切换到当前的100个线程，处理完后续的流程。工作线程是在不停的切换过程中提升了并发效率。而在单个请求中，async/await是有线程上下文切换的性能损耗，所以在处理一个本来就很快速的逻辑,例如读一个Redis缓存，那么性能会有比较显著的下降</p>
</blockquote>
<p>总结：异步编程只是提高了线程的利用率，针对一个本来就很“快”的操作，可能异步还不如同步。因为线程上下文的切换也会带来性能损耗</p>
<h2 id="async-await死锁问题">async/await死锁问题</h2>
<h3 id="可能发生死锁的程序类型">可能发生死锁的程序类型</h3>
<ul>
<li><code>WPF/WinForm</code>程序</li>
<li><a target="_blank" rel="noopener" href="http://asp.net">asp.net</a>(<a target="_blank" rel="noopener" href="http://xn--asp-628d60u5v0a.net">不包括asp.net</a> core)程序</li>
</ul>
<h3 id="什么情况下会产生死锁">什么情况下会产生死锁?</h3>
<p>调用 <code>Task.Wait()</code> 或者 <code>Task.Result</code> 立刻产生死锁的充分条件</p>
<ul>
<li>调用 <code>Wait()</code>或<code>Result</code>的代码位于<code>UI</code>线程</li>
<li><code>Task</code>的实际执行在其他线程，且需要返回<code>UI</code>线程</li>
</ul>
<h3 id="死锁的原因">死锁的原因?</h3>
<blockquote>
<p><code>UWP</code>、<code>WPF</code>、<code>Windows Forms</code>程序的 UI 线程都是单线程的。为了让使用了<code>async/await</code>的代码像使用同步代码一样简单，WPF 程序的<code>Application</code>类在构造的时候会将<code>主UI线程</code> Task的同步上下文设置为<code>DispatcherSynchronizationContext</code>的实例，当<code>Task</code>的任务结束时，会从<code>AsyncMethodStateMachine</code>中调用<code>Awaiter</code>的<code>OnComplete()</code>方法，而<code>await</code>后续方法的执行靠的就是<code>OnComplete()</code>方法中一层层调用到 <code>DispatcherSynchronizationContext</code>里的<code>Post</code>方法</p>
</blockquote>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Asynchronously invoke the callback in the SynchronizationContext.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Post</span>(<span class="params">SendOrPostCallback d, Object state</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Call BeginInvoke with the cached priority.  Note that BeginInvoke</span></span><br><span class="line">    <span class="comment">// preserves the behavior of passing exceptions to</span></span><br><span class="line">    <span class="comment">// Dispatcher.UnhandledException unlike InvokeAsync.  This is</span></span><br><span class="line">    <span class="comment">// desireable because there is no way to await the call to Post, so</span></span><br><span class="line">    <span class="comment">// exceptions are hard to observe.</span></span><br><span class="line">    _dispatcher.BeginInvoke(_priority, d, state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就是问题的关键！！！</p>
<p>如果<code>_dispatcher.BeginInvoke(_priority, d, state);</code>这句代码在后台线程。那么此时<code>UI线程</code>处于<code>Wait()/Result</code>调用中的阻塞状态，<code>BeginInvoke</code>中的任务是无论如何也无法执行到的，于是无论如何都无法完成这个<code>Post</code>任务，即无论如何也无法退出此异步任务的执行，于是<code>Wait()</code>便无法完成等待，产生死锁</p>
<p>Example</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DoAsync().Wait();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">async</span> Task <span class="title">DoAsync</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">await</span> Task.Run(() =&gt; &#123; &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无论是<code>WPF</code>还是<code>UWP</code>，只要在<code>UI</code>线程上调用上述代码，必然死锁</p>
<h3 id="There-Is-No-Thread">There Is No Thread</h3>
<p>读写文件，访问网络，这些 IO 阻塞的操作执行时，里面根本就没有线程。详情请阅读：<a target="_blank" rel="noopener" href="https://blog.stephencleary.com/2013/11/there-is-no-thread.html">There Is No Thread</a></p>
<p>还有另一些操作，也没有后台线程的参与，于是也不存在从后台线程回到主线程导致死锁的情况。如<code>Task.Yield</code>，还有<code>InvokeAsync</code>，它们也不会造成死锁。如果是控制台程序，或者一个普通的非UI线程，其<code>SynchronizationContext</code>为<code>null</code>，那么异步任务执行完后不需要回到原有线程，也不会造成死锁</p>
<h3 id="不会造成死锁的充分条件">不会造成死锁的充分条件</h3>
<ul>
<li>异步操作执行完后不需要回到原有线程（例如非 UI 线程和控制台线程）</li>
<li>异步操作不需要单独的线程执行任务</li>
</ul>
<h2 id="如何避免死锁">如何避免死锁?</h2>
<ul>
<li>在 UI 线程，如果使用了<code>async/await</code>，就尽量不要再使用<code>Task.Wait()/Task.Result</code>了，就一直异步一条路走到黑好了（微软称其为<code>Async All the Way</code>）</li>
<li>如果可能，尽量在异步任务后添加<code>.ConfigureAwait(false);</code>这样，异步任务后面继续执行的代码就不会回到原<code>UI</code>线程了，而是直接从线程池中再取出一个线程执行；这样，即便<code>UI</code>线程后续可能有别的原因造成阻塞，也不会产生死锁了；把原来的代码改成这样，就不会死锁了</li>
</ul>
<p>只能是一路<code>async/await</code>。微软将其描述为：<code>async/await 会像病毒一样在你的代码中传播</code>。</p>
<blockquote>
<p>Others have also noticed the spreading behavior of asynchronous programming and have called it “contagious” or compared it to a zombie virus.</p>
</blockquote>
<p>这句话的原文参见：<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/archive/msdn-magazine/2013/march/async-await-best-practices-in-asynchronous-programming">Async/Await - Best Practices in Asynchronous Programming</a></p>
<p>如果你是类库提供者，因为不确定调用者程序是<code>WPF</code>/<code>Winform</code>…，为了防止代码调用者在同步方法中使用<code>Wait()/Result</code>调用异步方法，还需要考虑添加<code>.ConfigureAwait(false);</code></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">async</span> Task <span class="title">DoAsync</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">await</span> Task.Run(() =&gt; &#123; &#125;).ConfigureAwait(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一句的目的是防止执行上下文切换回 UI 线程。</p>
<p>这样，即便真的使用 DoAsync().Wait() 也不会发生死锁。注意，整个方法调用链都需要使用<code>.ConfigureAwait(false)</code>才能够防止线程切换，在调用方的 Wait() 方法中发生死锁。</p>
<h2 id="更多死锁相关">更多死锁相关</h2>
<p><a target="_blank" rel="noopener" href="https://blog.walterlv.com/post/deadlock-in-task-wait.html">https://blog.walterlv.com/post/deadlock-in-task-wait.html</a><br>
<a target="_blank" rel="noopener" href="https://blog.walterlv.com/post/deadlock-of-invoke-in-lazy.html">https://blog.walterlv.com/post/deadlock-of-invoke-in-lazy.html</a><br>
<a target="_blank" rel="noopener" href="https://blog.walterlv.com/post/deadlock-if-await-in-ui-lock-context.html">https://blog.walterlv.com/post/deadlock-if-await-in-ui-lock-context.html</a><br>
<a target="_blank" rel="noopener" href="https://blog.walterlv.com/post/task-wait-may-cause-long-time-waiting.html">https://blog.walterlv.com/post/task-wait-may-cause-long-time-waiting.html</a></p>
<p><strong>解决方法</strong><br>
<a target="_blank" rel="noopener" href="https://blog.walterlv.com/post/using-configure-await-to-avoid-deadlocks.html">https://blog.walterlv.com/post/using-configure-await-to-avoid-deadlocks.html</a><br>
<a target="_blank" rel="noopener" href="https://blog.walterlv.com/post/convert-async-to-sync-by-push-frame.html">https://blog.walterlv.com/post/convert-async-to-sync-by-push-frame.html</a></p>
<p><strong>参考</strong><br>
<a target="_blank" rel="noopener" href="https://blog.csdn.net/WPwalter/article/details/78370706">https://blog.csdn.net/WPwalter/article/details/78370706</a><br>
<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/archive/msdn-magazine/2013/march/async-await-best-practices-in-asynchronous-programming">https://docs.microsoft.com/en-us/archive/msdn-magazine/2013/march/async-await-best-practices-in-asynchronous-programming</a><br>
<a target="_blank" rel="noopener" href="https://www.cnblogs.com/qingfenglin/p/12058267.html">https://www.cnblogs.com/qingfenglin/p/12058267.html</a><br>
<a target="_blank" rel="noopener" href="https://www.cnblogs.com/liqingwen/p/5844095.html">https://www.cnblogs.com/liqingwen/p/5844095.html</a><br>
<a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhaoshujie/p/11082753.html">https://www.cnblogs.com/zhaoshujie/p/11082753.html</a><br>
<a target="_blank" rel="noopener" href="https://q.cnblogs.com/q/107005/">https://q.cnblogs.com/q/107005/</a><br>
<a target="_blank" rel="noopener" href="https://rubikscode.net/2018/06/11/asynchronous-programming-in-net-benefits-and-tradeoffs-of-using-valuetask/">https://rubikscode.net/2018/06/11/asynchronous-programming-in-net-benefits-and-tradeoffs-of-using-valuetask/</a><br>
<a target="_blank" rel="noopener" href="https://blog.scooletz.com/2018/05/14/task-async-await-valuetask-ivaluetasksource-and-how-to-keep-your-sanity-in-modern-net-world/">https://blog.scooletz.com/2018/05/14/task-async-await-valuetask-ivaluetasksource-and-how-to-keep-your-sanity-in-modern-net-world/</a><br>
<a target="_blank" rel="noopener" href="https://www.cnblogs.com/ms27946/p/understanding-task-valuetask.html">https://www.cnblogs.com/ms27946/p/understanding-task-valuetask.html</a><br>
<a target="_blank" rel="noopener" href="https://www.cnblogs.com/ittranslator/p/13703279.html">https://www.cnblogs.com/ittranslator/p/13703279.html</a><br>
<a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/dotnet/understanding-the-whys-whats-and-whens-of-valuetask/">https://devblogs.microsoft.com/dotnet/understanding-the-whys-whats-and-whens-of-valuetask/</a><br>
<a target="_blank" rel="noopener" href="https://www.cnblogs.com/wcrBlog/p/11690460.html">https://www.cnblogs.com/wcrBlog/p/11690460.html</a><br>
<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/async/async-return-types#generalized-async-return-types-and-valuetasktresult">https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/async/async-return-types#generalized-async-return-types-and-valuetasktresult</a><br>
<a target="_blank" rel="noopener" href="https://q.cnblogs.com/q/124633/">https://q.cnblogs.com/q/124633/</a><br>
<a target="_blank" rel="noopener" href="https://www.cnblogs.com/dudu/p/9860959.html#!comments">https://www.cnblogs.com/dudu/p/9860959.html#!comments</a><br>
<a target="_blank" rel="noopener" href="http://labs.criteo.com/2018/10/net-threadpool-starvation-and-how-queuing-makes-it-worse/">http://labs.criteo.com/2018/10/net-threadpool-starvation-and-how-queuing-makes-it-worse/</a><br>
<a target="_blank" rel="noopener" href="https://www.cnblogs.com/xishuai/p/asp-net-sync-over-async.html">https://www.cnblogs.com/xishuai/p/asp-net-sync-over-async.html</a></p>

</article>

<div id="paginator">
  
</div>

                  <script src="https://utteranc.es/client.js" repo="wangpengliang815/blog-comments"
                    issue-term="pathname" label="issue" theme="github-light" crossorigin="anonymous" async>
                    </script>
              </div>
            </div>
            <div class="column col-2 hide-lg">
              <div class="book-post-info">
  
    <div class="book-post-meta">

  <div class="author">

    <!-- Author image -->
    <div class="author-img">
      
        <figure
          class="avatar avatar-lg"
          data-initial="W"
          style="background-color: #3b4351;">
        </figure>
      
    </div>

    <!-- Author title -->
    <div class="author-title">
      <div>Wang,PengLiang</div>
      <div>2021-09-03</div>
    </div>
  </div>

  

  <div class="divider"></div>
</div>
  

  <div class="book-tocbot">
</div>
<div class="book-tocbot-menu">
  <a class="book-toc-expand" onclick="expand_toc()">Expand all</a>
  <a onclick="go_top()">Back to top</a>
  <a onclick="go_bottom()">Go to bottom</a>
</div>


<script src="/js/book-toc.js"></script>

</div>
            </div>
          </div>

        </div>

        <a class="off-canvas-overlay" onclick="hide_canvas()"></a>
    </div>

  </body>

</html>


<script src="/js/book.js"></script>
