<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Prometheus 官方文档地址
监控样本# 通过 Node Exporter 暴露的 HTTP 服务，Prometheus 可以采集到当前主机所有监控指标的样本数据。比如：
# HELP node_cpu_guest_seconds_total Seconds the CPUs spent in guests (VMs) for each mode. # TYPE node_cpu_guest_seconds_total counter node_cpu_guest_seconds_total{cpu=&#34;0&#34;,mode=&#34;nice&#34;} 0 node_cpu_guest_seconds_total{cpu=&#34;0&#34;,mode=&#34;user&#34;} 0 node_cpu_guest_seconds_total{cpu=&#34;1&#34;,mode=&#34;nice&#34;} 0 node_cpu_guest_seconds_total{cpu=&#34;1&#34;,mode=&#34;user&#34;} 0 # HELP node_cpu_seconds_total Seconds the CPUs spent in each mode. # TYPE node_cpu_seconds_total counter node_cpu_seconds_total{cpu=&#34;0&#34;,mode=&#34;idle&#34;} 996.7 node_cpu_seconds_total{cpu=&#34;0&#34;,mode=&#34;iowait&#34;} 0.52其中非 # 开头的每一行表示当前 Node Exporter 采集到的一个监控样本：
node_cpu_seconds_total ：表示当前指标名称 大括号中的标签：表示当前样本的一些特征和维度 浮点数：表示该监控样本的具体值 时间序列（time-series）# Prometheus 会将所有采集到的样本数据以时间序列（time-series）的方式保存在内存数据库中，定时保存到硬盘上。
time-series 是按照时间戳和值的序列顺序存放的，称之为向量(vector)
每条 time-series 通过指标名称(metrics name)和一组标签集(labelset)命名。其中每一个点称为一个样本(sample)。样本由以下三部分组成：
指标（metric）：metric name 和描述当前样本特征的 labelsets 时间戳（timestamp）：一个精确到毫秒的时间戳 样本值（value）： 一个 float64 的浮点型数据表示当前样本的值 &lt;--------------- metric ---------------------&gt;&lt;-timestamp -&gt;&lt;-value-&gt; http_request_total{status=&#34;200&#34;, method=&#34;GET&#34;}@1434417560938 =&gt; 94355 http_request_total{status=&#34;200&#34;, method=&#34;GET&#34;}@1434417561287 =&gt; 94334 http_request_total{status=&#34;404&#34;, method=&#34;GET&#34;}@1434417560938 =&gt; 38473 http_request_total{status=&#34;404&#34;, method=&#34;GET&#34;}@1434417561287 =&gt; 38544 http_request_total{status=&#34;200&#34;, method=&#34;POST&#34;}@1434417560938 =&gt; 4748 http_request_total{status=&#34;200&#34;, method=&#34;POST&#34;}@1434417561287 =&gt; 4785指标（metric）# 指标（Metric）通过如下格式表示：
">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:url" content="http://localhost:1313/posts/prometheus/1.3promql%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80/">
  <meta property="og:site_name" content="CODE&#39;NOTE">
  <meta property="og:title" content="CODE&#39;NOTE">
  <meta property="og:description" content="Prometheus 官方文档地址
监控样本# 通过 Node Exporter 暴露的 HTTP 服务，Prometheus 可以采集到当前主机所有监控指标的样本数据。比如：
# HELP node_cpu_guest_seconds_total Seconds the CPUs spent in guests (VMs) for each mode. # TYPE node_cpu_guest_seconds_total counter node_cpu_guest_seconds_total{cpu=&#34;0&#34;,mode=&#34;nice&#34;} 0 node_cpu_guest_seconds_total{cpu=&#34;0&#34;,mode=&#34;user&#34;} 0 node_cpu_guest_seconds_total{cpu=&#34;1&#34;,mode=&#34;nice&#34;} 0 node_cpu_guest_seconds_total{cpu=&#34;1&#34;,mode=&#34;user&#34;} 0 # HELP node_cpu_seconds_total Seconds the CPUs spent in each mode. # TYPE node_cpu_seconds_total counter node_cpu_seconds_total{cpu=&#34;0&#34;,mode=&#34;idle&#34;} 996.7 node_cpu_seconds_total{cpu=&#34;0&#34;,mode=&#34;iowait&#34;} 0.52其中非 # 开头的每一行表示当前 Node Exporter 采集到的一个监控样本：
node_cpu_seconds_total ：表示当前指标名称 大括号中的标签：表示当前样本的一些特征和维度 浮点数：表示该监控样本的具体值 时间序列（time-series）# Prometheus 会将所有采集到的样本数据以时间序列（time-series）的方式保存在内存数据库中，定时保存到硬盘上。
time-series 是按照时间戳和值的序列顺序存放的，称之为向量(vector)
每条 time-series 通过指标名称(metrics name)和一组标签集(labelset)命名。其中每一个点称为一个样本(sample)。样本由以下三部分组成：
指标（metric）：metric name 和描述当前样本特征的 labelsets 时间戳（timestamp）：一个精确到毫秒的时间戳 样本值（value）： 一个 float64 的浮点型数据表示当前样本的值 &lt;--------------- metric ---------------------&gt;&lt;-timestamp -&gt;&lt;-value-&gt; http_request_total{status=&#34;200&#34;, method=&#34;GET&#34;}@1434417560938 =&gt; 94355 http_request_total{status=&#34;200&#34;, method=&#34;GET&#34;}@1434417561287 =&gt; 94334 http_request_total{status=&#34;404&#34;, method=&#34;GET&#34;}@1434417560938 =&gt; 38473 http_request_total{status=&#34;404&#34;, method=&#34;GET&#34;}@1434417561287 =&gt; 38544 http_request_total{status=&#34;200&#34;, method=&#34;POST&#34;}@1434417560938 =&gt; 4748 http_request_total{status=&#34;200&#34;, method=&#34;POST&#34;}@1434417561287 =&gt; 4785指标（metric）# 指标（Metric）通过如下格式表示：">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">


  <meta itemprop="name" content="CODE&#39;NOTE">
  <meta itemprop="description" content="Prometheus 官方文档地址
监控样本# 通过 Node Exporter 暴露的 HTTP 服务，Prometheus 可以采集到当前主机所有监控指标的样本数据。比如：
# HELP node_cpu_guest_seconds_total Seconds the CPUs spent in guests (VMs) for each mode. # TYPE node_cpu_guest_seconds_total counter node_cpu_guest_seconds_total{cpu=&#34;0&#34;,mode=&#34;nice&#34;} 0 node_cpu_guest_seconds_total{cpu=&#34;0&#34;,mode=&#34;user&#34;} 0 node_cpu_guest_seconds_total{cpu=&#34;1&#34;,mode=&#34;nice&#34;} 0 node_cpu_guest_seconds_total{cpu=&#34;1&#34;,mode=&#34;user&#34;} 0 # HELP node_cpu_seconds_total Seconds the CPUs spent in each mode. # TYPE node_cpu_seconds_total counter node_cpu_seconds_total{cpu=&#34;0&#34;,mode=&#34;idle&#34;} 996.7 node_cpu_seconds_total{cpu=&#34;0&#34;,mode=&#34;iowait&#34;} 0.52其中非 # 开头的每一行表示当前 Node Exporter 采集到的一个监控样本：
node_cpu_seconds_total ：表示当前指标名称 大括号中的标签：表示当前样本的一些特征和维度 浮点数：表示该监控样本的具体值 时间序列（time-series）# Prometheus 会将所有采集到的样本数据以时间序列（time-series）的方式保存在内存数据库中，定时保存到硬盘上。
time-series 是按照时间戳和值的序列顺序存放的，称之为向量(vector)
每条 time-series 通过指标名称(metrics name)和一组标签集(labelset)命名。其中每一个点称为一个样本(sample)。样本由以下三部分组成：
指标（metric）：metric name 和描述当前样本特征的 labelsets 时间戳（timestamp）：一个精确到毫秒的时间戳 样本值（value）： 一个 float64 的浮点型数据表示当前样本的值 &lt;--------------- metric ---------------------&gt;&lt;-timestamp -&gt;&lt;-value-&gt; http_request_total{status=&#34;200&#34;, method=&#34;GET&#34;}@1434417560938 =&gt; 94355 http_request_total{status=&#34;200&#34;, method=&#34;GET&#34;}@1434417561287 =&gt; 94334 http_request_total{status=&#34;404&#34;, method=&#34;GET&#34;}@1434417560938 =&gt; 38473 http_request_total{status=&#34;404&#34;, method=&#34;GET&#34;}@1434417561287 =&gt; 38544 http_request_total{status=&#34;200&#34;, method=&#34;POST&#34;}@1434417560938 =&gt; 4748 http_request_total{status=&#34;200&#34;, method=&#34;POST&#34;}@1434417561287 =&gt; 4785指标（metric）# 指标（Metric）通过如下格式表示：">
  <meta itemprop="wordCount" content="936">

<title>1.3 Prom Ql查询语言 | CODE&#39;NOTE</title>
<link rel="icon" href="/favicon.png" >
<link rel="manifest" href="/manifest.json">
<link rel="canonical" href="http://localhost:1313/posts/prometheus/1.3promql%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80/">
<link rel="stylesheet" href="/book.min.6970156cec683193d93c9c4edaf0d56574e4361df2e0c1be4f697ae81c3ba55f.css" integrity="sha256-aXAVbOxoMZPZPJxO2vDVZXTkNh3y4MG&#43;T2l66Bw7pV8=" crossorigin="anonymous">


  <script defer src="/fuse.min.js"></script>
  <script defer src="/en.search.min.3ed9c79c605914c45e19db90edfda0ca8d87c63064c1d6252862250c4e917346.js" integrity="sha256-PtnHnGBZFMReGduQ7f2gyo2HxjBkwdYlKGIlDE6Rc0Y=" crossorigin="anonymous"></script>



  
</head>
<body dir="ltr" class="book-kind-page book-type-posts">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    
<aside class="book-menu">
  <div class="book-menu-content">
    
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><span>CODE&#39;NOTE</span>
  </a>
</h2>


<div class="book-search hidden">
  <input id="book-search-input" type="text" 
    placeholder="Search"
    aria-label="Search"
    maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>
<script>document.querySelector(".book-search").classList.remove("hidden")</script>
























</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>



  </div>
</aside>
 

    <div class="book-page">
      <header class="book-header hidden">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/icons/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <h3>1.3 Prom Ql查询语言</h3>

  <label for="toc-control">
    
    <img src="/icons/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#counter-只增不减">Counter-&gt;只增不减</a></li>
    <li><a href="#gauge-可增可减">Gauge-&gt;可增可减</a></li>
    <li><a href="#histogramsummary">Histogram/Summary</a></li>
  </ul>

  <ul>
    <li><a href="#查询时间序列">查询时间序列</a></li>
    <li><a href="#标签过滤">标签过滤</a></li>
    <li><a href="#范围查询">范围查询</a></li>
    <li><a href="#时间位移">时间位移</a></li>
    <li><a href="#聚合操作">聚合操作</a></li>
    <li><a href="#操作符">操作符</a>
      <ul>
        <li><a href="#数学运算">数学运算</a></li>
        <li><a href="#布尔运算">布尔运算</a></li>
        <li><a href="#bool-修饰符">bool 修饰符</a></li>
      </ul>
    </li>
    <li><a href="#集合运算符">集合运算符</a></li>
    <li><a href="#操作符优先级">操作符优先级</a></li>
    <li><a href="#匹配模式">匹配模式</a>
      <ul>
        <li><a href="#一对一匹配">一对一匹配</a></li>
        <li><a href="#多对一和一对多">多对一和一对多</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#withoutby">without/by</a></li>
    <li><a href="#count_values">count_values</a></li>
    <li><a href="#topkboottomk">topk/boottomk</a></li>
    <li><a href="#quantile">quantile</a></li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
<article class="markdown book-post">
  <h1>
    1.3 Prom Ql查询语言
  </h1>
  


  

  


  <div class="book-post-content markdown-inner"><p><a href="https://prometheus.io/docs/introduction">Prometheus 官方文档地址</a></p>
<h1 id="监控样本">监控样本<a class="anchor" href="#%e7%9b%91%e6%8e%a7%e6%a0%b7%e6%9c%ac">#</a></h1>
<p>通过 Node Exporter 暴露的 HTTP 服务，Prometheus 可以采集到当前主机所有监控指标的样本数据。比如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># HELP node_cpu_guest_seconds_total Seconds the CPUs spent in guests (VMs) for each mode.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># TYPE node_cpu_guest_seconds_total counter</span>
</span></span><span style="display:flex;"><span>node_cpu_guest_seconds_total<span style="color:#f92672">{</span>cpu<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;0&#34;</span>,mode<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;nice&#34;</span><span style="color:#f92672">}</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>node_cpu_guest_seconds_total<span style="color:#f92672">{</span>cpu<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;0&#34;</span>,mode<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;user&#34;</span><span style="color:#f92672">}</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>node_cpu_guest_seconds_total<span style="color:#f92672">{</span>cpu<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;1&#34;</span>,mode<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;nice&#34;</span><span style="color:#f92672">}</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>node_cpu_guest_seconds_total<span style="color:#f92672">{</span>cpu<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;1&#34;</span>,mode<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;user&#34;</span><span style="color:#f92672">}</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># HELP node_cpu_seconds_total Seconds the CPUs spent in each mode.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># TYPE node_cpu_seconds_total counter</span>
</span></span><span style="display:flex;"><span>node_cpu_seconds_total<span style="color:#f92672">{</span>cpu<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;0&#34;</span>,mode<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;idle&#34;</span><span style="color:#f92672">}</span> 996.7
</span></span><span style="display:flex;"><span>node_cpu_seconds_total<span style="color:#f92672">{</span>cpu<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;0&#34;</span>,mode<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;iowait&#34;</span><span style="color:#f92672">}</span> 0.52</span></span></code></pre></div><p>其中非 <code>#</code> 开头的每一行表示当前 Node Exporter 采集到的一个监控样本：</p>
<ul>
<li><code>node_cpu_seconds_total</code> ：表示当前指标名称</li>
<li>大括号中的标签：表示当前样本的一些特征和维度</li>
<li>浮点数：表示该监控样本的具体值</li>
</ul>
<h1 id="时间序列time-series">时间序列（time-series）<a class="anchor" href="#%e6%97%b6%e9%97%b4%e5%ba%8f%e5%88%97time-series">#</a></h1>
<p>Prometheus 会将所有采集到的样本数据以时间序列（time-series）的方式保存在内存数据库中，定时保存到硬盘上。</p>
<blockquote class='book-hint '>
<p>time-series 是按照时间戳和值的序列顺序存放的，称之为向量(vector)</p>
</blockquote><p>每条 time-series 通过指标名称(metrics name)和一组标签集(labelset)命名。其中每一个点称为一个样本(sample)。样本由以下三部分组成：</p>
<ul>
<li>指标（metric）：metric name 和描述当前样本特征的 labelsets</li>
<li>时间戳（timestamp）：一个精确到毫秒的时间戳</li>
<li>样本值（value）： 一个 float64 的浮点型数据表示当前样本的值</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>&lt;--------------- metric ---------------------&gt;&lt;-timestamp -&gt;&lt;-value-&gt;
</span></span><span style="display:flex;"><span>http_request_total<span style="color:#f92672">{</span>status<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;200&#34;</span>, method<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;GET&#34;</span><span style="color:#f92672">}</span>@1434417560938 <span style="color:#f92672">=</span>&gt; <span style="color:#ae81ff">94355</span>
</span></span><span style="display:flex;"><span>http_request_total<span style="color:#f92672">{</span>status<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;200&#34;</span>, method<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;GET&#34;</span><span style="color:#f92672">}</span>@1434417561287 <span style="color:#f92672">=</span>&gt; <span style="color:#ae81ff">94334</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>http_request_total<span style="color:#f92672">{</span>status<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;404&#34;</span>, method<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;GET&#34;</span><span style="color:#f92672">}</span>@1434417560938 <span style="color:#f92672">=</span>&gt; <span style="color:#ae81ff">38473</span>
</span></span><span style="display:flex;"><span>http_request_total<span style="color:#f92672">{</span>status<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;404&#34;</span>, method<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;GET&#34;</span><span style="color:#f92672">}</span>@1434417561287 <span style="color:#f92672">=</span>&gt; <span style="color:#ae81ff">38544</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>http_request_total<span style="color:#f92672">{</span>status<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;200&#34;</span>, method<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;POST&#34;</span><span style="color:#f92672">}</span>@1434417560938 <span style="color:#f92672">=</span>&gt; <span style="color:#ae81ff">4748</span>
</span></span><span style="display:flex;"><span>http_request_total<span style="color:#f92672">{</span>status<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;200&#34;</span>, method<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;POST&#34;</span><span style="color:#f92672">}</span>@1434417561287 <span style="color:#f92672">=</span>&gt; <span style="color:#ae81ff">4785</span></span></span></code></pre></div><h1 id="指标metric">指标（metric）<a class="anchor" href="#%e6%8c%87%e6%a0%87metric">#</a></h1>
<p>指标（Metric）通过如下格式表示：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>&lt;metric name&gt;<span style="color:#f92672">{</span>&lt;label name&gt;<span style="color:#f92672">=</span>&lt;label value&gt;, ...<span style="color:#f92672">}</span></span></span></code></pre></div><ul>
<li>指标名称(metric name)：表示被监控样本的含义。比如：<code>http_request_total</code> 表示当前系统接收到的HTTP请求总量。指标名称只能由ASCII字符、数字、下划线以及冒号组成并必须符合正则表达式 <code>[a-zA-Z_:][a-zA-Z0-9_:]*</code></li>
<li>标签(label)：反映当前样本的特征维度，通过这些维度 Prometheus 可以对样本数据进行过滤，聚合等。标签的名称只能由ASCII字符、数字以及下划线组成并满足正则表达式 <code>[a-zA-Z_][a-zA-Z0-9_]*</code></li>
</ul>
<p>其中以 <code>__</code> 作为前缀的标签是系统保留的关键字，只能在系统内部使用。标签的值可以包含任何 Unicode 编码的字符。</p>
<p>在 Prometheus 的底层实现中指标名称实际上是以 <code>__name__=&lt;metric name&gt;</code> 的形式保存在数据库中的，因此以下两种方式均表示的同一条 time-series：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>api_http_requests_total<span style="color:#f92672">{</span>method<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;POST&#34;</span>, handler<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;/messages&#34;</span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>等同于：
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>__name__<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;api_http_requests_total&#34;</span>，method<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;POST&#34;</span>, handler<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;/messages&#34;</span><span style="color:#f92672">}</span></span></span></code></pre></div><blockquote class='book-hint '>
<p>在 Prometheus 源码中也可以指标(Metric)对应的数据结构，如下所示：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>type Metric LabelSet
</span></span><span style="display:flex;"><span>type LabelSet map<span style="color:#f92672">[</span>LabelName<span style="color:#f92672">]</span>LabelValue
</span></span><span style="display:flex;"><span>type LabelName string
</span></span><span style="display:flex;"><span>type LabelValue string</span></span></code></pre></div></blockquote><h1 id="metric-类型">Metric 类型<a class="anchor" href="#metric-%e7%b1%bb%e5%9e%8b">#</a></h1>
<p>为了能够理解和区分不同监控指标之间的差异，Prometheus 定义了4中不同的指标类型（metric type）：</p>
<ol>
<li>Counter（计数器）</li>
<li>Gauge（仪表盘）</li>
<li>Histogram（直方图）</li>
<li>Summary（摘要）</li>
</ol>
<p>Exporter Node 返回的样本数据中，其注释中也包含了该样本的类型。例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># HELP node_cpu_seconds_total Seconds the CPUs spent in each mode.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># TYPE node_cpu_seconds_total counter</span>
</span></span><span style="display:flex;"><span>node_cpu_seconds_total<span style="color:#f92672">{</span>cpu<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;0&#34;</span>,mode<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;idle&#34;</span><span style="color:#f92672">}</span> 996.7</span></span></code></pre></div><h2 id="counter-只增不减">Counter-&gt;只增不减<a class="anchor" href="#counter-%e5%8f%aa%e5%a2%9e%e4%b8%8d%e5%87%8f">#</a></h2>
<p>Counter 类型的指标工作方式和计数器一样，只增不减（除非系统发生重置）。如 <code>http_requests_total</code> ，<code>node_cpu</code> 都是 Counter 类型的监控指标。 一般在定义 Counter 类型指标的名称时推荐使用 <code>_total</code> 作为后缀。</p>
<p>示例：通过 <code>rate()</code> 函数获取HTTP请求量的增长率：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>rate<span style="color:#f92672">(</span>http_requests_total<span style="color:#f92672">[</span>5m<span style="color:#f92672">])</span></span></span></code></pre></div><p>查询当前系统中，访问量前10的 HTTP 地址：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>topk<span style="color:#f92672">(</span>10, http_requests_total<span style="color:#f92672">)</span></span></span></code></pre></div><h2 id="gauge-可增可减">Gauge-&gt;可增可减<a class="anchor" href="#gauge-%e5%8f%af%e5%a2%9e%e5%8f%af%e5%87%8f">#</a></h2>
<p>Gauge 类型的指标侧重于反应系统的当前状态。因此这类指标的样本数据可增可减。如：<code>node_memory_MemFree（主机当前空闲的内容大小）</code>、<code>node_memory_MemAvailable</code>（可用内存大小）都是 Gauge 类型的监控指标。</p>
<p>通过 Gauge 指标，可以直接查看系统的当前状态。对于 Gauge 类型的监控指标，通过 PromQL 内置函数 <code>delta()</code> 可以获取样本在一段时间的变化情况。例如，计算CPU温度在两个小时内的差异：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>delta<span style="color:#f92672">(</span>cpu_temp_celsius<span style="color:#f92672">{</span>host<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;zeus&#34;</span><span style="color:#f92672">}[</span>2h<span style="color:#f92672">])</span></span></span></code></pre></div><p>还可以使用 <code>deriv()</code> 计算样本的线性回归模型，甚至直接使用 <code>predict_linear()</code> 对数据的变化趋势进行预测。例如：预测系统磁盘空间在4个小时之后的剩余情况：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>predict_linear<span style="color:#f92672">(</span>node_filesystem_free<span style="color:#f92672">{</span>job<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;node&#34;</span><span style="color:#f92672">}[</span>1h<span style="color:#f92672">]</span>, <span style="color:#ae81ff">4</span> * 3600<span style="color:#f92672">)</span></span></span></code></pre></div><h2 id="histogramsummary">Histogram/Summary<a class="anchor" href="#histogramsummary">#</a></h2>
<p>Histogram 和 Summary 主要用于统计和分析样本的分布情况。</p>
<blockquote class='book-hint '>
<p>大多数情况下人们都倾向于使用某些量化指标的平均值，例如CPU的平均使用率、页面的平均响应时间。这种方式的问题很明显，以系统API调用的平均响应时间为例：如果大多数API请求都维持在100ms 的响应时间范围内，而个别请求的响应时间需要 5s，那么就会导致某些WEB页面的响应时间落到中位数的情况，这种现象被称为长尾问题</p>
</blockquote><p>为了区分是平均的慢还是长尾的慢，最简单的方式就是按照请求延迟的范围进行分组。例如：统计延迟在 0<del>10ms 之间的请求数有多少而 10</del>20ms 之间的请求数又有多少。通过这种方式可以快速分析系统慢的原因。Histogram 和Summary 都是为了能够解决这样问题的存在，通过 Histogram 和 Summary 类型的监控指标，可以快速了解监控样本的分布情况。</p>
<p>例如：指标 <code>prometheus_tsdb_wal_fsync_duration_seconds</code> 的指标类型为 Summary。 它记录了 Prometheus Server 中 <code>wal_fsync</code> 处理的处理时间，通过访问 Prometheus Server 的 <code>/metrics</code> 地址，可以获取到以下监控样本数据：</p>
<pre tabindex="0"><code># HELP prometheus_tsdb_wal_fsync_duration_seconds Duration of WAL fsync.
# TYPE prometheus_tsdb_wal_fsync_duration_seconds summary
prometheus_tsdb_wal_fsync_duration_seconds{quantile=&#34;0.5&#34;} 0.012352463
prometheus_tsdb_wal_fsync_duration_seconds{quantile=&#34;0.9&#34;} 0.014458005
prometheus_tsdb_wal_fsync_duration_seconds{quantile=&#34;0.99&#34;} 0.017316173
prometheus_tsdb_wal_fsync_duration_seconds_sum 2.888716127000002
prometheus_tsdb_wal_fsync_duration_seconds_count 216</code></pre><p>从上面的样本中可以得知当前 Prometheus Server 进行 <code>wal_fsync</code> 操作的总次数为216次，耗时 <code>2.888716127000002s</code>。其中中位数（quantile=0.5）的耗时为 0.012352463，9分位数（quantile=0.9）的耗时为 0.014458005s。</p>
<p>在 Prometheus Server 自身返回的样本数据中，还能找到类型为 Histogram 的监控指标<code>prometheus_tsdb_compaction_chunk_range_bucket</code>。</p>
<pre tabindex="0"><code># HELP prometheus_tsdb_compaction_chunk_range Final time range of chunks on their first compaction
# TYPE prometheus_tsdb_compaction_chunk_range histogram
prometheus_tsdb_compaction_chunk_range_bucket{le=&#34;100&#34;} 0
prometheus_tsdb_compaction_chunk_range_bucket{le=&#34;400&#34;} 0
prometheus_tsdb_compaction_chunk_range_bucket{le=&#34;1600&#34;} 0
prometheus_tsdb_compaction_chunk_range_bucket{le=&#34;6400&#34;} 0
prometheus_tsdb_compaction_chunk_range_bucket{le=&#34;25600&#34;} 0
prometheus_tsdb_compaction_chunk_range_bucket{le=&#34;102400&#34;} 0
prometheus_tsdb_compaction_chunk_range_bucket{le=&#34;409600&#34;} 0
prometheus_tsdb_compaction_chunk_range_bucket{le=&#34;1.6384e+06&#34;} 260
prometheus_tsdb_compaction_chunk_range_bucket{le=&#34;6.5536e+06&#34;} 780
prometheus_tsdb_compaction_chunk_range_bucket{le=&#34;2.62144e+07&#34;} 780
prometheus_tsdb_compaction_chunk_range_bucket{le=&#34;+Inf&#34;} 780
prometheus_tsdb_compaction_chunk_range_sum 1.1540798e+09
prometheus_tsdb_compaction_chunk_range_count 780</code></pre><p>对比 Summary 类型的指标：</p>
<ul>
<li>相似之处在于： Histogram 类型的样本同样会反应当前指标的记录的总数(以 <code>_count</code> 作为后缀)以及其值的总量（以 <code>_sum</code> 作为后缀）</li>
<li>不同在于： Histogram 指标直接反应了在不同区间内样本的个数，区间通过标签 <code>len</code> 进行定义</li>
</ul>
<p>对于 Histogram 的指标，还可以通过 <code>histogram_quantile()</code> 函数计算出其值的分位数。不同在于:</p>
<ul>
<li>Histogram 通过 <code>histogram_quantile</code> 函数是在服务器端计算的分位数（会消耗更多的资源）</li>
<li>Sumamry 的分位数则是直接在客户端计算完成（在通过 PromQL 进行查询时有更好的性能表现）</li>
</ul>
<blockquote class='book-hint '>
<p>选择这两种方式时应该按照自己的实际场景进行选择</p>
</blockquote><h1 id="promql">PromQL<a class="anchor" href="#promql">#</a></h1>
<p>Prometheus 通过指标名称（metrics name）以及对应的一组标签（labelset）来定义一条时间序列。指标名称反映了监控样本的基本标识，而 label 则在这个基本特征上为采集到的数	过滤，聚合，统计从而产生新的计算后的一条时间序列。</p>
<blockquote class='book-hint '>
<p>PromQL 是 Prometheus 内置的数据查询语言，其提供对时间序列数据丰富的查询，聚合以及逻辑运算能力的支持</p>
</blockquote><h2 id="查询时间序列">查询时间序列<a class="anchor" href="#%e6%9f%a5%e8%af%a2%e6%97%b6%e9%97%b4%e5%ba%8f%e5%88%97">#</a></h2>
<p>当 Prometheus 通过 Exporter Node 采集到相应的监控指标样本数据后，可以通过 PromQL 对监控样本数据进行查询。比如：直接使用监控指标名称查询</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>prometheus_http_requests_total
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 等同于：</span>
</span></span><span style="display:flex;"><span>prometheus_http_requests_total<span style="color:#f92672">{}</span></span></span></code></pre></div><p>该表达式返回指标名称为 <code>http_requests_total</code> 的所有时间序列：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>prometheus_http_requests_total<span style="color:#f92672">{</span>code<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;200&#34;</span>, handler<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;/-/ready&#34;</span>, instance<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;localhost:9090&#34;</span>, job<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;prometheus&#34;</span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>prometheus_http_requests_total<span style="color:#f92672">{</span>code<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;200&#34;</span>, handler<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;/api/v1/label/:name/values&#34;</span>, instance<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;localhost:9090&#34;</span>, job<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;prometheus&#34;</span><span style="color:#f92672">}</span></span></span></code></pre></div><h2 id="标签过滤">标签过滤<a class="anchor" href="#%e6%a0%87%e7%ad%be%e8%bf%87%e6%bb%a4">#</a></h2>
<p>PromQL 支持根据时间序列的标签匹配模式来对时间序列进行过滤，目前主要支持两种匹配模式：</p>
<ul>
<li>完全匹配 <code>=</code>：使用 <code>label=value</code> 选择标签满足表达式定义的时间序列</li>
<li>正则匹配 <code>!=</code> ：使用 <code>label!=value </code> 根据标签匹配排除时间序列</li>
</ul>
<p>比如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>prometheus_http_requests_total<span style="color:#f92672">{</span>instance<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;localhost:9090&#34;</span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>prometheus_http_requests_total<span style="color:#f92672">{</span>instance!<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;localhost:9090&#34;</span><span style="color:#f92672">}</span></span></span></code></pre></div><p>除了使用完全匹配的方式对时间序列进行过滤以外，PromQL 还可以支持使用正则表达式作为匹配条件，多个表达式之间使用 <code>|</code> 进行分离：PromQL 支持使用 <code>=~</code> 和 <code>!~</code> 两种正则匹配模式：</p>
<ul>
<li>使用 <code>label=~regx</code> 表示选择那些标签符合正则表达式定义的时间序列</li>
<li>反之使用 <code>label!~regx</code> 进行排除</li>
</ul>
<p>比如，如果想查询多个环节下的时间序列序列可以使用如下表达式：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>prometheus_http_requests_total<span style="color:#f92672">{</span>environment<span style="color:#f92672">=</span>~<span style="color:#e6db74">&#34;staging|testing|development&#34;</span>,method!<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;GET&#34;</span><span style="color:#f92672">}</span></span></span></code></pre></div><h2 id="范围查询">范围查询<a class="anchor" href="#%e8%8c%83%e5%9b%b4%e6%9f%a5%e8%af%a2">#</a></h2>
<p>直接通过类似于 PromQL 表达式  <code>process_http_request_total</code>  查询时间序列时，返回值中只会包含该时间序列中最新的一个样本值，这样的返回结果为 <strong>瞬时向量</strong>。相应的表达式称为 <strong>瞬时向量表达式</strong>。</p>
<p>如果需要过去一段时间范围内的样本数据时，则需要使用 <strong>区间向量表达式</strong>。区间向量表达式和瞬时向量表达式差异在于：在区间向量表达式中需要定义时间选择的范围，时间范围通过时间范围选择器 <code>[]</code> 进行定义。例如，通过以下表达式可以选择最近5分钟内的所有样本数据：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>http_request_total<span style="color:#f92672">{}[</span>5m<span style="color:#f92672">]</span></span></span></code></pre></div><p>该表达式将会返回查询到的时间序列中最近5分钟的所有样本数据：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>prometheus_http_requests_total<span style="color:#f92672">{</span>code<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;200&#34;</span>, handler<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;/-/ready&#34;</span>, instance<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;localhost:9090&#34;</span>, job<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;prometheus&#34;</span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">10</span> @1657164241.316
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">10</span> @1657164256.319
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">10</span> @1657164271.319
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">10</span> @1657164286.316
</span></span><span style="display:flex;"><span>prometheus_http_requests_total<span style="color:#f92672">{</span>code<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;200&#34;</span>, handler<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;/api/v1/label/:name/values&#34;</span>, instance<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;localhost:9090&#34;</span>, job<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;prometheus&#34;</span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">10</span> @1657164241.316
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">10</span> @1657164256.319
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">10</span> @1657164271.319
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">10</span> @1657164286.316
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">11</span> @1657164301.316</span></span></code></pre></div><p>通过区间向量表达式查询到的结果称为 <strong>区间向量</strong>。</p>
<p>除了使用 <code>m</code> 表示分钟以外，PromQL 的时间范围选择器支持其它时间单位：</p>
<ul>
<li><code>s</code> - 秒</li>
<li><code>m</code> - 分钟</li>
<li><code>h</code> - 小时</li>
<li><code>d</code> - 天</li>
<li><code>w</code> - 周</li>
<li><code>y</code> - 年</li>
</ul>
<h2 id="时间位移">时间位移<a class="anchor" href="#%e6%97%b6%e9%97%b4%e4%bd%8d%e7%a7%bb">#</a></h2>
<p>在瞬时向量表达式或者区间向量表达式中，都是以当前时间为基准：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>http_request_total<span style="color:#f92672">{}</span> <span style="color:#75715e"># 瞬时向量表达式，选择当前最新的数据</span>
</span></span><span style="display:flex;"><span>http_request_total<span style="color:#f92672">{}[</span>5m<span style="color:#f92672">]</span> <span style="color:#75715e"># 区间向量表达式，选择以当前时间为基准，5分钟内的数据</span></span></span></code></pre></div><p>如果想查询5分钟前的瞬时样本数据，或昨天一天区间内的样本数据可以使用位移操作，位移操作的关键字为 <code>offset</code>。可以使用 <code>offset</code> 执行时间位移操作：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>http_request_total<span style="color:#f92672">{}</span> offset 5m
</span></span><span style="display:flex;"><span>http_request_total<span style="color:#f92672">{}[</span>1d<span style="color:#f92672">]</span> offset 1d</span></span></code></pre></div><h2 id="聚合操作">聚合操作<a class="anchor" href="#%e8%81%9a%e5%90%88%e6%93%8d%e4%bd%9c">#</a></h2>
<p>一般如果描述样本特征的标签(label)在并非唯一的情况下，通过 PromQL 查询数据，会返回多条满足这些特征维度的时间序列。PromQL 提供的聚合操作可以用来对这些时间序列进行处理，形成一条新的时间序列：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># 查询系统所有http请求的总量</span>
</span></span><span style="display:flex;"><span>sum<span style="color:#f92672">(</span>http_request_total<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 按照mode计算主机CPU的平均使用时间</span>
</span></span><span style="display:flex;"><span>avg<span style="color:#f92672">(</span>node_cpu<span style="color:#f92672">)</span> by <span style="color:#f92672">(</span>mode<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 按照主机查询各个主机的CPU使用率</span>
</span></span><span style="display:flex;"><span>sum<span style="color:#f92672">(</span>sum<span style="color:#f92672">(</span>irate<span style="color:#f92672">(</span>node_cpu<span style="color:#f92672">{</span>mode!<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;idle&#39;</span><span style="color:#f92672">}[</span>5m<span style="color:#f92672">]))</span>  / sum<span style="color:#f92672">(</span>irate<span style="color:#f92672">(</span>node_cpu<span style="color:#f92672">[</span>5m<span style="color:#f92672">])))</span> by <span style="color:#f92672">(</span>instance<span style="color:#f92672">)</span></span></span></code></pre></div><h2 id="操作符">操作符<a class="anchor" href="#%e6%93%8d%e4%bd%9c%e7%ac%a6">#</a></h2>
<h3 id="数学运算">数学运算<a class="anchor" href="#%e6%95%b0%e5%ad%a6%e8%bf%90%e7%ae%97">#</a></h3>
<p>例如：通过指标  <code>node_memory_free_bytes_total</code>  获取到当前主机可用的内存空间大小，样本单位为 Bytes。如果要求使用 <code>MB</code> 作为单位响应数据，只需要将查询到的时间序列的样本值进行单位换算即可：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>node_memory_free_bytes_total / <span style="color:#f92672">(</span><span style="color:#ae81ff">1024</span> * 1024<span style="color:#f92672">)</span></span></span></code></pre></div><blockquote class='book-hint '>
<p>瞬时向量与标量之间进行数学运算时：数学运算符会依次作用于瞬时向量中的每一个样本值，从而得到一组新的时间序列</p>
</blockquote><p>瞬时向量与瞬时向量之间进行数学运算时，过程会相对复杂一点。 例如，如果想根据 <code>node_disk_bytes_written</code> 和  <code>node_disk_bytes_read</code> 获取主机磁盘IO的总量，可以使用如下表达式：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>node_disk_bytes_written + node_disk_bytes_read</span></span></code></pre></div><p>工作原理是：依次找到与左边向量元素匹配（标签完全一致）的右边向量元素进行运算，如果没找到匹配元素，则直接丢弃。同时新的时间序列将不会包含指标名称。 该表达式返回结果的示例如下所示：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#f92672">{</span>device<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;sda&#34;</span>,instance<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;localhost:9100&#34;</span>,job<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;node_exporter&#34;</span><span style="color:#f92672">}=</span>&gt;1634967552@1518146427.807 + 864551424@1518146427.807
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span>device<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;sdb&#34;</span>,instance<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;localhost:9100&#34;</span>,job<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;node_exporter&#34;</span><span style="color:#f92672">}=</span>&gt;0@1518146427.807 + 1744384@1518146427.807</span></span></code></pre></div><p>PromQL 支持的数学运算符如下所示：</p>
<ul>
<li><code>+</code> (加法)</li>
<li><code>-</code> (减法)</li>
<li><code>*</code> (乘法)</li>
<li><code>/</code> (除法)</li>
<li><code>%</code> (求余)</li>
<li><code>^</code> (幂运算)</li>
</ul>
<h3 id="布尔运算">布尔运算<a class="anchor" href="#%e5%b8%83%e5%b0%94%e8%bf%90%e7%ae%97">#</a></h3>
<p>在 PromQL 通过标签匹配模式，可以根据时间序列的特征维度对其进行查询。而布尔运算则支持根据时间序列中样本的值，对时间序列进行过滤。</p>
<p>例如：通过数学运算符可以计算出当前所有主机节点的内存使用率：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#f92672">(</span>node_memory_bytes_total - node_memory_free_bytes_total<span style="color:#f92672">)</span> / node_memory_bytes_total</span></span></code></pre></div><p>而如果只想知道当前内存使用率超过95%的主机通过使用布尔运算符可以方便的获取到该结果：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#f92672">(</span>node_memory_bytes_total - node_memory_free_bytes_total<span style="color:#f92672">)</span> / node_memory_bytes_total &gt; 0.95</span></span></code></pre></div><p>瞬时向量与标量进行布尔运算时：PromQL 依次比较向量中的所有时间序列样本的值，如果比较结果为 true 则保留，反之丢弃。</p>
<p>瞬时向量与瞬时向量直接进行布尔运算时：同样遵循默认的匹配模式：依次找到与左边向量元素匹配（标签完全一致）的右边向量元素进行相应的操作，如果没找到匹配元素，则直接丢弃。</p>
<p>目前，Prometheus支持以下布尔运算符如下：</p>
<ul>
<li><code>==</code> (相等)</li>
<li><code>!=</code> (不相等)</li>
<li><code>&gt;</code> (大于)</li>
<li><code>&lt;</code> (小于)</li>
<li><code>&gt;=</code> (大于等于)</li>
<li><code>&lt;=</code> (小于等于)</li>
</ul>
<h3 id="bool-修饰符">bool 修饰符<a class="anchor" href="#bool-%e4%bf%ae%e9%a5%b0%e7%ac%a6">#</a></h3>
<p>布尔运算符的默认行为是对时序数据进行过滤。而在其它的情况下可能需要的是真正的布尔结果。例如，只需要知道当前模块的 HTTP 请求量是否 &gt;=1000，如果大于等于1000则返回1（true）否则返回0（false）。这时可以使用  bool 修饰符改变布尔运算的默认行为。 例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>http_requests_total &gt; bool <span style="color:#ae81ff">1000</span></span></span></code></pre></div><p>使用 bool 修改符后，布尔运算不会对时间序列进行过滤，而是直接依次瞬时向量中的各个样本数据与标量的比较结果0或者1，从而形成一条新的时间序列。</p>
<pre tabindex="0"><code>http_requests_total{code=&#34;200&#34;,handler=&#34;query&#34;,instance=&#34;localhost:9090&#34;,job=&#34;prometheus&#34;,method=&#34;get&#34;}  1
http_requests_total{code=&#34;200&#34;,handler=&#34;query_range&#34;,instance=&#34;localhost:9090&#34;,job=&#34;prometheus&#34;,method=&#34;get&#34;}  0</code></pre><p>同时需要注意的是，如果是在两个标量之间使用布尔运算，则必须使用 bool 修饰符</p>
<pre tabindex="0"><code>2 == bool 2 # 结果为1</code></pre><h2 id="集合运算符">集合运算符<a class="anchor" href="#%e9%9b%86%e5%90%88%e8%bf%90%e7%ae%97%e7%ac%a6">#</a></h2>
<p>使用瞬时向量表达式能够获取到一个包含多个时间序列的集合，称为瞬时向量。 通过集合运算，可以在两个瞬时向量之间进行相应的集合操作。目前 Prometheus 支持以下集合运算符：</p>
<ul>
<li><code>and</code> (并且)</li>
<li><code>or</code> (或者)</li>
<li><code>unless</code> (排除)</li>
</ul>
<p><code>vector1 and vector2</code> 产生一个由 vector1 的元素组成的新的向量。该向量包含 vector1 中完全匹配 vector2 中的元素组成</p>
<p><code>vector1 or vector2</code> 产生一个新的向量，该向量包含 vector1 中所有的样本数据，以及 vector2 中没有与 vector1 匹配到的样本数据</p>
<p><code>vector1 unless vector2</code> 产生一个新的向量，新向量中的元素由 vector1 中没有与 vector2 匹配的元素组成</p>
<h2 id="操作符优先级">操作符优先级<a class="anchor" href="#%e6%93%8d%e4%bd%9c%e7%ac%a6%e4%bc%98%e5%85%88%e7%ba%a7">#</a></h2>
<p>对于复杂类型的表达式，需要了解运算操作的运行优先级，PromQL 操作符中优先级由高到低依次为：</p>
<ol>
<li><code>^</code></li>
<li><code>*, /, %</code></li>
<li><code>+, -</code></li>
<li><code>==, !=, &lt;=, &lt;, &gt;=, &gt;</code></li>
<li><code>and, unless</code></li>
<li><code>or</code></li>
</ol>
<h2 id="匹配模式">匹配模式<a class="anchor" href="#%e5%8c%b9%e9%85%8d%e6%a8%a1%e5%bc%8f">#</a></h2>
<p>向量与向量之间进行运算操作时会基于默认的匹配规则：依次找到与左边向量元素匹配（标签完全一致）的右边向量元素进行运算，如果没找到匹配元素，则直接丢弃。</p>
<p>在 PromQL 中有两种典型的匹配模式：一对一（one-to-one）,多对一（many-to-one）或一对多（one-to-many）。</p>
<h3 id="一对一匹配">一对一匹配<a class="anchor" href="#%e4%b8%80%e5%af%b9%e4%b8%80%e5%8c%b9%e9%85%8d">#</a></h3>
<p>一对一匹配模式会从操作符两边表达式获取的瞬时向量依次比较并找到唯一匹配(标签完全一致)的样本值。默认情况下，使用表达式：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>vector1 &lt;operator&gt; vector2</span></span></code></pre></div><p>在操作符两边表达式标签不一致的情况下，可以使用 <code>on(label list)</code> 或者 <code>ignoring(label list）</code>修改便签的匹配行为。使用 <code>ignoreing</code> 可以在匹配时忽略某些标签。而 <code>on</code> 则用于将匹配行为限定在某些标签之内。</p>
<pre tabindex="0"><code>&lt;vector expr&gt; &lt;bin-op&gt; ignoring(&lt;label list&gt;) &lt;vector expr&gt;
&lt;vector expr&gt; &lt;bin-op&gt; on(&lt;label list&gt;) &lt;vector expr&gt;</code></pre><p>例如当存在样本：</p>
<pre tabindex="0"><code>method_code:http_errors:rate5m{method=&#34;get&#34;, code=&#34;500&#34;}  24
method_code:http_errors:rate5m{method=&#34;get&#34;, code=&#34;404&#34;}  30
method_code:http_errors:rate5m{method=&#34;put&#34;, code=&#34;501&#34;}  3
method_code:http_errors:rate5m{method=&#34;post&#34;, code=&#34;500&#34;} 6
method_code:http_errors:rate5m{method=&#34;post&#34;, code=&#34;404&#34;} 21

method:http_requests:rate5m{method=&#34;get&#34;}  600
method:http_requests:rate5m{method=&#34;del&#34;}  34
method:http_requests:rate5m{method=&#34;post&#34;} 120</code></pre><p>使用 PromQL 表达式：</p>
<pre tabindex="0"><code>method_code:http_errors:rate5m{code=&#34;500&#34;} / ignoring(code) method:http_requests:rate5m</code></pre><p>该表达式会返回在过去5分钟内，HTTP请求状态码为500的在所有请求中的比例。如果没有使用 <code>ignoring(code)</code>，操作符两边表达式返回的瞬时向量中将找不到任何一个标签完全相同的匹配项。</p>
<p>因此结果如下：</p>
<pre tabindex="0"><code>{method=&#34;get&#34;}  0.04            //  24 / 600
{method=&#34;post&#34;} 0.05            //   6 / 120</code></pre><p>同时由于method为put和del的样本找不到匹配项，因此不会出现在结果当中。</p>
<h3 id="多对一和一对多">多对一和一对多<a class="anchor" href="#%e5%a4%9a%e5%af%b9%e4%b8%80%e5%92%8c%e4%b8%80%e5%af%b9%e5%a4%9a">#</a></h3>
<p>多对一和一对多两种匹配模式指的是“一”侧的每一个向量元素可以与&quot;多&quot;侧的多个元素匹配的情况。在这种情况下，必须使用 group 修饰符：<code>group_left</code> 或者 <code>group_right</code> 来确定哪一个向量具有更高的基数（充当“多”的角色）。</p>
<pre tabindex="0"><code>&lt;vector expr&gt; &lt;bin-op&gt; ignoring(&lt;label list&gt;) group_left(&lt;label list&gt;) &lt;vector expr&gt;
&lt;vector expr&gt; &lt;bin-op&gt; ignoring(&lt;label list&gt;) group_right(&lt;label list&gt;) &lt;vector expr&gt;
&lt;vector expr&gt; &lt;bin-op&gt; on(&lt;label list&gt;) group_left(&lt;label list&gt;) &lt;vector expr&gt;
&lt;vector expr&gt; &lt;bin-op&gt; on(&lt;label list&gt;) group_right(&lt;label list&gt;) &lt;vector expr&gt;</code></pre><p>多对一和一对多两种模式一定是出现在操作符两侧表达式返回的向量标签不一致的情况。因此需要使用 <code>ignoring</code> 和 <code>on</code> 修饰符来排除或者限定匹配的标签列表。</p>
<p>例如表达式：</p>
<pre tabindex="0"><code>method_code:http_errors:rate5m / ignoring(code) group_left method:http_requests:rate5m</code></pre><p>该表达式中，左向量 <code>method_code:http_errors:rate5m</code> 包含两个标签method和code。而右向量<code>method:http_requests:rate5m</code> 中只包含一个标签 method，因此匹配时需要使用 ignoring 限定匹配的标签为code。 在限定匹配标签后，右向量中的元素可能匹配到多个左向量中的元素 因此该表达式的匹配模式为多对一，需要使用 <code>group</code> 修饰符<code> group_left</code> 指定左向量具有更好的基数。</p>
<p>最终运算结果如下：</p>
<pre tabindex="0"><code>{method=&#34;get&#34;, code=&#34;500&#34;}  0.04            //  24 / 600
{method=&#34;get&#34;, code=&#34;404&#34;}  0.05            //  30 / 600
{method=&#34;post&#34;, code=&#34;500&#34;} 0.05            //   6 / 120
{method=&#34;post&#34;, code=&#34;404&#34;} 0.175           //  21 / 120</code></pre><blockquote class='book-hint '>
<p>注意：group 修饰符只能在比较和数学运算符中使用。在逻辑运算 <code>and</code>, <code>unless</code> 和 <code>or</code> 才注意操作中默认与右向量中的所有元素进行匹配。</p>
</blockquote><h1 id="聚合操作-1">聚合操作<a class="anchor" href="#%e8%81%9a%e5%90%88%e6%93%8d%e4%bd%9c-1">#</a></h1>
<p>Prometheus 还提供了下列内置的聚合操作符，这些操作符作用域瞬时向量。用于将瞬时表达式返回的样本数据进行聚合，形成一个新的时间序列。</p>
<ul>
<li><code>sum</code> (求和)</li>
<li><code>min</code> (最小值)</li>
<li><code>max</code> (最大值)</li>
<li><code>avg</code> (平均值)</li>
<li><code>stddev</code> (标准差)</li>
<li><code>stdvar</code> (标准差异)</li>
<li><code>count</code> (计数)</li>
<li><code>count_values</code> (对value进行计数)</li>
<li><code>bottomk</code> (后n条时序)</li>
<li><code>topk</code> (前n条时序)</li>
<li><code>quantile</code> (分布统计)</li>
</ul>
<p>使用聚合操作的语法如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>&lt;aggr-op&gt;<span style="color:#f92672">([</span>parameter,<span style="color:#f92672">]</span> &lt;vector expression&gt;<span style="color:#f92672">)</span> <span style="color:#f92672">[</span>without|by <span style="color:#f92672">(</span>&lt;label list&gt;<span style="color:#f92672">)]</span></span></span></code></pre></div><p>其中只有 <code>count_values</code>、<code>quantile</code>、<code>topk</code>、<code>bottomk </code>支持参数(parameter)。</p>
<h2 id="withoutby">without/by<a class="anchor" href="#withoutby">#</a></h2>
<ul>
<li><code>without</code> ：用于从计算结果中移除列举的标签而保留其它标签</li>
<li><code>by</code> ：正好相反，结果向量中只保留列出的标签，其余标签则移除</li>
</ul>
<p>通过 <code>without</code> 和 <code>by</code> 可以按照样本的问题对数据进行聚合。</p>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sum<span style="color:#f92672">(</span>http_requests_total<span style="color:#f92672">)</span> without <span style="color:#f92672">(</span>instance<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>等价于：
</span></span><span style="display:flex;"><span>sum<span style="color:#f92672">(</span>http_requests_total<span style="color:#f92672">)</span> by <span style="color:#f92672">(</span>code,handler,job,method<span style="color:#f92672">)</span></span></span></code></pre></div><p>如果只需要计算整个应用的HTTP请求总量，可以直接使用表达式：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sum<span style="color:#f92672">(</span>http_requests_total<span style="color:#f92672">)</span></span></span></code></pre></div><h2 id="count_values">count_values<a class="anchor" href="#count_values">#</a></h2>
<p><code>count_values</code> 用于时间序列中每一个样本值出现的次数。<code>count_values</code> 会为每一个唯一的样本值输出一个时间序列，并且每一个时间序列包含一个额外的标签。</p>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>count_values<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;count&#34;</span>, http_requests_total<span style="color:#f92672">)</span></span></span></code></pre></div><h2 id="topkboottomk">topk/boottomk<a class="anchor" href="#topkboottomk">#</a></h2>
<p><code>topk</code> 和 <code>bottomk</code> 则用于对样本值进行排序，返回当前样本值前n位，或者后n位的时间序列。</p>
<p>例如：获取HTTP请求数前5位的时序样本数据，可以使用表达式：</p>
<pre tabindex="0"><code>topk(5, http_requests_total)</code></pre><h2 id="quantile">quantile<a class="anchor" href="#quantile">#</a></h2>
<p><code>quantile</code> 用于计算当前样本数据值的分布情况 <code>quantile(φ, express)</code> 其中 <code>0 ≤ φ ≤ 1</code>。</p>
<p>例如：当φ为0.5时，即表示找到当前样本数据中的中位数：</p>
<pre tabindex="0"><code>quantile(0.5, http_requests_total)</code></pre><h1 id="常见内置函数">常见内置函数<a class="anchor" href="#%e5%b8%b8%e8%a7%81%e5%86%85%e7%bd%ae%e5%87%bd%e6%95%b0">#</a></h1>
<p><a href="https://www.prometheus.wang/promql/prometheus-promql-functions.html">内置函数相关参考</a></p>
</div>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">
  <div>
  
    <a href="/posts/prometheus/1.2exporter%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86/" class="flex align-center">
      <img src="/icons/backward.svg" class="book-icon" alt="Backward" />
      <span>1.2 Exporter数据采集</span>
    </a>
  
  </div>
  <div>
  
    <a href="/posts/prometheus/1.4alertmanager%E5%91%8A%E8%AD%A6%E5%A4%84%E7%90%86/" class="flex align-center">
      <span>1.4 Alertmanager告警处理</span>
      <img src="/icons/forward.svg" class="book-icon" alt="Forward" />
    </a>
  
  </div>
</div>
 
        
  
 
        
        
  
 
        
  
  
    <script>(function(){document.querySelectorAll("pre:has(code)").forEach(e=>{e.addEventListener("click",e.focus),e.addEventListener("copy",function(t){if(t.preventDefault(),navigator.clipboard){const t=window.getSelection().toString()||e.textContent;navigator.clipboard.writeText(t)}})})})()</script>
  

      </footer>

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
  
  <aside class="book-toc">
    <div class="book-toc-content">
      
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#counter-只增不减">Counter-&gt;只增不减</a></li>
    <li><a href="#gauge-可增可减">Gauge-&gt;可增可减</a></li>
    <li><a href="#histogramsummary">Histogram/Summary</a></li>
  </ul>

  <ul>
    <li><a href="#查询时间序列">查询时间序列</a></li>
    <li><a href="#标签过滤">标签过滤</a></li>
    <li><a href="#范围查询">范围查询</a></li>
    <li><a href="#时间位移">时间位移</a></li>
    <li><a href="#聚合操作">聚合操作</a></li>
    <li><a href="#操作符">操作符</a>
      <ul>
        <li><a href="#数学运算">数学运算</a></li>
        <li><a href="#布尔运算">布尔运算</a></li>
        <li><a href="#bool-修饰符">bool 修饰符</a></li>
      </ul>
    </li>
    <li><a href="#集合运算符">集合运算符</a></li>
    <li><a href="#操作符优先级">操作符优先级</a></li>
    <li><a href="#匹配模式">匹配模式</a>
      <ul>
        <li><a href="#一对一匹配">一对一匹配</a></li>
        <li><a href="#多对一和一对多">多对一和一对多</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#withoutby">without/by</a></li>
    <li><a href="#count_values">count_values</a></li>
    <li><a href="#topkboottomk">topk/boottomk</a></li>
    <li><a href="#quantile">quantile</a></li>
  </ul>
</nav>



    </div>
  </aside>
  
 
  </main>

  
</body>
</html>




















