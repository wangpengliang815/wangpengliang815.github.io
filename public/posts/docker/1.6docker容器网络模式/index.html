<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="安装Docker时会自动创建三个网络。可以使用 docker network ls 命令列出网络：
[root@centos-01 ~]# docker network ls NETWORK ID NAME DRIVER SCOPE cdda3ae8795a bridge bridge local ed7ffc7437dd host host local fa66bc1a17f4 none null local四种网络模式# 在使用 docker run 创建容器时，可以用 --network 指定容器的网络模式，Docker有以下四种网络模式：
--net=host ：容器和宿主机共享 Network namespace --net=none ：容器有独立的 Network namespace，但并没有对其进行任何网络设置，如分配 veth pair 和网桥连接、配置IP等 --net=bridge：默认设置 --net=container:name_Or_id ：容器和另外一个容器共享 Network namespace Bridge# 简介# 该模式是在启动docker服务后默认的网络模式，Docker 启动时，Docker使用Linux桥接（参考《Linux虚拟网络技术》），在宿主机虚拟一个Docker容器网桥 docker0，Docker启动一个容器时会根据Docker网桥的网段分配给容器一个IP地址，称为 Container-IP ，同时Docker网桥是每个容器的默认网关。因为在同一宿主机内的容器都接入同一个网桥，这样容器之间就能够通过容器的 Container-IP 互相通信。
当创建一个 Docker 容器时，同时会创建一个 veth pair 接口（当数据包发送到一个接口时，另外一个接口也可以接收相同的数据包）。这对接口一端在容器内，即 eth0 ；另一端在本地并被挂载到 docker0 网桥，名称以 veth 开头。通过这种方式主机可以跟容器通信，容器之间也可以相互通信。Docker就创建了在主机和所有容器之间的一个虚拟共享网络。
">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:url" content="http://localhost:1313/posts/docker/1.6docker%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F/">
  <meta property="og:site_name" content="CODE&#39;NOTE">
  <meta property="og:title" content="CODE&#39;NOTE">
  <meta property="og:description" content="安装Docker时会自动创建三个网络。可以使用 docker network ls 命令列出网络：
[root@centos-01 ~]# docker network ls NETWORK ID NAME DRIVER SCOPE cdda3ae8795a bridge bridge local ed7ffc7437dd host host local fa66bc1a17f4 none null local四种网络模式# 在使用 docker run 创建容器时，可以用 --network 指定容器的网络模式，Docker有以下四种网络模式：
--net=host ：容器和宿主机共享 Network namespace --net=none ：容器有独立的 Network namespace，但并没有对其进行任何网络设置，如分配 veth pair 和网桥连接、配置IP等 --net=bridge：默认设置 --net=container:name_Or_id ：容器和另外一个容器共享 Network namespace Bridge# 简介# 该模式是在启动docker服务后默认的网络模式，Docker 启动时，Docker使用Linux桥接（参考《Linux虚拟网络技术》），在宿主机虚拟一个Docker容器网桥 docker0，Docker启动一个容器时会根据Docker网桥的网段分配给容器一个IP地址，称为 Container-IP ，同时Docker网桥是每个容器的默认网关。因为在同一宿主机内的容器都接入同一个网桥，这样容器之间就能够通过容器的 Container-IP 互相通信。
当创建一个 Docker 容器时，同时会创建一个 veth pair 接口（当数据包发送到一个接口时，另外一个接口也可以接收相同的数据包）。这对接口一端在容器内，即 eth0 ；另一端在本地并被挂载到 docker0 网桥，名称以 veth 开头。通过这种方式主机可以跟容器通信，容器之间也可以相互通信。Docker就创建了在主机和所有容器之间的一个虚拟共享网络。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">


  <meta itemprop="name" content="CODE&#39;NOTE">
  <meta itemprop="description" content="安装Docker时会自动创建三个网络。可以使用 docker network ls 命令列出网络：
[root@centos-01 ~]# docker network ls NETWORK ID NAME DRIVER SCOPE cdda3ae8795a bridge bridge local ed7ffc7437dd host host local fa66bc1a17f4 none null local四种网络模式# 在使用 docker run 创建容器时，可以用 --network 指定容器的网络模式，Docker有以下四种网络模式：
--net=host ：容器和宿主机共享 Network namespace --net=none ：容器有独立的 Network namespace，但并没有对其进行任何网络设置，如分配 veth pair 和网桥连接、配置IP等 --net=bridge：默认设置 --net=container:name_Or_id ：容器和另外一个容器共享 Network namespace Bridge# 简介# 该模式是在启动docker服务后默认的网络模式，Docker 启动时，Docker使用Linux桥接（参考《Linux虚拟网络技术》），在宿主机虚拟一个Docker容器网桥 docker0，Docker启动一个容器时会根据Docker网桥的网段分配给容器一个IP地址，称为 Container-IP ，同时Docker网桥是每个容器的默认网关。因为在同一宿主机内的容器都接入同一个网桥，这样容器之间就能够通过容器的 Container-IP 互相通信。
当创建一个 Docker 容器时，同时会创建一个 veth pair 接口（当数据包发送到一个接口时，另外一个接口也可以接收相同的数据包）。这对接口一端在容器内，即 eth0 ；另一端在本地并被挂载到 docker0 网桥，名称以 veth 开头。通过这种方式主机可以跟容器通信，容器之间也可以相互通信。Docker就创建了在主机和所有容器之间的一个虚拟共享网络。">
  <meta itemprop="wordCount" content="797">

<title>1.6 Docker容器网络模式 | CODE&#39;NOTE</title>
<link rel="icon" href="/favicon.png" >
<link rel="manifest" href="/manifest.json">
<link rel="canonical" href="http://localhost:1313/posts/docker/1.6docker%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F/">
<link rel="stylesheet" href="/book.min.6970156cec683193d93c9c4edaf0d56574e4361df2e0c1be4f697ae81c3ba55f.css" integrity="sha256-aXAVbOxoMZPZPJxO2vDVZXTkNh3y4MG&#43;T2l66Bw7pV8=" crossorigin="anonymous">


  <script defer src="/fuse.min.js"></script>
  <script defer src="/en.search.min.3ed9c79c605914c45e19db90edfda0ca8d87c63064c1d6252862250c4e917346.js" integrity="sha256-PtnHnGBZFMReGduQ7f2gyo2HxjBkwdYlKGIlDE6Rc0Y=" crossorigin="anonymous"></script>



  
</head>
<body dir="ltr" class="book-kind-page book-type-posts">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    
<aside class="book-menu">
  <div class="book-menu-content">
    
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><span>CODE&#39;NOTE</span>
  </a>
</h2>


<div class="book-search hidden">
  <input id="book-search-input" type="text" 
    placeholder="Search"
    aria-label="Search"
    maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>
<script>document.querySelector(".book-search").classList.remove("hidden")</script>
























</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>



  </div>
</aside>
 

    <div class="book-page">
      <header class="book-header hidden">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/icons/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <h3>1.6 Docker容器网络模式</h3>

  <label for="toc-control">
    
    <img src="/icons/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#bridge">Bridge</a>
      <ul>
        <li><a href="#简介">简介</a></li>
        <li><a href="#测试">测试</a></li>
      </ul>
    </li>
    <li><a href="#host">Host</a>
      <ul>
        <li><a href="#简介-1">简介</a></li>
        <li><a href="#测试-1"><strong>测试</strong></a></li>
      </ul>
    </li>
    <li><a href="#container">Container</a></li>
    <li><a href="#none">None</a></li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
<article class="markdown book-post">
  <h1>
    1.6 Docker容器网络模式
  </h1>
  


  

  


  <div class="book-post-content markdown-inner"><p>安装Docker时会自动创建三个网络。可以使用 <code>docker network ls</code> 命令列出网络：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#f92672">[</span>root@centos-01 ~<span style="color:#f92672">]</span><span style="color:#75715e"># docker network ls</span>
</span></span><span style="display:flex;"><span>NETWORK ID     NAME      DRIVER    SCOPE
</span></span><span style="display:flex;"><span>cdda3ae8795a   bridge    bridge    local
</span></span><span style="display:flex;"><span>ed7ffc7437dd   host      host      local
</span></span><span style="display:flex;"><span>fa66bc1a17f4   none      null      local</span></span></code></pre></div><h1 id="四种网络模式">四种网络模式<a class="anchor" href="#%e5%9b%9b%e7%a7%8d%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%bc%8f">#</a></h1>
<p>在使用 <code>docker run</code> 创建容器时，可以用 <code>--network</code>  指定容器的网络模式，Docker有以下四种网络模式：</p>
<ul>
<li><code>--net=host</code> ：容器和宿主机共享 <code>Network namespace</code></li>
<li><code>--net=none</code> ：容器有独立的  <code>Network namespace</code>，但并没有对其进行任何网络设置，如分配 <code> veth pair</code> 和网桥连接、配置IP等</li>
<li><code>--net=bridge</code>：默认设置</li>
<li><code>--net=container:name_Or_id </code> ：容器和另外一个容器共享 <code>Network namespace</code></li>
</ul>
<h2 id="bridge">Bridge<a class="anchor" href="#bridge">#</a></h2>
<h3 id="简介">简介<a class="anchor" href="#%e7%ae%80%e4%bb%8b">#</a></h3>
<p>该模式是在启动docker服务后默认的网络模式，Docker 启动时，Docker使用Linux桥接（参考<a href="https://www.jianshu.com/p/f86d4b88777d">《Linux虚拟网络技术》</a>），在宿主机虚拟一个Docker容器网桥 <code>docker0</code>，Docker启动一个容器时会根据Docker网桥的网段分配给容器一个IP地址，称为 <code>Container-IP</code> ，同时Docker网桥是每个容器的默认网关。因为在同一宿主机内的容器都接入同一个网桥，这样容器之间就能够通过容器的 <code>Container-IP</code> 互相通信。</p>
<p>当创建一个 <code>Docker</code> 容器时，同时会创建一个 <code>veth pair</code>  接口（当数据包发送到一个接口时，另外一个接口也可以接收相同的数据包）。这对接口一端在容器内，即 <code>eth0</code> ；另一端在本地并被挂载到 <code>docker0</code>  网桥，名称以 <code>veth</code>  开头。通过这种方式主机可以跟容器通信，容器之间也可以相互通信。Docker就创建了在主机和所有容器之间的一个虚拟共享网络。</p>
<p>在安装和启动docker服务之后即可查看到这个 <code>docker0</code> 的虚拟网桥设备：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#f92672">[</span>root@centos-01 ~<span style="color:#f92672">]</span><span style="color:#75715e"># ip addr</span>
</span></span><span style="display:flex;"><span>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu <span style="color:#ae81ff">65536</span> qdisc noqueue state UNKNOWN group default qlen <span style="color:#ae81ff">1000</span>
</span></span><span style="display:flex;"><span>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
</span></span><span style="display:flex;"><span>    inet 127.0.0.1/8 scope host lo
</span></span><span style="display:flex;"><span>       valid_lft forever preferred_lft forever
</span></span><span style="display:flex;"><span>    inet6 ::1/128 scope host 
</span></span><span style="display:flex;"><span>       valid_lft forever preferred_lft forever
</span></span><span style="display:flex;"><span>       
</span></span><span style="display:flex;"><span>2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span style="color:#ae81ff">1500</span> qdisc pfifo_fast state UP group default qlen <span style="color:#ae81ff">1000</span>
</span></span><span style="display:flex;"><span>    link/ether 00:0c:29:50:75:ae brd ff:ff:ff:ff:ff:ff
</span></span><span style="display:flex;"><span>    inet 192.168.126.143/24 brd 192.168.126.255 scope global noprefixroute ens33
</span></span><span style="display:flex;"><span>       valid_lft forever preferred_lft forever
</span></span><span style="display:flex;"><span>    inet6 2409:8900:2b86:13cc:a958:4c6e:c162:309d/64 scope global noprefixroute dynamic 
</span></span><span style="display:flex;"><span>       valid_lft 3569sec preferred_lft 3569sec
</span></span><span style="display:flex;"><span>    inet6 fe80::1f3a:afc1:82f6:3f66/64 scope link noprefixroute 
</span></span><span style="display:flex;"><span>       valid_lft forever preferred_lft forever
</span></span><span style="display:flex;"><span>       
</span></span><span style="display:flex;"><span>3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu <span style="color:#ae81ff">1500</span> qdisc noqueue state DOWN group default 
</span></span><span style="display:flex;"><span>    link/ether 02:42:cb:f1:35:ea brd ff:ff:ff:ff:ff:ff
</span></span><span style="display:flex;"><span>    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0
</span></span><span style="display:flex;"><span>       valid_lft forever preferred_lft forever</span></span></code></pre></div><blockquote class='book-hint '>
<p><code>docker0</code> 网桥是宿主机虚拟出来的，并不是真实存在的网络设备，外部网络是无法通过ip地址直接寻址的，需要通过其他方式来使外部网络可以访问容器，一般会通过 <strong>访问宿主机ip结合容器的端口（端口映射）进行容器的访问</strong></p>
</blockquote><p><img src="/images/2021-09-09-14-29-16.png" alt="" /></p>
<p><strong>实现步骤</strong></p>
<ol>
<li><code>Docker Daemon</code> 利用 <code>veth pair</code>  技术，在宿主机上创建两个虚拟网络接口设备，假设为 <code>veth0</code>  和 <code>veth1</code> 。 <code>veth pair</code> 技术的特性可以保证无论哪一个 <code>veth</code>  接收到网络报文，都会将报文传输给另一方</li>
<li><code>Docker Daemon</code>  将 <code>veth0</code>  附加到 <code>Docker Daemon</code> 创建的 <code>docker0</code> 网桥上。保证宿主机的网络报文可以发往 <code>veth0</code> </li>
<li><code>Docker Daemon</code>  将 <code>veth1</code>  添加到 <code>Docker Container</code> 所属的 <code>namespace</code>  下，并被改名为 <code>eth0</code> 。保证宿主机的网络报文若发往 <code>veth0</code> 则立即会被 <code>eth0</code> 接收，实现宿主机到<code>Docker Container</code>网络的联通，同时也保证容器单独使用 <code>eth0</code>，实现容器网络环境的隔离</li>
</ol>
<p><strong>缺陷</strong></p>
<ol>
<li>该模式下容器不具有公有IP ，就是说和宿主机的 <code>eth0</code> 不处于同一个网段。导致的结果是：在宿主机以外不能直接和容器进行通信</li>
<li>虽然经过中间处理（NAT模式） 可以解决公有IP的问题，但是NAT模式仍然存在问题与不便，比如：容器都需要在宿主机上竞争端口，容器内部服务的访问者需要使用服务发现获知服务的外部端口等</li>
<li>另外由于NAT模式是在三层网络上的实现手段，会影响网络传输效率</li>
</ol>
<h3 id="测试">测试<a class="anchor" href="#%e6%b5%8b%e8%af%95">#</a></h3>
<p>1)：查看本机网络</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#f92672">[</span>root@centos-01 ~<span style="color:#f92672">]</span><span style="color:#75715e"># ip addr</span>
</span></span><span style="display:flex;"><span>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu <span style="color:#ae81ff">65536</span> qdisc noqueue state UNKNOWN group default qlen <span style="color:#ae81ff">1000</span>
</span></span><span style="display:flex;"><span>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
</span></span><span style="display:flex;"><span>    inet 127.0.0.1/8 scope host lo
</span></span><span style="display:flex;"><span>       valid_lft forever preferred_lft forever
</span></span><span style="display:flex;"><span>    inet6 ::1/128 scope host 
</span></span><span style="display:flex;"><span>       valid_lft forever preferred_lft forever
</span></span><span style="display:flex;"><span>       
</span></span><span style="display:flex;"><span>2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span style="color:#ae81ff">1500</span> qdisc pfifo_fast state UP group default qlen <span style="color:#ae81ff">1000</span>
</span></span><span style="display:flex;"><span>    link/ether 00:0c:29:50:75:ae brd ff:ff:ff:ff:ff:ff
</span></span><span style="display:flex;"><span>    inet 192.168.126.143/24 brd 192.168.126.255 scope global noprefixroute ens33
</span></span><span style="display:flex;"><span>       valid_lft forever preferred_lft forever
</span></span><span style="display:flex;"><span>    inet6 2409:8900:2b86:13cc:a958:4c6e:c162:309d/64 scope global noprefixroute dynamic 
</span></span><span style="display:flex;"><span>       valid_lft 3569sec preferred_lft 3569sec
</span></span><span style="display:flex;"><span>    inet6 fe80::1f3a:afc1:82f6:3f66/64 scope link noprefixroute 
</span></span><span style="display:flex;"><span>       valid_lft forever preferred_lft forever
</span></span><span style="display:flex;"><span>       
</span></span><span style="display:flex;"><span>3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu <span style="color:#ae81ff">1500</span> qdisc noqueue state DOWN group default 
</span></span><span style="display:flex;"><span>    link/ether 02:42:cb:f1:35:ea brd ff:ff:ff:ff:ff:ff
</span></span><span style="display:flex;"><span>    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0
</span></span><span style="display:flex;"><span>       valid_lft forever preferred_lft forever</span></span></code></pre></div><p>2)：创建容器并查看IP</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#f92672">[</span>root@centos-01 ~<span style="color:#f92672">]</span><span style="color:#75715e"># docker run -d  --name nginx  nginx</span>
</span></span><span style="display:flex;"><span>8afe1080ba992614f96b6868dbbcab463e37c98f8d3fa729245d48c2e6a1e3fe
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>root@centos-01 ~<span style="color:#f92672">]</span><span style="color:#75715e"># docker ps -a</span>
</span></span><span style="display:flex;"><span>CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS     NAMES
</span></span><span style="display:flex;"><span>8afe1080ba99   nginx     <span style="color:#e6db74">&#34;/docker-entrypoint.…&#34;</span>   <span style="color:#ae81ff">3</span> seconds ago   Up <span style="color:#ae81ff">2</span> seconds   80/tcp    nginx
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>root@centos-01 ~<span style="color:#f92672">]</span><span style="color:#75715e"># docker inspect nginx</span></span></span></code></pre></div><p><img src="/images/2021-09-09-14-34-08.png" alt="" /></p>
<p>发现其ip为 <code>172.17.0.2</code> ,当容器桥接 <code>docker0</code> 后，会自动分配 <code>ip</code> 地址，之后的IP地址递增。</p>
<p>3)：查看网桥和端口连接</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#f92672">[</span>root@centos-01 ~<span style="color:#f92672">]</span><span style="color:#75715e"># brctl show</span>
</span></span><span style="display:flex;"><span>bridge name	bridge id		STP enabled	interfaces
</span></span><span style="display:flex;"><span>docker0		8000.0242cbf135ea	no		veth3a98010</span></span></code></pre></div><p>一个新的网络接口  <code>veth3a98010</code>  被挂到了 <code>docker0</code> 上， <code>veth3a98010</code> 就是新创建容器的虚拟网卡。</p>
<p>4)：查看<code>veth pair</code> 配置</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#f92672">[</span>root@centos-01 ~<span style="color:#f92672">]</span><span style="color:#75715e"># ip addr</span>
</span></span><span style="display:flex;"><span>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu <span style="color:#ae81ff">65536</span> qdisc noqueue state UNKNOWN group default qlen <span style="color:#ae81ff">1000</span>
</span></span><span style="display:flex;"><span>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
</span></span><span style="display:flex;"><span>    inet 127.0.0.1/8 scope host lo
</span></span><span style="display:flex;"><span>       valid_lft forever preferred_lft forever
</span></span><span style="display:flex;"><span>    inet6 ::1/128 scope host 
</span></span><span style="display:flex;"><span>       valid_lft forever preferred_lft forever
</span></span><span style="display:flex;"><span>       
</span></span><span style="display:flex;"><span>2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span style="color:#ae81ff">1500</span> qdisc pfifo_fast state UP group default qlen <span style="color:#ae81ff">1000</span>
</span></span><span style="display:flex;"><span>    link/ether 00:0c:29:50:75:ae brd ff:ff:ff:ff:ff:ff
</span></span><span style="display:flex;"><span>    inet 192.168.126.143/24 brd 192.168.126.255 scope global noprefixroute ens33
</span></span><span style="display:flex;"><span>       valid_lft forever preferred_lft forever
</span></span><span style="display:flex;"><span>    inet6 2409:8900:2b86:13cc:a958:4c6e:c162:309d/64 scope global noprefixroute dynamic 
</span></span><span style="display:flex;"><span>       valid_lft 3520sec preferred_lft 3520sec
</span></span><span style="display:flex;"><span>    inet6 fe80::1f3a:afc1:82f6:3f66/64 scope link noprefixroute 
</span></span><span style="display:flex;"><span>       valid_lft forever preferred_lft forever
</span></span><span style="display:flex;"><span>       
</span></span><span style="display:flex;"><span>3: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span style="color:#ae81ff">1500</span> qdisc noqueue state UP group default 
</span></span><span style="display:flex;"><span>    link/ether 02:42:cb:f1:35:ea brd ff:ff:ff:ff:ff:ff
</span></span><span style="display:flex;"><span>    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0
</span></span><span style="display:flex;"><span>       valid_lft forever preferred_lft forever
</span></span><span style="display:flex;"><span>    inet6 fe80::42:cbff:fef1:35ea/64 scope link 
</span></span><span style="display:flex;"><span>       valid_lft forever preferred_lft forever
</span></span><span style="display:flex;"><span>       
</span></span><span style="display:flex;"><span>21: veth3a98010@if20: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span style="color:#ae81ff">1500</span> qdisc noqueue master docker0 state UP group default 
</span></span><span style="display:flex;"><span>    link/ether 16:ea:7d:ca:a3:07 brd ff:ff:ff:ff:ff:ff link-netnsid <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    inet6 fe80::14ea:7dff:feca:a307/64 scope link 
</span></span><span style="display:flex;"><span>       valid_lft forever preferred_lft forever
</span></span><span style="display:flex;"><span>       
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>root@centos-01 ~<span style="color:#f92672">]</span><span style="color:#75715e"># brctl show</span>
</span></span><span style="display:flex;"><span>bridge name	bridge id		STP enabled	interfaces
</span></span><span style="display:flex;"><span>docker0		8000.0242cbf135ea	no		veth3a98010
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>root@centos-01 ~<span style="color:#f92672">]</span><span style="color:#75715e"># docker exec  -it nginx /bin/bash</span>
</span></span><span style="display:flex;"><span>root@8afe1080ba99:/# cat /sys/class/net/eth0/iflink 
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">21</span></span></span></code></pre></div><p><strong>注意</strong>：<code>veth</code>  设备是成双成对出现的，一端在容器内部名为 <code>eth0</code>，一端加入到网桥名为 <code>vethxxx</code> （通常命名为veth），它们组成一个数据传输通道，一端进一端出，veth设备连接了两个网络设备并实现了数据通信；在bridge模式下，连在同一网桥上的容器可以相互通信。若出于安全考虑，也可以禁止它们之间通信，方法是在 <code>DOCKER_OPTS</code> 变量中设置 <code>–icc=false</code>，这样只有使用 <code>–link</code> 才能使两个容器通信。</p>
<h2 id="host">Host<a class="anchor" href="#host">#</a></h2>
<h3 id="简介-1">简介<a class="anchor" href="#%e7%ae%80%e4%bb%8b-1">#</a></h3>
<p>如果启动容器时使用的是host模式，那么容器将不会获得一个独立的 <code>Network Namespace（网络命名空间）</code> ，而是和宿主机系统共用一个。这意味着：容器不会虚拟出自己的网卡以及配置自己的ip等，而是使用宿主机的ip以及端口。不过在其他方面例如文件系统、进程列表等还是与之隔离的。使用host模式的容器可以直接使用宿主机的IP地址与外界通信，容器内部的服务端口也可以使用宿主机的端口，不需要进行 <code>NAT</code> ，Host最大的优势就是网络性能比较好，但是已经被使用的端口就不能再用了。</p>
<p><img src="/images/2021-09-09-14-36-38.png" alt="" /></p>
<p><strong>介绍</strong></p>
<ul>
<li>host 网络模式需要在容器创建时指定 <code>--network=host</code> </li>
<li>host 模式可以直接使用宿主机的IP地址与外界进行通信，若宿主机的 <code>eth0</code>  是一个公有 IP，那么容器也拥有这个公有IP。同时容器内服务的端口也可以使用宿主机的端口，无需额外进行 <code>NAT</code>  转换</li>
<li>host模式可以让容器共享宿主机网络栈，这样的好处是外部主机与容器直接通信，但是容器的网络缺少隔离性</li>
</ul>
<p><strong>缺陷</strong></p>
<ul>
<li>容器网络环境隔离性的弱化。即容器不再拥有隔离、独立的网络栈</li>
<li>使用 host 模式的容器虽然可以让容器内部的服务和传统情况无差别、无改造的使用，但是由于网络隔离性的弱化，该容器会与宿主机竞争网络栈的使用</li>
<li>容器内部将不再拥有所有的端口资源，原因是部分端口资源已经被宿主机本身的服务占用，还有部分端口已经用以 <code>bridge</code>  网络模式容器的端口映射</li>
</ul>
<h3 id="测试-1"><strong>测试</strong><a class="anchor" href="#%e6%b5%8b%e8%af%95-1">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#f92672">[</span>root@centos-01 ~<span style="color:#f92672">]</span><span style="color:#75715e"># docker run -d --network=host --name nginx  nginx</span>
</span></span><span style="display:flex;"><span>ba0eb1c89ab6b505619db9b6789074db397a9f729ce18aeb82543986971b83d1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>root@centos-01 ~<span style="color:#f92672">]</span><span style="color:#75715e"># docker ps -a</span>
</span></span><span style="display:flex;"><span>CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS     NAMES
</span></span><span style="display:flex;"><span>ba0eb1c89ab6   nginx     <span style="color:#e6db74">&#34;/docker-entrypoint.…&#34;</span>   <span style="color:#ae81ff">3</span> seconds ago   Up <span style="color:#ae81ff">2</span> seconds             nginx</span></span></code></pre></div><p>注意</p>
<ol>
<li>不需要添加 <code>-p</code> 参数，因为它使用的就是主机的IP和端口，添加 <code>-p</code> 参数后，反而会出现警告：   <code> WARNING: Published ports are discarded when using host network mode</code> </li>
<li>宿主机的ip路由转发功能一定要打开，否则所创建的容器无法联网。<code>echo 1 &gt; /proc/sys/net/ipv4/ip_forward</code> </li>
</ol>
<blockquote class='book-hint '>
<p>host端口占用模式是容器占用主机上当前所监听的端口(官网描述为publish)。比如这里nginx占用80端口，那么用host模式启动的时候，主机上的80端口会被nginx占用，这时其他的容器就不能再指定80端口，但可以指定其他端口，所以说一台主机上可以运行多个host模式的容器，只要彼此监听的端口不一样即可</p>
</blockquote><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#f92672">[</span>root@centos-01 ~<span style="color:#f92672">]</span><span style="color:#75715e"># curl 192.168.126.143:80</span>
</span></span><span style="display:flex;"><span>&lt;!DOCTYPE html&gt;
</span></span><span style="display:flex;"><span>&lt;html&gt;
</span></span><span style="display:flex;"><span>&lt;head&gt;
</span></span><span style="display:flex;"><span>&lt;title&gt;Welcome to nginx!&lt;/title&gt;
</span></span><span style="display:flex;"><span>&lt;style&gt;
</span></span><span style="display:flex;"><span>    body <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        width: 35em;
</span></span><span style="display:flex;"><span>        margin: <span style="color:#ae81ff">0</span> auto;
</span></span><span style="display:flex;"><span>        font-family: Tahoma, Verdana, Arial, sans-serif;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>&lt;/style&gt;
</span></span><span style="display:flex;"><span>&lt;/head&gt;
</span></span><span style="display:flex;"><span>&lt;body&gt;
</span></span><span style="display:flex;"><span>&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;
</span></span><span style="display:flex;"><span>&lt;p&gt;If you see this page, the nginx web server is successfully installed and
</span></span><span style="display:flex;"><span>working. Further configuration is required.&lt;/p&gt;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>&lt;p&gt;For online documentation and support please refer to
</span></span><span style="display:flex;"><span>&lt;a href<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;http://nginx.org/&#34;</span>&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;
</span></span><span style="display:flex;"><span>Commercial support is available at
</span></span><span style="display:flex;"><span>&lt;a href<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;http://nginx.com/&#34;</span>&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>&lt;p&gt;&lt;em&gt;Thank you <span style="color:#66d9ef">for</span> using nginx.&lt;/em&gt;&lt;/p&gt;
</span></span><span style="display:flex;"><span>&lt;/body&gt;
</span></span><span style="display:flex;"><span>&lt;/html&gt;</span></span></code></pre></div><h2 id="container">Container<a class="anchor" href="#container">#</a></h2>
<p><code>Container模式</code> 与 <code>Host模式</code> 类似，指定新创建的容器和已经存在的一个容器共享一个 <code>Network Namespace</code> 。这意味着：新建的容器不会创建自己的网卡等相关操作，而是和与指定的容器共享这些资源。除了网络方面，其文件系统、进程列表等都是隔离的。</p>
<p><img src="/images/2021-09-09-14-40-14.png" alt="" /></p>
<blockquote class='book-hint '>
<p>注：它并没有改善容器与宿主机以外世界通信的情况（和桥接模式一样，不能连接宿主机以外的其他设备）</p>
</blockquote><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#f92672">[</span>root@centos-01 ~<span style="color:#f92672">]</span><span style="color:#75715e"># docker run -d --name nginx --network=container:ba0eb1c89ab6b50 nginx</span></span></span></code></pre></div><h2 id="none">None<a class="anchor" href="#none">#</a></h2>
<p>Docker容器拥有自己的 <code>Network Namespace</code> ，但不会对容器进行任何的网络配置。这意味着：这个容器没有网卡、IP、路由等信息。需要自己为Docker容器添加网卡、配置IP等。这种方式网络的隔离性最为彻底，即表明关闭了容器的网络功能，也无法访问这个容器。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#f92672">[</span>root@centos-01 ~<span style="color:#f92672">]</span><span style="color:#75715e"># docker run -d --name nginx --network=none nginx</span></span></span></code></pre></div><h1 id="参考">参考<a class="anchor" href="#%e5%8f%82%e8%80%83">#</a></h1>
<ul>
<li><a href="https://www.w3cschool.cn/docker/docker-command-manual.html">https://www.w3cschool.cn/docker/docker-command-manual.html</a></li>
<li><a href="https://docs.docker.com/reference/">https://docs.docker.com/reference/</a></li>
<li><a href="https://www.runoob.com/docker/docker-command-manual.html">https://www.runoob.com/docker/docker-command-manual.html</a></li>
<li><a href="https://blog.csdn.net/qq_43791724/article/details/109758108">https://blog.csdn.net/qq_43791724/article/details/109758108</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/83041422">https://zhuanlan.zhihu.com/p/83041422</a></li>
</ul>
</div>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">
  <div>
  
    <a href="/posts/docker/1.5docker%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86/" class="flex align-center">
      <img src="/icons/backward.svg" class="book-icon" alt="Backward" />
      <span>1.5 Docker数据管理</span>
    </a>
  
  </div>
  <div>
  
    <a href="/posts/docker/1.7docker%E9%AB%98%E7%BA%A7%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/" class="flex align-center">
      <span>1.7 Docker高级网络配置</span>
      <img src="/icons/forward.svg" class="book-icon" alt="Forward" />
    </a>
  
  </div>
</div>
 
        
  
 
        
        
  
 
        
  
  
    <script>(function(){document.querySelectorAll("pre:has(code)").forEach(e=>{e.addEventListener("click",e.focus),e.addEventListener("copy",function(t){if(t.preventDefault(),navigator.clipboard){const t=window.getSelection().toString()||e.textContent;navigator.clipboard.writeText(t)}})})})()</script>
  

      </footer>

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
  
  <aside class="book-toc">
    <div class="book-toc-content">
      
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#bridge">Bridge</a>
      <ul>
        <li><a href="#简介">简介</a></li>
        <li><a href="#测试">测试</a></li>
      </ul>
    </li>
    <li><a href="#host">Host</a>
      <ul>
        <li><a href="#简介-1">简介</a></li>
        <li><a href="#测试-1"><strong>测试</strong></a></li>
      </ul>
    </li>
    <li><a href="#container">Container</a></li>
    <li><a href="#none">None</a></li>
  </ul>
</nav>



    </div>
  </aside>
  
 
  </main>

  
</body>
</html>




















