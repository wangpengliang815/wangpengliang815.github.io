<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，包含运行软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件，Docker 运行容器前需要本地存在对应的镜像，如果本地不存在会从镜像仓库下载该镜像。
操作系统分为内核和用户空间。对于 Linux 而言，内核启动后，会挂载 root 文件系统为其提供用户空间支持。而 Docker 镜像就相当于是一个 root 文件系统。比如官方镜像 ubuntu:18.04 就包含了完整的一套 Ubuntu 18.04 最小系统的 root 文件系统
镜像来源# 远程仓库下载 拷贝 自己制作镜像( Dockerfile ) 获取镜像# Docker Hub 上有大量高质量的镜像可以用，获取镜像的命令是 docker pull，格式为：
docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]具体选项可以通过 docker pull --help 命令看到，镜像名称格式如下：
Docker 镜像仓库地址：地址格式一般是 &lt;域名/IP&gt;[:端口号]。默认地址是 Docker Hub 仓库名：这里的仓库名是两段式名称，即 &lt;用户名&gt;/&lt;软件名&gt;。对于 Docker Hub，如果不给出用户名，则默认为 library，也就是官方镜像 比如：
[root@wangpengliang ~]# docker pull redis:6.2.4 6.2.4: Pulling from library/redis 69692152171a: Pull complete a4a46f2fd7e0: Pull complete bcdf6fddc3bd: Pull complete 2902e41faefa: Pull complete df3e1d63cdb1: Pull complete fa57f005a60d: Pull complete Digest: sha256:7e2c6181ad5c425443b56c7c73a9cd6df24a122345847d1ea9bb86a5afc76325 Status: Downloaded newer image for redis:6.2.4 docker.io/library/redis:6.2.4上面的命令中没有给出 Docker 镜像仓库地址，因此将会从 Docker Hub 获取镜像。而镜像名称是 redis:6.2.4，因此将会获取官方镜像 library/redis仓库中标签为 6.2.4 的镜像。
">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:url" content="http://localhost:1313/posts/docker/1.2docker%E9%95%9C%E5%83%8F/">
  <meta property="og:site_name" content="CODE&#39;NOTE">
  <meta property="og:title" content="CODE&#39;NOTE">
  <meta property="og:description" content="镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，包含运行软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件，Docker 运行容器前需要本地存在对应的镜像，如果本地不存在会从镜像仓库下载该镜像。
操作系统分为内核和用户空间。对于 Linux 而言，内核启动后，会挂载 root 文件系统为其提供用户空间支持。而 Docker 镜像就相当于是一个 root 文件系统。比如官方镜像 ubuntu:18.04 就包含了完整的一套 Ubuntu 18.04 最小系统的 root 文件系统
镜像来源# 远程仓库下载 拷贝 自己制作镜像( Dockerfile ) 获取镜像# Docker Hub 上有大量高质量的镜像可以用，获取镜像的命令是 docker pull，格式为：
docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]具体选项可以通过 docker pull --help 命令看到，镜像名称格式如下：
Docker 镜像仓库地址：地址格式一般是 &lt;域名/IP&gt;[:端口号]。默认地址是 Docker Hub 仓库名：这里的仓库名是两段式名称，即 &lt;用户名&gt;/&lt;软件名&gt;。对于 Docker Hub，如果不给出用户名，则默认为 library，也就是官方镜像 比如：
[root@wangpengliang ~]# docker pull redis:6.2.4 6.2.4: Pulling from library/redis 69692152171a: Pull complete a4a46f2fd7e0: Pull complete bcdf6fddc3bd: Pull complete 2902e41faefa: Pull complete df3e1d63cdb1: Pull complete fa57f005a60d: Pull complete Digest: sha256:7e2c6181ad5c425443b56c7c73a9cd6df24a122345847d1ea9bb86a5afc76325 Status: Downloaded newer image for redis:6.2.4 docker.io/library/redis:6.2.4上面的命令中没有给出 Docker 镜像仓库地址，因此将会从 Docker Hub 获取镜像。而镜像名称是 redis:6.2.4，因此将会获取官方镜像 library/redis仓库中标签为 6.2.4 的镜像。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">


  <meta itemprop="name" content="CODE&#39;NOTE">
  <meta itemprop="description" content="镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，包含运行软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件，Docker 运行容器前需要本地存在对应的镜像，如果本地不存在会从镜像仓库下载该镜像。
操作系统分为内核和用户空间。对于 Linux 而言，内核启动后，会挂载 root 文件系统为其提供用户空间支持。而 Docker 镜像就相当于是一个 root 文件系统。比如官方镜像 ubuntu:18.04 就包含了完整的一套 Ubuntu 18.04 最小系统的 root 文件系统
镜像来源# 远程仓库下载 拷贝 自己制作镜像( Dockerfile ) 获取镜像# Docker Hub 上有大量高质量的镜像可以用，获取镜像的命令是 docker pull，格式为：
docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]具体选项可以通过 docker pull --help 命令看到，镜像名称格式如下：
Docker 镜像仓库地址：地址格式一般是 &lt;域名/IP&gt;[:端口号]。默认地址是 Docker Hub 仓库名：这里的仓库名是两段式名称，即 &lt;用户名&gt;/&lt;软件名&gt;。对于 Docker Hub，如果不给出用户名，则默认为 library，也就是官方镜像 比如：
[root@wangpengliang ~]# docker pull redis:6.2.4 6.2.4: Pulling from library/redis 69692152171a: Pull complete a4a46f2fd7e0: Pull complete bcdf6fddc3bd: Pull complete 2902e41faefa: Pull complete df3e1d63cdb1: Pull complete fa57f005a60d: Pull complete Digest: sha256:7e2c6181ad5c425443b56c7c73a9cd6df24a122345847d1ea9bb86a5afc76325 Status: Downloaded newer image for redis:6.2.4 docker.io/library/redis:6.2.4上面的命令中没有给出 Docker 镜像仓库地址，因此将会从 Docker Hub 获取镜像。而镜像名称是 redis:6.2.4，因此将会获取官方镜像 library/redis仓库中标签为 6.2.4 的镜像。">
  <meta itemprop="wordCount" content="1165">

<title>1.2 Docker镜像 | CODE&#39;NOTE</title>
<link rel="icon" href="/favicon.png" >
<link rel="manifest" href="/manifest.json">
<link rel="canonical" href="http://localhost:1313/posts/docker/1.2docker%E9%95%9C%E5%83%8F/">
<link rel="stylesheet" href="/book.min.6970156cec683193d93c9c4edaf0d56574e4361df2e0c1be4f697ae81c3ba55f.css" integrity="sha256-aXAVbOxoMZPZPJxO2vDVZXTkNh3y4MG&#43;T2l66Bw7pV8=" crossorigin="anonymous">


  <script defer src="/fuse.min.js"></script>
  <script defer src="/en.search.min.3ed9c79c605914c45e19db90edfda0ca8d87c63064c1d6252862250c4e917346.js" integrity="sha256-PtnHnGBZFMReGduQ7f2gyo2HxjBkwdYlKGIlDE6Rc0Y=" crossorigin="anonymous"></script>



  
</head>
<body dir="ltr" class="book-kind-page book-type-posts">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    
<aside class="book-menu">
  <div class="book-menu-content">
    
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><span>CODE&#39;NOTE</span>
  </a>
</h2>


<div class="book-search hidden">
  <input id="book-search-input" type="text" 
    placeholder="Search"
    aria-label="Search"
    maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>
<script>document.querySelector(".book-search").classList.remove("hidden")</script>
























</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>



  </div>
</aside>
 

    <div class="book-page">
      <header class="book-header hidden">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/icons/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <h3>1.2 Docker镜像</h3>

  <label for="toc-control">
    
    <img src="/icons/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#git-repo-构建">Git repo 构建</a></li>
    <li><a href="#tar-压缩包构建">tar 压缩包构建</a></li>
    <li><a href="#读取-dockerfile-构建">读取 Dockerfile 构建</a></li>
    <li><a href="#读取上下文压缩包构建">读取上下文压缩包构建</a></li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
<article class="markdown book-post">
  <h1>
    1.2 Docker镜像
  </h1>
  


  

  


  <div class="book-post-content markdown-inner"><p>镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，包含运行软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件，Docker 运行容器前需要本地存在对应的镜像，如果本地不存在会从镜像仓库下载该镜像。</p>
<blockquote class='book-hint '>
<p>操作系统分为内核和用户空间。对于 Linux 而言，内核启动后，会挂载 <code>root</code> 文件系统为其提供用户空间支持。而 Docker 镜像就相当于是一个 root 文件系统。比如官方镜像 ubuntu:18.04 就包含了完整的一套 Ubuntu 18.04 最小系统的 root 文件系统</p>
</blockquote><h1 id="镜像来源">镜像来源<a class="anchor" href="#%e9%95%9c%e5%83%8f%e6%9d%a5%e6%ba%90">#</a></h1>
<ul>
<li>远程仓库下载</li>
<li>拷贝</li>
<li>自己制作镜像( <code>Dockerfile</code> )</li>
</ul>
<h1 id="获取镜像">获取镜像<a class="anchor" href="#%e8%8e%b7%e5%8f%96%e9%95%9c%e5%83%8f">#</a></h1>
<p><a href="https://hub.docker.com/explore/">Docker Hub</a> 上有大量高质量的镜像可以用，获取镜像的命令是 <code>docker pull</code>，格式为：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker pull <span style="color:#f92672">[</span>选项<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>Docker Registry 地址<span style="color:#f92672">[</span>:端口号<span style="color:#f92672">]</span>/<span style="color:#f92672">]</span>仓库名<span style="color:#f92672">[</span>:标签<span style="color:#f92672">]</span></span></span></code></pre></div><p>具体选项可以通过 <code>docker pull --help</code> 命令看到，镜像名称格式如下：</p>
<ul>
<li>Docker 镜像仓库地址：地址格式一般是 <code>&lt;域名/IP&gt;[:端口号]</code>。默认地址是 Docker Hub</li>
<li>仓库名：这里的仓库名是两段式名称，即 <code>&lt;用户名&gt;/&lt;软件名&gt;</code>。对于 Docker Hub，如果不给出用户名，则默认为 <code>library</code>，也就是官方镜像</li>
</ul>
<p>比如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#f92672">[</span>root@wangpengliang ~<span style="color:#f92672">]</span><span style="color:#75715e"># docker pull redis:6.2.4</span>
</span></span><span style="display:flex;"><span>6.2.4: Pulling from library/redis
</span></span><span style="display:flex;"><span>69692152171a: Pull complete 
</span></span><span style="display:flex;"><span>a4a46f2fd7e0: Pull complete 
</span></span><span style="display:flex;"><span>bcdf6fddc3bd: Pull complete 
</span></span><span style="display:flex;"><span>2902e41faefa: Pull complete 
</span></span><span style="display:flex;"><span>df3e1d63cdb1: Pull complete 
</span></span><span style="display:flex;"><span>fa57f005a60d: Pull complete 
</span></span><span style="display:flex;"><span>Digest: sha256:7e2c6181ad5c425443b56c7c73a9cd6df24a122345847d1ea9bb86a5afc76325
</span></span><span style="display:flex;"><span>Status: Downloaded newer image <span style="color:#66d9ef">for</span> redis:6.2.4
</span></span><span style="display:flex;"><span>docker.io/library/redis:6.2.4</span></span></code></pre></div><p>上面的命令中没有给出 Docker 镜像仓库地址，因此将会从 Docker Hub 获取镜像。而镜像名称是 <code>redis:6.2.4</code>，因此将会获取官方镜像 <code>library/redis</code>仓库中标签为 <code>6.2.4</code>  的镜像。</p>
<p>从下载过程中可以看到分层存储的概念，镜像是由多层存储所构成。下载也是一层层的去下载，并非单一文件下载。过程中给出了每一层的 ID 的前 12 位。下载结束后，给出该镜像完整的 <code>sha256</code> 的摘要以确保下载一致性。</p>
<h1 id="镜像列表">镜像列表<a class="anchor" href="#%e9%95%9c%e5%83%8f%e5%88%97%e8%a1%a8">#</a></h1>
<p>镜像下载完成后可以使用 <code>docker image ls</code> 查看本地镜像列表</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#f92672">[</span>root@wangpengliang ~<span style="color:#f92672">]</span><span style="color:#75715e"># docker image ls</span>
</span></span><span style="display:flex;"><span>REPOSITORY    TAG       IMAGE ID       CREATED        SIZE
</span></span><span style="display:flex;"><span>redis         6.2.4     fad0ee7e917a   <span style="color:#ae81ff">2</span> days ago     105MB
</span></span><span style="display:flex;"><span>redis         latest    fad0ee7e917a   <span style="color:#ae81ff">2</span> days ago     105MB
</span></span><span style="display:flex;"><span>hello-world   latest    d1165f221234   <span style="color:#ae81ff">3</span> months ago   13.3kB</span></span></code></pre></div><p>列表包含了 仓库名、标签、镜像 ID、创建时间以及所占用的空间，镜像 ID 是镜像的唯一标识，一个镜像可以对应多个标签。</p>
<h1 id="镜像体积">镜像体积<a class="anchor" href="#%e9%95%9c%e5%83%8f%e4%bd%93%e7%a7%af">#</a></h1>
<p>仔细观察会注意到上面标识的所占用空间和在 Docker Hub 上看到的镜像大小不同。比如，<code>redis:6.2.4</code> 镜像大小，在这里是 <code>105 MB</code>，但是在 <a href="https://hub.docker.com/r/library/ubuntu/tags/">Docker Hub</a> 显示的却是 <code>37 MB</code>。这是因为 Docker Hub 中显示的体积是压缩后的体积。在镜像下载和上传过程中镜像是保持着压缩状态的，因此 Docker Hub 所显示的大小是网络传输中更关心的流量大小。而 <code>docker image ls</code> 显示的是镜像下载到本地后，展开的大小。准确说，是展开后的各层所占空间的总和，因为镜像到本地查看空间的时候，更关心的是本地磁盘空间占用的大小。</p>
<p>另外一个需要注意的问题是，<code>docker image ls</code> 列表中的镜像体积总和并非是所有镜像实际硬盘消耗。由于 Docker 镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。由于 Docker 使用 <a href="https://www.jianshu.com/p/3ba255463047">UNION FS</a>，相同的层只需要保存一份即可。因此实际镜像硬盘占用空间很可能要比这个列表镜像大小的总和要小。</p>
<p>通过以下命令可以查看镜像、容器、数据卷所占用的空间：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#f92672">[</span>root@wangpengliang ~<span style="color:#f92672">]</span><span style="color:#75715e"># docker system df</span>
</span></span><span style="display:flex;"><span>TYPE            TOTAL     ACTIVE    SIZE      RECLAIMABLE
</span></span><span style="display:flex;"><span>Images          <span style="color:#ae81ff">2</span>         <span style="color:#ae81ff">1</span>         105.4MB   13.34kB <span style="color:#f92672">(</span>0%<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>Containers      <span style="color:#ae81ff">1</span>         <span style="color:#ae81ff">1</span>         26B       0B <span style="color:#f92672">(</span>0%<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>Local Volumes   <span style="color:#ae81ff">1</span>         <span style="color:#ae81ff">1</span>         0B        0B
</span></span><span style="display:flex;"><span>Build Cache     <span style="color:#ae81ff">0</span>         <span style="color:#ae81ff">0</span>         0B        0B</span></span></code></pre></div><h1 id="虚悬镜像">虚悬镜像<a class="anchor" href="#%e8%99%9a%e6%82%ac%e9%95%9c%e5%83%8f">#</a></h1>
<p>有时候可以看到这种特殊的镜像，仓库名和标签均为 <code>&lt;none&gt;</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>&lt;none&gt;               &lt;none&gt;              00285df0df87        <span style="color:#ae81ff">5</span> days ago          <span style="color:#ae81ff">342</span> MB</span></span></code></pre></div><p>这个镜像原本是有镜像名和标签的，比如原来为 <code>mongo:3.2</code>，随着官方镜像维护，发布了新版本后，重新 <code>docker pull mongo:3.2</code> 时，<code>mongo:3.2</code> 这个镜像名被转移到了新下载的镜像身上，而旧的镜像上的这个名称则被取消，从而成为了 <code>&lt;none&gt;</code>。除了 <code>docker pull</code> 可能导致这种情况，<code>docker build</code> 也同样可以导致这种现象。由于新旧镜像同名，旧镜像名称被取消，从而出现仓库名、标签均为 <code>&lt;none&gt;</code> 的镜像。这类无标签镜像也被称为 <strong>虚悬镜像(dangling image)</strong> 。</p>
<p>通过以下命令可以查看这类镜像：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>docker image ls -f dangling<span style="color:#f92672">=</span>true
</span></span><span style="display:flex;"><span>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
</span></span><span style="display:flex;"><span>&lt;none&gt;              &lt;none&gt;              00285df0df87        <span style="color:#ae81ff">5</span> days ago          <span style="color:#ae81ff">342</span> MB</span></span></code></pre></div><p>一般来说虚悬镜像已经失去了存在的价值，是可以随意删除的。可以通过以下命令删除：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>docker image prune</span></span></code></pre></div><h1 id="中间层镜像">中间层镜像<a class="anchor" href="#%e4%b8%ad%e9%97%b4%e5%b1%82%e9%95%9c%e5%83%8f">#</a></h1>
<p>为了加速镜像构建、重复利用资源，Docker 会利用 中间层镜像。所以在使用一段时间后，可能会看到一些依赖的中间层镜像。默认的 <code>docker image ls</code> 列表中只会显示顶层镜像，如果希望显示包括中间层镜像在内的所有镜像的话，需要加 <code>-a</code> 参数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker image ls -a</span></span></code></pre></div><p>这样会看到很多无标签的镜像，这些无标签的镜像很多都是中间层镜像，是其它镜像所依赖的镜像。这些无标签镜像不应该删除，否则会导致上层镜像因为依赖丢失而出错。实际上，这些镜像也没必要删除，因为之前说过，相同的层只会存一遍，而这些镜像是别的镜像的依赖，因此并不会因为它们被列出来而多存了一份，只要删除依赖它们的镜像后，这些被依赖的中间层镜像也会被连带删除。</p>
<h1 id="列出部分镜像">列出部分镜像<a class="anchor" href="#%e5%88%97%e5%87%ba%e9%83%a8%e5%88%86%e9%95%9c%e5%83%8f">#</a></h1>
<p>不加任何参数的情况下，<code>docker image ls</code> 会列出所有顶层镜像，但有时候只希望列出部分镜像。<code>docker image ls</code> 有几个参数可以帮助做到</p>
<p>根据仓库名列出镜像：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#f92672">[</span>root@wangpengliang ~<span style="color:#f92672">]</span><span style="color:#75715e"># docker image ls redis</span>
</span></span><span style="display:flex;"><span>REPOSITORY   TAG       IMAGE ID       CREATED      SIZE
</span></span><span style="display:flex;"><span>redis        6.2.4     fad0ee7e917a   <span style="color:#ae81ff">2</span> days ago   105MB
</span></span><span style="display:flex;"><span>redis        latest    fad0ee7e917a   <span style="color:#ae81ff">2</span> days ago   105MB</span></span></code></pre></div><p>指定仓库名和标签：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#f92672">[</span>root@wangpengliang ~<span style="color:#f92672">]</span><span style="color:#75715e"># docker image ls redis:6.2.4</span>
</span></span><span style="display:flex;"><span>REPOSITORY   TAG       IMAGE ID       CREATED      SIZE
</span></span><span style="display:flex;"><span>redis        6.2.4     fad0ee7e917a   <span style="color:#ae81ff">2</span> days ago   105MB</span></span></code></pre></div><p>除此以外，<code>docker image ls</code> 还支持过滤器参数 <code>--filter</code>或者简写 <code>-f</code>。</p>
<p>只显示镜像ID <code>-q</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#f92672">[</span>root@wangpengliang ~<span style="color:#f92672">]</span><span style="color:#75715e"># docker image ls -q</span>
</span></span><span style="display:flex;"><span>fad0ee7e917a
</span></span><span style="display:flex;"><span>fad0ee7e917a
</span></span><span style="display:flex;"><span>d1165f221234</span></span></code></pre></div><p>格式化显示镜像结果，只包含镜像ID和仓库名：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#f92672">[</span>root@wangpengliang ~<span style="color:#f92672">]</span><span style="color:#75715e"># docker image ls --format &#34;{{.ID}}: {{.Repository}}&#34;</span>
</span></span><span style="display:flex;"><span>fad0ee7e917a: redis
</span></span><span style="display:flex;"><span>fad0ee7e917a: redis
</span></span><span style="display:flex;"><span>d1165f221234: hello-world
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 以表格等距显示（需要自己定义列）</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>root@wangpengliang ~<span style="color:#f92672">]</span><span style="color:#75715e"># docker image ls --format &#34;table {{.ID}}\t{{.Repository}}\t{{.Tag}}&#34;</span>
</span></span><span style="display:flex;"><span>IMAGE ID       REPOSITORY    TAG
</span></span><span style="display:flex;"><span>fad0ee7e917a   redis         6.2.4
</span></span><span style="display:flex;"><span>fad0ee7e917a   redis         latest
</span></span><span style="display:flex;"><span>d1165f221234   hello-world   latest</span></span></code></pre></div><h1 id="删除镜像">删除镜像<a class="anchor" href="#%e5%88%a0%e9%99%a4%e9%95%9c%e5%83%8f">#</a></h1>
<p>如果要删除本地镜像，可以使用 <code>docker image rm</code> 命令，格式为：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ docker image rm <span style="color:#f92672">[</span>选项<span style="color:#f92672">]</span> &lt;镜像1&gt; <span style="color:#f92672">[</span>&lt;镜像2&gt; ...<span style="color:#f92672">]</span> <span style="color:#75715e">#&lt;镜像&gt; 可以是 镜像短 ID、镜像长 ID、镜像名 或者 镜像摘要</span></span></span></code></pre></div><p>或者使用：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span> dcoker rmi &lt;镜像&gt;</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#f92672">[</span>root@wangpengliang ~<span style="color:#f92672">]</span><span style="color:#75715e"># docker image ls</span>
</span></span><span style="display:flex;"><span>REPOSITORY    TAG       IMAGE ID       CREATED        SIZE
</span></span><span style="display:flex;"><span>redis         6.2.4     fad0ee7e917a   <span style="color:#ae81ff">2</span> days ago     105MB
</span></span><span style="display:flex;"><span>redis         latest    fad0ee7e917a   <span style="color:#ae81ff">2</span> days ago     105MB
</span></span><span style="display:flex;"><span>hello-world   latest    d1165f221234   <span style="color:#ae81ff">3</span> months ago   13.3kB
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>root@wangpengliang ~<span style="color:#f92672">]</span><span style="color:#75715e"># docker rmi redis:latest</span>
</span></span><span style="display:flex;"><span>Untagged: redis:latest
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>root@wangpengliang ~<span style="color:#f92672">]</span><span style="color:#75715e"># docker image ls</span>
</span></span><span style="display:flex;"><span>REPOSITORY    TAG       IMAGE ID       CREATED        SIZE
</span></span><span style="display:flex;"><span>redis         6.2.4     fad0ee7e917a   <span style="color:#ae81ff">2</span> days ago     105MB
</span></span><span style="display:flex;"><span>hello-world   latest    d1165f221234   <span style="color:#ae81ff">3</span> months ago   13.3kB</span></span></code></pre></div><h1 id="运行容器">运行容器<a class="anchor" href="#%e8%bf%90%e8%a1%8c%e5%ae%b9%e5%99%a8">#</a></h1>
<p>上面了解了关于镜像的一些基础知识，有了镜像就能够以这个镜像为基础启动并运行一个容器。以 <code>redis</code> 为例</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#f92672">[</span>root@wangpengliang ~<span style="color:#f92672">]</span><span style="color:#75715e"># docker run -it --name redis -d redis:6.2.4</span>
</span></span><span style="display:flex;"><span>68b9ad2b60fc7fd2a546e764448798195c86f5f22bfce200cd7e583d60df8096
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>root@wangpengliang ~<span style="color:#f92672">]</span><span style="color:#75715e"># docker ps -a</span>
</span></span><span style="display:flex;"><span>CONTAINER ID   IMAGE         COMMAND                  CREATED         STATUS         PORTS      NAMES
</span></span><span style="display:flex;"><span>68b9ad2b60fc   redis:6.2.4   <span style="color:#e6db74">&#34;docker-entrypoint.s…&#34;</span>   <span style="color:#ae81ff">4</span> seconds ago   Up <span style="color:#ae81ff">3</span> seconds   6379/tcp   redis
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>root@wangpengliang ~<span style="color:#f92672">]</span><span style="color:#75715e"># docker exec -it redis /bin/bash</span>
</span></span><span style="display:flex;"><span>root@68b9ad2b60fc:/data# cat /etc/os-release 
</span></span><span style="display:flex;"><span>PRETTY_NAME<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;Debian GNU/Linux 10 (buster)&#34;</span>
</span></span><span style="display:flex;"><span>NAME<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;Debian GNU/Linux&#34;</span>
</span></span><span style="display:flex;"><span>VERSION_ID<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;10&#34;</span>
</span></span><span style="display:flex;"><span>VERSION<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;10 (buster)&#34;</span>
</span></span><span style="display:flex;"><span>VERSION_CODENAME<span style="color:#f92672">=</span>buster
</span></span><span style="display:flex;"><span>ID<span style="color:#f92672">=</span>debian
</span></span><span style="display:flex;"><span>HOME_URL<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;https://www.debian.org/&#34;</span>
</span></span><span style="display:flex;"><span>SUPPORT_URL<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;https://www.debian.org/support&#34;</span>
</span></span><span style="display:flex;"><span>BUG_REPORT_URL<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;https://bugs.debian.org/&#34;</span></span></span></code></pre></div><h1 id="unionfs">UnionFS<a class="anchor" href="#unionfs">#</a></h1>
<ul>
<li>联合文件系统是一种分层、轻量级并且高性能的文件系统，支持对文件系统的修改，作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下（unite directories into a single virtual filesystem）</li>
<li>UnionFS是Docker镜像的基础，镜像可以通过分层来继承，基于基础镜像（没有父镜像的镜像），可以制作各种具体的应用镜像</li>
<li>特性一次同时加载多个文件系统，但从外面看起来只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录</li>
<li>Docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统叫 UnionFS</li>
<li>BootFS（Boot file system）主要包含 bootloader 和 kernel，bootloader 主要是引导加载 kernel，Linux 刚启动时会加载 BootFS文件系统，在 Docker 镜像的最底层是 BootFS。这一层与典型的 Linux/Unix 系统是一样的，包含 boot 加载器和内核。当 boot 加载完成之后整个内核就都在内存中了，此时内存的使用权已由 BootFS 转交给内核，此时系统也会卸载 BootFS</li>
<li>RootFS（Root File System），在 BootFS 之上，包含的就是典型 Linux 系统中的 /dev，/proc，/bin，/etc 等标准目录和文件。RootFS就是各种不同的操作系统发行版，比如 Ubuntu CentOS 等</li>
</ul>
<blockquote class='book-hint '>
<p>比如：mysql 和 tomcat 都需要 centos 环境，先安装 mysql 就有了 centos 的环境，再安装 tomcat 时就可以共用这一层 centos ，不需要再下载 centos</p>
</blockquote><h1 id="commit镜像">Commit镜像<a class="anchor" href="#commit%e9%95%9c%e5%83%8f">#</a></h1>
<p>镜像是容器的基础，每次执行 <code>docker run</code> 的时候都会指定哪个镜像作为容器运行的基础。之前例子中一直使用来自于 Docker Hub 的镜像。直接使用这些镜像是可以满足一定的需求，而当这些镜像无法直接满足需求时，就需要定制镜像。</p>
<p>镜像是多层存储，每一层是在前一层的基础上进行的修改。容器同样也是多层存储，以镜像为基础层，在其基础上加一层作为容器运行时的存储层。</p>
<p>以定制一个 Web 服务器为例，来了解镜像是如何构建的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>docker run --name webserver -d -p 80:80 nginx</span></span></code></pre></div><p>使用 nginx 镜像启动一个容器，命名为 <code>webserver </code>并且映射 <code>80</code> 端口，然后浏览器去访问这个服务器会看到默认的 nginx 欢迎页面。</p>
<p><img src="/images/2021-09-09-13-42-21.png" alt="" /></p>
<p>现在将&quot;Welcome to nginx!&quot;  改成 &ldquo;Welcome to Docker!&quot;，通过 <code>docker cp</code> 将容器内文件拷贝出来修改后再放回去。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#f92672">[</span>root@wangpengliang home<span style="color:#f92672">]</span><span style="color:#75715e"># docker cp 470e01aed950:/usr/share/nginx/html/index.html /home/</span></span></span></code></pre></div><blockquote class='book-hint '>
<p>这里也可以使用 docker exec 进入到容器内进行修改，不过因为容器内并没安装 <code>vi</code> ，还需额外安装就懒得折腾了</p>
</blockquote><p>现在刷新浏览器的话，会发现内容改变了。
<img src="/images/2021-09-09-13-43-16.png" alt="" />
上面修改了容器的文件，也就是改动了容器的存储层。可以通过 <code>docker diff</code> 命令看到具体的改动</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#f92672">[</span>root@wangpengliang home<span style="color:#f92672">]</span><span style="color:#75715e"># docker diff webserver </span>
</span></span><span style="display:flex;"><span>C /etc
</span></span><span style="display:flex;"><span>C /etc/nginx
</span></span><span style="display:flex;"><span>C /etc/nginx/conf.d
</span></span><span style="display:flex;"><span>C /etc/nginx/conf.d/default.conf
</span></span><span style="display:flex;"><span>C /run
</span></span><span style="display:flex;"><span>A /run/nginx.pid
</span></span><span style="display:flex;"><span>C /usr
</span></span><span style="display:flex;"><span>C /usr/share
</span></span><span style="display:flex;"><span>C /usr/share/nginx
</span></span><span style="display:flex;"><span>C /usr/share/nginx/html
</span></span><span style="display:flex;"><span>C /usr/share/nginx/html/index.html
</span></span><span style="display:flex;"><span>C /var
</span></span><span style="display:flex;"><span>C /var/cache
</span></span><span style="display:flex;"><span>C /var/cache/nginx
</span></span><span style="display:flex;"><span>A /var/cache/nginx/fastcgi_temp
</span></span><span style="display:flex;"><span>A /var/cache/nginx/proxy_temp
</span></span><span style="display:flex;"><span>A /var/cache/nginx/scgi_temp
</span></span><span style="display:flex;"><span>A /var/cache/nginx/uwsgi_temp
</span></span><span style="display:flex;"><span>A /var/cache/nginx/client_temp
</span></span><span style="display:flex;"><span>C /root
</span></span><span style="display:flex;"><span>A /root/.bash_history</span></span></code></pre></div><p>当运行一个容器时（如果不使用卷），做的任何文件修改都会被记录于容器存储层里。而 Docker 提供了一个 <code>docker commit</code> 命令，可以将容器的存储层保存下来成为镜像。换句话说就是在原有镜像的基础上再叠加上容器的存储层，并构成新的镜像。以后运行这个新镜像时，就会拥有原有容器最后的文件变化。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>docker commit <span style="color:#f92672">[</span>选项<span style="color:#f92672">]</span> &lt;容器ID或容器名&gt; <span style="color:#f92672">[</span>&lt;仓库名&gt;<span style="color:#f92672">[</span>:&lt;标签&gt;<span style="color:#f92672">]]</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>docker commit -m<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;提交的描述信息&#34;</span> -a<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;作者&#34;</span> 容器id 目标镜像名<span style="color:#f92672">[</span>tag<span style="color:#f92672">]</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#f92672">[</span>root@wangpengliang ~<span style="color:#f92672">]</span><span style="color:#75715e"># docker commit -m=&#39;nginx2.0&#39; -a=&#39;wangpengliang&#39; 470e01aed950 nginx:2.0</span>
</span></span><span style="display:flex;"><span>sha256:546ad28bcf61aeedd04de8c255efa508ee65eeff0b2a4529d17d3df835aa6bb2
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>root@wangpengliang ~<span style="color:#f92672">]</span><span style="color:#75715e"># docker image ls</span>
</span></span><span style="display:flex;"><span>REPOSITORY    TAG       IMAGE ID       CREATED         SIZE
</span></span><span style="display:flex;"><span>nginx         2.0       546ad28bcf61   <span style="color:#ae81ff">5</span> seconds ago   133MB
</span></span><span style="display:flex;"><span>redis         6.2.4     fad0ee7e917a   <span style="color:#ae81ff">2</span> days ago      105MB
</span></span><span style="display:flex;"><span>nginx         latest    d1a364dc548d   <span style="color:#ae81ff">9</span> days ago      133MB
</span></span><span style="display:flex;"><span>hello-world   latest    d1165f221234   <span style="color:#ae81ff">3</span> months ago    13.3kB</span></span></code></pre></div><p>使用 <code>docker history</code> 可以具体查看镜像内的历史记录，如果比较 <code>nginx:latest</code> 的历史记录，会发现新增了刚刚提交的这一层：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#f92672">[</span>root@wangpengliang ~<span style="color:#f92672">]</span><span style="color:#75715e"># docker history nginx:2.0</span>
</span></span><span style="display:flex;"><span>IMAGE          CREATED              CREATED BY                                      SIZE      COMMENT
</span></span><span style="display:flex;"><span>546ad28bcf61   About a minute ago   nginx -g daemon off;                            2.03kB    nginx2.0
</span></span><span style="display:flex;"><span>d1a364dc548d   <span style="color:#ae81ff">9</span> days ago           /bin/sh -c <span style="color:#75715e">#(nop)  CMD [&#34;nginx&#34; &#34;-g&#34; &#34;daemon…   0B        </span>
</span></span><span style="display:flex;"><span>&lt;missing&gt;      <span style="color:#ae81ff">9</span> days ago           /bin/sh -c <span style="color:#75715e">#(nop)  STOPSIGNAL SIGQUIT           0B        </span>
</span></span><span style="display:flex;"><span>&lt;missing&gt;      <span style="color:#ae81ff">9</span> days ago           /bin/sh -c <span style="color:#75715e">#(nop)  EXPOSE 80                    0B        </span>
</span></span><span style="display:flex;"><span>&lt;missing&gt;      <span style="color:#ae81ff">9</span> days ago           /bin/sh -c <span style="color:#75715e">#(nop)  ENTRYPOINT [&#34;/docker-entr…   0B        </span>
</span></span><span style="display:flex;"><span>&lt;missing&gt;      <span style="color:#ae81ff">9</span> days ago           /bin/sh -c <span style="color:#75715e">#(nop) COPY file:09a214a3e07c919a…   4.61kB    </span>
</span></span><span style="display:flex;"><span>&lt;missing&gt;      <span style="color:#ae81ff">9</span> days ago           /bin/sh -c <span style="color:#75715e">#(nop) COPY file:0fd5fca330dcd6a7…   1.04kB    </span>
</span></span><span style="display:flex;"><span>&lt;missing&gt;      <span style="color:#ae81ff">9</span> days ago           /bin/sh -c <span style="color:#75715e">#(nop) COPY file:0b866ff3fc1ef5b0…   1.96kB    </span>
</span></span><span style="display:flex;"><span>&lt;missing&gt;      <span style="color:#ae81ff">9</span> days ago           /bin/sh -c <span style="color:#75715e">#(nop) COPY file:65504f71f5855ca0…   1.2kB     </span>
</span></span><span style="display:flex;"><span>&lt;missing&gt;      <span style="color:#ae81ff">9</span> days ago           /bin/sh -c set -x     <span style="color:#f92672">&amp;&amp;</span> addgroup --system -…   63.9MB    
</span></span><span style="display:flex;"><span>&lt;missing&gt;      <span style="color:#ae81ff">9</span> days ago           /bin/sh -c <span style="color:#75715e">#(nop)  ENV PKG_RELEASE=1~buster     0B        </span>
</span></span><span style="display:flex;"><span>&lt;missing&gt;      <span style="color:#ae81ff">9</span> days ago           /bin/sh -c <span style="color:#75715e">#(nop)  ENV NJS_VERSION=0.5.3        0B        </span>
</span></span><span style="display:flex;"><span>&lt;missing&gt;      <span style="color:#ae81ff">9</span> days ago           /bin/sh -c <span style="color:#75715e">#(nop)  ENV NGINX_VERSION=1.21.0     0B        </span>
</span></span><span style="display:flex;"><span>&lt;missing&gt;      <span style="color:#ae81ff">3</span> weeks ago          /bin/sh -c <span style="color:#75715e">#(nop)  LABEL maintainer=NGINX Do…   0B        </span>
</span></span><span style="display:flex;"><span>&lt;missing&gt;      <span style="color:#ae81ff">3</span> weeks ago          /bin/sh -c <span style="color:#75715e">#(nop)  CMD [&#34;bash&#34;]                 0B        </span>
</span></span><span style="display:flex;"><span>&lt;missing&gt;      <span style="color:#ae81ff">3</span> weeks ago          /bin/sh -c <span style="color:#75715e">#(nop) ADD file:7362e0e50f30ff454…   69.3MB</span></span></span></code></pre></div><p>新的镜像定制好后，运行这个镜像。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>docker run --name webserver2 -d -p 81:80 nginx:2.0</span></span></code></pre></div><p>这里命名为新的服务为 <code>webserver2</code> ，并且映射到 <code>81</code> 端口。看到结果内容和之前修改后的 <code>webserver</code> 一样</p>
<p><img src="/images/2021-09-09-13-46-31.png" alt="" /></p>
<h1 id="慎用commit镜像">慎用Commit镜像<a class="anchor" href="#%e6%85%8e%e7%94%a8commit%e9%95%9c%e5%83%8f">#</a></h1>
<p><code>docker commit</code> 命令虽然可以比较直观的帮助理解镜像分层存储的概念，但是实际环境中并不推荐这么用，原因有如下几点：</p>
<p><strong>问题一：</strong></p>
<p>仔细观察之前的 <code>docker diff webserver</code> 的结果，会发现除了真正想要修改的 <code>/usr/share/nginx/html/index.html</code> 文件外，由于命令的执行还有很多文件被改动或添加了。这还仅仅是最简单的操作，如果是安装软件包、编译构建那会有大量的无关内容被添加进来。如果不清理干净，将导致镜像极为臃肿。</p>
<p><strong>问题二：</strong></p>
<p>使用 <code>docker commit</code> 意味着所有对镜像的操作都是黑箱操作，生成的镜像也被称为黑箱镜像，除了制作镜像的人知道执行过什么命令、怎么生成的镜像，别人根本无从得知。而且，即使是这个制作镜像的人，过一段时间后也无法记清具体操作。虽然 <code>docker diff</code> 或许可以得到一些线索，但是远远不到可以确保生成一致镜像的地步。这种黑箱镜像将导致维护工作非常痛苦。</p>
<p><strong>问题三：</strong></p>
<p>镜像所使用的分层存储的概念是除当前层外，之前的每一层都是不会发生改变的，换句话说，任何修改的结果仅仅是在当前层进行标记、添加、修改，而不会改动上一层。如果使用 <code>docker commit</code> 制作镜像以及后期修改的话，每一次修改都会让镜像更加臃肿一次，所删除的上一层的东西并不会丢失，会一直如影随形的跟着这个镜像，即使根本无法访问到。这也会让镜像更加臃肿。</p>
<h1 id="dockerfile示例">DockerFile示例<a class="anchor" href="#dockerfile%e7%a4%ba%e4%be%8b">#</a></h1>
<p>根据之前的 <code>docker commit</code> 了解到镜像的定制实际上就是定制每一层所添加的配置、文件。如果可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是<code>Dockerfile</code> 。</p>
<p>Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。了解了 Dockerfile 如何构建镜像后，以 nginx 举例来构建这个镜像。</p>
<p>在空白目录中建立文件命名为 <code>Dockerfile</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ mkdir mynginx
</span></span><span style="display:flex;"><span>$ cd mynginx
</span></span><span style="display:flex;"><span>$ touch Dockerfile</span></span></code></pre></div><p>编写内容：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>FROM nginx
</span></span><span style="display:flex;"><span>RUN echo <span style="color:#e6db74">&#39;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#39;</span> &gt; /usr/share/nginx/html/index.html</span></span></code></pre></div><p>使用 <code>docker build</code> 命令依赖 <code>Dockerfile</code>文件生成镜像：（注意：最后有个<code>.</code> 这是必须的）</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#f92672">[</span>root@wangpengliang ~<span style="color:#f92672">]</span><span style="color:#75715e"># docker build -t nginx:3.0 .</span></span></span></code></pre></div><p>查看构建好的镜像：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#f92672">[</span>root@wangpengliang ~<span style="color:#f92672">]</span><span style="color:#75715e"># docker image ls</span>
</span></span><span style="display:flex;"><span>REPOSITORY    TAG       IMAGE ID       CREATED         SIZE
</span></span><span style="display:flex;"><span>nginx         3.0       f89693105193   <span style="color:#ae81ff">7</span> minutes ago   133MB
</span></span><span style="display:flex;"><span>nginx         2.0       546ad28bcf61   <span style="color:#ae81ff">3</span> days ago      133MB
</span></span><span style="display:flex;"><span>redis         6.2.4     fad0ee7e917a   <span style="color:#ae81ff">5</span> days ago      105MB
</span></span><span style="display:flex;"><span>nginx         latest    d1a364dc548d   <span style="color:#ae81ff">12</span> days ago     133MB
</span></span><span style="display:flex;"><span>hello-world   latest    d1165f221234   <span style="color:#ae81ff">3</span> months ago    13.3kB</span></span></code></pre></div><p>运行 <code>nginx:3.0</code> 镜像测试：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>docker run --name webserver3 -d -p 82:80 nginx:3.0</span></span></code></pre></div><p><img src="/images/2021-09-09-13-49-52.png" alt="" /></p>
<h1 id="其他-docker-build用法">其他 <code>Docker Build</code> 用法<a class="anchor" href="#%e5%85%b6%e4%bb%96-docker-build%e7%94%a8%e6%b3%95">#</a></h1>
<h2 id="git-repo-构建">Git repo 构建<a class="anchor" href="#git-repo-%e6%9e%84%e5%bb%ba">#</a></h2>
<p><code>docker build</code> 支持从 <code>URL</code>  构建，比如可以直接从 Git repo 中构建：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ docker build https://github.com/twang2218/gitlab-ce-zh.git#:11.1
</span></span><span style="display:flex;"><span>Sending build context to Docker daemon 2.048 kB
</span></span><span style="display:flex;"><span>Step1: FROM gitlab/gitlab-ce:11.1.0-ce.0
</span></span><span style="display:flex;"><span>11.1.0-ce.0:Pulling from gitlab/gitlab-ce
</span></span><span style="display:flex;"><span>aed15891ba52:Already exists
</span></span><span style="display:flex;"><span>773ae8583d14:Already exists</span></span></code></pre></div><p>这里指定了构建所需的 <code>git repo</code> ，并且指定默认的 <code>master</code> 分支，构建目录为 <code>/11.1/</code>，然后 Docker 就会去 <code>git clone</code> 这个项目、切换到指定分支、并进入到指定目录后开始构建。</p>
<h2 id="tar-压缩包构建">tar 压缩包构建<a class="anchor" href="#tar-%e5%8e%8b%e7%bc%a9%e5%8c%85%e6%9e%84%e5%bb%ba">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ docker build http://server/context.tar.gz</span></span></code></pre></div><p>如果给出的 <code>URL</code>  不是个 <code>Git repo</code> ，而是个 <code>tar</code> 压缩包，那么 Docker 引擎会下载这个包，并自动解压缩，以其作为上下文，开始构建。</p>
<h2 id="读取-dockerfile-构建">读取 Dockerfile 构建<a class="anchor" href="#%e8%af%bb%e5%8f%96-dockerfile-%e6%9e%84%e5%bb%ba">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker build -&lt;Dockerfile
</span></span><span style="display:flex;"><span>或
</span></span><span style="display:flex;"><span>cat Dockerfile| docker build -</span></span></code></pre></div><p>如果标准输入传入的是文本文件，则将其视为 <code>Dockerfile</code>，并开始构建。这种形式由于直接从标准输入中读取 Dockerfile 的内容，它没有上下文，因此不可以像其他方法那样可以将本地文件 <code>COPY</code> 到镜像之类的事情。</p>
<h2 id="读取上下文压缩包构建">读取上下文压缩包构建<a class="anchor" href="#%e8%af%bb%e5%8f%96%e4%b8%8a%e4%b8%8b%e6%96%87%e5%8e%8b%e7%bc%a9%e5%8c%85%e6%9e%84%e5%bb%ba">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ docker build -&lt; context.tar.gz</span></span></code></pre></div><p>如果发现标准输入的文件格式是 <code>gzip</code>、<code>bzip2</code> 以及 <code>xz</code> 的话，将会使其为上下文压缩包，直接将其展开，将里面视为上下文，并开始构建。</p>
</div>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">
  <div>
  
    <a href="/posts/docker/1.1docker%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%89%E8%A3%85/" class="flex align-center">
      <img src="/icons/backward.svg" class="book-icon" alt="Backward" />
      <span>1.1 Docker概念及安装</span>
    </a>
  
  </div>
  <div>
  
    <a href="/posts/docker/1.3docker%E5%AE%B9%E5%99%A8/" class="flex align-center">
      <span>1.3 Docker容器</span>
      <img src="/icons/forward.svg" class="book-icon" alt="Forward" />
    </a>
  
  </div>
</div>
 
        
  
 
        
        
  
 
        
  
  
    <script>(function(){document.querySelectorAll("pre:has(code)").forEach(e=>{e.addEventListener("click",e.focus),e.addEventListener("copy",function(t){if(t.preventDefault(),navigator.clipboard){const t=window.getSelection().toString()||e.textContent;navigator.clipboard.writeText(t)}})})})()</script>
  

      </footer>

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
  
  <aside class="book-toc">
    <div class="book-toc-content">
      
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#git-repo-构建">Git repo 构建</a></li>
    <li><a href="#tar-压缩包构建">tar 压缩包构建</a></li>
    <li><a href="#读取-dockerfile-构建">读取 Dockerfile 构建</a></li>
    <li><a href="#读取上下文压缩包构建">读取上下文压缩包构建</a></li>
  </ul>
</nav>



    </div>
  </aside>
  
 
  </main>

  
</body>
</html>




















