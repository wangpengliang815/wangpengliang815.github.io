<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Elasticsearch 简称 ES，是一个开源、高扩展的分布式全文检索引擎，可以实现近乎实时的存储、检索数据且扩展性很好，可以扩展到上百台服务器，处理PB级别的数据。ES 底层是开源库 Lucene，ES 实现了对 Lucene 的封装，并提供 REST 风格的操作接口开箱即用。通过简单的 RESTful API 来隐藏Lucene的复杂性，从而让全文搜索变得简单。
ElasticSearch 对比 Solr# Solr 利用 Zookeeper 进行分布式管理， Elasticsearch 自身带有分布式协调管理功能 Solr 支持更多格式的数据，而 Elasticsearch 仅支持json文件格式 Solr 官方提供的功能更多，而 Elasticsearch 本身更注重于核心功能，高级功能由第三方插件提供 Solr 在传统的搜索应用中表现好于 Elasticsearch，但在处理实时搜索应用时效率明显低于 Elasticsearch ElasticSearch 安装# 注意：ES 使用 Java 开发，使用 Lucene 作为核心，所以需要配置好java环境（jdk1.8 以上）
下载地址：ElasticSearch 官网，如果下载比较慢可以试试：newbe.pro
Windows 平台下载完成直接解压即可，目录结构如下：
bin // 可执行二进制文件 config // 配置信息目录 lib // jar包存放目录,比如lucene相关的jar包 logs // 日志 modulES // 模块 plugins // 插件ElasticSearch 配置# 调整内存# 修改 conf\jvm.option 文件
">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:url" content="http://localhost:1313/posts/elk/1.1elastaticsearch%E5%85%A5%E9%97%A8/">
  <meta property="og:site_name" content="CODE&#39;NOTE">
  <meta property="og:title" content="CODE&#39;NOTE">
  <meta property="og:description" content="Elasticsearch 简称 ES，是一个开源、高扩展的分布式全文检索引擎，可以实现近乎实时的存储、检索数据且扩展性很好，可以扩展到上百台服务器，处理PB级别的数据。ES 底层是开源库 Lucene，ES 实现了对 Lucene 的封装，并提供 REST 风格的操作接口开箱即用。通过简单的 RESTful API 来隐藏Lucene的复杂性，从而让全文搜索变得简单。
ElasticSearch 对比 Solr# Solr 利用 Zookeeper 进行分布式管理， Elasticsearch 自身带有分布式协调管理功能 Solr 支持更多格式的数据，而 Elasticsearch 仅支持json文件格式 Solr 官方提供的功能更多，而 Elasticsearch 本身更注重于核心功能，高级功能由第三方插件提供 Solr 在传统的搜索应用中表现好于 Elasticsearch，但在处理实时搜索应用时效率明显低于 Elasticsearch ElasticSearch 安装# 注意：ES 使用 Java 开发，使用 Lucene 作为核心，所以需要配置好java环境（jdk1.8 以上）
下载地址：ElasticSearch 官网，如果下载比较慢可以试试：newbe.pro
Windows 平台下载完成直接解压即可，目录结构如下：
bin // 可执行二进制文件 config // 配置信息目录 lib // jar包存放目录,比如lucene相关的jar包 logs // 日志 modulES // 模块 plugins // 插件ElasticSearch 配置# 调整内存# 修改 conf\jvm.option 文件">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">


  <meta itemprop="name" content="CODE&#39;NOTE">
  <meta itemprop="description" content="Elasticsearch 简称 ES，是一个开源、高扩展的分布式全文检索引擎，可以实现近乎实时的存储、检索数据且扩展性很好，可以扩展到上百台服务器，处理PB级别的数据。ES 底层是开源库 Lucene，ES 实现了对 Lucene 的封装，并提供 REST 风格的操作接口开箱即用。通过简单的 RESTful API 来隐藏Lucene的复杂性，从而让全文搜索变得简单。
ElasticSearch 对比 Solr# Solr 利用 Zookeeper 进行分布式管理， Elasticsearch 自身带有分布式协调管理功能 Solr 支持更多格式的数据，而 Elasticsearch 仅支持json文件格式 Solr 官方提供的功能更多，而 Elasticsearch 本身更注重于核心功能，高级功能由第三方插件提供 Solr 在传统的搜索应用中表现好于 Elasticsearch，但在处理实时搜索应用时效率明显低于 Elasticsearch ElasticSearch 安装# 注意：ES 使用 Java 开发，使用 Lucene 作为核心，所以需要配置好java环境（jdk1.8 以上）
下载地址：ElasticSearch 官网，如果下载比较慢可以试试：newbe.pro
Windows 平台下载完成直接解压即可，目录结构如下：
bin // 可执行二进制文件 config // 配置信息目录 lib // jar包存放目录,比如lucene相关的jar包 logs // 日志 modulES // 模块 plugins // 插件ElasticSearch 配置# 调整内存# 修改 conf\jvm.option 文件">
  <meta itemprop="wordCount" content="366">

<title>1.1 Elastatic Search入门 | CODE&#39;NOTE</title>
<link rel="icon" href="/favicon.png" >
<link rel="manifest" href="/manifest.json">
<link rel="canonical" href="http://localhost:1313/posts/elk/1.1elastaticsearch%E5%85%A5%E9%97%A8/">
<link rel="stylesheet" href="/book.min.6970156cec683193d93c9c4edaf0d56574e4361df2e0c1be4f697ae81c3ba55f.css" integrity="sha256-aXAVbOxoMZPZPJxO2vDVZXTkNh3y4MG&#43;T2l66Bw7pV8=" crossorigin="anonymous">


  <script defer src="/fuse.min.js"></script>
  <script defer src="/en.search.min.3ed9c79c605914c45e19db90edfda0ca8d87c63064c1d6252862250c4e917346.js" integrity="sha256-PtnHnGBZFMReGduQ7f2gyo2HxjBkwdYlKGIlDE6Rc0Y=" crossorigin="anonymous"></script>



  
</head>
<body dir="ltr" class="book-kind-page book-type-posts">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    
<aside class="book-menu">
  <div class="book-menu-content">
    
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><span>CODE&#39;NOTE</span>
  </a>
</h2>


<div class="book-search hidden">
  <input id="book-search-input" type="text" 
    placeholder="Search"
    aria-label="Search"
    maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>
<script>document.querySelector(".book-search").classList.remove("hidden")</script>
























</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>



  </div>
</aside>
 

    <div class="book-page">
      <header class="book-header hidden">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/icons/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <h3>1.1 Elastatic Search入门</h3>

  <label for="toc-control">
    
    <img src="/icons/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#调整内存">调整内存</a></li>
    <li><a href="#开启跨域">开启跨域</a></li>
  </ul>

  <ul>
    <li><a href="#index-索引">index 索引</a></li>
    <li><a href="#type-类型"><del>type 类型</del></a></li>
    <li><a href="#filed字段">Filed字段</a></li>
    <li><a href="#mapping-映射">mapping 映射</a></li>
    <li><a href="#document-文档">document 文档</a></li>
    <li><a href="#cluster-集群">cluster 集群</a></li>
    <li><a href="#node-节点">node 节点</a></li>
    <li><a href="#shards-分片">shards 分片</a></li>
    <li><a href="#replicas-复制">replicas 复制</a></li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
<article class="markdown book-post">
  <h1>
    1.1 Elastatic Search入门
  </h1>
  


  

  


  <div class="book-post-content markdown-inner"><p>Elasticsearch 简称 ES，是一个<strong>开源</strong>、<strong>高扩展</strong>的<strong>分布式全文检索引擎</strong>，可以实现近乎实时的存储、检索数据且扩展性很好，可以扩展到上百台服务器，处理PB级别的数据。ES 底层是开源库 Lucene，ES 实现了对 Lucene 的封装，并提供  <code>REST</code> 风格的操作接口开箱即用。通过简单的 RESTful API 来隐藏Lucene的复杂性，从而让全文搜索变得简单。</p>
<!-- more -->
<h1 id="elasticsearch-对比-solr">ElasticSearch 对比 Solr<a class="anchor" href="#elasticsearch-%e5%af%b9%e6%af%94-solr">#</a></h1>
<ul>
<li>Solr 利用 <code>Zookeeper</code> 进行分布式管理， Elasticsearch 自身带有分布式协调管理功能</li>
<li>Solr 支持更多格式的数据，而 Elasticsearch 仅支持json文件格式</li>
<li>Solr 官方提供的功能更多，而 Elasticsearch 本身更注重于核心功能，高级功能由第三方插件提供</li>
<li>Solr 在传统的搜索应用中表现好于 Elasticsearch，但在处理实时搜索应用时效率明显低于 Elasticsearch</li>
</ul>
<h1 id="elasticsearch-安装">ElasticSearch 安装<a class="anchor" href="#elasticsearch-%e5%ae%89%e8%a3%85">#</a></h1>
<blockquote class='book-hint '>
<p>注意：ES 使用 Java 开发，使用 Lucene 作为核心，所以需要配置好java环境（<code>jdk1.8</code> 以上）</p>
</blockquote><p>下载地址：<a href="https://www.elastic.co/products/elasticsearch">ElasticSearch 官网</a>，如果下载比较慢可以试试：<a href="https://www.newbe.pro/Mirrors/Mirrors-Elasticsearch">newbe.pro</a></p>
<p>Windows 平台下载完成直接解压即可，目录结构如下：</p>
<p><img src="/images/2022-03-06-00-17-58.png" alt="" /></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>bin     // 可执行二进制文件
</span></span><span style="display:flex;"><span>config  // 配置信息目录
</span></span><span style="display:flex;"><span>lib     // jar包存放目录,比如lucene相关的jar包
</span></span><span style="display:flex;"><span>logs    // 日志
</span></span><span style="display:flex;"><span>modulES // 模块
</span></span><span style="display:flex;"><span>plugins // 插件</span></span></code></pre></div><h1 id="elasticsearch-配置">ElasticSearch 配置<a class="anchor" href="#elasticsearch-%e9%85%8d%e7%bd%ae">#</a></h1>
<h2 id="调整内存">调整内存<a class="anchor" href="#%e8%b0%83%e6%95%b4%e5%86%85%e5%ad%98">#</a></h2>
<p>修改 <code>conf\jvm.option</code> 文件</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">-</span>Xms1g
</span></span><span style="display:flex;"><span><span style="color:#f92672">-</span>Xmx1g
</span></span><span style="display:flex;"><span>修改为自己定义的值<span style="color:#960050;background-color:#1e0010">，</span>比如
</span></span><span style="display:flex;"><span><span style="color:#f92672">-</span>xms256m
</span></span><span style="display:flex;"><span><span style="color:#f92672">-</span>xmx256m
</span></span><span style="display:flex;"><span>防止因为内存不足无法启动</span></span></code></pre></div><h2 id="开启跨域">开启跨域<a class="anchor" href="#%e5%bc%80%e5%90%af%e8%b7%a8%e5%9f%9f">#</a></h2>
<p>修改 <code>conf\elasticsearch.yml</code> 文件，在末尾加入如下代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>http.<span style="color:#a6e22e">cors</span>.<span style="color:#a6e22e">enabled</span>: <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>http.<span style="color:#a6e22e">cors</span>.<span style="color:#a6e22e">allow</span><span style="color:#f92672">-</span>origin: <span style="color:#e6db74">&#34;*&#34;</span>
</span></span><span style="display:flex;"><span>network.<span style="color:#a6e22e">host</span>: 127.<span style="color:#a6e22e">0</span>.<span style="color:#a6e22e">0</span>.<span style="color:#a6e22e">1</span></span></span></code></pre></div><h1 id="elasticsearch-启动">ElasticSearch 启动<a class="anchor" href="#elasticsearch-%e5%90%af%e5%8a%a8">#</a></h1>
<p>双击 <code>bin</code> 目录下的 <code>elasticsearch.bat</code> 启动：</p>
<p><img src="/images/2022-03-06-00-29-21.png" alt="" /></p>
<blockquote class='book-hint '>
<p>:warning: ES集群之间使用tcp进行通信，<code>9300</code> 是tcp通信端口，<code>9200</code> 是http协议端口</p>
</blockquote><p>浏览器测试访问：</p>
<p><img src="/images/2022-03-06-00-31-42.png" alt="" /></p>
<h1 id="elasticsearch-head">Elasticsearch-head<a class="anchor" href="#elasticsearch-head">#</a></h1>
<p>通过安装 <code>ElasticSearch</code> 的 <code>head</code> 插件，可以实现图形化查看索引数据。<a href="https://github.com/mobz/elasticsearch-head">下载地址</a></p>
<p>下载完成后解压即可，目录结构如下：</p>
<p><img src="/images/2022-03-06-00-34-01.png" alt="" /></p>
<p><code>Elasticsearch-head</code> 依赖于 <code>node.js</code> 所以需要先保证本地有 <code>node.js</code> 的环境：</p>
<pre tabindex="0"><code>C:\Users\Administrator&gt;node -v
v14.17.3</code></pre><p>使用 <code>npm</code> 还原依赖：</p>
<pre tabindex="0"><code>D:\Elasticsearch\elasticsearch-head-master&gt;npm install</code></pre><blockquote class='book-hint '>
<p>注意：如果下载速度较慢，可以切换淘宝镜像使用 cnpm</p>
</blockquote><p>启动 <code>Elasticsearch-head</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>D:<span style="color:#ae81ff">\E</span>lasticsearch<span style="color:#ae81ff">\e</span>lasticsearch-head-master&gt;npm run start
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>&gt; elasticsearch-head@0.0.0 start D:<span style="color:#ae81ff">\E</span>lasticsearch<span style="color:#ae81ff">\e</span>lasticsearch-head-master
</span></span><span style="display:flex;"><span>&gt; grunt server
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Running <span style="color:#e6db74">&#34;connect:server&#34;</span> <span style="color:#f92672">(</span>connect<span style="color:#f92672">)</span> task
</span></span><span style="display:flex;"><span>Waiting forever...
</span></span><span style="display:flex;"><span>Fatal error: Port <span style="color:#ae81ff">9100</span> is already in use by another procESs.
</span></span><span style="display:flex;"><span>npm ERR! code ELIFECYCLE
</span></span><span style="display:flex;"><span>npm ERR! errno <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>npm ERR! elasticsearch-head@0.0.0 start: <span style="color:#e6db74">`</span>grunt server<span style="color:#e6db74">`</span>
</span></span><span style="display:flex;"><span>npm ERR! Exit status <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>npm ERR!
</span></span><span style="display:flex;"><span>npm ERR! Failed at the elasticsearch-head@0.0.0 start script.
</span></span><span style="display:flex;"><span>npm ERR! This is probably not a problem with npm. There is likely additional logging output above.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>npm ERR! A complete log of this run can be found in:
</span></span><span style="display:flex;"><span>npm ERR!     C:<span style="color:#ae81ff">\U</span>sers<span style="color:#ae81ff">\A</span>dministrator<span style="color:#ae81ff">\A</span>ppData<span style="color:#ae81ff">\R</span>oaming<span style="color:#ae81ff">\n</span>pm-cache<span style="color:#ae81ff">\_</span>logs<span style="color:#ae81ff">\2</span>022-03-05T16_39_04_056Z-debug.log</span></span></code></pre></div><p>这里报错：<code>Port 9100 is already in use by another procESs.</code> ，原因是 <code>9100</code> 端口被占用，查看哪个进程占用的端口号并结束该进程：</p>
<pre tabindex="0"><code>D:\Elasticsearch\elasticsearch-head-master&gt;netstat -ano | findstr &#34;9100&#34;
  TCP    0.0.0.0:9100           0.0.0.0:0              LISTENING       12276
  TCP    127.0.0.1:53459        127.0.0.1:9100         TIME_WAIT       0

D:\Elasticsearch\elasticsearch-head-master&gt;taskkill -pid 12276 -F
成功: 已终止 PID 为 12276 的进程。</code></pre><p>重新启动：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>D:<span style="color:#ae81ff">\E</span>lasticsearch<span style="color:#ae81ff">\e</span>lasticsearch-head-master&gt;npm run start
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>&gt; elasticsearch-head@0.0.0 start D:<span style="color:#ae81ff">\E</span>lasticsearch<span style="color:#ae81ff">\e</span>lasticsearch-head-master
</span></span><span style="display:flex;"><span>&gt; grunt server
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Running <span style="color:#e6db74">&#34;connect:server&#34;</span> <span style="color:#f92672">(</span>connect<span style="color:#f92672">)</span> task
</span></span><span style="display:flex;"><span>Waiting forever...
</span></span><span style="display:flex;"><span>Started connect web server on http://localhost:9100</span></span></code></pre></div><p>浏览器访问：</p>
<p><img src="/images/2022-03-06-00-44-44.png" alt="" /></p>
<p>ok，至此完成 <code>Elasticsearch-head</code> 的安装启动。</p>
<h1 id="elasticsearch-核心概念">Elasticsearch 核心概念<a class="anchor" href="#elasticsearch-%e6%a0%b8%e5%bf%83%e6%a6%82%e5%bf%b5">#</a></h1>
<p>Elasticsearch 是面向文档（<code>document oriented</code> ）的，这意味着它可以存储整个对象或文档（<code>document</code> ）。然而它不仅会存储，还会索引( <code>index</code> )每个文档的内容使之可以被搜索。在Elasticsearch中，可以对文档（而非成行或列的数据）进行索引、搜索、排序、过滤。Elasticsearch 对比传统关系型数据库如下：</p>
<blockquote class='book-hint '>
<p>RDBMS ‐&gt; DatabasES ‐&gt; TablES ‐&gt; Rows ‐&gt; Columns
Elasticsearch ‐&gt; IndicES ‐&gt; TypES ‐&gt; Documents ‐&gt; Fields</p>
</blockquote><h2 id="index-索引">index 索引<a class="anchor" href="#index-%e7%b4%a2%e5%bc%95">#</a></h2>
<blockquote class='book-hint '>
<p>一个索引就是一个拥有几分相似特征的文档的集合。比如客户数据索引、产品目录索引、订单数据索引。索引由一个名字来标识（名称必须全部小写），当要对这个索引中的文档进行索引、搜索、更新和删除时都要使用到这个名字。一个集群中可以定义任意多的索引。可类比SqlServer中的数据库</p>
</blockquote><h2 id="type-类型"><del>type 类型</del><a class="anchor" href="#type-%e7%b1%bb%e5%9e%8b">#</a></h2>
<blockquote class='book-hint '>
<p>一个索引中可以定义一种或多种类型。一个类型是索引的一个逻辑上的分类/分区，其语义完全自己定义。通常会为具有一组共同字段的文档定义一个类型。假设运营一个博客平台并且将所有的数据存储到一个索引中。在这个索引中，可以为用户数据定义一个类型，为博客数据定义另一个类型。可类比SqlServer中的表</p>
<p><strong>:rotating_light: 注意</strong>：ES 7.0 以及之后的版本中 Type 被废弃。一个 index 中只有一个默认的 type，即 <code>_doc</code></p>
</blockquote><h2 id="filed字段">Filed字段<a class="anchor" href="#filed%e5%ad%97%e6%ae%b5">#</a></h2>
<blockquote class='book-hint '>
<p>相当于数据表的字段，对文档数据根据不同属性进行的分类标识 。</p>
</blockquote><h2 id="mapping-映射">mapping 映射<a class="anchor" href="#mapping-%e6%98%a0%e5%b0%84">#</a></h2>
<blockquote class='book-hint '>
<p>mapping 在处理数据的方式和规则方面做一些限制，如某个字段的数据类型、默认值、分析器、是否被索引等等，这些都可以在映射里设置，其它就是处理ES里面数据的一些使用规则设置也叫做映射，按最优规则处理数据对性能提高很大，因此才需要建立映射，并且需要思考如何建立映射才能对性能更好。相当于SqlServer中的创建表的过程，设置主键外键等等</p>
</blockquote><h2 id="document-文档">document 文档<a class="anchor" href="#document-%e6%96%87%e6%a1%a3">#</a></h2>
<blockquote class='book-hint '>
<p>一个文档是一个可被索引的基础信息单元。比如：客户文档、产品文档。文档以JSON（ <code>Javascript Object Notation</code> ）格式表示。一个 <code>index/type</code> 里可以存储任意多的文档。注意：尽管一个文档物理上存在于一个索引之中，但文档必须被索引赋予一个索引的 <code>type</code> 。 插入索引库以文档为单位，类比与数据库中的一行数据</p>
</blockquote><h2 id="cluster-集群">cluster 集群<a class="anchor" href="#cluster-%e9%9b%86%e7%be%a4">#</a></h2>
<blockquote class='book-hint '>
<p>一个集群就是由一个或多个节点组织在一起，它们共同持有整个的数据，并一起提供索引和搜索功能。一个集群由一个唯一的名字标识，这个名字默认是“elasticsearch”。一个节点只能通过指定某个集群的名字，来加入这个集群。</p>
</blockquote><h2 id="node-节点">node 节点<a class="anchor" href="#node-%e8%8a%82%e7%82%b9">#</a></h2>
<blockquote class='book-hint '>
<p>一个节点是集群中的一个服务器，作为集群的一部分，它存储数据，参与集群的索引和搜索功能。一 个节点由一个名字来标识，默认情况下，这个名字是一个随机的漫威漫画角色的名字，这个名字会在启动时候赋予节点。</p>
</blockquote><blockquote class='book-hint '>
<p>一个节点可以通过配置集群名称的方式来加入一个指定的集群。默认情况下，每个节点都会被安排加入到一个叫做 <code>elasticsearch</code> 的集群中，这意味着，如果网络中启动了若干个节点，并假定它们能够相互发现彼此， 它们将会自动地形成并加入到一个叫 <code>elasticsearch</code> 的集群中。</p>
</blockquote><blockquote class='book-hint '>
<p>一个集群里可以拥有任意多个节点。而且如果当前网络中没有运行任何 Elasticsearch 节点， 这时启动一个节点，会默认创建并加入一个叫做 <code>elasticsearch</code> 的集群。</p>
</blockquote><h2 id="shards-分片">shards 分片<a class="anchor" href="#shards-%e5%88%86%e7%89%87">#</a></h2>
<blockquote class='book-hint '>
<p>一个索引可以存储超出单个节点硬件限制的大量数据。比如，一个具有10亿文档的索引占据1TB的磁盘空间，而任一节点都没有这样大的磁盘空间；或者单个节点处理搜索请求，响应太慢。为了解决这个问题，Elasticsearch 提供了将索引划分成多份的能力，这些份就叫做分片。当创建一个索引时，可以指定想要的分片的数量。每个分片本身也是一个功能完善并且独立的“索引”，这个“索引”可以被放置到集群中的任何节点上。分片很重要，主要有两方面的原因：</p>
<ul>
<li>允许水平分割/扩展内容容量</li>
<li>允许在分片（潜在地，位于多个节点上）之上进行分布式的、并行的操作，进而提高性能/吞吐量</li>
</ul>
<p>至于一个分片怎样分布，它的文档怎样聚合返回给搜索请求，是完全由Elasticsearch管理的，对于用户来说这些都是透明的。</p>
</blockquote><h2 id="replicas-复制">replicas 复制<a class="anchor" href="#replicas-%e5%a4%8d%e5%88%b6">#</a></h2>
<blockquote class='book-hint '>
<p>在一个网络/云的环境里，失败随时都可能发生，在某个分片/节点不知怎么的就处于离线状态，或者由于任何原因消失了，这种情况下，有一个故障转移机制是非常有用并且是强烈推荐的。为此目的，Elasticsearch允许创建分片的一份或多份拷贝，这些拷贝叫做复制分片，或者直接叫复制。</p>
</blockquote><blockquote class='book-hint '>
<p>复制之所以重要，有两个主要原因</p>
<ul>
<li>在分片/节点失败的情况下，提供了高可用性。因为这个原因，注意到复制分片从不与原/主要（original/primary）分片置于同一节点上是非常重要的。</li>
<li>扩展搜索量/吞吐量，因为搜索可以在所有的复制上并行运行。总之，每个索引可以被分成多个分片。一个索引也可以被复制0次（意思是没有复制）或多次。一旦复制了，每个索引就有了主分片（作为复制源的原来的分片）和复制分片（主分片的拷贝）之别。分片和复制的数量可以在索引创建的时候指定。在索引创建之后，可以在任何时候动态地改变复制的数量，但是事后不能改变分片的数量。</li>
</ul>
</blockquote><blockquote class='book-hint '>
<p>默认情况下，Elasticsearch 中的每个索引被分片5个主分片和1个复制，这意味着如果集群中有两个节点，索引将会有5个主分片和另外5个复制分片（1个完全拷贝），这样的话每个索引总共就有10个分片。</p>
</blockquote></div>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">
  <div>
  
    <a href="/posts/dotnet/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" class="flex align-center">
      <img src="/icons/backward.svg" class="book-icon" alt="Backward" />
      <span>面向对象</span>
    </a>
  
  </div>
  <div>
  
    <a href="/posts/elk/1.2elastaticsearch%E9%85%8D%E7%BD%AE/" class="flex align-center">
      <span>1.2 Elastatic Search配置</span>
      <img src="/icons/forward.svg" class="book-icon" alt="Forward" />
    </a>
  
  </div>
</div>
 
        
  
 
        
        
  
 
        
  
  
    <script>(function(){document.querySelectorAll("pre:has(code)").forEach(e=>{e.addEventListener("click",e.focus),e.addEventListener("copy",function(t){if(t.preventDefault(),navigator.clipboard){const t=window.getSelection().toString()||e.textContent;navigator.clipboard.writeText(t)}})})})()</script>
  

      </footer>

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
  
  <aside class="book-toc">
    <div class="book-toc-content">
      
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#调整内存">调整内存</a></li>
    <li><a href="#开启跨域">开启跨域</a></li>
  </ul>

  <ul>
    <li><a href="#index-索引">index 索引</a></li>
    <li><a href="#type-类型"><del>type 类型</del></a></li>
    <li><a href="#filed字段">Filed字段</a></li>
    <li><a href="#mapping-映射">mapping 映射</a></li>
    <li><a href="#document-文档">document 文档</a></li>
    <li><a href="#cluster-集群">cluster 集群</a></li>
    <li><a href="#node-节点">node 节点</a></li>
    <li><a href="#shards-分片">shards 分片</a></li>
    <li><a href="#replicas-复制">replicas 复制</a></li>
  </ul>
</nav>



    </div>
  </aside>
  
 
  </main>

  
</body>
</html>




















