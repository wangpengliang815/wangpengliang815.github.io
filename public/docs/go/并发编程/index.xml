<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>并发编程 on CODE&#39;NOTE</title>
    <link>http://localhost:1313/docs/go/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</link>
    <description>Recent content in 并发编程 on CODE&#39;NOTE</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <atom:link href="http://localhost:1313/docs/go/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title></title>
      <link>http://localhost:1313/docs/go/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/channel/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/go/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/channel/</guid>
      <description>&lt;h1 id=&#34;channel&#34;&gt;channel&lt;a class=&#34;anchor&#34; href=&#34;#channel&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;上一章学习了 &lt;code&gt;goroutine&lt;/code&gt; 的使用方式。但是单纯的将函数并发执行并没有意义。函数与函数间需要交换数据才能体现并发执行的意义。虽然可以使用共享内存进行数据交换，但是共享内存在不同的 &lt;code&gt;goroutine&lt;/code&gt; 中容易发生竞态问题。为了保证数据交换的正确性，很多并发模型中必须使用互斥量对内存进行加锁，但这种做法势必造成性能问题。&lt;/p&gt;&#xA;&lt;p&gt;Go语言采用的并发模型是 &lt;code&gt;CSP（Communicating Sequential Processes）&lt;/code&gt; 提倡：&lt;strong&gt;通过通信共享内存&lt;/strong&gt;而不是&lt;strong&gt;通过共享内存实现通信&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;如果把 &lt;code&gt;goroutine&lt;/code&gt; 比作是Go程序并发的执行体，&lt;code&gt;channel&lt;/code&gt;就是它们之间的连接。&lt;code&gt;channel&lt;/code&gt; 是可以让一个 &lt;code&gt;goroutine&lt;/code&gt; 发送特定值到另一个 &lt;code&gt;goroutine&lt;/code&gt; 的通信机制。&lt;/p&gt;&#xA;&lt;p&gt;Go语言中的通道 &lt;code&gt;channel&lt;/code&gt; 是一种特殊的类型。通道像一个传送带或者队列，总是遵循先入先出（&lt;code&gt;First In First Out&lt;/code&gt;）的规则，保证收发数据的顺序。每一个通道都是一个具体类型的导管，也就是说：声明 &lt;code&gt;channel&lt;/code&gt;  时需要为其指定元素类型。&lt;/p&gt;&#xA;&lt;h2 id=&#34;channel-类型&#34;&gt;channel 类型&lt;a class=&#34;anchor&#34; href=&#34;#channel-%e7%b1%bb%e5%9e%8b&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;channel&lt;/code&gt; 是 Go 语言中一种特有的类型。声明格式如下：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;变量名称&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;chan&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;元素类型&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;chan&lt;/code&gt; ：关键字&lt;/li&gt;&#xA;&lt;li&gt;元素类型：是指通道中传递元素的类型&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;比如：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ch1&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;chan&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;   &lt;span style=&#34;color:#75715e&#34;&gt;// 声明一个传递整型的通道&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ch2&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;chan&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 声明一个传递布尔型的通道&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ch3&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;chan&lt;/span&gt; []&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// 声明一个传递int切片的通道&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;channel-零值&#34;&gt;channel 零值&lt;a class=&#34;anchor&#34; href=&#34;#channel-%e9%9b%b6%e5%80%bc&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;未初始化的通道类型变量其默认零值是 &lt;code&gt;nil&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ch&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;chan&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;ch&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;// &amp;lt;nil&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;channel-初始化&#34;&gt;channel 初始化&lt;a class=&#34;anchor&#34; href=&#34;#channel-%e5%88%9d%e5%a7%8b%e5%8c%96&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;声明的通道类型变量需要使用内置的 &lt;code&gt;make&lt;/code&gt; 函数初始化之后才能使用。格式如下：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;make(&lt;span style=&#34;color:#66d9ef&#34;&gt;chan&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;元素类型&lt;/span&gt;, [&lt;span style=&#34;color:#a6e22e&#34;&gt;缓冲大小&lt;/span&gt;])&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中：&lt;code&gt;channel&lt;/code&gt; 的缓冲大小是可选的。比如：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;ch4&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; make(&lt;span style=&#34;color:#66d9ef&#34;&gt;chan&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;ch5&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; make(&lt;span style=&#34;color:#66d9ef&#34;&gt;chan&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)  &lt;span style=&#34;color:#75715e&#34;&gt;// 声明一个缓冲区大小为1的通道&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;channel-操作&#34;&gt;channel 操作&lt;a class=&#34;anchor&#34; href=&#34;#channel-%e6%93%8d%e4%bd%9c&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;通道共有 &lt;code&gt;发送（send）&lt;/code&gt;、&lt;code&gt;接收(receive）&lt;/code&gt;和 &lt;code&gt;关闭（close）&lt;/code&gt; 三种操作。发送和接收操作都使用&lt;code&gt;&amp;lt;-&lt;/code&gt;符号。&lt;/p&gt;&#xA;&lt;p&gt;比如定义一个通道：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;ch&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; make(&lt;span style=&#34;color:#66d9ef&#34;&gt;chan&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;发送-send&#34;&gt;发送 send&lt;a class=&#34;anchor&#34; href=&#34;#%e5%8f%91%e9%80%81-send&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;将一个值发送到通道中。&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/docs/go/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/csp%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/go/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/csp%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B/</guid>
      <description>&lt;h1 id=&#34;并发模型&#34;&gt;并发模型&lt;a class=&#34;anchor&#34; href=&#34;#%e5%b9%b6%e5%8f%91%e6%a8%a1%e5%9e%8b&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;业界将如何实现并发编程总结归纳为各式各样的并发模型，常见的并发模型有以下几种：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;线程&amp;amp;锁模型&lt;/li&gt;&#xA;&lt;li&gt;Actor模型&lt;/li&gt;&#xA;&lt;li&gt;CSP模型&lt;/li&gt;&#xA;&lt;li&gt;Fork&amp;amp;Join模型&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Go语言中的并发程序主要是通过基于 &lt;code&gt;CSP（communicating sequential processes）&lt;/code&gt; 的 &lt;code&gt;goroutine&lt;/code&gt; 和 &lt;code&gt;channel&lt;/code&gt;来实现，当然也支持使用传统的多线程共享内存的并发方式。&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/docs/go/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/goroutine/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/go/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/goroutine/</guid>
      <description>&lt;p&gt;并发编程在当前软件领域是一个非常重要的概念，随着CPU等硬件的发展，都希望让程序运行的更快。Go语言在语言层面天生支持并发（基于 &lt;code&gt;goroutine&lt;/code&gt; 的高并发），充分利用现代CPU的多核优势，这也是Go语言能够大范围流行的一个很重要的原因。&lt;/p&gt;&#xA;&lt;h1 id=&#34;概念了解&#34;&gt;概念了解&lt;a class=&#34;anchor&#34; href=&#34;#%e6%a6%82%e5%bf%b5%e4%ba%86%e8%a7%a3&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;串行并发并行&#34;&gt;串行/并发/并行&lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%b2%e8%a1%8c%e5%b9%b6%e5%8f%91%e5%b9%b6%e8%a1%8c&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;strong&gt;串行&lt;/strong&gt;：按照一定顺序先后执行&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;并发&lt;/strong&gt;：同一时间段内执行多个任务，逻辑上的同时发生。一个处理器（在不同时刻或者说在同一时间间隔内）&amp;ldquo;同时&amp;quot;处理多个任务。宏观上是并发的，微观上是按排队等待、唤醒、执行的步骤序列执行&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;并行&lt;/strong&gt;：物理上的同时发生。多核处理器或多个处理器（在同一时刻）同时处理多个任务。并行性允许多个程序同一时刻可在不同 CPU 上同时执行&lt;/p&gt;&#xA;&lt;h2 id=&#34;进程线程协程&#34;&gt;进程/线程/协程&lt;a class=&#34;anchor&#34; href=&#34;#%e8%bf%9b%e7%a8%8b%e7%ba%bf%e7%a8%8b%e5%8d%8f%e7%a8%8b&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;进程（process）：程序在操作系统中的一次执行过程，系统进行资源分配和调度的一个独立单位&lt;/p&gt;&#xA;&lt;p&gt;线程（thread）：操作系统基于进程开启的轻量级进程，是操作系统调度执行的最小单位&lt;/p&gt;&#xA;&lt;p&gt;协程（coroutine）：非操作系统提供而是由用户自行创建和控制的 &lt;code&gt;用户态线程&lt;/code&gt;，比线程更轻量级&lt;/p&gt;&#xA;&lt;h2 id=&#34;阻塞非阻塞&#34;&gt;阻塞/非阻塞&lt;a class=&#34;anchor&#34; href=&#34;#%e9%98%bb%e5%a1%9e%e9%9d%9e%e9%98%bb%e5%a1%9e&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;strong&gt;阻塞&lt;/strong&gt;：阻塞是进程(也可以是线程、协程)的状态之一（新建、就绪、运行、阻塞、终止). 指的是当数据未准备就绪，这个进程(线程、协程)一直等待，这就是阻塞&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;非阻塞&lt;/strong&gt;： 当数据为准备就绪，该进程(线程、协程)不等待可以继续执行，这就是非阻塞&lt;/p&gt;&#xA;&lt;h2 id=&#34;同步异步&#34;&gt;同步/异步&lt;a class=&#34;anchor&#34; href=&#34;#%e5%90%8c%e6%ad%a5%e5%bc%82%e6%ad%a5&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;strong&gt;同步&lt;/strong&gt;： 发起一个调用时，在没有得到结果之前，这个调用就不返回。调用过程一直在等待。这是同步&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;异步&lt;/strong&gt;：发起调用后就立刻返回，这次调用过程就结束了，等到有结果了被调用方主动通知调用者结果。这是异步&lt;/p&gt;&#xA;&lt;h1 id=&#34;goroutine&#34;&gt;goroutine&lt;a class=&#34;anchor&#34; href=&#34;#goroutine&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;&lt;code&gt;goroutine&lt;/code&gt; 是 Go 语言支持并发的核心，一个 &lt;code&gt;goroutine&lt;/code&gt; 会以一个很小的栈开始其生命周期，一般只需要 &lt;code&gt;2KB&lt;/code&gt; 。与操作系统线程区别在于：操作系统线程由系统内核进行调度， &lt;code&gt;goroutine&lt;/code&gt; 是由Go运行时（runtime）负责调度。Go运行时会智能地将 m个 &lt;code&gt;goroutine&lt;/code&gt; 合理地分配给 &lt;code&gt;n&lt;/code&gt; 个操作系统线程，实现类似 &lt;code&gt;m:n&lt;/code&gt; 的调度机制，不再需要Go开发者自行在代码层面维护一个线程池。&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;goroutine&lt;/code&gt; 是 Go 程序中最基本的并发执行单元。每一个 Go 程序都至少包含一个 goroutine（&lt;code&gt;main goroutine&lt;/code&gt;），Go程序启动时它会自动创建。Go语言编程中不需要去自己写进程、线程、协程，当需要让某个任务并发执行的时候，只需要把这个任务包装成一个函数，开启一个 &lt;code&gt;goroutine&lt;/code&gt; 去执行这个函数就可以了。&lt;/p&gt;&#xA;&lt;h1 id=&#34;go关键字&#34;&gt;go关键字&lt;a class=&#34;anchor&#34; href=&#34;#go%e5%85%b3%e9%94%ae%e5%ad%97&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;Go语言中只需要在函数或方法调用前加上&lt;code&gt;go&lt;/code&gt;关键字就可以创建一个 &lt;code&gt;goroutine&lt;/code&gt; ，让该函数或方法在新创建的 &lt;code&gt;goroutine&lt;/code&gt; 中执行。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;go&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;test&lt;/span&gt;()  &lt;span style=&#34;color:#75715e&#34;&gt;// 创建一个新的 goroutine 运行函数test&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;匿名函数也支持使用 &lt;code&gt;go&lt;/code&gt; 关键字创建 &lt;code&gt;goroutine&lt;/code&gt; 执行。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;go&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt;(){&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// ...&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}()&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;一个 &lt;code&gt;goroutine&lt;/code&gt; 必定对应一个函数/方法，可以创建多个 &lt;code&gt;goroutine&lt;/code&gt; 去执行相同的函数/方法。&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/docs/go/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/gpm%E5%8E%9F%E7%90%86%E4%B8%8E%E8%B0%83%E5%BA%A6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/go/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/gpm%E5%8E%9F%E7%90%86%E4%B8%8E%E8%B0%83%E5%BA%A6/</guid>
      <description>&lt;h1 id=&#34;动态栈&#34;&gt;动态栈&lt;a class=&#34;anchor&#34; href=&#34;#%e5%8a%a8%e6%80%81%e6%a0%88&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;操作系统的线程一般都有固定的栈内存（通常为 &lt;code&gt;2MB&lt;/code&gt; ）,而 Go 语言中的 &lt;code&gt;goroutine&lt;/code&gt; 非常轻量级，一个 &lt;code&gt;goroutine&lt;/code&gt; 的初始栈空间很小（一般为 &lt;code&gt;2KB&lt;/code&gt; ），所以在 Go 语言中一次创建数万个 goroutine 也是可能的。并且 goroutine 的栈不是固定的，可以根据需要动态地增大或缩小， Go 的 runtime 会自动为 goroutine 分配合适的栈空间。&lt;/p&gt;&#xA;&lt;h1 id=&#34;goroutine调度&#34;&gt;goroutine调度&lt;a class=&#34;anchor&#34; href=&#34;#goroutine%e8%b0%83%e5%ba%a6&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;操作系统的线程会被操作系统内核调度时会挂起当前执行的线程并将它的寄存器内容保存到内存中，选出下一次要执行的线程并从内存中恢复该线程的寄存器信息，然后恢复执行该线程的现场并开始执行线程。从一个线程切换到另一个线程需要完整的上下文切换。因为可能需要多次内存访问，索引这个切换上下文的操作开销较大，会增加运行的cpu周期。&lt;/p&gt;&#xA;&lt;p&gt;区别于操作系统内核调度操作系统线程，goroutine 的调度是Go语言运行时（runtime）层面的实现，是完全由 Go 语言本身实现的一套调度系统——go scheduler。它的作用是按照一定的规则将所有的 goroutine 调度到操作系统线程上执行。&lt;/p&gt;&#xA;&lt;p&gt;在经历数个版本的迭代之后，目前 Go 语言的调度器采用的是 &lt;code&gt;GPM&lt;/code&gt; 调度模型。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://www.liwenzhou.com/images/Go/concurrence/gpm.png&#34; alt=&#34;gpm&#34; /&gt;&lt;/p&gt;&#xA;&lt;p&gt;其中：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;G：表示 goroutine，每执行一次&lt;code&gt;go f()&lt;/code&gt;就创建一个 G，包含要执行的函数和上下文信息。&lt;/li&gt;&#xA;&lt;li&gt;全局队列（Global Queue）：存放等待运行的 G。&lt;/li&gt;&#xA;&lt;li&gt;P：表示 goroutine 执行所需的资源，最多有 GOMAXPROCS 个。&lt;/li&gt;&#xA;&lt;li&gt;P 的本地队列：同全局队列类似，存放的也是等待运行的G，存的数量有限，不超过256个。新建 G 时，G 优先加入到 P 的本地队列，如果本地队列满了会批量移动部分 G 到全局队列。&lt;/li&gt;&#xA;&lt;li&gt;M：线程想运行任务就得获取 P，从 P 的本地队列获取 G，当 P 的本地队列为空时，M 也会尝试从全局队列或其他 P 的本地队列获取 G。M 运行 G，G 执行之后，M 会从 P 获取下一个 G，不断重复下去。&lt;/li&gt;&#xA;&lt;li&gt;Goroutine 调度器和操作系统调度器是通过 M 结合起来的，每个 M 都代表了1个内核线程，操作系统调度器负责把内核线程分配到 CPU 的核上执行。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;单从线程调度讲，Go语言相比起其他语言的优势在于OS线程是由OS内核来调度的， goroutine 则是由Go运行时（runtime）自己的调度器调度的，完全是在用户态下完成的， 不涉及内核态与用户态之间的频繁切换，包括内存的分配与释放，都是在用户态维护着一块大的内存池， 不直接调用系统的malloc函数（除非内存池需要改变），成本比调度OS线程低很多。 另一方面充分利用了多核的硬件资源，近似的把若干goroutine均分在物理线程上， 再加上本身 goroutine 的超轻量级，以上种种特性保证了 goroutine 调度方面的性能。&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/docs/go/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/go/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/</guid>
      <description>&lt;h1 id=&#34;原子操作&#34;&gt;原子操作&lt;a class=&#34;anchor&#34; href=&#34;#%e5%8e%9f%e5%ad%90%e6%93%8d%e4%bd%9c&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;针对整数数据类型（int32、uint32、int64、uint64）我们还可以使用原子操作来保证并发安全，通常直接使用原子操作比使用锁操作效率更高。Go语言中原子操作由内置的标准库&lt;code&gt;sync/atomic&lt;/code&gt;提供。&lt;/p&gt;&#xA;&lt;h2 id=&#34;atomic包&#34;&gt;atomic包&lt;a class=&#34;anchor&#34; href=&#34;#atomic%e5%8c%85&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;方法&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;解释&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;func LoadInt32(addr *int32) (val int32) func LoadInt64(addr *int64) (val int64) func LoadUint32(addr *uint32) (val uint32) func LoadUint64(addr *uint64) (val uint64) func LoadUintptr(addr *uintptr) (val uintptr) func LoadPointer(addr *unsafe.Pointer) (val unsafe.Pointer)&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;读取操作&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;func StoreInt32(addr *int32, val int32) func StoreInt64(addr *int64, val int64) func StoreUint32(addr *uint32, val uint32) func StoreUint64(addr *uint64, val uint64) func StoreUintptr(addr *uintptr, val uintptr) func StorePointer(addr *unsafe.Pointer, val unsafe.Pointer)&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;写入操作&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;func AddInt32(addr *int32, delta int32) (new int32) func AddInt64(addr *int64, delta int64) (new int64) func AddUint32(addr *uint32, delta uint32) (new uint32) func AddUint64(addr *uint64, delta uint64) (new uint64) func AddUintptr(addr *uintptr, delta uintptr) (new uintptr)&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;修改操作&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;func SwapInt32(addr *int32, new int32) (old int32) func SwapInt64(addr *int64, new int64) (old int64) func SwapUint32(addr *uint32, new uint32) (old uint32) func SwapUint64(addr *uint64, new uint64) (old uint64) func SwapUintptr(addr *uintptr, new uintptr) (old uintptr) func SwapPointer(addr *unsafe.Pointer, new unsafe.Pointer) (old unsafe.Pointer)&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;交换操作&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool) func CompareAndSwapInt64(addr *int64, old, new int64) (swapped bool) func CompareAndSwapUint32(addr *uint32, old, new uint32) (swapped bool) func CompareAndSwapUint64(addr *uint64, old, new uint64) (swapped bool) func CompareAndSwapUintptr(addr *uintptr, old, new uintptr) (swapped bool) func CompareAndSwapPointer(addr *unsafe.Pointer, old, new unsafe.Pointer) (swapped bool)&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;比较并交换操作&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;示例&#34;&gt;示例&lt;a class=&#34;anchor&#34; href=&#34;#%e7%a4%ba%e4%be%8b&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;我们填写一个示例来比较下互斥锁和原子操作的性能。&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/docs/go/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E5%92%8C%E9%94%81/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/go/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E5%92%8C%E9%94%81/</guid>
      <description>&lt;h1 id=&#34;并发安全和锁&#34;&gt;并发安全和锁&lt;a class=&#34;anchor&#34; href=&#34;#%e5%b9%b6%e5%8f%91%e5%ae%89%e5%85%a8%e5%92%8c%e9%94%81&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;有时候我们的代码中可能会存在多个 goroutine 同时操作一个资源（临界区）的情况，这种情况下就会发生&lt;code&gt;竞态问题&lt;/code&gt;（数据竞态）。这就好比现实生活中十字路口被各个方向的汽车竞争，还有火车上的卫生间被车厢里的人竞争。&lt;/p&gt;&#xA;&lt;p&gt;我们用下面的代码演示一个数据竞争的示例。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;package&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; (&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;fmt&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;sync&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; (&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int64&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;wg&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sync&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;WaitGroup&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// 等待组&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// add 对全局变量x执行5000次加1操作&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &amp;lt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5000&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;wg&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Done&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;wg&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Add&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;go&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;go&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;wg&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Wait&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们将上面的代码编译后执行，不出意外每次执行都会输出诸如9537、5865、6527等不同的结果。这是为什么呢？&lt;/p&gt;&#xA;&lt;p&gt;在上面的示例代码片中，我们开启了两个 goroutine 分别执行 add 函数，这两个 goroutine 在访问和修改全局的&lt;code&gt;x&lt;/code&gt;变量时就会存在数据竞争，某个 goroutine 中对全局变量&lt;code&gt;x&lt;/code&gt;的修改可能会覆盖掉另一个 goroutine 中的操作，所以导致最后的结果与预期不符。&lt;/p&gt;&#xA;&lt;h2 id=&#34;互斥锁&#34;&gt;互斥锁&lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%92%e6%96%a5%e9%94%81&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;互斥锁是一种常用的控制共享资源访问的方法，它能够保证同一时间只有一个 goroutine 可以访问共享资源。Go 语言中使用&lt;code&gt;sync&lt;/code&gt;包中提供的&lt;code&gt;Mutex&lt;/code&gt;类型来实现互斥锁。&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;sync.Mutex&lt;/code&gt;提供了两个方法供我们使用。&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;方法名&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: center&#34;&gt;功能&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;func (m *Mutex) Lock()&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;获取互斥锁&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;func (m *Mutex) Unlock()&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: center&#34;&gt;释放互斥锁&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;我们在下面的示例代码中使用互斥锁限制每次只有一个 goroutine 才能修改全局变量&lt;code&gt;x&lt;/code&gt;，从而修复上面代码中的问题。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
