<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="值类型和引用类型# C#的类型一共分为两类
值类型 ValueType 引用类型 ReferenceType 值类型和引用类型都继承自 System.Object 类。不同的是几乎所有的引用类型都直接从 System.Object 继承，而值类型则继承 System.ValueType 。System.ValueType直接派生于System.Object。即System.ValueType本身是一个类类型，而不是值类型。关键在于ValueType重写了Equals()方法，从而对值类型按照实例的值来比较，而不是引用地址来比较。
区别# 引用类型变量的赋值只复制对对象的引用而不复制对象本身。而将一个值类型变量赋给另一个值类型变量时，将复制包含的值 引用类型可以派生出新的类型，而值类型不能 引用类型可以包含 null 值，值类型不能（可空类型功能允许将 null 赋给值类型） 引用类型存储在堆中。类实例化时会在堆中开辟一部分空间存储类的实例，类实例的引用（指针）还是存储在栈中。值类型总是分配在它声明的地方(作为字段时跟随其所属的实例存储在堆上。作为局部变量时存储在栈上)。 误区：“引用类型存储在堆上，值类型保存在栈上”，这句话前半部分是正确的，引用类型的实例总是在堆上创建的。但是变量的值是在声明的位置存储的，所以假定一个类中有一个int类型的实例变量，那么这个变量的值是跟对象中的其他数据在一起也就是堆上。只有局部变量（方法内部声明的变量）和方法参数在栈上。
使用场合# 值类型：在内存管理方面具有更好的效率，但不支持多态不能派生新的类型，适合用做存储数据的载体 引用类型：支持多态可以派生新的类型 内存的逻辑划分之栈和堆# C#程序在CLR上运行时，内存从逻辑上划分两大块：栈、堆，这两个基本元素组成了C#程序的运行环境。
栈：在程序运行的时候，每个线程(Thread)都会维护一个自己的专属线程堆栈 堆：是程序在运行的时候请求操作系统分配给自己的内存空间，储存着使用的各种对象等信息，跟栈不同的是它们被调用完毕不会立即被清理掉 栈的特征# 栈空间比较小（每个线程只有一个栈占用 1MB，栈内存溢出抛出 StackOverflowException 但是读取速度快 数据只能从栈的顶端插入或删除，是连续存储的，把数据放到栈顶称为入栈，从栈顶删除数据称为出栈​ 存放方法的参数、局部变量、返回地址等值，当一个方法执行完毕后立刻自动清除 栈的结构# 栈帧：每个方法执行都会分配一块独立的内存空间来存储方法运行需要的数据，按后入先出的方式进入和弹出线程栈。
堆的特征# 堆空间比较大（32位最多分配1.5GB，64位最多分配8TB，堆内存溢出抛出 OutOfMemoryException ，但是读取速度慢 数据存储不连续，与栈不同：堆里的内存能够以任意顺序存入和移除 存放引用类型的对象，通过GC清理 堆的结构# 参考：Drill Into .NET Framework Internals to See How the CLR Creates Runtime Objects ​
代码运行时内存分配情况# 变量和对象在内存中的分配# 示例代码：
class TestClass { public int x; public static string y; } void Test1() { var a=1; var b=new TestClass(); var c=a; var d=b; var e=d.x; var f=TestClass.y; }内存分配情况：
"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://wangpengliang815.github.io/docs/dotnet/%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"><meta property="og:site_name" content="CODE'NOTE"><meta property="og:title" content="CODE'NOTE"><meta property="og:description" content="值类型和引用类型# C#的类型一共分为两类
值类型 ValueType 引用类型 ReferenceType 值类型和引用类型都继承自 System.Object 类。不同的是几乎所有的引用类型都直接从 System.Object 继承，而值类型则继承 System.ValueType 。System.ValueType直接派生于System.Object。即System.ValueType本身是一个类类型，而不是值类型。关键在于ValueType重写了Equals()方法，从而对值类型按照实例的值来比较，而不是引用地址来比较。
区别# 引用类型变量的赋值只复制对对象的引用而不复制对象本身。而将一个值类型变量赋给另一个值类型变量时，将复制包含的值 引用类型可以派生出新的类型，而值类型不能 引用类型可以包含 null 值，值类型不能（可空类型功能允许将 null 赋给值类型） 引用类型存储在堆中。类实例化时会在堆中开辟一部分空间存储类的实例，类实例的引用（指针）还是存储在栈中。值类型总是分配在它声明的地方(作为字段时跟随其所属的实例存储在堆上。作为局部变量时存储在栈上)。 误区：“引用类型存储在堆上，值类型保存在栈上”，这句话前半部分是正确的，引用类型的实例总是在堆上创建的。但是变量的值是在声明的位置存储的，所以假定一个类中有一个int类型的实例变量，那么这个变量的值是跟对象中的其他数据在一起也就是堆上。只有局部变量（方法内部声明的变量）和方法参数在栈上。
使用场合# 值类型：在内存管理方面具有更好的效率，但不支持多态不能派生新的类型，适合用做存储数据的载体 引用类型：支持多态可以派生新的类型 内存的逻辑划分之栈和堆# C#程序在CLR上运行时，内存从逻辑上划分两大块：栈、堆，这两个基本元素组成了C#程序的运行环境。
栈：在程序运行的时候，每个线程(Thread)都会维护一个自己的专属线程堆栈 堆：是程序在运行的时候请求操作系统分配给自己的内存空间，储存着使用的各种对象等信息，跟栈不同的是它们被调用完毕不会立即被清理掉 栈的特征# 栈空间比较小（每个线程只有一个栈占用 1MB，栈内存溢出抛出 StackOverflowException 但是读取速度快 数据只能从栈的顶端插入或删除，是连续存储的，把数据放到栈顶称为入栈，从栈顶删除数据称为出栈​ 存放方法的参数、局部变量、返回地址等值，当一个方法执行完毕后立刻自动清除 栈的结构# 栈帧：每个方法执行都会分配一块独立的内存空间来存储方法运行需要的数据，按后入先出的方式进入和弹出线程栈。
堆的特征# 堆空间比较大（32位最多分配1.5GB，64位最多分配8TB，堆内存溢出抛出 OutOfMemoryException ，但是读取速度慢 数据存储不连续，与栈不同：堆里的内存能够以任意顺序存入和移除 存放引用类型的对象，通过GC清理 堆的结构# 参考：Drill Into .NET Framework Internals to See How the CLR Creates Runtime Objects ​
代码运行时内存分配情况# 变量和对象在内存中的分配# 示例代码：
class TestClass { public int x; public static string y; } void Test1() { var a=1; var b=new TestClass(); var c=a; var d=b; var e=d.x; var f=TestClass.y; }内存分配情况："><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta itemprop=name content="CODE'NOTE"><meta itemprop=description content="值类型和引用类型# C#的类型一共分为两类
值类型 ValueType 引用类型 ReferenceType 值类型和引用类型都继承自 System.Object 类。不同的是几乎所有的引用类型都直接从 System.Object 继承，而值类型则继承 System.ValueType 。System.ValueType直接派生于System.Object。即System.ValueType本身是一个类类型，而不是值类型。关键在于ValueType重写了Equals()方法，从而对值类型按照实例的值来比较，而不是引用地址来比较。
区别# 引用类型变量的赋值只复制对对象的引用而不复制对象本身。而将一个值类型变量赋给另一个值类型变量时，将复制包含的值 引用类型可以派生出新的类型，而值类型不能 引用类型可以包含 null 值，值类型不能（可空类型功能允许将 null 赋给值类型） 引用类型存储在堆中。类实例化时会在堆中开辟一部分空间存储类的实例，类实例的引用（指针）还是存储在栈中。值类型总是分配在它声明的地方(作为字段时跟随其所属的实例存储在堆上。作为局部变量时存储在栈上)。 误区：“引用类型存储在堆上，值类型保存在栈上”，这句话前半部分是正确的，引用类型的实例总是在堆上创建的。但是变量的值是在声明的位置存储的，所以假定一个类中有一个int类型的实例变量，那么这个变量的值是跟对象中的其他数据在一起也就是堆上。只有局部变量（方法内部声明的变量）和方法参数在栈上。
使用场合# 值类型：在内存管理方面具有更好的效率，但不支持多态不能派生新的类型，适合用做存储数据的载体 引用类型：支持多态可以派生新的类型 内存的逻辑划分之栈和堆# C#程序在CLR上运行时，内存从逻辑上划分两大块：栈、堆，这两个基本元素组成了C#程序的运行环境。
栈：在程序运行的时候，每个线程(Thread)都会维护一个自己的专属线程堆栈 堆：是程序在运行的时候请求操作系统分配给自己的内存空间，储存着使用的各种对象等信息，跟栈不同的是它们被调用完毕不会立即被清理掉 栈的特征# 栈空间比较小（每个线程只有一个栈占用 1MB，栈内存溢出抛出 StackOverflowException 但是读取速度快 数据只能从栈的顶端插入或删除，是连续存储的，把数据放到栈顶称为入栈，从栈顶删除数据称为出栈​ 存放方法的参数、局部变量、返回地址等值，当一个方法执行完毕后立刻自动清除 栈的结构# 栈帧：每个方法执行都会分配一块独立的内存空间来存储方法运行需要的数据，按后入先出的方式进入和弹出线程栈。
堆的特征# 堆空间比较大（32位最多分配1.5GB，64位最多分配8TB，堆内存溢出抛出 OutOfMemoryException ，但是读取速度慢 数据存储不连续，与栈不同：堆里的内存能够以任意顺序存入和移除 存放引用类型的对象，通过GC清理 堆的结构# 参考：Drill Into .NET Framework Internals to See How the CLR Creates Runtime Objects ​
代码运行时内存分配情况# 变量和对象在内存中的分配# 示例代码：
class TestClass { public int x; public static string y; } void Test1() { var a=1; var b=new TestClass(); var c=a; var d=b; var e=d.x; var f=TestClass.y; }内存分配情况："><meta itemprop=wordCount content="265"><title>值类型和引用类型的内存分配 | CODE'NOTE</title><link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://wangpengliang815.github.io/docs/dotnet/%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/><link rel=stylesheet href=/book.min.6970156cec683193d93c9c4edaf0d56574e4361df2e0c1be4f697ae81c3ba55f.css integrity="sha256-aXAVbOxoMZPZPJxO2vDVZXTkNh3y4MG+T2l66Bw7pV8=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.16bbea805e586532aeca5e48249564b81bcbb5a9d44401ea4658ef5e6a5e812f.js integrity="sha256-FrvqgF5YZTKuyl5IJJVkuBvLtanURAHqRljvXmpegS8=" crossorigin=anonymous></script></head><body dir=ltr class="book-kind-page book-type-docs"><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>CODE'NOTE</span></a></h2><div class="book-search hidden"><input id=book-search-input type=text placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li><input type=checkbox id=section-f32afe48992fac3b3fc76dc3b27dd1d5 class=toggle checked>
<label for=section-f32afe48992fac3b3fc76dc3b27dd1d5 class=flex><a role=button>📚 .NET</a>
<img src=/icons/chevron-right.svg class=book-icon alt=Expand></label><ul><li><a href=/docs/dotnet/%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/ class=active>值类型和引用类型的内存分配</a></li><li><a href=/docs/dotnet/%E5%8F%8D%E5%B0%84%E6%8A%80%E6%9C%AF/>反射技术</a></li><li><a href=/docs/dotnet/%E5%9F%BA%E7%A1%80%E5%90%88%E9%9B%86/>基础合集</a></li><li><a href=/docs/dotnet/%E5%A4%9A%E7%BA%BF%E7%A8%8B/>多线程</a></li><li><a href=/docs/dotnet/%E5%A7%94%E6%89%98%E5%92%8C%E4%BA%8B%E4%BB%B6/>委托和事件</a></li><li><a href=/docs/dotnet/%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B/>并行编程</a></li><li><a href=/docs/dotnet/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/>异步编程</a></li><li><a href=/docs/dotnet/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/>数据结构</a></li><li><a href=/docs/dotnet/%E6%B3%9B%E5%9E%8B%E6%8A%80%E6%9C%AF/>泛型技术</a></li><li><a href=/docs/dotnet/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/>线程同步</a></li><li><a href=/docs/dotnet/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/>面向对象</a></li></ul></li><li><input type=checkbox id=section-17ee4616d3316ecf2ecdb7c27cfa2a63 class=toggle>
<label for=section-17ee4616d3316ecf2ecdb7c27cfa2a63 class=flex><a role=button>🎭 PMI-ACP</a>
<img src=/icons/chevron-right.svg class=book-icon alt=Expand></label><ul><li><a href=/docs/acp/pmi-acp%E5%9F%BA%E7%A1%80%E4%BA%86%E8%A7%A3/>Pmi Acp基础了解</a></li><li><a href=/docs/acp/pmi-acpdown/>Pmi Acpdown</a></li><li><a href=/docs/acp/pmi-acp%E5%A4%87%E8%80%83%E7%AC%94%E8%AE%B001/>Pmi Acp备考笔记01</a></li><li><a href=/docs/acp/pmi-acp%E5%A4%87%E8%80%83%E7%AC%94%E8%AE%B002/>Pmi Acp备考笔记02</a></li><li><a href=/docs/acp/pmi-acp%E5%A4%87%E8%80%83%E7%AC%94%E8%AE%B003/>Pmi Acp备考笔记03</a></li></ul></li><li><input type=checkbox id=section-fba10961f5d9c66eab238d766cb1a791 class=toggle>
<label for=section-fba10961f5d9c66eab238d766cb1a791 class=flex><a role=button>⌛ 软件测试</a>
<img src=/icons/chevron-right.svg class=book-icon alt=Expand></label><ul><li><a href=/docs/test/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/>单元测试</a></li><li><a href=/docs/test/%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95k6/>压力测试k6</a></li><li><a href=/docs/test/%E8%87%AA%E5%8A%A8%E5%8C%96ui%E6%B5%8B%E8%AF%95/>自动化 Ui测试</a></li><li><a href=/docs/test/%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95/>集成测试</a></li></ul></li><li><input type=checkbox id=section-92cef1621a3b87cdf19787a11c3e85e0 class=toggle>
<label for=section-92cef1621a3b87cdf19787a11c3e85e0 class=flex><a role=button>⛷️ Prometheus</a>
<img src=/icons/chevron-right.svg class=book-icon alt=Expand></label><ul><li><a href=/docs/prometheus/1.1prometheus%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%AE%89%E8%A3%85/>1.1 Prometheus简介及安装</a></li><li><a href=/docs/prometheus/1.2exporter%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86/>1.2 Exporter数据采集</a></li><li><a href=/docs/prometheus/1.3promql%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80/>1.3 Prom Ql查询语言</a></li><li><a href=/docs/prometheus/1.4alertmanager%E5%91%8A%E8%AD%A6%E5%A4%84%E7%90%86/>1.4 Alertmanager告警处理</a></li><li><a href=/docs/prometheus/1.5grafana%E7%9B%91%E6%8E%A7%E5%8F%AF%E8%A7%86%E5%8C%96/>1.5 Grafana监控可视化</a></li></ul></li><li><input type=checkbox id=section-c4b81cc06a2cdd0259ab09c2dde93fb5 class=toggle>
<label for=section-c4b81cc06a2cdd0259ab09c2dde93fb5 class=flex><a role=button>🐇 RabbitMq</a>
<img src=/icons/chevron-right.svg class=book-icon alt=Expand></label><ul><li><a href=/docs/rabbitmq/1.1rabbitmq%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%89%E8%A3%85/>1.1 Rabbit Mq概念及安装</a></li><li><a href=/docs/rabbitmq/1.2%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D/>1.2工作模式介绍</a></li><li><a href=/docs/rabbitmq/1.3%E6%B6%88%E6%81%AF%E7%A1%AE%E8%AE%A4%E5%8F%8A%E6%8C%81%E4%B9%85%E5%8C%96/>1.3消息确认及持久化</a></li><li><a href=/docs/rabbitmq/1.4%E4%B8%A4%E7%A7%8D%E6%B6%88%E8%B4%B9%E6%A8%A1%E5%BC%8F%E5%92%8Cqos%E7%9A%84%E5%AE%9E%E7%8E%B0/>1.4两种消费模式和 Qos的实现</a></li><li><a href=/docs/rabbitmq/1.5channel%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95/>1.5 Channel常见方法</a></li><li><a href=/docs/rabbitmq/1.6rabbitmq%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/>1.6 Rabbit Mq常用命令</a></li><li><a href=/docs/rabbitmq/1.7rabbitmq%E5%B8%B8%E8%A7%81%E7%AD%96%E7%95%A5/>1.7 Rabbit Mq常见策略</a></li><li><a href=/docs/rabbitmq/1.8rabbitmq%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/>1.8 Rabbit Mq常见问题</a></li><li><a href=/docs/rabbitmq/1.9rabbitmq%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88/>1.9 Rabbit Mq集群方案</a></li><li><a href=/docs/rabbitmq/%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9E%E6%8E%A5rabbitmq/>客户端连接 Rabbit Mq</a></li></ul></li><li><input type=checkbox id=section-45de5b9a6214c965d493f727c3af2aae class=toggle>
<label for=section-45de5b9a6214c965d493f727c3af2aae class=flex><a role=button>🐹 Golang</a>
<img src=/icons/chevron-right.svg class=book-icon alt=Expand></label><ul><li><a href=/docs/go/01%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/>01开发环境搭建</a></li><li><a href=/docs/go/02%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/>02变量和常量</a></li><li><a href=/docs/go/03%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/>03基本数据类型</a></li><li><a href=/docs/go/04%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/>04流程控制和运算符</a></li><li><a href=/docs/go/05%E6%95%B0%E7%BB%84/>05数组</a></li><li><a href=/docs/go/06%E5%88%87%E7%89%87/>06切片</a></li><li><a href=/docs/go/07map/>07map</a></li><li><a href=/docs/go/08%E5%87%BD%E6%95%B0/>08函数</a></li><li><a href=/docs/go/09%E6%8C%87%E9%92%88/>09指针</a></li><li><a href=/docs/go/10%E5%8F%8D%E5%B0%84/>10反射</a></li><li><a href=/docs/go/11%E7%BB%93%E6%9E%84%E4%BD%93/>11结构体</a></li><li><a href=/docs/go/12%E6%8E%A5%E5%8F%A3/>12接口</a></li><li><a href=/docs/go/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/channel/>Channel</a></li><li><a href=/docs/go/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/csp%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B/>Csp并发模型</a></li><li><a href=/docs/go/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/goroutine/>Goroutine</a></li><li><a href=/docs/go/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/gpm%E5%8E%9F%E7%90%86%E4%B8%8E%E8%B0%83%E5%BA%A6/>Gpm原理与调度</a></li><li><a href=/docs/go/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/>原子操作</a></li><li><a href=/docs/go/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E5%92%8C%E9%94%81/>并发安全和锁</a></li><li><a href=/docs/go/%E6%A0%87%E5%87%86%E5%BA%93/flag/>Flag</a></li><li><a href=/docs/go/%E6%A0%87%E5%87%86%E5%BA%93/fmt/>Fmt</a></li><li><a href=/docs/go/%E6%A0%87%E5%87%86%E5%BA%93/log/>Log</a></li><li><a href=/docs/go/%E6%A0%87%E5%87%86%E5%BA%93/time/>Time</a></li></ul></li><li><input type=checkbox id=section-61dde4567035e1fd2b5d2aa51b82a7a0 class=toggle>
<label for=section-61dde4567035e1fd2b5d2aa51b82a7a0 class=flex><a role=button>💫 Microservice</a>
<img src=/icons/chevron-right.svg class=book-icon alt=Expand></label><ul><li><a href=/docs/microservice/1.1%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8%E4%B9%8B%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/>1.1微服务入门之项目搭建</a></li><li><a href=/docs/microservice/1.2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8%E4%B9%8B%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0/>1.2微服务入门之服务注册与发现</a></li><li><a href=/docs/microservice/1.3%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8%E4%B9%8B%E7%BD%91%E5%85%B3/>1.3微服务入门之网关</a></li><li><a href=/docs/microservice/1.4%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8%E4%B9%8B%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF/>1.4微服务入门之事件总线</a></li><li><a href=/docs/microservice/1.5%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8%E4%B9%8Bdockercompose/>1.5微服务入门之 Docker Compose</a></li><li><a href=/docs/microservice/consul%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0/>Consul服务注册发现</a></li></ul></li><li><input type=checkbox id=section-e6c26370c56585ceaa14c64b7d769452 class=toggle>
<label for=section-e6c26370c56585ceaa14c64b7d769452 class=flex><a role=button>📦 Redis</a>
<img src=/icons/chevron-right.svg class=book-icon alt=Expand></label><ul><li><a href=/docs/redis/1.10redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/>1.10 Redis常见问题</a></li><li><a href=/docs/redis/1.1nosql%E6%A6%82%E8%BF%B0/>1.1 No Sql概述</a></li><li><a href=/docs/redis/1.2redis%E5%AE%89%E8%A3%85/>1.2 Redis安装</a></li><li><a href=/docs/redis/1.3redis%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/>1.3 Redis基本数据类型</a></li><li><a href=/docs/redis/1.4redis%E7%89%B9%E6%AE%8A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/>1.4 Redis特殊数据类型</a></li><li><a href=/docs/redis/1.5redis%E4%BA%8B%E5%8A%A1%E6%93%8D%E4%BD%9C/>1.5 Redis事务操作</a></li><li><a href=/docs/redis/1.6redis%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/>1.6 Redis配置文件详解</a></li><li><a href=/docs/redis/1.7redis%E6%8C%81%E4%B9%85%E5%8C%96/>1.7 Redis持久化</a></li><li><a href=/docs/redis/1.8redis%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/>1.8 Redis发布订阅</a></li><li><a href=/docs/redis/1.9redis%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88/>1.9 Redis集群方案</a></li><li><a href=/docs/redis/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BAredis%E9%9B%86%E7%BE%A4/>使用 Docker搭建 Redis集群</a></li><li><a href=/docs/redis/%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9E%E6%8E%A5redis/>客户端连接 Redis</a></li></ul></li><li><input type=checkbox id=section-f781adde1ca4021db6751ec1e71e0572 class=toggle>
<label for=section-f781adde1ca4021db6751ec1e71e0572 class=flex><a role=button>🔎 ELK</a>
<img src=/icons/chevron-right.svg class=book-icon alt=Expand></label><ul><li><a href=/docs/elk/1.1elastaticsearch%E5%85%A5%E9%97%A8/>1.1 Elastatic Search入门</a></li><li><a href=/docs/elk/1.2elastaticsearch%E9%85%8D%E7%BD%AE/>1.2 Elastatic Search配置</a></li><li><a href=/docs/elk/1.3%E4%BD%BF%E7%94%A8kibana%E6%93%8D%E4%BD%9Ces/>1.3使用 Kibana操作 Es</a></li></ul></li><li><input type=checkbox id=section-17df8bdb44c678e43d193647c6ae88f1 class=toggle>
<label for=section-17df8bdb44c678e43d193647c6ae88f1 class=flex><a role=button>🚢 Docker</a>
<img src=/icons/chevron-right.svg class=book-icon alt=Expand></label><ul><li><a href=/docs/docker/1.1docker%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%89%E8%A3%85/>1.1 Docker概念及安装</a></li><li><a href=/docs/docker/1.2docker%E9%95%9C%E5%83%8F/>1.2 Docker镜像</a></li><li><a href=/docs/docker/1.3docker%E5%AE%B9%E5%99%A8/>1.3 Docker容器</a></li><li><a href=/docs/docker/1.4docker%E4%BB%93%E5%BA%93/>1.4 Docker仓库</a></li><li><a href=/docs/docker/1.5docker%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86/>1.5 Docker数据管理</a></li><li><a href=/docs/docker/1.6docker%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F/>1.6 Docker容器网络模式</a></li><li><a href=/docs/docker/1.7docker%E9%AB%98%E7%BA%A7%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/>1.7 Docker高级网络配置</a></li><li><a href=/docs/docker/1.8dockerfile/>1.8 Dockerfile</a></li><li><a href=/docs/docker/1.9dockercompose/>1.9 Docker Compose</a></li><li><a href=/docs/docker/2.0dockermachine/>2.0 Docker Machine</a></li><li><a href=/docs/docker/2.1dockerswarm/>2.1 Docker Swarm</a></li><li><a href=/docs/docker/2.2docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/>2.2 Docker常用命令</a></li><li><a href=/docs/docker/2.3portainer%E5%8F%AF%E8%A7%86%E5%8C%96%E9%9D%A2%E6%9D%BF/>2.3 Portainer可视化面板</a></li></ul></li><li><input type=checkbox id=section-566aa18ccd5b6b6934a70aded3a8361a class=toggle>
<label for=section-566aa18ccd5b6b6934a70aded3a8361a class=flex><a role=button>🕸️ K8s</a>
<img src=/icons/chevron-right.svg class=book-icon alt=Expand></label><ul><li><a href=/docs/kubernetes/kubernetes%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/>Kubernetes基础知识</a></li><li><a href=/docs/kubernetes/kubernetes%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85/>Kubernetes集群安装</a></li></ul></li><li><input type=checkbox id=section-04176b4c8c5f502db36c25b60db03d67 class=toggle>
<label for=section-04176b4c8c5f502db36c25b60db03d67 class=flex><a role=button>🖥️ Linux</a>
<img src=/icons/chevron-right.svg class=book-icon alt=Expand></label><ul><li><a href=/docs/linux/centos7%E5%8D%87%E7%BA%A7gcc%E7%89%88%E6%9C%AC/>Centos7升级gcc版本</a></li><li><a href=/docs/linux/centos%E5%AE%89%E8%A3%85hexo/>Centos安装 Hexo</a></li><li><a href=/docs/linux/centos%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/>Centos网络配置</a></li><li><a href=/docs/linux/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/>Linux常用命令</a></li><li><a href=/docs/linux/linux%E7%9B%AE%E5%BD%95%E8%AF%B4%E6%98%8E/>Linux目录说明</a></li><li><a href=/docs/linux/vmware%E5%AE%89%E8%A3%85centos/>Vmware安装 Centos</a></li></ul></li><li><input type=checkbox id=section-9397a01455952fcbd887e2206a8a3054 class=toggle>
<label for=section-9397a01455952fcbd887e2206a8a3054 class=flex><a role=button>🛍️ Devops</a>
<img src=/icons/chevron-right.svg class=book-icon alt=Expand></label><ul><li><a href=/docs/devops/gitlab%E5%AE%89%E8%A3%85/>Gitlab安装</a></li><li><a href=/docs/devops/jenkins%E5%AE%89%E8%A3%85/>Jenkins安装</a></li><li><a href=/docs/devops/jenkins%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/>Jenkins常见操作</a></li><li><a href=/docs/devops/nugetserver%E6%90%AD%E5%BB%BA/>Nuget Server搭建</a></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class="book-header hidden"><div class="flex align-center justify-between"><label for=menu-control><img src=/icons/menu.svg class=book-icon alt=Menu></label><h3>值类型和引用类型的内存分配</h3><label for=toc-control><img src=/icons/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class=hidden><nav id=TableOfContents><ul><li><a href=#栈的特征>栈的特征</a></li><li><a href=#栈的结构>栈的结构</a></li><li><a href=#堆的特征>堆的特征</a></li><li><a href=#堆的结构>堆的结构</a></li></ul><ul><li><a href=#变量和对象在内存中的分配>变量和对象在内存中的分配</a></li><li><a href=#方法参数在栈中的分配>方法参数在栈中的分配</a></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=值类型和引用类型>值类型和引用类型<a class=anchor href=#%e5%80%bc%e7%b1%bb%e5%9e%8b%e5%92%8c%e5%bc%95%e7%94%a8%e7%b1%bb%e5%9e%8b>#</a></h1><p>C#的类型一共分为两类</p><ul><li>值类型 <code>ValueType</code></li><li>引用类型 <code>ReferenceType</code></li></ul><p>值类型和引用类型都继承自 <code>System.Object</code> 类。不同的是几乎所有的引用类型都直接从 <code>System.Object</code> 继承，而值类型则继承 <code>System.ValueType </code>。<code>System.ValueType</code>直接派生于<code>System.Object</code>。即<code>System.ValueType</code>本身是一个类类型，而不是值类型。关键在于<code>ValueType</code>重写了<code>Equals()</code>方法，从而对值类型按照实例的值来比较，而不是引用地址来比较。</p><h1 id=区别>区别<a class=anchor href=#%e5%8c%ba%e5%88%ab>#</a></h1><ul><li>引用类型变量的赋值只复制对对象的引用而不复制对象本身。而将一个值类型变量赋给另一个值类型变量时，将复制包含的值</li><li>引用类型可以派生出新的类型，而值类型不能</li><li>引用类型可以包含 <code>null</code> 值，值类型不能（<strong>可空类型功能允许将 null 赋给值类型</strong>）</li><li>引用类型存储在堆中。类实例化时会在堆中开辟一部分空间存储类的实例，类实例的引用（指针）还是存储在栈中。值类型总是分配在它声明的地方(作为字段时跟随其所属的实例存储在堆上。作为局部变量时存储在栈上)。</li></ul><blockquote class=book-hint><p>误区：&ldquo;引用类型存储在堆上，值类型保存在栈上&rdquo;，这句话前半部分是正确的，引用类型的实例总是在堆上创建的。但是变量的值是在声明的位置存储的，所以假定一个类中有一个<code>int</code>类型的实例变量，那么这个变量的值是跟对象中的其他数据在一起也就是堆上。只有局部变量（方法内部声明的变量）和方法参数在栈上。</p></blockquote><h1 id=使用场合>使用场合<a class=anchor href=#%e4%bd%bf%e7%94%a8%e5%9c%ba%e5%90%88>#</a></h1><ul><li>值类型：在内存管理方面具有更好的效率，但不支持多态不能派生新的类型，适合用做存储数据的载体</li><li>引用类型：支持多态可以派生新的类型</li></ul><h1 id=内存的逻辑划分之栈和堆>内存的逻辑划分之栈和堆<a class=anchor href=#%e5%86%85%e5%ad%98%e7%9a%84%e9%80%bb%e8%be%91%e5%88%92%e5%88%86%e4%b9%8b%e6%a0%88%e5%92%8c%e5%a0%86>#</a></h1><p>C#程序在CLR上运行时，内存从逻辑上划分两大块：栈、堆，这两个基本元素组成了C#程序的运行环境。</p><ul><li>栈：在程序运行的时候，每个线程(<code>Thread</code>)都会维护一个自己的专属线程堆栈</li><li>堆：是程序在运行的时候请求操作系统分配给自己的内存空间，储存着使用的各种对象等信息，跟栈不同的是它们被调用完毕不会立即被清理掉</li></ul><h2 id=栈的特征>栈的特征<a class=anchor href=#%e6%a0%88%e7%9a%84%e7%89%b9%e5%be%81>#</a></h2><ul><li>栈空间比较小（每个线程只有一个栈占用 <code>1MB</code>，栈内存溢出抛出 <code>StackOverflowException</code> 但是读取速度快</li><li>数据只能从栈的顶端插入或删除，是连续存储的，<strong>把数据放到栈顶称为入栈</strong>，<strong>从栈顶删除数据称为出栈</strong>​</li><li>存放方法的参数、局部变量、返回地址等值，当一个方法执行完毕后立刻自动清除</li></ul><h2 id=栈的结构>栈的结构<a class=anchor href=#%e6%a0%88%e7%9a%84%e7%bb%93%e6%9e%84>#</a></h2><p><img src=/images/2021-09-02-22-41-17.png alt></p><blockquote class=book-hint><p>栈帧：每个方法执行都会分配一块独立的内存空间来存储方法运行需要的数据，按<strong>后入先出</strong>的方式进入和弹出线程栈。</p></blockquote><h2 id=堆的特征>堆的特征<a class=anchor href=#%e5%a0%86%e7%9a%84%e7%89%b9%e5%be%81>#</a></h2><ul><li>堆空间比较大（32位最多分配1.5GB，64位最多分配8TB，堆内存溢出抛出 <code>OutOfMemoryException</code> ，但是读取速度慢</li><li>数据存储不连续，与栈不同：堆里的内存能够以任意顺序存入和移除</li><li>存放引用类型的对象，通过<code>GC</code>清理</li></ul><h2 id=堆的结构>堆的结构<a class=anchor href=#%e5%a0%86%e7%9a%84%e7%bb%93%e6%9e%84>#</a></h2><p>参考：<a href=https://docs.microsoft.com/en-us/archive/msdn-magazine/2005/may/net-framework-internals-how-the-clr-creates-runtime-objects>Drill Into .NET Framework Internals to See How the CLR Creates Runtime Objects</a>
​</p><h1 id=代码运行时内存分配情况>代码运行时内存分配情况<a class=anchor href=#%e4%bb%a3%e7%a0%81%e8%bf%90%e8%a1%8c%e6%97%b6%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e6%83%85%e5%86%b5>#</a></h1><h2 id=变量和对象在内存中的分配>变量和对象在内存中的分配<a class=anchor href=#%e5%8f%98%e9%87%8f%e5%92%8c%e5%af%b9%e8%b1%a1%e5%9c%a8%e5%86%85%e5%ad%98%e4%b8%ad%e7%9a%84%e5%88%86%e9%85%8d>#</a></h2><p><strong>示例代码</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TestClass</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> x;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>string</span> y;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> Test1()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>var</span> a=<span style=color:#ae81ff>1</span>; 
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>var</span> b=<span style=color:#66d9ef>new</span> TestClass();
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>var</span> c=a;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>var</span> d=b;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>var</span> e=d.x;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>var</span> f=TestClass.y;
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p><strong>内存分配情况</strong>：</p><p><img src=/images/2021-09-02-22-42-10.png alt></p><ol><li><code>Test1()</code>方法被调用：系统为该方法创建一个栈桢，用于存储该方法使用到的值类型的变量、指针、调用其他方法的返回地址等</li><li>方法执行到 <code>var a=1</code>：变量<code>a</code>的值<code>1</code>首先入栈存储，栈的起始地址为<code>0x000000671b77e5a4</code></li><li>方法执行到 <code>var b=new TestClass()</code>：在堆中开辟一块内存用于存储<code>TestClass</code>实例对象，然后变量<code>b</code>入栈，变量<code>b</code>的值为<code>TestClass</code>实例对象的引用（实际存储的是<code>TestClass</code>实例在堆上的内存地址，也就是指针）</li><li>方法执行到 <code>var c=a</code>：将变量<code>c</code>压入栈，因为<code>a</code>是值类型，所以将变量<code>a</code>的值拷贝赋值给<code>c</code></li><li>方法执行到 <code>var d=b</code>：将变量<code>d</code>压入栈，因为<code>b</code>是引用类型，所以将变量<code>b</code>引用的地址赋值给变量<code>d</code>，此时变量<code>b</code>和<code>d</code>都指向堆内存中的<code>TestClass</code>实例对象</li><li>方法执行到 <code>var e=d.x</code>时：将变量<code>e</code>压入栈，因为<code>x</code>字段是值类型，所以将<code>x</code>的实际值0（int类型初始化的默认值为0）赋值给<code>e</code></li><li>方法执行到 <code>var f=TestClass.y</code>：将变量<code>f</code>压入栈，因为<code>y</code>字段是引用类型，所以<code>f</code>变量的值为<code>y</code> 字段的引用</li></ol><h2 id=方法参数在栈中的分配>方法参数在栈中的分配<a class=anchor href=#%e6%96%b9%e6%b3%95%e5%8f%82%e6%95%b0%e5%9c%a8%e6%a0%88%e4%b8%ad%e7%9a%84%e5%88%86%e9%85%8d>#</a></h2><p><strong>示例代码：</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TestClass</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> x;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> sum(<span style=color:#66d9ef>int</span> i,<span style=color:#66d9ef>int</span> j){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> i+j;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> Test1()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>var</span> a=<span style=color:#66d9ef>new</span> TestClass();
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> b = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  b=a.sum(<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p><strong>内存分配情况：</strong></p><p><img src=/images/2021-09-02-22-42-35.png alt>
​</p><ol><li>方法执行到 <code>var a=new TestClass()</code> : 在堆中开辟一块内存用于存储<code>TestClass</code>实例对象，然后变量<code>a</code>入栈，变量<code>a</code>的值为<code>TestClass</code>实例对象的引用（实际上存储的是<code>TestClass</code>实例在堆上的内存地址，也就是指针）</li><li>方法执行到 <code>int b = 0</code>：将局部变量<code>b</code>压入栈，因为<code>b</code>是值类型所以值<code>0</code>存储在栈中</li><li>方法执行到 <code>b=a.sum(1,2)</code>：首先两个<code>int</code>类型实参<code>1，2</code>分别入栈，并将<code>sum</code>方法的返回地址压入栈，<code>sum</code>方法执行结束之后应返回至该位置</li></ol><h1 id=systemstring>System.String<a class=anchor href=#systemstring>#</a></h1><ul><li>特性一：字符串是不可变的，字符串一经创建便不能更改，不能变长、变短或修改其中的任何字符。</li><li>特性二：字符串驻留（字符串池化），<code>CLR</code>可通过一个<code>String</code>对象共享多个完全一致的<code>String</code>内容，这样能减少系统中字符串的数量，从而节省内存。<code>String</code>的驻留机制实际上是在<code>SystemDomain</code>中进行的。 当<code>CLR</code>被加载之后，会在<code>SystemDomain</code>对应的<code>managed heap</code>中创建一个<code>Hashtable</code>，<code>Hashtable</code>中记录了所有在代码中使用字面量声明的字符串实例的引用，<code>Hashtable</code>的<code>Key</code>为字符串本身，<code>Value</code>为字符串对象的地址。</li></ul><p><strong>示例代码：</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Main(<span style=color:#66d9ef>string</span>[] args)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>   <span style=color:#75715e>//申请一块堆内存，把地址放在Hashtable的key为hello的元素中</span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>string</span> str1 = <span style=color:#e6db74>&#34;hello&#34;</span>; 
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>   <span style=color:#75715e>//由于上一句已经创建了key为hello的元素，所以不需要申请新的堆内存</span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>string</span> str2 = <span style=color:#e6db74>&#34;hello&#34;</span>;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>   <span style=color:#75715e>//编译成MSIL语言时 已经与string str3 = &#34;hello&#34;一样了</span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>string</span> str3 = <span style=color:#e6db74>&#34;&#34;</span> + <span style=color:#e6db74>&#34;e&#34;</span> + <span style=color:#e6db74>&#34;l&#34;</span> + <span style=color:#e6db74>&#34;l&#34;</span> + <span style=color:#e6db74>&#34;o&#34;</span>; 
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>   <span style=color:#75715e>//显式new</span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>string</span> str4 = <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>string</span>(<span style=color:#66d9ef>new</span> <span style=color:#66d9ef>char</span>[] { <span style=color:#e6db74>&#39;h&#39;</span>, <span style=color:#e6db74>&#39;e&#39;</span>, <span style=color:#e6db74>&#39;l&#39;</span>, <span style=color:#e6db74>&#39;l&#39;</span>, <span style=color:#e6db74>&#39;o&#39;</span> }); 
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>   <span style=color:#75715e>//申请一块堆内存，把地址放在Hashtable的key为hello2的元素中</span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>string</span> str5 = <span style=color:#e6db74>&#34;hello2&#34;</span>;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>   <span style=color:#75715e>//True 引用同一块堆内存 </span>
</span></span><span style=display:flex><span>   Console.WriteLine(<span style=color:#66d9ef>object</span>.ReferenceEquals(str1, str2).ToString());
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>   <span style=color:#75715e>//True 也是引用同一块堆内存</span>
</span></span><span style=display:flex><span>   Console.WriteLine(<span style=color:#66d9ef>object</span>.ReferenceEquals(str1, str3).ToString()); 
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>   <span style=color:#75715e>//False 引用了不同的堆内存 </span>
</span></span><span style=display:flex><span>   Console.WriteLine(<span style=color:#66d9ef>object</span>.ReferenceEquals(str1, str4).ToString());
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>   <span style=color:#75715e>// 先从Hashtable中检索是否有重复的key ，检索到了hello2，所以不需要申请新的堆内存</span>
</span></span><span style=display:flex><span>   str2 = <span style=color:#e6db74>&#34;hello2&#34;</span>; 
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>   <span style=color:#75715e>//False str2与str1已经不引用同一个堆</span>
</span></span><span style=display:flex><span>   Console.WriteLine(<span style=color:#66d9ef>object</span>.ReferenceEquals(str1, str2).ToString());
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>   <span style=color:#75715e>//True 变成与str5引用同一个堆内存</span>
</span></span><span style=display:flex><span>   Console.WriteLine(<span style=color:#66d9ef>object</span>.ReferenceEquals(str2, str5).ToString()); 
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>   <span style=color:#75715e>// 控制台输入两个相同的字符串</span>
</span></span><span style=display:flex><span>   str1 = Console.ReadLine();
</span></span><span style=display:flex><span>   str2 = Console.ReadLine();
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>   <span style=color:#75715e>//False 因为 str1 和 str2 两个变量并非字面量声明的字符串，所以不会触发字符串驻留机制</span>
</span></span><span style=display:flex><span>   Console.WriteLine(<span style=color:#66d9ef>object</span>.ReferenceEquals(str1, str2).ToString());
</span></span><span style=display:flex><span>   Console.ReadLine();
</span></span><span style=display:flex><span>}</span></span></code></pre></div><h1 id=静态字段和属性>静态字段和属性<a class=anchor href=#%e9%9d%99%e6%80%81%e5%ad%97%e6%ae%b5%e5%92%8c%e5%b1%9e%e6%80%a7>#</a></h1><p>类型的静态字段和静态属性的支持字段（例如 int）存储在类型对象（加载堆）中。</p><p><code>JIT</code> 会在进行编译时找到这些静态成员的地址，并在之后的编译时硬编码它们，然后写在机器码中。</p><p>这样，再次访问静态成员时就不需要通过类型对象。程序中所有类型的静态成员组成一个全局的数组，它包括每一个类型中的基元类型静态成员的内存地址。</p><p>数组的地址会被钉死 (pinned)，使得它不会被 <code>GC</code> 回收掉（除非卸载应用程序域），这样机器码中的硬编码将一直有意义，直到程序终止。</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div></div><div></div></div><div class="flex flex-wrap justify-between"><span></span><span><a href=/docs/dotnet/%E5%8F%8D%E5%B0%84%E6%8A%80%E6%9C%AF/ class="flex align-center"><span>反射技术</span>
<img src=/icons/forward.svg class=book-icon alt=Forward></a></span></div><script>(function(){document.querySelectorAll("pre:has(code)").forEach(e=>{e.addEventListener("click",e.focus),e.addEventListener("copy",function(t){if(t.preventDefault(),navigator.clipboard){const t=window.getSelection().toString()||e.textContent;navigator.clipboard.writeText(t)}})})})()</script></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#栈的特征>栈的特征</a></li><li><a href=#栈的结构>栈的结构</a></li><li><a href=#堆的特征>堆的特征</a></li><li><a href=#堆的结构>堆的结构</a></li></ul><ul><li><a href=#变量和对象在内存中的分配>变量和对象在内存中的分配</a></li><li><a href=#方法参数在栈中的分配>方法参数在栈中的分配</a></li></ul></nav></div></aside></main></body></html>