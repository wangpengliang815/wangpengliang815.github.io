<!DOCTYPE html>
<html lang="">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">

    
      <link rel="icon" href="/favicon.png" />
    

    <title>
        
          CODE&#39;NOTE
        
    </title>

    <!-- Spectre.css framework -->
    <link href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/spectre.css/0.5.9/spectre.min.css" rel="stylesheet">
    <link href="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/spectre.css/0.5.9/spectre-exp.min.css" rel="stylesheet">
    <link href="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/spectre.css/0.5.9/spectre-icons.min.css" rel="stylesheet">

    <!-- theme css & js -->
    
<link rel="stylesheet" href="/css/book.css">

    
<script src="/js/book.js"></script>


    <!-- tocbot -->
    <script src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/tocbot/4.18.2/tocbot.min.js"></script>
    <link href="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/tocbot/4.18.2/tocbot.css" rel="stylesheet">
    
    <!-- katex -->    
    <link href="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/KaTeX/0.15.2/katex.min.css" rel="stylesheet">

    
    
<script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/zooming/2.1.1/zooming.js"></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    const zooming = new Zooming()
    zooming.listen('.book-content img')
})
</script>

<meta name="generator" content="Hexo 5.4.1"></head>

<body>

<div class="book-container">
  <div class="book-sidebar">
    <div class="book-brand">
  <a href="/">
    <img src="/favicon.png">
    <span>CODE&#39;NOTE</span>
  </a>
</div>
    <div id="menu" class="book-menu hide">
  <h2 id="☘️-Home-v3">☘️ <a href="/">Home</a></h2>
<h2 id="🐹-Golang-v3">🐹 Golang</h2>
<ul>
<li><a href="/go/01%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA">开发环境搭建</a></li>
<li><a href="/go/02%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F">变量和常量</a></li>
<li><a href="/go/03%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">基本数据类型</a></li>
<li><a href="/go/04%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6">流程控制和运算符</a></li>
<li><a href="/go/05%E6%95%B0%E7%BB%84">数组</a></li>
<li><a href="/go/06%E5%88%87%E7%89%87">切片</a></li>
<li><a href="/go/07map">map</a></li>
<li><a href="/go/08%E5%87%BD%E6%95%B0">函数</a></li>
<li><a href="/go/09%E6%8C%87%E9%92%88">指针</a></li>
<li><a href="/go/10%E5%8F%8D%E5%B0%84">反射</a></li>
<li><a href="/go/11%E7%BB%93%E6%9E%84%E4%BD%93">结构体</a></li>
<li><a href="/go/12%E6%8E%A5%E5%8F%A3">接口</a></li>
<li><a href="/go/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/goroutine">goroutine</a></li>
<li><a href="/go/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/channel">channel</a></li>
<li><a href="/go/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E5%92%8C%E9%94%81">并发安全和锁</a></li>
<li><a href="/go/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C">原子操作</a></li>
<li><a href="/go/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/GPM%E5%8E%9F%E7%90%86%E4%B8%8E%E8%B0%83%E5%BA%A6">GPM与调度分析</a></li>
<li><a href="/go/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/CSP%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B">CSP并发模型</a></li>
<li><a href="/go/%E6%A0%87%E5%87%86%E5%BA%93/fmt">标准库fmt</a></li>
<li><a href="/go/%E6%A0%87%E5%87%86%E5%BA%93/flag">标准库flag</a></li>
<li><a href="/go/%E6%A0%87%E5%87%86%E5%BA%93/time">标准库time</a></li>
<li><a href="/go/%E6%A0%87%E5%87%86%E5%BA%93/go_%E6%A0%87%E5%87%86%E5%BA%93log">标准库log</a></li>
</ul>
<h2 id="🛍️-DevOps-v3">🛍️ DevOps</h2>
<ul>
<li><a href="/devops/gitlab%E5%AE%89%E8%A3%85">GitLab 安装 </a></li>
<li><a href="/devops/jenkins%E5%AE%89%E8%A3%85">Jenkins 安装 </a></li>
<li><a href="/devops/jenkins%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C">Jenkins 常见操作 </a></li>
</ul>
<h2 id="⛷️-Prometheus-v3">⛷️ Prometheus</h2>
<ul>
<li><a href="/prometheus/1.1Prometheus%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%AE%89%E8%A3%85">Prometheus 简介及安装 </a></li>
<li><a href="/prometheus/1.2Exporter%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86">Exporter 数据采集</a></li>
<li><a href="/prometheus/1.3PromQL%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80">PromQL 查询语言</a></li>
<li><a href="/prometheus/1.4Alertmanager%E5%91%8A%E8%AD%A6%E5%A4%84%E7%90%86">Alertmanager 告警</a></li>
<li><a href="/prometheus/1.5Grafana%E7%9B%91%E6%8E%A7%E5%8F%AF%E8%A7%86%E5%8C%96">Grafana 监控可视化</a></li>
</ul>
<h2 id="🚢-Docker-v3">🚢 Docker</h2>
<ul>
<li><a href="/docker/1.1Docker%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%89%E8%A3%85">Docker 概念及安装</a></li>
<li><a href="/docker/1.2Docker%E9%95%9C%E5%83%8F">使用镜像</a></li>
<li><a href="/docker/1.3Docker%E5%AE%B9%E5%99%A8">操作容器</a></li>
<li><a href="/docker/1.4Docker%E4%BB%93%E5%BA%93">访问仓库</a></li>
<li><a href="/docker/1.5Docker%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86">数据管理</a></li>
<li><a href="/docker/1.6Docker%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F">网络模式</a></li>
<li><a href="/docker/1.7Docker%E9%AB%98%E7%BA%A7%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE">高级网络配置</a></li>
<li><a href="/docker/1.8Dockerfile">Dockerfile</a></li>
<li><a href="/docker/1.9DockerCompose">DockerCompose</a></li>
<li><a href="/docker/2.0DockerMachine">DockerMachine</a></li>
<li><a href="/docker/2.1DockerSwarm">DockerSwarm</a></li>
<li><a href="/docker/2.2Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4">常用命令</a></li>
<li><a href="/docker/2.3Portainer%E5%8F%AF%E8%A7%86%E5%8C%96%E9%9D%A2%E6%9D%BF">Portainer 可视化面板</a></li>
</ul>
<h2 id="🕸️-Kubernetes-v3">🕸️ Kubernetes</h2>
<ul>
<li><a href="/test/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95">单元测试</a></li>
</ul>
<h2 id="🔎-ELK-Stack-v3">🔎 ELK Stack</h2>
<ul>
<li><a href="/elk/1.1ElastaticSearch%E5%85%A5%E9%97%A8">ElastaticSearch入门</a></li>
<li><a href="/elk/1.2ElastaticSearch%E9%85%8D%E7%BD%AE">ElastaticSearch配置</a></li>
<li><a href="/elk/1.3%E4%BD%BF%E7%94%A8Kibana%E6%93%8D%E4%BD%9CES">使用Kibana操作ES</a></li>
</ul>
<h2 id="🐇-RabbitMQ-v3">🐇 RabbitMQ</h2>
<ul>
<li><a href="/rabbitMq/1.1RabbitMQ%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%89%E8%A3%85">1.1 RabbitMQ概念及安装</a></li>
<li><a href="/rabbitMq/1.2%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D">1.2 工作模式介绍</a></li>
<li><a href="/rabbitMq/1.3%E6%B6%88%E6%81%AF%E7%A1%AE%E8%AE%A4%E5%8F%8A%E6%8C%81%E4%B9%85%E5%8C%96">1.3 消息确认及持久化</a></li>
<li><a href="/rabbitMq/1.4%E4%B8%A4%E7%A7%8D%E6%B6%88%E8%B4%B9%E6%A8%A1%E5%BC%8F%E5%92%8CQOS%E7%9A%84%E5%AE%9E%E7%8E%B0">1.4 两种消费模式和QOS</a></li>
<li><a href="/rabbitMq/1.5Channel%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95">1.5 Channel常见方法</a></li>
<li><a href="/rabbitMq/1.6RabbitMQ%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4">1.6 RabbitMQ常用命令</a></li>
<li><a href="/rabbitMq/1.7RabbitMQ%E5%B8%B8%E8%A7%81%E7%AD%96%E7%95%A5">1.7 RabbitMQ常见策略</a></li>
<li><a href="/rabbitMq/1.8RabbitMQ%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98">1.8 RabbitMQ常见问题</a></li>
<li><a href="/rabbitMq/1.9RabbitMQ%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88">1.9 RabbitMQ集群方案</a></li>
<li><a href="/rabbitMq/%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9E%E6%8E%A5RabbitMQ">客户端连接RabbitMQ</a></li>
</ul>
<h2 id="📦-Redis-v3">📦 Redis</h2>
<ul>
<li><a href="/redis/1.1NoSql%E6%A6%82%E8%BF%B0">1.1 NoSql概述</a></li>
<li><a href="/redis/1.2Redis%E5%AE%89%E8%A3%85">1.2 Redis安装</a></li>
<li><a href="/redis/1.3Redis%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">1.3 Redis基本数据类型</a></li>
<li><a href="/redis/1.4Redis%E7%89%B9%E6%AE%8A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">1.4 Redis特殊数据类型</a></li>
<li><a href="/redis/1.5Redis%E4%BA%8B%E5%8A%A1%E6%93%8D%E4%BD%9C">1.5 Redis事务操作</a></li>
<li><a href="/redis/1.6Redis%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3">1.6 Redis配置文件详解</a></li>
<li><a href="/redis/1.7Redis%E6%8C%81%E4%B9%85%E5%8C%96">1.7 Redis持久化</a></li>
<li><a href="/redis/1.8Redis%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85">1.8 Redis发布订阅</a></li>
<li><a href="/redis/1.9Redis%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88">1.9 Redis集群方案</a></li>
<li><a href="/redis/1.10Redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98">1.10 Redis常见问题</a></li>
<li><a href="/redis/%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9E%E6%8E%A5Redis">客户端连接Redis</a></li>
<li><a href="/redis/%E4%BD%BF%E7%94%A8Docker%E6%90%AD%E5%BB%BARedis%E9%9B%86%E7%BE%A4">使用Docker搭建Redis集群</a></li>
</ul>
<h2 id="💫-MicroService-v3">💫 MicroService</h2>
<ul>
<li><a href="/microservice/1.1%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8%E4%B9%8B%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA">1.1 微服务之项目搭建</a></li>
<li><a href="/microservice/1.2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8%E4%B9%8B%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0">1.2 微服务之服务注册发现</a></li>
<li><a href="/microservice/1.3%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8%E4%B9%8B%E7%BD%91%E5%85%B3">1.3 微服务之网关</a></li>
<li><a href="/microservice/1.4%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8%E4%B9%8B%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF">1.4 微服务之事件总线</a></li>
<li><a href="/microservice/1.5%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8%E4%B9%8BDockerCompose">1.5 微服务之DockerCompose</a></li>
<li><a href="/microservice/Consul%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0">Consul服务注册发现</a></li>
</ul>
<h2 id="⌛-Test-v3">⌛ Test</h2>
<ul>
<li><a href="/test/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95">单元测试</a></li>
<li><a href="/test/%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95">集成测试</a></li>
<li><a href="/test/%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95k6">压力测试k6</a></li>
<li><a href="/test/%E8%87%AA%E5%8A%A8%E5%8C%96UI%E6%B5%8B%E8%AF%95">自动化UI测试</a></li>
</ul>
<h2 id="🖥️-Linux-v3">🖥️ Linux</h2>
<ul>
<li><a href="/linux/VMware%E5%AE%89%E8%A3%85Centos">VMware 安装Centos</a></li>
<li><a href="/linux/Linux%E7%9B%AE%E5%BD%95%E8%AF%B4%E6%98%8E">Linux 目录说明</a></li>
<li><a href="/linux/Centos%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE">Centos 网络配置</a></li>
<li><a href="/linux/Centos7%E5%8D%87%E7%BA%A7gcc%E7%89%88%E6%9C%AC">Centos7升级gcc版本</a></li>
<li><a href="/linux/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4">Linux常用命令</a></li>
</ul>
<h2 id="📚-NET-v3">📚  .NET</h2>
<ul>
<li><a href="/dotnet/%E5%9F%BA%E7%A1%80%E5%90%88%E9%9B%86">基础合集</a></li>
<li><a href="/dotnet/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1">面向对象</a></li>
<li><a href="/dotnet/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">数据结构</a></li>
<li><a href="/dotnet/%E6%B3%9B%E5%9E%8B%E6%8A%80%E6%9C%AF">泛型技术</a></li>
<li><a href="/dotnet/%E5%8F%8D%E5%B0%84%E6%8A%80%E6%9C%AF">反射技术</a></li>
<li><a href="/dotnet/%E5%A4%9A%E7%BA%BF%E7%A8%8B">多线程</a></li>
<li><a href="/dotnet/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5">线程同步</a></li>
<li><a href="/dotnet/%E5%A7%94%E6%89%98%E5%92%8C%E4%BA%8B%E4%BB%B6">委托和事件</a></li>
<li><a href="/dotnet/%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B">并行编程</a></li>
<li><a href="/dotnet/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B">异步编程</a></li>
<li><a href="/dotnet/%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D">值类型和引用类型内存分配</a></li>
<li><a href="/dotnet/1.1DataProtection%E7%AE%80%E4%BB%8B">1.1 DataProtection简介</a></li>
<li><a href="/dotnet/1.2%E5%AE%9E%E8%B7%B5%E5%8F%8A%E5%A4%9A%E7%8E%AF%E5%A2%83%E8%B0%83%E8%AF%95">1.2 实践及多环境调试</a></li>
<li><a href="/dotnet/1.3%E5%9F%BA%E4%BA%8EDataProtection%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BF%9D%E6%8A%A4%E6%96%B9%E6%A1%88">1.3 数据保护方案</a></li>
<li><a href="/dotnet/1.4%E6%96%B9%E6%A1%88%E5%AE%9E%E8%B7%B5%E5%8F%8A%E9%9B%86%E6%88%90AzureDevops%E7%AE%A1%E9%81%93">1.4 AzureDevops集成</a></li>
</ul>

</div>


<script src="/js/book-menu.js"></script>

  </div>

  <div class="sidebar-toggle" onclick="sidebar_toggle()" onmouseover="add_inner()" onmouseleave="remove_inner()">
  <div class="sidebar-toggle-inner"></div>
</div>

<script>
function add_inner() {
  let inner = document.querySelector('.sidebar-toggle-inner')
  inner.classList.add('show')  
}

function remove_inner() {
  let inner = document.querySelector('.sidebar-toggle-inner')
  inner.classList.remove('show')
}

function sidebar_toggle() {
    let sidebar_toggle = document.querySelector('.sidebar-toggle')
    let sidebar = document.querySelector('.book-sidebar')
    let content = document.querySelector('.off-canvas-content')
    if (sidebar_toggle.classList.contains('extend')) { // show
        sidebar_toggle.classList.remove('extend')
        sidebar.classList.remove('hide')
        content.classList.remove('extend')
    }
    else { // hide
        sidebar_toggle.classList.add('extend')
        sidebar.classList.add('hide')
        content.classList.add('extend')
    }
}
</script>

  <div class="off-canvas-content" style="margin-left:10rem;">
    <div class="columns">
      <div class="column col-10 col-lg-12">
        <div class="book-navbar">
          <!-- For Responsive Layout -->

<header class="navbar">
  <section class="navbar-section">
    <a onclick="open_sidebar()">
      <i class="icon icon-menu"></i>
    </a>
  </section>
</header>

        </div>
        <div class="book-content">
          <div class="book-post">
  <p><a target="_blank" rel="noopener" href="https://prometheus.io/docs/introduction">Prometheus 官方文档地址</a></p>
<h1 id="监控样本">监控样本</h1>
<p>通过 Node Exporter 暴露的 HTTP 服务，Prometheus 可以采集到当前主机所有监控指标的样本数据。比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># HELP node_cpu_guest_seconds_total Seconds the CPUs spent in guests (VMs) for each mode.</span></span><br><span class="line"><span class="comment"># TYPE node_cpu_guest_seconds_total counter</span></span><br><span class="line">node_cpu_guest_seconds_total&#123;cpu=<span class="string">&quot;0&quot;</span>,mode=<span class="string">&quot;nice&quot;</span>&#125; 0</span><br><span class="line">node_cpu_guest_seconds_total&#123;cpu=<span class="string">&quot;0&quot;</span>,mode=<span class="string">&quot;user&quot;</span>&#125; 0</span><br><span class="line">node_cpu_guest_seconds_total&#123;cpu=<span class="string">&quot;1&quot;</span>,mode=<span class="string">&quot;nice&quot;</span>&#125; 0</span><br><span class="line">node_cpu_guest_seconds_total&#123;cpu=<span class="string">&quot;1&quot;</span>,mode=<span class="string">&quot;user&quot;</span>&#125; 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># HELP node_cpu_seconds_total Seconds the CPUs spent in each mode.</span></span><br><span class="line"><span class="comment"># TYPE node_cpu_seconds_total counter</span></span><br><span class="line">node_cpu_seconds_total&#123;cpu=<span class="string">&quot;0&quot;</span>,mode=<span class="string">&quot;idle&quot;</span>&#125; 996.7</span><br><span class="line">node_cpu_seconds_total&#123;cpu=<span class="string">&quot;0&quot;</span>,mode=<span class="string">&quot;iowait&quot;</span>&#125; 0.52</span><br></pre></td></tr></table></figure>
<p>其中非 <code>#</code> 开头的每一行表示当前 Node Exporter 采集到的一个监控样本：</p>
<ul>
<li><code>node_cpu_seconds_total</code> ：表示当前指标名称</li>
<li>大括号中的标签：表示当前样本的一些特征和维度</li>
<li>浮点数：表示该监控样本的具体值</li>
</ul>
<h1 id="时间序列（time-series）">时间序列（time-series）</h1>
<p>Prometheus 会将所有采集到的样本数据以时间序列（time-series）的方式保存在内存数据库中，定时保存到硬盘上。</p>
<blockquote>
<p>time-series 是按照时间戳和值的序列顺序存放的，称之为向量(vector)</p>
</blockquote>
<p>每条 time-series 通过指标名称(metrics name)和一组标签集(labelset)命名。其中每一个点称为一个样本(sample)。样本由以下三部分组成：</p>
<ul>
<li>指标（metric）：metric name 和描述当前样本特征的 labelsets</li>
<li>时间戳（timestamp）：一个精确到毫秒的时间戳</li>
<li>样本值（value）： 一个 float64 的浮点型数据表示当前样本的值</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;--------------- metric ---------------------&gt;&lt;-timestamp -&gt;&lt;-value-&gt;</span><br><span class="line">http_request_total&#123;status=<span class="string">&quot;200&quot;</span>, method=<span class="string">&quot;GET&quot;</span>&#125;@1434417560938 =&gt; 94355</span><br><span class="line">http_request_total&#123;status=<span class="string">&quot;200&quot;</span>, method=<span class="string">&quot;GET&quot;</span>&#125;@1434417561287 =&gt; 94334</span><br><span class="line"></span><br><span class="line">http_request_total&#123;status=<span class="string">&quot;404&quot;</span>, method=<span class="string">&quot;GET&quot;</span>&#125;@1434417560938 =&gt; 38473</span><br><span class="line">http_request_total&#123;status=<span class="string">&quot;404&quot;</span>, method=<span class="string">&quot;GET&quot;</span>&#125;@1434417561287 =&gt; 38544</span><br><span class="line"></span><br><span class="line">http_request_total&#123;status=<span class="string">&quot;200&quot;</span>, method=<span class="string">&quot;POST&quot;</span>&#125;@1434417560938 =&gt; 4748</span><br><span class="line">http_request_total&#123;status=<span class="string">&quot;200&quot;</span>, method=<span class="string">&quot;POST&quot;</span>&#125;@1434417561287 =&gt; 4785</span><br></pre></td></tr></table></figure>
<h1 id="指标（metric）">指标（metric）</h1>
<p>指标（Metric）通过如下格式表示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;metric name&gt;&#123;&lt;label name&gt;=&lt;label value&gt;, ...&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>指标名称(metric name)：表示被监控样本的含义。比如：<code>http_request_total</code> 表示当前系统接收到的HTTP请求总量。指标名称只能由ASCII字符、数字、下划线以及冒号组成并必须符合正则表达式 <code>[a-zA-Z_:][a-zA-Z0-9_:]*</code></li>
<li>标签(label)：反映当前样本的特征维度，通过这些维度 Prometheus 可以对样本数据进行过滤，聚合等。标签的名称只能由ASCII字符、数字以及下划线组成并满足正则表达式 <code>[a-zA-Z_][a-zA-Z0-9_]*</code></li>
</ul>
<p>其中以 <code>__</code> 作为前缀的标签是系统保留的关键字，只能在系统内部使用。标签的值可以包含任何 Unicode 编码的字符。</p>
<p>在 Prometheus 的底层实现中指标名称实际上是以 <code>__name__=&lt;metric name&gt;</code> 的形式保存在数据库中的，因此以下两种方式均表示的同一条 time-series：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">api_http_requests_total&#123;method=<span class="string">&quot;POST&quot;</span>, handler=<span class="string">&quot;/messages&quot;</span>&#125;</span><br><span class="line">等同于：</span><br><span class="line">&#123;__name__=<span class="string">&quot;api_http_requests_total&quot;</span>，method=<span class="string">&quot;POST&quot;</span>, handler=<span class="string">&quot;/messages&quot;</span>&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在 Prometheus 源码中也可以指标(Metric)对应的数据结构，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> Metric LabelSet</span><br><span class="line"><span class="built_in">type</span> LabelSet map[LabelName]LabelValue</span><br><span class="line"><span class="built_in">type</span> LabelName string</span><br><span class="line"><span class="built_in">type</span> LabelValue string</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="Metric-类型">Metric 类型</h1>
<p>为了能够理解和区分不同监控指标之间的差异，Prometheus 定义了4中不同的指标类型（metric type）：</p>
<ol>
<li>Counter（计数器）</li>
<li>Gauge（仪表盘）</li>
<li>Histogram（直方图）</li>
<li>Summary（摘要）</li>
</ol>
<p>Exporter Node 返回的样本数据中，其注释中也包含了该样本的类型。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># HELP node_cpu_seconds_total Seconds the CPUs spent in each mode.</span></span><br><span class="line"><span class="comment"># TYPE node_cpu_seconds_total counter</span></span><br><span class="line">node_cpu_seconds_total&#123;cpu=<span class="string">&quot;0&quot;</span>,mode=<span class="string">&quot;idle&quot;</span>&#125; 996.7</span><br></pre></td></tr></table></figure>
<h2 id="Counter-只增不减">Counter-&gt;只增不减</h2>
<p>Counter 类型的指标工作方式和计数器一样，只增不减（除非系统发生重置）。如 <code>http_requests_total</code> ，<code>node_cpu</code> 都是 Counter 类型的监控指标。 一般在定义 Counter 类型指标的名称时推荐使用 <code>_total</code> 作为后缀。</p>
<p>示例：通过 <code>rate()</code> 函数获取HTTP请求量的增长率：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rate(http_requests_total[5m])</span><br></pre></td></tr></table></figure>
<p>查询当前系统中，访问量前10的 HTTP 地址：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">topk(10, http_requests_total)</span><br></pre></td></tr></table></figure>
<h2 id="Gauge-可增可减">Gauge-&gt;可增可减</h2>
<p>Gauge 类型的指标侧重于反应系统的当前状态。因此这类指标的样本数据可增可减。如：<code>node_memory_MemFree（主机当前空闲的内容大小）</code>、<code>node_memory_MemAvailable</code>（可用内存大小）都是 Gauge 类型的监控指标。</p>
<p>通过 Gauge 指标，可以直接查看系统的当前状态。对于 Gauge 类型的监控指标，通过 PromQL 内置函数 <code>delta()</code> 可以获取样本在一段时间的变化情况。例如，计算CPU温度在两个小时内的差异：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delta(cpu_temp_celsius&#123;host=<span class="string">&quot;zeus&quot;</span>&#125;[2h])</span><br></pre></td></tr></table></figure>
<p>还可以使用 <code>deriv()</code> 计算样本的线性回归模型，甚至直接使用 <code>predict_linear()</code> 对数据的变化趋势进行预测。例如：预测系统磁盘空间在4个小时之后的剩余情况：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">predict_linear(node_filesystem_free&#123;job=<span class="string">&quot;node&quot;</span>&#125;[1h], 4 * 3600)</span><br></pre></td></tr></table></figure>
<h2 id="Histogram-Summary">Histogram/Summary</h2>
<p>Histogram 和 Summary 主要用于统计和分析样本的分布情况。</p>
<blockquote>
<p>大多数情况下人们都倾向于使用某些量化指标的平均值，例如CPU的平均使用率、页面的平均响应时间。这种方式的问题很明显，以系统API调用的平均响应时间为例：如果大多数API请求都维持在100ms 的响应时间范围内，而个别请求的响应时间需要 5s，那么就会导致某些WEB页面的响应时间落到中位数的情况，这种现象被称为长尾问题</p>
</blockquote>
<p>为了区分是平均的慢还是长尾的慢，最简单的方式就是按照请求延迟的范围进行分组。例如：统计延迟在 0~10ms 之间的请求数有多少而 10~20ms 之间的请求数又有多少。通过这种方式可以快速分析系统慢的原因。Histogram 和Summary 都是为了能够解决这样问题的存在，通过 Histogram 和 Summary 类型的监控指标，可以快速了解监控样本的分布情况。</p>
<p>例如：指标 <code>prometheus_tsdb_wal_fsync_duration_seconds</code> 的指标类型为 Summary。 它记录了 Prometheus Server 中 <code>wal_fsync</code> 处理的处理时间，通过访问 Prometheus Server 的 <code>/metrics</code> 地址，可以获取到以下监控样本数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># HELP prometheus_tsdb_wal_fsync_duration_seconds Duration of WAL fsync.</span><br><span class="line"># TYPE prometheus_tsdb_wal_fsync_duration_seconds summary</span><br><span class="line">prometheus_tsdb_wal_fsync_duration_seconds&#123;quantile=&quot;0.5&quot;&#125; 0.012352463</span><br><span class="line">prometheus_tsdb_wal_fsync_duration_seconds&#123;quantile=&quot;0.9&quot;&#125; 0.014458005</span><br><span class="line">prometheus_tsdb_wal_fsync_duration_seconds&#123;quantile=&quot;0.99&quot;&#125; 0.017316173</span><br><span class="line">prometheus_tsdb_wal_fsync_duration_seconds_sum 2.888716127000002</span><br><span class="line">prometheus_tsdb_wal_fsync_duration_seconds_count 216</span><br></pre></td></tr></table></figure>
<p>从上面的样本中可以得知当前 Prometheus Server 进行 <code>wal_fsync</code> 操作的总次数为216次，耗时 <code>2.888716127000002s</code>。其中中位数（quantile=0.5）的耗时为 0.012352463，9分位数（quantile=0.9）的耗时为 0.014458005s。</p>
<p>在 Prometheus Server 自身返回的样本数据中，还能找到类型为 Histogram 的监控指标<code>prometheus_tsdb_compaction_chunk_range_bucket</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># HELP prometheus_tsdb_compaction_chunk_range Final time range of chunks on their first compaction</span><br><span class="line"># TYPE prometheus_tsdb_compaction_chunk_range histogram</span><br><span class="line">prometheus_tsdb_compaction_chunk_range_bucket&#123;le=&quot;100&quot;&#125; 0</span><br><span class="line">prometheus_tsdb_compaction_chunk_range_bucket&#123;le=&quot;400&quot;&#125; 0</span><br><span class="line">prometheus_tsdb_compaction_chunk_range_bucket&#123;le=&quot;1600&quot;&#125; 0</span><br><span class="line">prometheus_tsdb_compaction_chunk_range_bucket&#123;le=&quot;6400&quot;&#125; 0</span><br><span class="line">prometheus_tsdb_compaction_chunk_range_bucket&#123;le=&quot;25600&quot;&#125; 0</span><br><span class="line">prometheus_tsdb_compaction_chunk_range_bucket&#123;le=&quot;102400&quot;&#125; 0</span><br><span class="line">prometheus_tsdb_compaction_chunk_range_bucket&#123;le=&quot;409600&quot;&#125; 0</span><br><span class="line">prometheus_tsdb_compaction_chunk_range_bucket&#123;le=&quot;1.6384e+06&quot;&#125; 260</span><br><span class="line">prometheus_tsdb_compaction_chunk_range_bucket&#123;le=&quot;6.5536e+06&quot;&#125; 780</span><br><span class="line">prometheus_tsdb_compaction_chunk_range_bucket&#123;le=&quot;2.62144e+07&quot;&#125; 780</span><br><span class="line">prometheus_tsdb_compaction_chunk_range_bucket&#123;le=&quot;+Inf&quot;&#125; 780</span><br><span class="line">prometheus_tsdb_compaction_chunk_range_sum 1.1540798e+09</span><br><span class="line">prometheus_tsdb_compaction_chunk_range_count 780</span><br></pre></td></tr></table></figure>
<p>对比 Summary 类型的指标：</p>
<ul>
<li>相似之处在于： Histogram 类型的样本同样会反应当前指标的记录的总数(以 <code>_count</code> 作为后缀)以及其值的总量（以 <code>_sum</code> 作为后缀）</li>
<li>不同在于： Histogram 指标直接反应了在不同区间内样本的个数，区间通过标签 <code>len</code> 进行定义</li>
</ul>
<p>对于 Histogram 的指标，还可以通过 <code>histogram_quantile()</code> 函数计算出其值的分位数。不同在于:</p>
<ul>
<li>Histogram 通过 <code>histogram_quantile</code> 函数是在服务器端计算的分位数（会消耗更多的资源）</li>
<li>Sumamry 的分位数则是直接在客户端计算完成（在通过 PromQL 进行查询时有更好的性能表现）</li>
</ul>
<blockquote>
<p>选择这两种方式时应该按照自己的实际场景进行选择</p>
</blockquote>
<h1 id="PromQL">PromQL</h1>
<p>Prometheus 通过指标名称（metrics name）以及对应的一组标签（labelset）来定义一条时间序列。指标名称反映了监控样本的基本标识，而 label 则在这个基本特征上为采集到的数	过滤，聚合，统计从而产生新的计算后的一条时间序列。</p>
<blockquote>
<p>PromQL 是 Prometheus 内置的数据查询语言，其提供对时间序列数据丰富的查询，聚合以及逻辑运算能力的支持</p>
</blockquote>
<h2 id="查询时间序列">查询时间序列</h2>
<p>当 Prometheus 通过 Exporter Node 采集到相应的监控指标样本数据后，可以通过 PromQL 对监控样本数据进行查询。比如：直接使用监控指标名称查询</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">prometheus_http_requests_total</span><br><span class="line"><span class="comment"># 等同于：</span></span><br><span class="line">prometheus_http_requests_total&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>该表达式返回指标名称为 <code>http_requests_total</code> 的所有时间序列：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">prometheus_http_requests_total&#123;code=<span class="string">&quot;200&quot;</span>, handler=<span class="string">&quot;/-/ready&quot;</span>, instance=<span class="string">&quot;localhost:9090&quot;</span>, job=<span class="string">&quot;prometheus&quot;</span>&#125;</span><br><span class="line">prometheus_http_requests_total&#123;code=<span class="string">&quot;200&quot;</span>, handler=<span class="string">&quot;/api/v1/label/:name/values&quot;</span>, instance=<span class="string">&quot;localhost:9090&quot;</span>, job=<span class="string">&quot;prometheus&quot;</span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="标签过滤">标签过滤</h2>
<p>PromQL 支持根据时间序列的标签匹配模式来对时间序列进行过滤，目前主要支持两种匹配模式：</p>
<ul>
<li>完全匹配 <code>=</code>：使用 <code>label=value</code> 选择标签满足表达式定义的时间序列</li>
<li>正则匹配 <code>!=</code> ：使用 <code>label!=value </code> 根据标签匹配排除时间序列</li>
</ul>
<p>比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">prometheus_http_requests_total&#123;instance=<span class="string">&quot;localhost:9090&quot;</span>&#125;</span><br><span class="line">prometheus_http_requests_total&#123;instance!=<span class="string">&quot;localhost:9090&quot;</span>&#125;</span><br></pre></td></tr></table></figure>
<p>除了使用完全匹配的方式对时间序列进行过滤以外，PromQL 还可以支持使用正则表达式作为匹配条件，多个表达式之间使用 <code>|</code> 进行分离：PromQL 支持使用 <code>=~</code> 和 <code>!~</code> 两种正则匹配模式：</p>
<ul>
<li>使用 <code>label=~regx</code> 表示选择那些标签符合正则表达式定义的时间序列</li>
<li>反之使用 <code>label!~regx</code> 进行排除</li>
</ul>
<p>比如，如果想查询多个环节下的时间序列序列可以使用如下表达式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prometheus_http_requests_total&#123;environment=~<span class="string">&quot;staging|testing|development&quot;</span>,method!=<span class="string">&quot;GET&quot;</span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="范围查询">范围查询</h2>
<p>直接通过类似于 PromQL 表达式  <code>process_http_request_total</code>  查询时间序列时，返回值中只会包含该时间序列中最新的一个样本值，这样的返回结果为 <strong>瞬时向量</strong>。相应的表达式称为 <strong>瞬时向量表达式</strong>。</p>
<p>如果需要过去一段时间范围内的样本数据时，则需要使用 <strong>区间向量表达式</strong>。区间向量表达式和瞬时向量表达式差异在于：在区间向量表达式中需要定义时间选择的范围，时间范围通过时间范围选择器 <code>[]</code> 进行定义。例如，通过以下表达式可以选择最近5分钟内的所有样本数据：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_request_total&#123;&#125;[5m]</span><br></pre></td></tr></table></figure>
<p>该表达式将会返回查询到的时间序列中最近5分钟的所有样本数据：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">prometheus_http_requests_total&#123;code=<span class="string">&quot;200&quot;</span>, handler=<span class="string">&quot;/-/ready&quot;</span>, instance=<span class="string">&quot;localhost:9090&quot;</span>, job=<span class="string">&quot;prometheus&quot;</span>&#125;</span><br><span class="line">10 @1657164241.316</span><br><span class="line">10 @1657164256.319</span><br><span class="line">10 @1657164271.319</span><br><span class="line">10 @1657164286.316</span><br><span class="line">prometheus_http_requests_total&#123;code=<span class="string">&quot;200&quot;</span>, handler=<span class="string">&quot;/api/v1/label/:name/values&quot;</span>, instance=<span class="string">&quot;localhost:9090&quot;</span>, job=<span class="string">&quot;prometheus&quot;</span>&#125;</span><br><span class="line">10 @1657164241.316</span><br><span class="line">10 @1657164256.319</span><br><span class="line">10 @1657164271.319</span><br><span class="line">10 @1657164286.316</span><br><span class="line">11 @1657164301.316</span><br></pre></td></tr></table></figure>
<p>通过区间向量表达式查询到的结果称为 <strong>区间向量</strong>。</p>
<p>除了使用 <code>m</code> 表示分钟以外，PromQL 的时间范围选择器支持其它时间单位：</p>
<ul>
<li><code>s</code> - 秒</li>
<li><code>m</code> - 分钟</li>
<li><code>h</code> - 小时</li>
<li><code>d</code> - 天</li>
<li><code>w</code> - 周</li>
<li><code>y</code> - 年</li>
</ul>
<h2 id="时间位移">时间位移</h2>
<p>在瞬时向量表达式或者区间向量表达式中，都是以当前时间为基准：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http_request_total&#123;&#125; <span class="comment"># 瞬时向量表达式，选择当前最新的数据</span></span><br><span class="line">http_request_total&#123;&#125;[5m] <span class="comment"># 区间向量表达式，选择以当前时间为基准，5分钟内的数据</span></span><br></pre></td></tr></table></figure>
<p>如果想查询5分钟前的瞬时样本数据，或昨天一天区间内的样本数据可以使用位移操作，位移操作的关键字为 <code>offset</code>。可以使用 <code>offset</code> 执行时间位移操作：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http_request_total&#123;&#125; offset 5m</span><br><span class="line">http_request_total&#123;&#125;[1d] offset 1d</span><br></pre></td></tr></table></figure>
<h2 id="聚合操作">聚合操作</h2>
<p>一般如果描述样本特征的标签(label)在并非唯一的情况下，通过 PromQL 查询数据，会返回多条满足这些特征维度的时间序列。PromQL 提供的聚合操作可以用来对这些时间序列进行处理，形成一条新的时间序列：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询系统所有http请求的总量</span></span><br><span class="line">sum(http_request_total)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照mode计算主机CPU的平均使用时间</span></span><br><span class="line">avg(node_cpu) by (mode)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照主机查询各个主机的CPU使用率</span></span><br><span class="line">sum(sum(irate(node_cpu&#123;mode!=<span class="string">&#x27;idle&#x27;</span>&#125;[5m]))  / sum(irate(node_cpu[5m]))) by (instance)</span><br></pre></td></tr></table></figure>
<h2 id="操作符">操作符</h2>
<h3 id="数学运算">数学运算</h3>
<p>例如：通过指标  <code>node_memory_free_bytes_total</code>  获取到当前主机可用的内存空间大小，样本单位为 Bytes。如果要求使用 <code>MB</code> 作为单位响应数据，只需要将查询到的时间序列的样本值进行单位换算即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node_memory_free_bytes_total / (1024 * 1024)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>瞬时向量与标量之间进行数学运算时：数学运算符会依次作用于瞬时向量中的每一个样本值，从而得到一组新的时间序列</p>
</blockquote>
<p>瞬时向量与瞬时向量之间进行数学运算时，过程会相对复杂一点。 例如，如果想根据 <code>node_disk_bytes_written</code> 和  <code>node_disk_bytes_read</code> 获取主机磁盘IO的总量，可以使用如下表达式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node_disk_bytes_written + node_disk_bytes_read</span><br></pre></td></tr></table></figure>
<p>工作原理是：依次找到与左边向量元素匹配（标签完全一致）的右边向量元素进行运算，如果没找到匹配元素，则直接丢弃。同时新的时间序列将不会包含指标名称。 该表达式返回结果的示例如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;device=<span class="string">&quot;sda&quot;</span>,instance=<span class="string">&quot;localhost:9100&quot;</span>,job=<span class="string">&quot;node_exporter&quot;</span>&#125;=&gt;1634967552@1518146427.807 + 864551424@1518146427.807</span><br><span class="line">&#123;device=<span class="string">&quot;sdb&quot;</span>,instance=<span class="string">&quot;localhost:9100&quot;</span>,job=<span class="string">&quot;node_exporter&quot;</span>&#125;=&gt;0@1518146427.807 + 1744384@1518146427.807</span><br></pre></td></tr></table></figure>
<p>PromQL 支持的数学运算符如下所示：</p>
<ul>
<li><code>+</code> (加法)</li>
<li><code>-</code> (减法)</li>
<li><code>*</code> (乘法)</li>
<li><code>/</code> (除法)</li>
<li><code>%</code> (求余)</li>
<li><code>^</code> (幂运算)</li>
</ul>
<h3 id="布尔运算">布尔运算</h3>
<p>在 PromQL 通过标签匹配模式，可以根据时间序列的特征维度对其进行查询。而布尔运算则支持根据时间序列中样本的值，对时间序列进行过滤。</p>
<p>例如：通过数学运算符可以计算出当前所有主机节点的内存使用率：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(node_memory_bytes_total - node_memory_free_bytes_total) / node_memory_bytes_total</span><br></pre></td></tr></table></figure>
<p>而如果只想知道当前内存使用率超过95%的主机通过使用布尔运算符可以方便的获取到该结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(node_memory_bytes_total - node_memory_free_bytes_total) / node_memory_bytes_total &gt; 0.95</span><br></pre></td></tr></table></figure>
<p>瞬时向量与标量进行布尔运算时：PromQL 依次比较向量中的所有时间序列样本的值，如果比较结果为 true 则保留，反之丢弃。</p>
<p>瞬时向量与瞬时向量直接进行布尔运算时：同样遵循默认的匹配模式：依次找到与左边向量元素匹配（标签完全一致）的右边向量元素进行相应的操作，如果没找到匹配元素，则直接丢弃。</p>
<p>目前，Prometheus支持以下布尔运算符如下：</p>
<ul>
<li><code>==</code> (相等)</li>
<li><code>!=</code> (不相等)</li>
<li><code>&gt;</code> (大于)</li>
<li><code>&lt;</code> (小于)</li>
<li><code>&gt;=</code> (大于等于)</li>
<li><code>&lt;=</code> (小于等于)</li>
</ul>
<h3 id="bool-修饰符">bool 修饰符</h3>
<p>布尔运算符的默认行为是对时序数据进行过滤。而在其它的情况下可能需要的是真正的布尔结果。例如，只需要知道当前模块的 HTTP 请求量是否 &gt;=1000，如果大于等于1000则返回1（true）否则返回0（false）。这时可以使用  bool 修饰符改变布尔运算的默认行为。 例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_requests_total &gt; bool 1000</span><br></pre></td></tr></table></figure>
<p>使用 bool 修改符后，布尔运算不会对时间序列进行过滤，而是直接依次瞬时向量中的各个样本数据与标量的比较结果0或者1，从而形成一条新的时间序列。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http_requests_total&#123;code=&quot;200&quot;,handler=&quot;query&quot;,instance=&quot;localhost:9090&quot;,job=&quot;prometheus&quot;,method=&quot;get&quot;&#125;  1</span><br><span class="line">http_requests_total&#123;code=&quot;200&quot;,handler=&quot;query_range&quot;,instance=&quot;localhost:9090&quot;,job=&quot;prometheus&quot;,method=&quot;get&quot;&#125;  0</span><br></pre></td></tr></table></figure>
<p>同时需要注意的是，如果是在两个标量之间使用布尔运算，则必须使用 bool 修饰符</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 == bool 2 # 结果为1</span><br></pre></td></tr></table></figure>
<h2 id="集合运算符">集合运算符</h2>
<p>使用瞬时向量表达式能够获取到一个包含多个时间序列的集合，称为瞬时向量。 通过集合运算，可以在两个瞬时向量之间进行相应的集合操作。目前 Prometheus 支持以下集合运算符：</p>
<ul>
<li><code>and</code> (并且)</li>
<li><code>or</code> (或者)</li>
<li><code>unless</code> (排除)</li>
</ul>
<p><code>vector1 and vector2</code> 产生一个由 vector1 的元素组成的新的向量。该向量包含 vector1 中完全匹配 vector2 中的元素组成</p>
<p><code>vector1 or vector2</code> 产生一个新的向量，该向量包含 vector1 中所有的样本数据，以及 vector2 中没有与 vector1 匹配到的样本数据</p>
<p><code>vector1 unless vector2</code> 产生一个新的向量，新向量中的元素由 vector1 中没有与 vector2 匹配的元素组成</p>
<h2 id="操作符优先级">操作符优先级</h2>
<p>对于复杂类型的表达式，需要了解运算操作的运行优先级，PromQL 操作符中优先级由高到低依次为：</p>
<ol>
<li><code>^</code></li>
<li><code>*, /, %</code></li>
<li><code>+, -</code></li>
<li><code>==, !=, &lt;=, &lt;, &gt;=, &gt;</code></li>
<li><code>and, unless</code></li>
<li><code>or</code></li>
</ol>
<h2 id="匹配模式">匹配模式</h2>
<p>向量与向量之间进行运算操作时会基于默认的匹配规则：依次找到与左边向量元素匹配（标签完全一致）的右边向量元素进行运算，如果没找到匹配元素，则直接丢弃。</p>
<p>在 PromQL 中有两种典型的匹配模式：一对一（one-to-one）,多对一（many-to-one）或一对多（one-to-many）。</p>
<h3 id="一对一匹配">一对一匹配</h3>
<p>一对一匹配模式会从操作符两边表达式获取的瞬时向量依次比较并找到唯一匹配(标签完全一致)的样本值。默认情况下，使用表达式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector1 &lt;operator&gt; vector2</span><br></pre></td></tr></table></figure>
<p>在操作符两边表达式标签不一致的情况下，可以使用 <code>on(label list)</code> 或者 <code>ignoring(label list）</code>修改便签的匹配行为。使用 <code>ignoreing</code> 可以在匹配时忽略某些标签。而 <code>on</code> 则用于将匹配行为限定在某些标签之内。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;vector expr&gt; &lt;bin-op&gt; ignoring(&lt;label list&gt;) &lt;vector expr&gt;</span><br><span class="line">&lt;vector expr&gt; &lt;bin-op&gt; on(&lt;label list&gt;) &lt;vector expr&gt;</span><br></pre></td></tr></table></figure>
<p>例如当存在样本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">method_code:http_errors:rate5m&#123;method=&quot;get&quot;, code=&quot;500&quot;&#125;  24</span><br><span class="line">method_code:http_errors:rate5m&#123;method=&quot;get&quot;, code=&quot;404&quot;&#125;  30</span><br><span class="line">method_code:http_errors:rate5m&#123;method=&quot;put&quot;, code=&quot;501&quot;&#125;  3</span><br><span class="line">method_code:http_errors:rate5m&#123;method=&quot;post&quot;, code=&quot;500&quot;&#125; 6</span><br><span class="line">method_code:http_errors:rate5m&#123;method=&quot;post&quot;, code=&quot;404&quot;&#125; 21</span><br><span class="line"></span><br><span class="line">method:http_requests:rate5m&#123;method=&quot;get&quot;&#125;  600</span><br><span class="line">method:http_requests:rate5m&#123;method=&quot;del&quot;&#125;  34</span><br><span class="line">method:http_requests:rate5m&#123;method=&quot;post&quot;&#125; 120</span><br></pre></td></tr></table></figure>
<p>使用 PromQL 表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">method_code:http_errors:rate5m&#123;code=&quot;500&quot;&#125; / ignoring(code) method:http_requests:rate5m</span><br></pre></td></tr></table></figure>
<p>该表达式会返回在过去5分钟内，HTTP请求状态码为500的在所有请求中的比例。如果没有使用 <code>ignoring(code)</code>，操作符两边表达式返回的瞬时向量中将找不到任何一个标签完全相同的匹配项。</p>
<p>因此结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;method=&quot;get&quot;&#125;  0.04            //  24 / 600</span><br><span class="line">&#123;method=&quot;post&quot;&#125; 0.05            //   6 / 120</span><br></pre></td></tr></table></figure>
<p>同时由于method为put和del的样本找不到匹配项，因此不会出现在结果当中。</p>
<h3 id="多对一和一对多">多对一和一对多</h3>
<p>多对一和一对多两种匹配模式指的是“一”侧的每一个向量元素可以与&quot;多&quot;侧的多个元素匹配的情况。在这种情况下，必须使用 group 修饰符：<code>group_left</code> 或者 <code>group_right</code> 来确定哪一个向量具有更高的基数（充当“多”的角色）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;vector expr&gt; &lt;bin-op&gt; ignoring(&lt;label list&gt;) group_left(&lt;label list&gt;) &lt;vector expr&gt;</span><br><span class="line">&lt;vector expr&gt; &lt;bin-op&gt; ignoring(&lt;label list&gt;) group_right(&lt;label list&gt;) &lt;vector expr&gt;</span><br><span class="line">&lt;vector expr&gt; &lt;bin-op&gt; on(&lt;label list&gt;) group_left(&lt;label list&gt;) &lt;vector expr&gt;</span><br><span class="line">&lt;vector expr&gt; &lt;bin-op&gt; on(&lt;label list&gt;) group_right(&lt;label list&gt;) &lt;vector expr&gt;</span><br></pre></td></tr></table></figure>
<p>多对一和一对多两种模式一定是出现在操作符两侧表达式返回的向量标签不一致的情况。因此需要使用 <code>ignoring</code> 和 <code>on</code> 修饰符来排除或者限定匹配的标签列表。</p>
<p>例如表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">method_code:http_errors:rate5m / ignoring(code) group_left method:http_requests:rate5m</span><br></pre></td></tr></table></figure>
<p>该表达式中，左向量 <code>method_code:http_errors:rate5m</code> 包含两个标签method和code。而右向量<code>method:http_requests:rate5m</code> 中只包含一个标签 method，因此匹配时需要使用 ignoring 限定匹配的标签为code。 在限定匹配标签后，右向量中的元素可能匹配到多个左向量中的元素 因此该表达式的匹配模式为多对一，需要使用 <code>group</code> 修饰符<code> group_left</code> 指定左向量具有更好的基数。</p>
<p>最终运算结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;method=&quot;get&quot;, code=&quot;500&quot;&#125;  0.04            //  24 / 600</span><br><span class="line">&#123;method=&quot;get&quot;, code=&quot;404&quot;&#125;  0.05            //  30 / 600</span><br><span class="line">&#123;method=&quot;post&quot;, code=&quot;500&quot;&#125; 0.05            //   6 / 120</span><br><span class="line">&#123;method=&quot;post&quot;, code=&quot;404&quot;&#125; 0.175           //  21 / 120</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：group 修饰符只能在比较和数学运算符中使用。在逻辑运算 <code>and</code>, <code>unless</code> 和 <code>or</code> 才注意操作中默认与右向量中的所有元素进行匹配。</p>
</blockquote>
<h1 id="聚合操作-v2">聚合操作</h1>
<p>Prometheus 还提供了下列内置的聚合操作符，这些操作符作用域瞬时向量。用于将瞬时表达式返回的样本数据进行聚合，形成一个新的时间序列。</p>
<ul>
<li><code>sum</code> (求和)</li>
<li><code>min</code> (最小值)</li>
<li><code>max</code> (最大值)</li>
<li><code>avg</code> (平均值)</li>
<li><code>stddev</code> (标准差)</li>
<li><code>stdvar</code> (标准差异)</li>
<li><code>count</code> (计数)</li>
<li><code>count_values</code> (对value进行计数)</li>
<li><code>bottomk</code> (后n条时序)</li>
<li><code>topk</code> (前n条时序)</li>
<li><code>quantile</code> (分布统计)</li>
</ul>
<p>使用聚合操作的语法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;aggr-op&gt;([parameter,] &lt;vector expression&gt;) [without|by (&lt;label list&gt;)]</span><br></pre></td></tr></table></figure>
<p>其中只有 <code>count_values</code>、<code>quantile</code>、<code>topk</code>、<code>bottomk </code>支持参数(parameter)。</p>
<h2 id="without-by">without/by</h2>
<ul>
<li><code>without</code> ：用于从计算结果中移除列举的标签而保留其它标签</li>
<li><code>by</code> ：正好相反，结果向量中只保留列出的标签，其余标签则移除</li>
</ul>
<p>通过 <code>without</code> 和 <code>by</code> 可以按照样本的问题对数据进行聚合。</p>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sum(http_requests_total) without (instance)</span><br><span class="line">等价于：</span><br><span class="line">sum(http_requests_total) by (code,handler,job,method)</span><br></pre></td></tr></table></figure>
<p>如果只需要计算整个应用的HTTP请求总量，可以直接使用表达式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum(http_requests_total)</span><br></pre></td></tr></table></figure>
<h2 id="count-values">count_values</h2>
<p><code>count_values</code> 用于时间序列中每一个样本值出现的次数。<code>count_values</code> 会为每一个唯一的样本值输出一个时间序列，并且每一个时间序列包含一个额外的标签。</p>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count_values(<span class="string">&quot;count&quot;</span>, http_requests_total)</span><br></pre></td></tr></table></figure>
<h2 id="topk-boottomk">topk/boottomk</h2>
<p><code>topk</code> 和 <code>bottomk</code> 则用于对样本值进行排序，返回当前样本值前n位，或者后n位的时间序列。</p>
<p>例如：获取HTTP请求数前5位的时序样本数据，可以使用表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">topk(5, http_requests_total)</span><br></pre></td></tr></table></figure>
<h2 id="quantile">quantile</h2>
<p><code>quantile</code> 用于计算当前样本数据值的分布情况 <code>quantile(φ, express)</code> 其中 <code>0 ≤ φ ≤ 1</code>。</p>
<p>例如：当φ为0.5时，即表示找到当前样本数据中的中位数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quantile(0.5, http_requests_total)</span><br></pre></td></tr></table></figure>
<h1 id="常见内置函数">常见内置函数</h1>
<p><a target="_blank" rel="noopener" href="https://www.prometheus.wang/promql/prometheus-promql-functions.html">内置函数相关参考</a></p>

</div>


  <div class="book-comments">
    




  </div>



<script src="/js/book-post.js"></script>

        </div>
      </div>
      <div class="column col-2 hide-lg">
        <div class="book-post-info">
  
    <div class="book-post-meta">
 <!--
  <div class="author">
    <div class="author-img">
      
        <figure
          class="avatar avatar-lg"
          data-initial="W"
          style="background-color: #3b4351;">
        </figure>
      
    </div>

    <div class="author-title">
      <div>WangPengLiang</div>
      <!-- <div>2022-07-05</div> 
    </div>
  </div>
-->

  

  <div class="divider"></div>
</div>

  

  <div class="book-tocbot">
</div>
<div class="book-tocbot-menu">
  <a class="book-toc-expand" onclick="expand_toc()">Expand all</a>
  <a onclick="go_top()">Back to top</a>
  <a onclick="go_bottom()">Go to bottom</a>
</div>


<script src="/js/book-toc.js"></script>

</div>
      </div>
    </div>
  </div>
  
  <a class="off-canvas-overlay" onclick="hide_canvas()"></a>
</div>

</body>
</html>


<script src="/js/book.js"></script>
