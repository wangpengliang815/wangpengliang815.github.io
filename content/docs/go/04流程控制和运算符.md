# 流程控制

## If 

```go
	score := 60
	if score >= 90 {
		fmt.Println("A")
	} else if score > 70 {
		fmt.Println("B")
	} else {
		fmt.Println("C")
	}
```

## If 特殊写法

可以在 if 表达式之前添加一个执行语句，再根据变量值进行判断。这种写法可以将返回值与判断放在一行进行处理，而且返回值的作用范围被限制在 `if、else` 语句组合中。这么做的好处在于：在编程中，变量的作用范围越小，所造成的问题可能性越小，每一个变量代表一个状态，有状态的地方，状态就会被修改，函数的局部变量只会影响一个函数的执行，但全局变量可能会影响所有代码的执行状态，因此限制变量的作用范围对代码的稳定性有很大的帮助。

```go
	if score := 60; score >= 90 {
		fmt.Println("A")
	} else if score > 75 {
		fmt.Println("B")
	} else {
		fmt.Println("C")
	}
```

## for

条件表达式返回 `true` 时循环体不停地进行循环，直到条件表达式返回 `false` 时自动退出循环，例如：

```go
	sum := 0
	for i := 0; i < 5; i++ {
		sum += i // 1+2+3+4
	}
	fmt.Println(sum)
```

`for` 循环的初始语句可以被忽略，但是初始语句后的分号必须要写，例如：

```go
	i := 0
	for ; i < 10; i++ {
		fmt.Println(i)
	}
```

`for` 循环的初始语句和结束语句都可以省略，类似于C#中的 `while`（满足条件表达式时持续循环，否则结束循环。），比如：

```go
	j := 0
	// 循环的初始语句和结束语句都可以省略:
	for j < 10 {
		fmt.Println(j)
		j++
	}
```

无限循环：

```go
	for {
		fmt.Print("hello word")
	}
```

`for` 循环可以通过`break`、`goto`、`return`、`panic `语句强制退出循环。

## for range

Go 语言中可以使用 `for range` 遍历数组、切片、字符串、`map`  及通道（channel）。 通过 `for range` 遍历的返回值有以下规律：

1. 数组、切片、字符串返回索引和值
2. `map` 返回键和值
3. `channel` 只返回通道内的值

```go
c := [...]int{1, 2, 3}
for _, v := range c {
		fmt.Printf("value:%d\n", v)
}
```

## switch case

使用 `switch` 语句可方便地对大量的值进行条件判断。

```go
	sex := "男"
	switch sex {
	case "男":
		fmt.Println("男性")
	case "女":
		fmt.Println("女性")
	default:
		fmt.Println("无效的输入！")
	}
```

Go语言规定每个`switch`只能有一个`default`分支。

一个分支可以有多个值，多个case值中间使用英文逗号分隔。比如：

```go
	switch n := 7; n {
	case 1, 3, 5, 7, 9:
		fmt.Println("奇数")
	case 2, 4, 6, 8:
		fmt.Println("偶数")
	default:
		fmt.Println(n)
	}
```

分支还可以使用表达式，这时候switch语句后面不需要再跟判断变量。例如：

```go
	age := 30
	switch {
	case age < 25:
		fmt.Println("好好学习吧")
	case age > 25 && age < 35:
		fmt.Println("好好工作吧")
	case age > 60:
		fmt.Println("好好享受吧")
	default:
		fmt.Println("活着真好")
	}
```

`fallthrough`语法可以执行满足条件的case的下一个case，是为了兼容C语言中的case设计的。

```go
	s := "a"
	switch {
	case s == "a":
		fallthrough
	case s == "b":
		fmt.Println("b")
	case s == "c":
		fmt.Println("c")
	default:
		fmt.Println("...")
	}
```

输出：

```shell
b
```

## goto

`goto`  语句通过标签进行代码间的无条件跳转。C#中也有只是不推荐使用，只在特定场景下才考虑使用。因为goto可以无条件地转移到过程中指定的行会造成程序流程的混乱，使理解和调试程序都产生困难。Go语言中使用  `goto` 语句能简化一些代码的实现过程。 例如双层嵌套的for循环要退出时：

```go
	// 示例一：内层循环打印到2时结束，外层循环也随即结束
	var breakFlag bool
	for i := 0; i < 10; i++ {
		for j := 0; j < 10; j++ {
			if j == 2 {
				// 设置退出标签
				breakFlag = true
				break
			}
			fmt.Printf("%v-%v\n", i, j)
		}
		// 外层for循环判断
		if breakFlag {
			break
		}
	}
```
使用 `goto` 简化
```go

	for i := 0; i < 10; i++ {
		for j := 0; j < 10; j++ {
			if j == 2 {
				// 设置退出标签
				goto breakTag
			}
			fmt.Printf("%v-%v\n", i, j)
		}
	}
	return
	// 标签
breakTag:
	fmt.Println("结束for循环")
```

## break

`break` 语句可以结束 `for` 、 `switch` 和 `select` 的代码块。`break`语句还可以在语句后面添加标签，如果加了标签就会跳出标签对应的for循环，标签要求必须定义在对应的 `for`、 `switch` 和  `select `的代码块上。 例如：

```go
func breakTest() {
BREAKDEMO1:
	for i := 0; i < 10; i++ {
		for j := 0; j < 10; j++ {
			if j == 2 {
				break BREAKDEMO1 // 如果加了标签就会跳出标签对应的for循环
			}
			fmt.Printf("%v-%v\n", i, j)
		}
	}
}
```

## continue

`continue `语句可以结束当前循环，开始下一次的循环迭代过程，仅限在`for`循环内使用。在 `continue`语句后添加标签时，表示开始标签对应的循环。例如：

```go
func processControlContinue() {
forloop1:
	for i := 0; i < 5; i++ {
		// forloop2:
		for j := 0; j < 5; j++ {
			if i == 2 && j == 2 {
				continue forloop1
			}
			fmt.Printf("%v-%v\n", i, j)
		}
	}
    
	for i := 0; i < 10; i++ {
		if i == 2 {
			continue
		}
		fmt.Println(i)
	}
}
```

# 运算符

运算符用于在程序运行时执行数学或逻辑运算，Go 语言内置的运算符有：

- 算术运算符
- 关系运算符
- 逻辑运算符
- 位运算符
- 赋值运算符

## 算术运算符

| 运算符 | 描述 |
| :----: | :--: |
|   +    | 相加 |
|   -    | 相减 |
|   *    | 相乘 |
|   /    | 相除 |
|   %    | 求余 |

**注意：** `++`（自增）和`--`（自减）在Go语言中是单独的语句，并不是运算符。

## 关系运算符

| 运算符 |                             描述                             |
| :----: | :----------------------------------------------------------: |
|   ==   |    检查两个值是否相等，如果相等返回 True 否则返回 False。    |
|   !=   |  检查两个值是否不相等，如果不相等返回 True 否则返回 False。  |
|   >    |  检查左边值是否大于右边值，如果是返回 True 否则返回 False。  |
|   >=   | 检查左边值是否大于等于右边值，如果是返回 True 否则返回 False。 |
|   <    |  检查左边值是否小于右边值，如果是返回 True 否则返回 False。  |
|   <=   | 检查左边值是否小于等于右边值，如果是返回 True 否则返回 False。 |

## 逻辑运算符

| 运算符 |                             描述                             |
| :----: | :----------------------------------------------------------: |
|   &&   | 逻辑 AND 运算符。 如果两边的操作数都是 True，则为 True，否则为 False。 |
|  \|\|  | 逻辑 OR 运算符。 如果两边的操作数有一个 True，则为 True，否则为 False。 |
|   !    | 逻辑 NOT 运算符。 如果条件为 True，则为 False，否则为 True。 |

## 位运算符

位运算符对整数在内存中的二进制位进行操作。

| 运算符 |                             描述                             |
| :----: | :----------------------------------------------------------: |
|   &    |    参与运算的两数各对应的二进位相与。 （两位均为1才为1）     |
|   \|   |  参与运算的两数各对应的二进位相或。 （两位有一个为1就为1）   |
|   ^    | 参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。 （两位不一样则为1） |
|   <<   | 左移n位就是乘以2的n次方。 “a<<b”是把a的各二进位全部左移b位，高位丢弃，低位补0。 |
|   >>   | 右移n位就是除以2的n次方。 “a>>b”是把a的各二进位全部右移b位。 |

## 赋值运算符

| 运算符 |                      描述                      |
| :----: | :--------------------------------------------: |
|   =    | 简单的赋值运算符，将一个表达式的值赋给一个左值 |
|   +=   |                  相加后再赋值                  |
|   -=   |                  相减后再赋值                  |
|   *=   |                  相乘后再赋值                  |
|   /=   |                  相除后再赋值                  |
|   %=   |                  求余后再赋值                  |
|  <<=   |                   左移后赋值                   |
|  >>=   |                   右移后赋值                   |
|   &=   |                  按位与后赋值                  |
|  \|=   |                  按位或后赋值                  |
|   ^=   |                 按位异或后赋值                 |